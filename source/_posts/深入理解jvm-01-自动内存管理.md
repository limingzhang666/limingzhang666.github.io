---
title: 深入理解jvm-01-自动内存管理
copyright: true
related_posts: true
date: 2020-12-26 15:02:06
tags: 自动内存管理
categories: jvm
---

# 自动内存管理



## Java运行时数据区域

![](/uploads/jvm/01-runtimedatazone.png)

### 程序计数器  （线程私有的）

Program Counter Register， 可以看作是当前线程执行字节码的行号指示器

- **字节码解释器 ** 工作时  通过改变***程序计数器*** 的值，来选取下一条需要执行的字节码指令 。

  相当于时程序控制流的 指示器，告诉jvm 下一条要执行的命令是什么 。 分支、循环、跳转、异常处理、线程恢复等 都依赖 改变 **程序计数器 **值来完成  

  

- jvm 的多线程是通过线程 轮流切换、分配处理器执行时间的方式实现的。 

- 在任何一个确定的时间，处理器只会处理某一个线程中的指令。为了确保线程切换回去后，能恢复到之前 线程的正确执行位置，

  所以每条线程都有独立的 ***程序计数器*** ，各个线程之间的程序计数器 互相隔离，互不影响干扰，独立存储

  **所以 说 程序计数器是 线程私有的**

- 如果A线程执行 的是java方法，计数器记录的是 字节码指令的地址 。
- 如果B线程执行的是 本地Native 方法，计数器记录的是 空 undefined



### Java虚拟机栈（线程私有的）

Java Virtual Machine Stack 也是线程私有的。所以它的生命周期 和线程相同

- **为 执行Java 方法 服务**

- ***java虚拟机栈***  描述的是java方法执行的**线程内存模型** 
- 每个方法被执行的时候，jvm都会同步创建一个**栈帧 （stack frame）**，用于存储 **局部变量表**、操作数栈、动态连接、方法出口等信息
- 一个方法从 被调用执行 到 执行完毕的过程，对应这一个 栈帧 从虚拟机栈从 入栈到 出栈的过程 
- ps : 程序员口中 笼统的 将java 内存分为 堆内存（Heap）和 栈内存（Stack） 。栈内存指的就是  ***java虚拟机栈***  ，再具体一点就是 其中的 ***局部变量表***
- ***栈帧（Stack Frame）是方法运行期很重要的 基本数据结构***



#### 局部变量表 

- 存放 了编译期可知的 各种java 基本数据类型 （boolean、byte、char、short、int、long、float、double）

- 存放了各类对象引用类型 （reference）（不是真的对象，是对象的地址 或者句柄）

- 存放了 returnAdress 类型 （指向了一条 字节码指令 的地址）

  

- 存储空间的单位 用 局部变量槽（Slot）来表示， 所以 局部变量表的大小，指的 就是 变量槽 的数量，比如 64位长度的long 和double占用2个 Slot，其他类型1个Slot 



- 在该区域，存在2中异常情况
  - 如果线程请求的栈深度 大于jvm 允许的深度， 抛出 StackOverflowError
  - 如果java虚拟机栈 允许 动态扩展，但是申请不到足够内存，抛出 OutofMemoryErrory 

### 本地方法栈 

Native Method Stack

- ***为执行本地方法 (Native Method)服务***
-  也会报 栈深度溢出 （Stack Overflow error）和 栈扩展异常 （OutOfMemoryError）

### Java 堆（Heap）（线程共享）

- java 堆是JVM 管理的内存中 ***最大的一块*** 
- ***所有线程共享***的 内存区域
- 用于存放对象实例，Java世界里 **“几乎” **所有的对象实例都在这里分配内存 
- 因为有可能未来出现 ***值类型***，并且 因为***逃逸分析***技术的发展，栈上分配、标量替换优化手段 ，所以 不是全部java对象都在Heap上分配内存



- java 堆是GC管理的内存区域，所以也称为 ***GC堆***
- 以前的GC 器 大部分使用的是 **经典分代收集** 理论设计的，所以 将java堆 化为为 新生代、老年代、永久代、Eden区，2个Survivor 。但是现在 也存在不使用 分代收集的 GC器
- 所有线程共享的java堆 可以划分出 多个线程私有的  ***分配缓冲区******（Thread Local Allocation Buffer，TLAB）***，用于  **提高分配内存的效率**
- 不管如果将 java堆细分，java堆都是**存储 对象的实例**，更细的划分只是为了**更好的回收内存或者更好的分配内存**  

- java堆 即可设计成固定大小的，也可以 设计成 可扩展的 ，
- 当前大部分 JVM都是设计成 可扩展的 ，通过 **（-Xmx 和-Xms ）**设定

- 如果堆 没有内存完成 实例分配，并且 堆也不可扩展时候，JVM 会抛出 OutOfMemoryError  (OOM)



### 方法区 (非堆 Non-Heap)（线程共享）

Method Area

- 用于存储已经被JVM加载的类型信息 、常量、静态变量、即时编译器编译后的代码缓存等数据  
- 《java虚拟机规范》将方法区描述为 堆的一个逻辑部分，别名为  ***“非堆”***（***Non-Heap）***，用于和 java堆 区分开来
- 在Java8以前，把 方法区成为 “永久代（Permanent Generation）” ，但本质上2者 并不是等价的。   
- 因为当时 团队把GC的分代设计  扩展到了方法区， 使用了 永久代 来实现方法区的收集 。当时 希望像管理 java堆 一样的方式管理 方法区这一部分内存 。这样就可以 ***不用专门为 方法区 编写内存管理的代码*** ， 
- 但是后面经过验证发现 永久代的实现更容易引起 OOM，永久代有 （-XX: MaxPermSize的上限 ，即使不设置也会有默认值）
- 所以java8的版本 完全废弃了 永久代的概念， 使用***元空间*** （Meta-space） 来代替 。（使用本地内存管理的 方式 实现）

- 对方法区的内存回收目标：主要是针对 常量池的回收和类型的卸载 。回收效果不是很棒，但是又不能不管
- GC 操作在该区域的频率是很少的 ，如同它的前称 “永久代”的名字一样 



#### 运行时常量池 

runtime constant pool ，是方法区的一部分 。

- Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是 ***常量池表（Constant Pool Table）***，用于 存放编译期生成的各种字面量和 符号引用。
- 常量池表 就是放在 运行时常量池 中
- 运行时常量池  具备 动态性，java 语言并不要求常量一定在编译期才能产生，运行时也可以将新的常量放在池中 ，如： String的 intern()方法
- 因为  运行时常量池 是方法区的一部分，所以也受 方法区的内存现在，当申请不到内存的时候，也会报  OOM
- 

### 直接内存

Direct Memory ,并不是JVM运行时数据区的一部分 ，也不是《java虚拟机规范》中定义的内存区域，但是这部分内存频繁被使用， 也可能抛出 OOM 



- JDK 1.4中假如 NIO（new Input/Output）类，引入了一种基于通道（Channel）与缓冲区的 I/O方式 ，它可以使用Native 函数库 直接分配 堆外内存，然后

  通过一个存储在java堆 里面的DirectByBuffer 对象作为 这块内存的引用进行操作，这样 避免java堆 和Native堆中 来回复制对象 。



- 直接内存的分配不会受 java堆大小的限制，但是 受到 计算机总内存 大小的限制 。
- 一般 服务器管理员管理虚拟机配置的时候 ，会更根据实际内存 设置 -Xmx的大小，但经常忽略掉 直接内存。  导致 各个内存区域 总和 大于 物理内存限制 。 从而动态扩展的时候出现  OOM



## Java对象的创建

jvm 会进行类加载操作，类加载操作完成后，对象实例所需的内存大小就已经确定了 ，然后就需要对java对象实例 进行 内存分配了。 

### 分配内存的方式

为对象分配内存任务的操作，就等同于 把一块确定大小的 内存 从java堆中分配出来 

#### 指针碰撞

- 如果 java堆中 内存时决定规整的，所有被使用的内存 都被放在 一边，空闲的内存被放在另一边，中间放着一个***指针***   为分界点的指示器 ，

- 那所分配内存就仅仅时把 指针 往空闲空间方向挪动一段与 对象大小相等的距离 ，这种分配称为 ***指针碰撞（Bump The Pointer）***

#### 空闲列表

- 如果java堆中的内存不是规整的 ，已经被使用的内存 和空闲的内存相互交错在一起， 那么虚拟机就需要 维护一个列表，记录那些内存块 时可用的。

-  在分配内存 的时候，找到一块足够大的空间划分给 对象实例，并更新列表上的记录，这种方式称为 ***空闲列表（Free List）***





java堆是否规整，取决于 GC器是否带有空间压缩整理（Compact）的能力决定，因此

因此，

- 当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；
- 当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。

### 解决 分配内存空间的并发问题

- 对进行分配内存空间的操作进行同步处理，保证更新操作的原子性

- 把内存分配动作安装线程划分在不同的 空间中进行。即 每个线程在 java堆中预先分配一小块内存 ，称为 本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）。线程分配内存的时候，先在该线程的本地缓冲区 中分配。当本地缓冲区用完了，分配新的缓冲区时候，才需要同步锁定 。

  使用 -XX: +/-UseTLAB 参数来设定



## 对象的内存布局

对象在堆内存中的存储布局分为3部分

- 对象头（Header）

  对象头部分包含2类信息

  - “Mark Word” ：用于存储对象自身的运行时数据 ，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
  - 类型指针： 即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例

- 实例数据（Instance Data）

  - 实例数据是  对象真正存储的有效信息，即 程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。

  - 这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。
  - HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs），

  - 从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。

- 对齐填充（Padding）

  - 这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
  - 由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。
  - 对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），

  - 因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。



## 对象的访问定位

创建对象自然是为了后续使用该对象，java通过栈上的reference数据来操作堆上的具体对象。 

主流的访问方式使用使用 句柄 和 直接指针 这两种：

### 句柄的方式

java堆中划出 一块内存作为句柄池，reference 中存储的就是对象的句柄地址 。而 句柄中包含对象的实例数据与类型数据各自的具体地址信息 

![](/uploads/jvm/02-handlePool.png)

### 直接使用指针的方式：

java堆中的内存布局 必须考虑如何放置 类型数据的相关信息 。reference 存储的直接就是对象地址 。如果只是访问对象本身的话，不需要多一次间接访问的开销 。

![](/uploads/jvm/03-redirectPointer.png)



###  两种方式各有优势

- 使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（GC时候移动对象是非常普遍的行为）时，只会改变句柄中的实例数据指针，而reference本身不需要被修改 
- 使用直接指针的好处就是 速度更快，节省了一次指针定位的时间开销，由于对象访问非常频繁，因为这类开销积少成多后是 非常可观的执行成本
- hotspot 使用的就是  直接指针