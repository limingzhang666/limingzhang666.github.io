---
title: 设计模式之禅-04-工厂模式
copyright: true
related_posts: true
date: 2020-11-23 21:25:11
tags: 工厂模式
categories: 设计模式
---
## 工厂模式

Define an interface for creating an object,but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.(定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。)



![](/uploads/design_patterns/04Factory/factory01.png)

在工厂方法模式中，抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；

Creator为抽象创建类，也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。

- 抽象产品类 与 具体产品类

```java
public abstract class Product {
	//产品类的公共方法
    public void method1(){
    //业务逻辑处理
    }
    //抽象方法
    public abstract void method2();
}

public class ConcreteProduct1 extends Product {
    public void method2() {
    //业务逻辑处理
    }
}
public class ConcreteProduct2 extends Product {
    public void method2() {
    //业务逻辑处理
    }
}

```

- 抽象工厂类

```java
public abstract class Creator{
	 /*
        * 创建一个产品对象，其输入参数类型可以自行设置
        * 通常为String、Enum、Class等，当然也可以为空
	*/	
    public abstract <T extends Product> T createProduct(Class<T> c);
}
```

- 具体工厂类

``` java
public class ConcreteCreator extends Creator {
    public <T extends Product> T createProduct(Class<T> c){
    Product product=null;
    try {
    	product = (Product)Class.forName(c.getName()).newInstance();
        } catch (Exception e) {
        //异常处理
        }
    	return (T)product;
    }
}
```

- ### 优点
  
  - 良好的封装性，代码结构清晰。只需要知道产品的类名就可以了，不需要创建对象的过程，减低模块的耦合性
  - 扩展性优秀。下次需要增加一个产品时候，只需要适当的修改具体工厂类或者扩展一个工厂类，就可以拥抱变化。或者只是单纯的增加产品类
  - 屏蔽产品类。 产品类的实现如何变化，调用者都不需要关心，只需要关心产品的接口。
  - 解耦
- ### 使用场景
  
  - 工厂模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重考虑是否需要增加一个工厂类进行管理，增加代码复杂度
  - 需要灵活、可扩展的框架时，可以考虑采用工厂方法模式 。





- ### 扩展

  - #### 简单工厂模式图

    当一个模块只需要一个工厂类时候，就可以去除抽象工厂类AbstractHumanFactory 

    ![](/uploads/design_patterns/04Factory/simple_factory.png)

  - #### 升级为多个工厂类

    当初始化一个对象很耗费精力，各个产品有自己独特得逻辑，放在同一个工厂方法中会使得代码结构不清晰，这个时候就可以多设置几个具体的工厂类。

    ![](/uploads/design_patterns/04Factory/multipleConcreteFactory.png)

    注意： 抽象方法中已经不再需要传递相关参数了，因为每一个具体的工厂都已经非常明确自己的职责： 创建自己负责的产品类对象

    ```java
    // 多工厂模式的抽象工厂类
    public abstract class AbstractHumanFactory {
    	public abstract Human createHuman();
    }
    //  白色人种的创建工厂
    public class whiteHumanFactory extends AbstractHumanFactory {
        public Human createHuman() {
        return new WhiteHuman();
        }
    }
    ```

    

  -  #### 替代单例模式

    单例模式的核心要求是 ： 在内存中只有一个对象，通过工厂方法 也可以只在内存中生产一个对象。

    ![](/uploads/design_patterns/04Factory/factory_singleton.png)

    单例对象 构造函数肯定是私有的，目的就是 不允许通过new的方式创建一个对象。

    ```java
    public class Singleton {
        //不允许通过new产生一个对象
        private Singleton(){
        }
        public void doSomething(){
        //业务处理
        }
    }
    ```

    

    所以单例工厂可以通过反射的方式去创建对象，然后提供给外部访问，从而保证内存中对象唯一

    ```java
    public class SingletonFactory {
        private static Singleton singleton;
        static{
        try {
            Class cl= Class.forName(Singleton.class.getName());
            //获得无参构造
            Constructor constructor=cl.getDeclaredConstructor();
            //设置无参构造是可访问的
            constructor.setAccessible(true);
            //产生一个实例对象
            singleton = (Singleton)constructor.newInstance();
        } catch (Exception e) {
        	//异常处理
        	}
        }
        public static Singleton getSingleton(){
        	return singleton;
        }
    }	
    
    ```

   


  - #### 延迟初始化（lazy_init）

    类似于缓存一样，当一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。

    ![lazy_init_factory.png](/uploads/design_patterns/04Factory/lazy_init_factory.png)

```java
public class ProductFactory {
    private static final Map<String,Product> prMap = new HashMap();
    public static synchronized Product createProduct(String type) throws Exception{
    	Product product =null;
        //如果Map中已经有这个对象
        if(prMap.containsKey(type)){
       		product = prMap.get(type);
        }else{
        if(type.equals("Product1")){
        	product = new ConcreteProduct1();
        }else{
        	product = new ConcreteProduct2();
     	}
            //同时把对象放到缓存容器中
            prMap.put(type,product);
        }
    	return product;
    }
}
```

延迟加载 可以扩展，比如限制某个产品类的最大实例化数量，可以通过判断Map中已有的对象数量来实现，这样的处理是非常有意义的。如JDBC链接数据库都会要求设置一个最大连接数量（MaxConnections）