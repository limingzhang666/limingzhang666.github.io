---
title: java高并发详解-12-深入理解volatile关键字
copyright: true
comments: true
related_posts: true
date: 2021-03-08 18:19:34
tags: volatile关键字
categories: 高并发详解

---

# Java内存模型
- Java内存模型（Java Memory Mode，JMM） 指定了Java虚拟机如何与计算机 的主存（RAM）进行工作。

Java的内存模型决定了一个线程对共享变量的写入何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系。具体如下：

1. 共享变量存储与主内存之中，每个线程都可以访问
2. 每个线程都有私有的工作内存或者称为本地内存
3. 工作内存只存储该线程对共享变量的副本
4. 线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存
5. 工作内存和Java内存模型一样也是一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。



# 并发编程的三个重要特性

原子性、有序性、 可见性

## 原子性

所谓原子性是指在一次的操作和多次操作中，要么所有的操作全部都得到了执行并且不会受到 任何因素的干扰而中断，要么所有的操作都不执行

### 注意：

- 两个原子性的操作结合在一起未必还是原子性的，比如 i++ (其中get i，i+1，set i=x 三者都是原子性操作，但是不代表 i++就是原子性操作)
- volatile 关键字不保证 数据的原子性，synchronized关键字保证，自从 JDK1.5 版本开始，其提供的原子类型变量也 可以保证原子性

## 有序性

有序性是指 程序代码在执行过程中的先后顺序，由于Java 在编译器以及运行期的优化，导致了 代码的 执行顺序未必就是开发者编写代码时的顺序，

因为会存在 指令重排序的情况（Instruction Recorder）



## 可见性

可见性是指，当一个线程对共享变量进行了修改，那么另外的线程 可以立即看到修改后的最新值 



# JMM如何保证三大特性

- JVM采用 内存模型的机制来 屏蔽各个平台和操作系统之间内存访问的差异，以实现让 Java程序在各种平台下达到一致的内存访问效果
- Java的内存模型规定了所有的变量都是存在于 主内存（RAM）当中的，而每个线程都有自己的工作内存或者本地内存。线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接对主内存 进行操作，并且每一个线程都不能访问其他线程的工作内存或者本地内存 。

## 1.JMM与原子性

在Java语言中，对基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的，因此诸如此类的操作是  不可被中断的，要么执行，要么不执行，正所谓 一荣俱荣一损俱损。

（1） x=10； 赋值操作

x=10的操作是原子性的，执行线程首先会将x=10，写入工作内存中，然后再将其 写入主内存（）

（2）y=x； 赋值操作

这条操作时非原子性的，因为它 包含如下两个重要的步骤

1. 执行线程从主内存中 读取x的值（如果x 已经存在于 执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中
2. 在执行线程的 工作内存中修改y的值为x，然后将y的值写入 主内存之中

虽然第一步和第二步 都是原子类型的操作，但是合在 一起就不是原子操作了

（3）y++； 自增操作

这条操作语句时非原子性的，因为它包含3个重要的步骤，具体如下

1. 执行线程从主内存中读取y的值，然后将其存入当前线程的工作内存之中

2. 在执行线程工作内存中为y执行加1操作

3. 将y的值写入主内存

   

（4）z=z+1； 加一操作（与自增操作等价）

这条操作语句时非原子性的，因为它包含3个重要的步骤，具体如下：

1. 执行线程从主内存中读取z的值（如果z已经存在于执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中
2. 在执行线程工作内存中为z执行加1操作
3. 将z的值写入主内存 



总结：

- 多个原子性的操作在一起就不再是原子性操作了
- 简单的读取与赋值操作时原子性的，将一个变量赋给另一个变量的操作不是原子性的
- java内存模型（JMM）只保证了基本读取和赋值的原子性操作，其他的均不保证，
- **如果想要使得某些代码片段具备原子性，需要使用关键字 synchronized，或者 JUC中的lock ，**
- **如果想要使得int 等类型自增操作具备原子性，可以使用JUC 包下的原子封装类型 java.util.concurrent.atomic.***
- **volatile 关键字不具备保证 原子性的语义**



## 2.JMM与可见性

在多线程环境中，如果某个线程首次读取共享变量，则首先 到主内存中获取该变量，然后存入 工作内存中，以后只需要在工作内存中读取该变量即可。 

同样的，如果对该变量执行了修改的操作，则先 将新值写入工作内存中，然后再刷新至 主内存中， **但是什么时候最新的值会被刷新至主内存中是不太确定的**，

java提供了以下三种方式来保证可见性

- 使用关键字 volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（当然也会缓存到线程自己的工作内存中，当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），对于共享资源的写操作当然是 先修改工作内存，但是修改结束后会立刻将其刷新到主内存中
- 通过synchronized 关键字能够保证可见性，synchronized 关键字能够保证同一时刻 ，只有一个线程获得锁，然后执行同步党法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存当中
- 通过JUC 提供的显示锁Lock也能保证可见性，Lock的lock方法能够保证 在同一时刻只有一个线程获得锁，然后执行同步方法，并且会确保在锁 释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存当中

总结： **volatile关键字具有保证可见性的语义**



## 3.JMM与有序性

在Java内存模型中，允许编译器和处理器对指令进行重排序/。但是在多线程的情况下，重排序会影响到程序的正确运行，Java提供了3种保证有序性的方式

- 使用volatile 关键字来保证有序性
- 使用 synchronized关键字来保证有序性、
- 使用  显示锁Lock 来保证有序性

另外Java的内存模型具备一些天生的有序性规则，不需要任何同步手段就能够保证有序性，这个规则被称为Happens-before原则。



happens-before原则

- 程序次序规则： 在一个线程内，代码按照编写的次序执行，编写在后面的操作发生于 编写在前面的操作之后
- 锁定规则： 一个unlock操作要先行发生于对同一个锁的lock操作
- volatile变量规则：  对一个变量的写操作 要早于对这个变量之后的读操作
- 传递规则
- 线程启动规则： THread对象的start 方法先行于对该线程的任何动作，
- 线程中断规则：  对线程执行interrupt方法肯定要优先于捕获到中断信号 
- 线程的终结规则：

总结： volatile关键字具有保证顺序性的语义



# volatile关键字深入解析

被volatile 修饰的实例变量 或者类变量具备如下两层语义

- 保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰的变量，另一个线程会立即看到最新的值
- 禁止对指令进行重排序操作
- volatile 并不保证 原子性

## volatile的原理和实现机制

通过对OpenJDK下 unsafe.cpp 源码的阅读会发现 被volatile修饰的变量存在于 一个 lock 的前缀，源码如下：

“lock；” 前缀实际上相当于是一个 内存屏障，该内存屏障会为 指令的执行 提供如下几个保障。

- 确保指令重排序时不会将其后面的代码排到内存屏障之前
- 确保指令重排序时不会将其后面的代码派操内存屏障之后
- 确保在执行内存屏障修饰的指令时前面的代码全部执行完成
- 强制将线程工作内存中的值 修改刷新至主内存中
- 如果是写操作，则会导致其他线程工作内存（CPU Cache）中缓存数据失效

## volatile的使用场景

1. 开关控制利用可见性的特点
2. 状态标记利用顺序性特点

## volatile和synchronized

 1.使用上的区别

- volatile关键字**只能用于修饰实例变量或者类变量**，不能用于修饰方法以及方法参数 和局部变量、常量等
- synchronized 关键字不能用于对变量的修饰，只能用于修饰方法或者语句块 
- volatile 修饰的变量可以为null ，synchronized 关键字同步语句块的monitor对象不能为null 

2. 对原子性的保证

- volatile无法保证原子性
- 由于synchronized 是一种排他的机制，因此被 synchronized 关键字修饰的同步代码 是无法被中途打断的，因此可以能够保证代码的原子性

3. 对可见性的保证

- 两者均可以保证共享资源在多线程间的可见性，但是实现机制完全不同
- synchronized 借助于JVM指令 monitor enter 和 monitor exit 对通过排他的方式使得 同步代码串行化，在monitor exit时所有共享资源都将会被刷新到主内存中
- volatile 使用机器指令“lock；”的方式迫使其他线程工作内存中的数据失效，不得到 主内存中进行再次加载

4. 对有序性的保证

- volatile关键字禁止JVM 编译器以及处理器对其进行重排序，所以 它能够保证有序性
- synchronized 关键字所修饰的同步方法 也可以保证顺序性，但是这种顺序性 是以程序的串行化执行换来的，  在synchronized 关键字所修饰的代码块中 代码指令也会发生指令重排序的情况

5. 其他

- volatile不会使得线程陷入阻塞
- synchronized 关键字会使得 线程进入阻塞状态



# 总结

- 并发编程的3个重要特性： 原子性，可见性 和有序性

- java 如何保证这3个重要特性，synchronized主要是 排他机制，确保每次都只有一个线程通过。volatile 主要是通过内存屏障“lock；”以及防止指令重排序的方式来实现

  