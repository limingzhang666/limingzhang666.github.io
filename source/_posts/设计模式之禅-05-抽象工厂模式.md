---
title: 设计模式之禅-05-抽象工厂模式
copyright: true
related_posts: true
date: 2020-11-23 23:45:28
tags: 抽象工厂模式
categories: 设计模式
---
## 抽象工厂模式（Abstract Factory Pattern）
Provide an interface for creating families of related or dependent objects without specifying their concrete classes. （为创建一组相关的或者相互依赖的对象 提供一个接口，而且无须指定他们的具体类）

抽象工厂模式的通用类图如下所示：

![](/uploads/design_patterns/05abstractFactory/universe_abstract_factory.png)

![](/uploads/design_patterns/05abstractFactory/abstract_factory_source.png)

其实就是将 结果（product） 抽象化了，具体的结果由 creator指定

```java
 代码清单9-11 抽象产品类
public abstract class AbstractProductA {
    //每个产品共有的方法
    public void shareMethod(){
	}
    //每个产品相同方法，不同实现
    public abstract void doSomething();
    }
}
代码清单9-12 产品A1的实现类
public class ProductA1 extends AbstractProductA {
public void doSomething() {
System.out.println("产品A1的实现方法");
}
}
代码清单9-13 产品A2的实现类
public class ProductA2 extends AbstractProductA {
    public void doSomething() {
    System.out.println("产品A2的实现方法");
    }
}

代码清单9-14 抽象工厂类
public abstract class AbstractCreator {
    //创建A产品家族
    public abstract AbstractProductA createProductA();
    //创建B产品家族
    public abstract AbstractProductB createProductB();
}
代码清单9-15 产品等级1的实现类
public class Creator1 extends AbstractCreator {
    //只生产产品等级为1的A产品
    public AbstractProductA createProductA() {
    	return new ProductA1();
    }
    //只生产产品等级为1的B产品
    public AbstractProductB createProductB() {
    	return new ProductB1();
    }
}
```



### 优点

- 封装性，每个产品的实现类不是高层模块需要关心的 。高层模块只关心接口，抽象，不关心具体的实现创建过程 ，

   创建的工作由工厂类负责 

-  产品族内的约束为非公开状态 。就是各个产品之间的一些比例关系，具体产品类的约束是在工厂内实现的。

### 缺点

- 产品族的扩展非常困难，假如再增加一个  AbstractProductC,改动很大，具有侵入性

### 抽象工厂模式的使用场景



使用场景定义非常简单：  一个对象族（或者是 一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式 。

### 抽象工厂模式的注意事项

- 产品族扩展比较困难，但是产品等级( Creator1 )扩展时非常容易的 ,增加一个createor3 extends AbstractCreator 就行了。

