---
title: 设计模式之禅-03-单例模式
copyright: true
related_posts: true
date: 2020-11-19 23:17:55
tags: 单例模式
categories: 设计模式
---
## 单例模式

```java
public class Singleton {
private static final Singleton singleton = new Singleton();
//限制产生多个对象
private Singleton(){
}
//通过该方法获得实例对象
public static Singleton getSingleton(){
return singleton;
}
//类中其他方法，尽量是static
public static void doSomething(){
}
}
```
单例模式(SingleTon Pattern):
 Ensure a class has only one instance,and provide a global point of access to it 
 (确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例)

![](/uploads/design_patterns/03Singleton/Singleton01.png)

### 优点

- 减少了内存的开支，特别是一个对象需要频繁创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势十分明显
- 可以避免对资源的多重占用，如一个写文件的动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作

###  缺点

- 扩展很困难，除了修改代码基本没有第二种途径。
- 对测试不利，如果在并行开发的环境，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock

### 使用场景

- 要求生成唯一序列号的环境
- 在整个项目中需要一个共享访问点或者共享数据，如web页面的计数器，
- 需要定义大量的静态常量和静态方法（如 工具类）的环境，可以采用单例模式，当然也可以直接声明为 static的方式

### 注意事项

```java
public class Singleton{
    private static Singleton singleton=null;
    private Singleton(){
        
    }
    public static Singleton getSingleton(){
        if(singleton ==null ){
            singleton=new Singleton();
        }
        return singleton;
    }
    
}
```



在高并发的情况下，单例模式需要考虑并发问题，解决不安全 的方法有很多，可以在getSingleton方法前加synchronized 关键字

### 扩展

有上限数量的单例模式

```java
public class Emperor {
    //定义最多能产生的实例数量
    private static int maxNumOfEmperor = 2;
    //每个皇帝都有名字，使用一个ArrayList来容纳，每个对象的私有属性
    private static ArrayList<String> nameList=new ArrayList<String>();
    //定义一个列表，容纳所有的皇帝实例
    private static ArrayList<Emperor> emperorList=new ArrayList<Emperor>();
    //当前皇帝序列号
    private static int countNumOfEmperor =0;
    //产生所有的对象
    static{
        for(int i=0;i<maxNumOfEmperor;i++){
        	emperorList.add(new Emperor("皇"+(i+1)+"帝"));
        }
    }
    private Emperor(){
    //世俗和道德约束你，目的就是不产生第二个皇帝
    }
    //传入皇帝名称，建立一个皇帝对象
    private Emperor(String name){
    	nameList.add(name);
    }
    //随机获得一个皇帝对象
    public static Emperor getInstance(){
        Random random = new Random();
        //随机拉出一个皇帝，只要是个精神领袖就成
        countNumOfEmperor = random.nextInt(maxNumOfEmperor);
        return emperorList.get(countNumOfEmperor);
    }
    //皇帝发话了
    public static void say(){
   		 System.out.println(nameList.get(countNumOfEmperor));
    }
}

```



### TODO: 各种线程 安全的单例模式

1. 如 枚举Enum 等



