---
title: 深入理解jvm-04-垃圾收集算法
copyright: true
related_posts: true
date: 2020-12-27 12:01:23
tags: 垃圾收集算法
categories: jvm
---



# 垃圾收集算法

## 分代收集理论

两个分代假说：

#### 弱分代假说（Weak Generational Hypothesis）：

-  绝大多数对象都是朝生夕灭的 

#### 强分代假说（Strong Generaional Hypothesis）：

-  熬过越多次GC过程的对象 就越难以消亡

这两个分代假说共同奠定了多款常用GC器一致的设计原则：

- GC器应该将Java 堆Heap 划分出不同的区域，然后将回收对象依据其 年龄（对象熬过GC收集的次数） 分配到不同的区域进行存储 。
- 而不同的区域 因为其对象的不同特性，可以采用不同的垃圾收集算法 。
- 如果区域对象 大多数对象都是朝生夕灭 的，难以熬过GC过程的 ，那把他们放在一起，每次回收只标记那些少量存活的对象实例，这样就可以用少量代价回收大量空间
- 如果剩下的都是难以消亡的对象，就把这个年龄大的对象 集中放在一起，jvm使用低频率区回收这个区域。  
- 这样就兼顾了GC的时间开销 和内存空间的有效利用



将java堆进行划分成 不同区域后，gc器 才可以每次只收集其中某一个 或某些部分的区域， 因此 出现了  MInor GC , Major GC, Full GC

这样的回收类型划分，

针对不同区域的，安排与里面存储对象存亡特征相匹配的 GC 算法，如 标记删除，标记复制，标记整理 



因为存在 跨代引用的场景，老年代与新生代 可能存在互相引用的情况，这样 纪要通过GCRoot的可达性分析 ，也要额外遍历整个老年代的对象 来确保可达性分析结果的正确性， 这样由很大的性能负担

 所以出行第三条经验法则

#### 跨代引用假说（Intergenerational Reference Hypothesis）：

- 跨代引用相对于同代引用来说 仅仅占极少数
- 这其实是通过强分代假说和 弱分代假说逻辑推理得出的推论： 
- 存在互相引用关系的2个对象，应该是倾向于同时生存和同时消亡的，
- 如果某个新生代对象存在跨代引用，那么由于老年代对象难以消亡，所以 新生代对象在GC过程的时候也难以消亡，从而得以存活。慢慢的随着 之前新生代对象的年龄的增长，它也会被 晋升到老年代之中，这时候就不存在 跨代引用了

- ps:  依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描



## GC 名词字典

- 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集
  - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。
  - 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集。
  - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。

- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。



## 标记-清除（Mark-Sweep）算法 

算法分为“标记”和“清除”两个阶段：

- 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，
- 也可以反过来，标记存活的对象，统一回收所有未被标记的对象。
- 标记过程就是对象是否属于垃圾的判定过程，
- 后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的

###  缺点

- 第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过
  程的执行效率都随对象数量增长而降低
- 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

![](/uploads/jvm/05-mark-sweep.png)



## 标记-复制（Mark-Copy）算法

### 半区复制 （Semispace Copying）

- 将可用内存按容量分为大小相等的2块 ，每次只使用其中1块 。 

- 当这一块的内存用完了，就将还存活的对象复制到另一块上面 ，
- 然后就将还存活的对象复制到另一块上面，
- 然后再把已经使用过的内存空间一次清理掉。 

### 优点

- 如果内存中多数对象都是存活的，这种算法会产生大量的内存间的复制 开销

- ***但是***   在新生代这个 内存区域，98%的对象实例都熬不过第一轮收集，所以 不是算法有问题，是将算法 没有用到对的区域
-  因为多数对象都是可回收的状态，所以算法复制的就是占少数的存活对象 
- 而且因为每次都是针对整个半区进行回收，分配内存时候也不用考虑 空间碎片整理的情况，只需要移动堆顶指针，按顺序分配即可，简单 高效

###  缺点

- 复制回收算法的代价是 将内存缩小一半，空间浪费未免太多了一点

![](/uploads/jvm/06-mark_copy.png)

### 优化半区复制 （Appel式回收）

因为IBM 对 对象的朝生夕灭 特点做了调研，新生代中的对象 98% 熬不过第一轮收集，所以 提出了优化版的半区复制算法，即： 

Appel 式回收：

#### 具体做法：

- 将新生代  分为一块较大的Eden区（80%）  + Survivor_1（10%）+Survivor_2（10%）
- 每次分配内存时候，只使用 Eden（80%） 和 Survivor_1（10%），而 Survivor_2（10%）就暂时浪费掉
- 当 发生 GC的时候，就将 Eden（80%） 和 Survivor_1（10%）中的存活对象 复制到 Survivor_2（10%） 中
- 然后直接清理掉Eden（80%） 和 Survivor_1（10%）



#### 逃生门”的安全设计（分配担保）：

98%的对象都熬不过第一轮GC 这个是 普通场景， 没有人能保证 每一次 GC后 ，继续存活的对象 不超过10% ，所以 Survivor_2（10%） 有可能装不下了。

这个时候 Appel 有一个 “逃生门”的安全设计 ：

- 当 Survivor_2（10%）容纳不了一次  Minor GC （新生代GC，Young GC）存活对象， 
- 就需要 依赖其他内存区域（实际上大多数是老年代） 进行分配担保，就将一部分 存活对象移入 老年代

#### 分配担保 （Todo）

- 内存的分配担保好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有什么风险了。
- 内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代，这对虚拟机来说就是安全的



## 标记整理（Mark-Compact）算法

- 标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种标记-复制算法 .

- 针对老年代对象的存亡特征，提出了 有针对性的 “标记-整理”（Mark-Compact）算法


### 过程

- 首先标记出所有需要回收的对象，
- 让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如图3-4所示。

![](/uploads/jvm/07-mark-compact.png)



### 缺点：

- 如果移动存活对象，尤其是在老年代 这种每次回收都有大量对象存活区域 ，移动存活对象并更新所有 引用这些对象的地方将会是一种极为负重的操作 ，

  而且这种对象移动操作必须全程暂停用户应用程序才能进行。 Stop The World

- 如果不考虑移动和整理存活对象的话，，存活对象倒置 的空间碎片化问题就 只能依赖更为复杂的内存分配器和内存访问器来解决。

- 内存的访问 是用户程序最频繁的操作，如果这个环节上增加了额外的负担，势必影响用户程序的吞吐量



### 总结：

- 基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。
- 从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿
- 但是从整个程序的吞吐量来看，移动对象会更划算。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要
  高得多，这部分的耗时增加，总吞吐量仍然是下降的

- HotSpot虚拟机里面关注吞吐量的ParallelScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的

- 还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。



## 根节点枚举

- 枚举根节点的时候，用户线程必须要停顿。

- 根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行
- 这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因



- 虚拟机应当是有办法直接得到哪些地方存放着对象引用的。
- 在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，
- 在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。



### 安全点（SafePoint）

- 实际上HotSpot也的确没有为每条指令都生成OopMap,只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）
- 安全点的设定，决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停
- 安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。

#### 抢先式中断（Preemptive Suspension）：

抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。

现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。

#### 主动式中断（Voluntary Suspension）:

- 当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。
- 轮询标志的地方和安全点是重合的，
- 另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。



### 安全区域（Safe Region）：

- 用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。

- 对于这种情况，就必须引入安全区域（Safe Region）来解决。
- 安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。
- 我们也可以把安全区域看作被扩展拉伸了的安全点 



当用户线程执行到安全区域里面的代码时，

- 首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。
- 当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），
- 如果完成了，那线程就当作没事发生过，继续执行；
- 否则它就必须一直等待，直到收到可以离开安全区域的信号为止。



### 记忆集与卡表（Remembered Set）：

- 为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围

- 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构

- 在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节

  

#### 卡精度：

  每个记录精确到一块内存区域，该区域内有对象含有跨代指针。