---
title: 设计模式之禅-07-建造者模式
copyright: true
related_posts: true
date: 2020-12-20 15:02:08
tags: 
    - 建造者模式
    - Builder
categories: 设计模式
---

## 建造者模式

### 定义：  

建造者模式（Builder Pattern）也叫 生成器模式

Separate the construction of a complex object  from its representation so that the same construction process can create different representations (将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 )

建造者模式的通用类图如下图所示：

聚合（导演类 ，builder ）

继承（builder，具体Builder）

依赖（具体Builder，产品类）

![](/uploads/design_patterns/07builder/builder03.png)



- Product 产品类

  通常是实现了模板模式，也就是由 模板方法和基本方法，就是ConcreteMOdle

- Builder 抽象建造类

  规范产品的组件，一般是由子类实现。如CarBuilder

- ConcreteBuilder 具体的建造者

  实现抽象类定义的所有方法，并且返回一个组件好的对象，

- Director 导演类

  负责安排已有模块的顺序，返回告诉Builder开始建造

- ps: 导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。当然在建造者模式比较庞大时，导演雷可以有多个





### 示例

![](/uploads/design_patterns/07builder/builder01.png)

![](/uploads/design_patterns/07builder/builder02.png)



```java

public abstract class CarBuilder {
    //建造一个模型，你要给我一个顺序要求，就是组装顺序
    public abstract void setSequence(ArrayList<String> sequence);
    //设置完毕顺序后，就可以直接拿到这个车辆模型
    public abstract CarModel getCarModel();
}

public class BenzBuilder extends CarBuilder {
    private BenzModel benz = new BenzModel();
    public CarModel getCarModel() {
    	return this.benz;
    }
    public void setSequence(ArrayList<String> sequence) {
    	this.benz.setSequence(sequence);
    }
}

public class Director {
    private ArrayList<String> sequence = new ArrayList();
    private BenzBuilder benzBuilder = new BenzBuilder();
    private BMWBuilder bmwBuilder = new BMWBuilder();
    /*
    * A类型的奔驰车模型，先start，然后stop，其他什么引擎、喇叭一概没有
    */
    public BenzModel getABenzModel(){
        //清理场景，这里是一些初级程序员不注意的地方
        this.sequence.clear();
        //ABenzModel的执行顺序
        this.sequence.add("start");
        this.sequence.add("stop");
        //按照顺序返回一个奔驰车
        this.benzBuilder.setSequence(this.sequence);
        return (BenzModel)this.benzBuilder.getCarModel();
    }
    /*
    * B型号的奔驰车模型，是先发动引擎，然后启动，然后停止，没有喇叭
    */
    public BenzModel getBBenzModel(){
        this.sequence.clear();
        this.sequence.add("engine boom");
        this.sequence.add("start");
        this.sequence.add("stop");
        this.benzBuilder.setSequence(this.sequence);
        return (BenzModel)this.benzBuilder.getCarModel();
    }
    /*
    * C型号的宝马车是先按下喇叭（炫耀嘛），然后启动，然后停止
    */
    public BMWModel getCBMWModel(){
        this.sequence.clear();
        this.sequence.add("alarm");
        this.sequence.add("start");
        this.sequence.add("stop");
        this.bmwBuilder.setSequence(this.sequence);
        return (BMWModel)this.bmwBuilder.getCarModel();
    }
    /*
    * D类型的宝马车只有一个功能，就是跑，启动起来就跑，永远不停止
    */
    public BMWModel getDBMWModel(){
        this.sequence.clear();
        this.sequence.add("start");
        this.bmwBuilder.setSequence(this.sequence);
        return (BMWModel)this.benzBuilder.getCarModel();
    }
/*
* 这里还可以有很多方法，你可以先停止，然后再启动，或者一直停着不动，静态的嘛
* 导演类嘛，按照什么顺序是导演说了算
*/
}
```



### 优点

- 封装性

  使用建造者模式 可以使得 客户端不必知道产品内部组成得细节。

- 建造者独立，容易扩展

  BenzBuilder 和 BMWBuilder 是互相独立的，对系统的扩展非常有利。

- 便于控制细节风险

  由于具体的建造者都是独立的。因此可以对建造过程逐步细化，而不对其他的模块产生任何影响

### 使用场景

- 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式

- 多个部件或零件，都可以装配到同一个对象中，但是产生的运行结果又不相同的时候，则可以使用该模式
- 产品类非常复杂，或者产品类中的调用顺序不同 产生了不同的效能，这个时候使用建造者模式非常合适

- 在对象构建过程中，会使用到系统的一些其他对象，这些对象在产品对象的创建过程中不容易得到时，也可以采用建造者模式封装该对象的创建过程。     这种场景只能时一个补偿方案，因为一个对象不同意获得，而在设计阶段并发没发觉，而要通过 Builder模式 柔化创建过程，本身已经违反设计的最初目标 。

### 注意事项

- 建造者模式关注的是 零件类型和装配工艺（顺序），这个是它和工厂模式最大的不同

### 扩展

- 建造者模式是零件的组装，组装顺序不同，对象的效能也不同，这才是建造者模式要表达的核心意义，
- 建造者模式最主要的功能是基本方法的调用顺序的安排，也就是这些基本方法已经实现了（通过模板方法模式）
- 工厂模式重点则是 创建，创建零件是它的主要职责，组装顺序则不是它的关注点