---
title: 设计模式之禅-02-六大设计原则
copyright: true
related_posts: true
date: 2020-11-14 23:56:49
tags: 
   - 设计原则
   - 设计模式
categories: 设计模式
---
## 单一职责原则
 (SRP)Single Responsibility Principle:
 There should never be more than one reason for a class to change.
 我觉得这个单一职责原则看起来很简单，就是说一个接口对应一个职责，一个接口只做一件事情。
 就比如 老外饭桌上吃饭餐具分刀和叉。刀用来切割食物，叉用来固定和移动食物，分工很明确。而我们的筷子就全部把这些事情做完了。
 再比如 厨房刀具分水果刀、切肉刀等等，屠夫杀猪也会准备很多刀，功能都不一，这就是单一职责。

应用到项目开发， 可是职责的划分其实很不确定，这个因项目而异，因环境而异。

 - 对于接口，我们在设计的时候一定要做到单一职责，但是对于实现类我们就需要多考虑。生搬硬套单一职责，就会引起类的剧增，制造了系统的复杂性。

 - 对于方法，单一职责也适用。一个方法做一件事情，方法名体现了方法的功能。这样既愉悦自己，也愉悦自己的同事，一眼就可以知道这个方法做了什么事情。

 - 现实有现实的难处，我们要考虑很多因素，工期，成本，人员技术水平等，可能会很难实施

   But 建议就是接口尽量单一职责，方法一定要单一职责



## 里氏替换原则

定义一：如果对每一个类型为S的对象o1 ，都有类型为T的对象o2，使得以T定义的所有程序P在所有对象o1 都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型 。

定义二：  所有引用基类的地方都必须能透明地 使用其子类的对象

简单讲就是： 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或者异常。使用者根本不需要知道是父类还是子类。

举个例子，定义了一个通用的接口方法， 方法参数就设置为一个抽象方法，只有在具体实现使用的时候，才会传子类进去。

里氏替换原则为良好的继承定义了一个规范，包含了4层含义

- 子类必须完全 实现父类的方法

  （如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生”畸变“，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承）

- 子类可以有自己的特性

  (如果某个方法中显式的指出参数就是子类，那么传父类进来肯定就编译不通过了)

- 覆盖或实现父类的方法是，输入参数可以被放大

  todo: （应该从jvm字节码层面去思考为什么可以这么做）

  - 假如父类的方法参数是HashMap,子类的方法参数是Map，子类方法参数范围变大了，那么子类就是 重载（Overload）了这方法。      
    这个时候，子类的输入参数类型范围扩大了，子类代替父类传递到调用者中，子类的方法永远不会被执行。这个是正常的。如果是想要子类的方法被执行，那么请和子类参数一样，这是 覆写（Override）
  - 假如父类的方法入参是Map，子类的方法参数是HashMap，子类方法参数范围变小了。这样的话，子类在没有覆写 父类方法的前提下，却被执行了，这样会引起业务关系的紊乱，歪曲了父类的意图。

  

- 覆写或实现父类的方法时，输出结果可以被缩小 

  - 如果是覆写（Override），父类和子类同名方法的输入类型是相同的，子类方法的返回值S范围  小于等于 父类的返回值范围F
  - 如果是重载（OverLoad）,则方法的输入参数类型或者数量不相同

  

- 总结：

  尽量避免子类的‘’个性”，一旦子类有个性，子类和父类之间的关系就难调和，出现混乱了。尽量把子类当作父类来使用。

  把子类单独作为一个业务来使用，则会让代码的耦合扑朔迷离，却反类替换标准



## 依赖倒置原则

（Dependence Inversion Principle,DIP）

​	High level modules should not depend upon low level modules,Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions

翻译过来包含3层含义：

- 高层模块不应该依赖底层模块，两者都应该依赖其抽象

不可分割的原子逻辑就是底层模块，原子逻辑的再次组装就是高层模块。

- 抽象不应该依赖细节
- 细节应该依赖抽象

抽象指的是抽象类或者接口，细节指的是其实现类或者继承者，特点是可以被实例化。

其实最精简的解释就是：面向接口编程。

- 模块之间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是 通过接口或者抽象类产生的
- 接口或抽象类不依赖实现类
- 实现类依赖 接口或抽象类



- 好处： 

  - 依赖倒置有利于并行开发，2个类具有依赖关系，只要指定出2者之间的接口（或者抽象类）就可以独立开发了，而且项目之间的单元测试也可以独立进行了。

  - TDD（测试驱动开发）开发模式就是依赖倒置的最高级运用，丢给你一个接口，就可以自行Mock了 

![](/uploads/design_patterns/02SixPrinciple/DependenceInversionPrincipl.png)

```
classDiagram
Driver ..> IDriver : 实现
IDriver --> ICar : 依赖
ICar<.. BenzCar : 实现
ICar ..> BMWCar : 实现
class IDriver{
    <<interface>>
     +driver(ICar car)  void
   
}
class ICar{
  	<<interface>>
     +run()  void
}

```


- 依赖的3中写法
  - 构造函数传递依赖对象
  - Setter方法传递依赖对象
  - 接口声明依赖对象，接口注入





## 接口隔离原则

简单概述就是2个重点：

- Cilents should not be forced to depend upon interfaces that they donot use (客户端不应依赖它不需要的接口)

- The dependency of one class to another one should depend on the smallest possible interface(类间的依赖关系应该建立在最小的接口上)

  需要对接口进行细化，保证它的纯洁性

  要求接口 中的方法尽量少 

  如果多个模块依赖一个接口的功能，那我们应该给每个模块提供单独的接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问

  ![](/uploads/design_patterns/02SixPrinciple/InterfaceIsolation01.png)

  ```
  classDiagram
  AbstractSearcher o--> IPettyGirl : 聚合
  Searcher --|> AbstractSearcher : 继承
  IPettyGirl <.. PettyGirl :实现
  
  class IPettyGirl{
      <<interface>>
       +goodLooking()  void
       +niceFiggure()  void
       +greatTemperment()  void
     
  }
  class AbstractSearcher{
  	<<abstract>>
  	+AbstractSearcher(IPettyGirl _pettyGirl)
  	 show()* void
  }
  
  ```

  如上图： 这里 IPettyGirl 接口就 过于臃肿了，我们的审美观点都在改变，美女的定义也在变化。有些女生虽然长的不是很出众，但是气质好，也属于美女，大家也都喜欢，所以这里：

  可以把IPettyGirl  拆分成：外形美的美女IGoodBodyGirl、 气质美的美女IGreatTemperamentGirl  

  ![](/uploads/design_patterns/02SixPrinciple/InterfaceIsolation02.png)

  ```
  classDiagram
  AbstractSearcher o--> IGoodBodyGirl : 聚合
  AbstractSearcher o--> IGreatTemperamentGirl  : 聚合
  Searcher --|> AbstractSearcher : 继承
  IGreatTemperamentGirl   <.. PettyGirl :实现
  IGoodBodyGirl   <.. PettyGirl :实现
  
  class IGoodBodyGirl{
      <<interface>>
       +goodLooking()  void
       +niceFiggure()  void
  }
  class IGreatTemperamentGirl  {
      <<interface>>
       +greatTemperment()  void
     
  }
  
  class AbstractSearcher{
  	<<abstract>>
  	+AbstractSearcher(IGoodBodyGirl _goodBodyGirl)
  	+AbstractSearcher(IGreatTemperamentGirl _greatTemperamentGirl)
  	 show()* void
  }
  
  ```

  

- ps：

  以上把一个臃肿的接口 变更为两个独立的接口 就是 接口隔离原则的表现形式。 让 AbstractSearcher依赖2个装用的接口比依赖一个综合的接口要更灵活。

  接口是我们设计阶段对外提供的 契约，通过分散定义多个接口，可以预防未来变更的扩展，提供系统的灵活性和可维护性

- 总结

  -  接口要尽量小 ，小是有粒度的，要符合  单一职责原则，不要过度拆分

  - 接口要高内聚，就是接口中尽量少公布public方法，接口是对外的承诺，承诺越少，变更的风险就越少。

    就是不讲任何条件，立刻完成任务的行为就是高内聚的表现。

  - 定制服务，假如 项目作为服务方 为各个接入方 提供了 各个接入方（互相隔离）专用的查询接口，本系统内部还有 不隔离的混合查询方式。该混合查询方式也能满足各个接入方的查询需求，但是就不能对外公布 。

  - 接口设计是有粒度的 ，粒度越小系统越灵活，但是灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。所以这个衡量度，需要根据 实践，经验，领悟 去判断 。



## 迪米特原则

迪米特法则（Law of Demeter,LoD）也叫 最少知识原则（Least Knowledge Principle，LKP）

:一个对象应该对其他对象有最少的了解，一个类应该对自己需要调用的类知道的最少，被调用的类内部如何复杂与我无关，我只关心你提供的public的方法，其他的一概不关心。

换句话说，外部只需要一个获取结果的方法就行，不需要知道接口是具体如何实现的细节，我给你一个结果，你不必关注我的实现方式。细节的方法不需要提供出去

-  只和直接朋友交流 （only talk to your immediate friends ） ： 类与类之间的关系是建立在类间的，而不是方法间的，因此一个方法尽量不要引入一个类中不存在的对象

- 朋友间也是有距离的，一个类公开的public属性或者方法越多，修改时 涉及的面就越大，变更引起的风险扩散就越大。因此为了保持朋友类间的距离，需要尽量收敛，多用private 、package-private. protected等访问权限

-  是自己的就是自己的 ： 如果一个方法放在本类中也可以，放在其他类中也可以。判断方法是：  如果一个方法放在本类中，既不增加类间关系，也不对本类产生负面影响，就放在本类中 。（当然前提一定也是 符合单一职责原则的，不要放一个不相干的方法进来)

  

核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。读者在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。



## 开闭原则



Software entities like classes,modules and  functions should be open for extension but closed for modifications .(一个软件实体如类、模块和函数应该对扩展开放，对修改关闭)

尽量不修改原有的已经上线的代码， 通过扩展的方式 适应新的需求。

### 开闭原则的重要性：

- 开发原则对测试的影响

  已经投产的代码都是有意义的，都是接受系统规则的约束，都是经过几轮测试的。 因此有变化提出的时候，就需要考虑原来的健壮代码是否可以不修改，仅仅通过扩展实现 。否则修改了原有代码就需要各种回归测试 ，提高了 成本

- 开闭原则提高了复用性

  面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的 ，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越细，被复用的可能性越大。  怎么提高复用率，缩小逻辑粒度，直到一个逻辑不可再拆分为止

- 开闭原则可以提高可维护性

  一款软件投产后，维护人员的工作不仅是对数据进行维护，还可能要对程序进行扩展。扩展一个类很简单，因为修改一个类，就得需要读懂原有的代码，牵扯的模块，怕的就是牵一发动全身。



### 开闭原则的使用方式

1.抽象约束

- 接口抽象

- 参数类型及引用对象抽象、

- 抽象层保持稳定

