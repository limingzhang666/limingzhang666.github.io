---
title: 设计模式之禅-02-六大设计原则
copyright: true
related_posts: true
date: 2020-11-14 23:56:49
tags: 
    - 设计原则
     - 设计模式
categories: 设计模式
---
## 单一职责原则
 (SRP)Single Responsibility Principle:
 There should never be more than one reason for a class to change.
 我觉得这个单一职责原则看起来很简单，就是说一个接口对应一个职责，一个接口只做一件事情。
 就比如 老外饭桌上吃饭餐具分刀和叉。刀用来切割食物，叉用来固定和移动食物，分工很明确。而我们的筷子就全部把这些事情做完了。
 再比如 厨房刀具分水果刀、切肉刀等等，屠夫杀猪也会准备很多刀，功能都不一，这就是单一职责。

应用到项目开发， 可是职责的划分其实很不确定，这个因项目而异，因环境而异。

 - 对于接口，我们在设计的时候一定要做到单一职责，但是对于实现类我们就需要多考虑。生搬硬套单一职责，就会引起类的剧增，制造了系统的复杂性。

 - 对于方法，单一职责也适用。一个方法做一件事情，方法名体现了方法的功能。这样既愉悦自己，也愉悦自己的同事，一眼就可以知道这个方法做了什么事情。

 - 现实有现实的难处，我们要考虑很多因素，工期，成本，人员技术水平等，可能会很难实施

   But 建议就是接口尽量单一职责，方法一定要单一职责



## 里氏替换原则

定义一：如果对每一个类型为S的对象o1 ，都有类型为T的对象o2，使得以T定义的所有程序P在所有对象o1 都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型 。

定义二：  所有引用基类的地方都必须能透明地 使用其子类的对象

简单讲就是： 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或者异常。使用者根本不需要知道是父类还是子类。

举个例子，定义了一个通用的接口方法， 方法参数就设置为一个抽象方法，只有在具体实现使用的时候，才会传子类进去。

里氏替换原则为良好的继承定义了一个规范，包含了4层含义

- 子类必须完全 实现父类的方法

  （如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生”畸变“，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承）

- 子类可以有自己的特性

  (如果某个方法中显式的指出参数就是子类，那么传父类进来肯定就编译不通过了)

- 覆盖或实现父类的方法是，输入参数可以被放大

  todo: （应该从jvm字节码层面去思考为什么可以这么做）

  - 假如父类的方法参数是HashMap,子类的方法参数是Map，子类方法参数范围变大了，那么子类就是 重载（Overload）了这方法。      
    这个时候，子类的输入参数类型范围扩大了，子类代替父类传递到调用者中，子类的方法永远不会被执行。这个是正常的。如果是想要子类的方法被执行，那么请和子类参数一样，这是 覆写（Override）
  - 假如父类的方法入参是Map，子类的方法参数是HashMap，子类方法参数范围变小了。这样的话，子类在没有覆写 父类方法的前提下，却被执行了，这样会引起业务关系的紊乱，歪曲了父类的意图。

  

- 覆写或实现父类的方法时，输出结果可以被缩小 

  - 如果是覆写（Override），父类和子类同名方法的输入类型是相同的，子类方法的返回值S范围  小于等于 父类的返回值范围F
  - 如果是重载（OverLoad）,则方法的输入参数类型或者数量不相同

  

- 总结：

  尽量避免子类的‘’个性”，一旦子类有个性，子类和父类之间的关系就难调和，出现混乱了。尽量把子类当作父类来使用。

  把子类单独作为一个业务来使用，则会让代码的耦合扑朔迷离，却反类替换标准



## 依赖倒置原则

（Dependence Inversion Principle,DIP）

​	High level modules should not depend upon low level modules,Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions

## 接口隔离原则
## 迪米特原则
## 开闭原则

