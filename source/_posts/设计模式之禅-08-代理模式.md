---
title: 设计模式之禅-08-代理模式
copyright: true
related_posts: true
date: 2020-12-20 23:28:54
tags: 
	-代理模式
	-委托模式
categories: 设计模式之禅
---

## 代理模式（Proxy Pattern）

### 定义

Provide a surrogate or placeholder for another object to control access to it (为其他对象提供一种代理以控制对这个对象的访问)

#### 类图

![](/uploads/design_patterns/08proxy/proxy01.png)

- 代理模式也叫委托模式，他是一项基本设计技巧。 其他的很多模式都是在更特殊的场合下采用 委托模式

- Subject 抽象主题角色

  抽象主题类可以是抽象类，也可以是接口，是一个最普通的业务类型定义，没有特殊要求

- RealSubject 具体主题角色

  也叫 ： 被委托角色、被代理角色。是 业务逻辑的具体执行者

- Proxy 代理主题角色

  也叫做 委托类、代理类。它负责对真是角色的应用，把所有抽象主题类定义的方法限制委托给 真实主题角色卡实现， 

  并且在真实主题角色处理完毕 前后做预处理 以及善后处理 工作

  ```java
  // 代码清单12-6 抽象主题类
  public interface Subject {
      //定义一个方法
      public void request();
  }
  
  // 代码清单12-7 真实主题类
  public class RealSubject implements Subject {
      //实现方法
      public void request() {
      //业务逻辑处理
      }
  }
  // 代码清单12-8 代理类
  public class Proxy implements Subject {
      //要代理哪个实现类
      private Subject subject = null;
      //默认被代理者
      public Proxy(){
     	 this.subject = new Proxy();
      }
      //通过构造函数传递代理者
      public Proxy(Object...objects ){
      }
      //实现接口中定义的方法
      public void request() {
          this.before();
          this.subject.request();
          this.after();
      }
      //预处理
      private void before(){
     	 //do something
      }
      //善后处理
      private void after(){
      	//do something
      }
  }
  
  ```

  - 一个代理类可以代理多个 被委托者，因此 一个代理类具体代理 哪个真实主题角色，是由场景类决定的。 
  - 当然最简单的情况就是 一个主题类和一个代理类。  
  -  一个接口只需要一个代理类即可，具体代理哪个实现类 ，则由高层模块来决定，也就是在代理类的构造函数中 传递被代理者。

### 应用

#### 优点

- 职责清晰

  真实的角色 只是去实现实际的业务逻辑，不用去关心其非本职责的事务， 通过后期的代理 完成一件事务，附带的结果就是code 简洁清晰

-  高扩展性

  具体主题角色是随时都会发生变化的，只要它实现了接口 。而代理类不需要修改，因为真正的实现是 具体实现类做的。代理类只是增强 

- 智能化

#### 场景

Spring Aop 动态代理

#### 扩展

##### 普通扩展



![](/uploads/design_patterns/08proxy/normalProxy.png)

GamePlayer 的构造函数增加了 _gamePlayer参数，而代理角色只需要传入代理者 名字即可，而不需要说是替代哪个对象做代理

```java
// 代码清单12-10 普通代理的游戏者
public class GamePlayer implements IGamePlayer {
    private String name = "";
    //构造函数限制谁能创建对象，并同时传递姓名
    public GamePlayer(IGamePlayer _gamePlayer,String _name) throws Exception{
    if(_gamePlayer == null ){
    	throw new Exception("不能创建真实角色！");
    }else{
   	 	this.name = _name;
    }
    }
    //打怪，最期望的就是杀老怪
    public void killBoss() {
    	System.out.println(this.name + "在打怪！");
    }
    //进游戏之前你肯定要登录吧，这是一个必要条件
    public void login(String user, String password) {
    	System.out.println("登录名为"+user + "的用户" + this.name + "登录成功！");
    }
    //升级，升级有很多方法，花钱买是一种，做任务也是一种
    public void upgrade() {
    	System.out.println(this.name + " 又升了一级！");
    }
}

// 代码清单12-11 普通代理的代理者
public class GamePlayerProxy implements IGamePlayer {
    private IGamePlayer gamePlayer = null;
    //通过构造函数传递要对谁进行代练
    public GamePlayerProxy(String name){
    try {
    	gamePlayer = new GamePlayer(this,name);
    } catch (Exception e) {
    // TODO 异常处理
    }
    }
    //代练杀怪
    public void killBoss() {
    	this.gamePlayer.killBoss();
    }
    //代练登录
    public void login(String user, String password) {
   	 	this.gamePlayer.login(user, password);
    }
    //代练升级
    public void upgrade() {
    	this.gamePlayer.upgrade();
    }
}
```



在该模式下，调用者只知道代理 而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色可以任意修改，对高层模块没有任何影响。

该模式非常适合对扩展性要求较高的场合。  

在真实项目中，一般都是通过约定来 禁止new 一个真实的角色。这里GamePlayer的构造函数要求，必须传入一个 GamePlayerProxy

##### 强制代理



必须通过真实角色查找代理角色，否则不能访问 ，只有通过真实角色指定的代理类才可以访问 ，也就是是说 真实角色管理代理角色。

高层模块new 了一个真实角色的对象，返回的确实代理角色。

比喻ps： 你和一个明星很熟，互相认识，有事情需要找他，于是你直接给他打电话。但是 明星却让你去找经纪人。

你想直接绕过明星的代理，但是返回的还是 明星的代理。这就是强制代理

![](/uploads/design_patterns/08proxy/forceProxy.png)

```java
// 代码清单12-13 强制代理的接口类
public interface IGamePlayer {
    //登录游戏
    public void login(String user,String password);
    //杀怪，这是网络游戏的主要特色
    public void killBoss();
    //升级
    public void upgrade();
    //每个人都可以找一下自己的代理
    public IGamePlayer getProxy();
}

public class GamePlayer implements IGamePlayer {
    private String name = "";
    //我的代理是谁
    private IGamePlayer proxy = null;
    public GamePlayer(String _name){
   	 	this.name = _name;
    }
    //找到自己的代理
    public IGamePlayer getProxy(){
        this.proxy = new GamePlayerProxy(this);
        return this.proxy;
    }
    //打怪，最期望的就是杀老怪
    public void killBoss() {
        if(this.isProxy()){
        	System.out.println(this.name + "在打怪！");
        }else{
            System.out.println("请使用指定的代理访问");
        }
    }
    //进游戏之前你肯定要登录吧，这是一个必要条件
    public void login(String user, String password) {
        if(this.isProxy()){
        	System.out.println("登录名为"+user+"的用户"+this.name+"登录成功！");
        }else{
        	System.out.println("请使用指定的代理访问");;
        }
    }
    //升级，升级有很多方法，花钱买是一种，做任务也是一种
    public void upgrade() {
        if(this.isProxy()){
        	System.out.println(this.name + " 又升了一级！");
        }else{
        	System.out.println("请使用指定的代理访问");
        }
    }
    //校验是否是代理访问
    private boolean isProxy(){
        if(this.proxy == null){
            return false;
        }else{
            return true;
        }
    }
}

// 代码清单12-15 强制代理的代理类
public class GamePlayerProxy implements IGamePlayer {
    private IGamePlayer gamePlayer = null;
    //构造函数传递用户名
    public GamePlayerProxy(IGamePlayer _gamePlayer){
    	this.gamePlayer = _gamePlayer;
    }
    //代练杀怪
    public void killBoss() {
    	this.gamePlayer.killBoss();
    }
    //代练登录
    public void login(String user, String password) {
    	this.gamePlayer.login(user, password);
    }
    //代练升级
    public void upgrade() {
        this.gamePlayer.upgrade();
    }
    //代理的代理暂时还没有，就是自己
    public IGamePlayer getProxy(){
    	return this;
    }
}
```

ps: 强制代理的概念  是 从真实角色找到代理角色，不需要直接访问真实角色。 高层模块 只要调用getProxy 就可以访问真实角色的所有方法，他根本不需要产生一个代理出来，代理的管理已经由真实角色自己完成 。

##### 代理是有个性的

一个类可以实现多个接口，完成不同任务的整合。也就是说代理类不仅仅可以实现主题接口，也可以实现其他接口完成不同的任务 ，而且

ps: 代理的目的 是在目标对象方法的基础上 作增强，这种增强的本质是对目标对象的方法进行拦截和过滤 。

![](/uploads/design_patterns/08proxy/wavedProxy.png)



```java
public interface IProxy {
    //计算费用
    public void count();
}

public class GamePlayerProxy implements IGamePlayer,IProxy {
    private IGamePlayer gamePlayer = null;
    //通过构造函数传递要对谁进行代练
    public GamePlayerProxy(IGamePlayer _gamePlayer){
   	 	this.gamePlayer = _gamePlayer;
    }
    //代练杀怪
    public void killBoss() {
    	this.gamePlayer.killBoss();
    }
    //代练登录
    public void login(String user, String password) {
    	this.gamePlayer.login(user, password);
    }
    //代练升级
    public void upgrade() {
    	this.gamePlayer.upgrade();
    this.count();
    }
    //计算费用
    public void count(){
    	System.out.println("升级总费用是：150元");
    }
}	
```



##### 动态代理

动态代理是 在实现阶段不需要关心代理谁 ，而在运行阶段才指定代理哪一个对象 。 相对来说，自己写代理类的方式就是静态代理。

AOP（Aspect Oriented Programming），其核心就是动态代理机制 

![](/uploads/design_patterns/08proxy/aopProxy.png)

- 在类图中增加了一个 InvocationHandler 接口 和GamePlayIH 类，作用就是产生一个对象的代理对象。

- 其中 InvocationHandler 就是JDK 提供的动态代理接口，对被代理类的方法进行代理 

  ```java
  // 代码清单12-21 动态代理类
  public class GamePlayIH implements InvocationHandler {
      //被代理者
      Class cls =null;
      //被代理的实例
      Object obj = null;
      //我要代理谁
      public GamePlayIH(Object _obj){
      	this.obj = _obj;
      }
      //调用被代理的方法
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          Object result = method.invoke(this.obj, args);
          return result;
      }
  }
  
  
  ```

- 其中invoke 方法是 接口InvocationHandler 定义必须实现的 。他完成对真实方法的调用 

- 动态代理是 更具被代理的接口 （ here:   Class cls =null; ）生成所有的方法 ,  也就是说给定一个接口，动态代理会宣称： 我已经实现了该接口下的所有方法

- 动态代理如何实现被代理接口中的方法：

  -  默认情况下所有方法的返回值  都是空的，代理已经实现了它，但是没有任何的逻辑含义 
  - 都是通过 InvocationHandler 接口，所有方法都由该 Handler 来进行处理，即 所有被代理的方法都由 InvocationHandler接管实际的处理任务 

```java
代码清单12-22 动态代理的场景类
public class Client {
public static void main(String[] args) throws Throwable {
    //定义一个痴迷的玩家
		IGamePlayer player = new GamePlayer("张三");		
		//定义一个hanlder
		InvocationHandler handler = new GamePlayIH(player);		
		//开始打游戏，记下时间戳
		System.out.println("开始时间是：2009-8-25 10:45");		
		//获得类的class loader
		ClassLoader cl = player.getClass().getClassLoader();		
		//动态产生一个代理者
		IGamePlayer proxy = (IGamePlayer)Proxy.newProxyInstance(cl,new Class[]{IGamePlayer.class},handler);		
		//登录
		proxy.login("zhangSan", "password");		
		//开始杀怪
		proxy.killBoss();
		//升级
		proxy.upgrade();
		//记录结束游戏时间
		System.out.println("结束时间是：2009-8-26 03:40");
    }
}
```

- 我们既没有创建代理类，也没有实现IGamePlayer 接口，却实现了 代练的功能 。这就是动态代理 





```java
// 代码清单12-23 修正后的动态代理
public class GamePlayIH implements InvocationHandler {
	//被代理者
	Class cls =null;
	//被代理的实例
	Object obj = null;
	
	//我要代理谁
	public MyIvocationHandler(Object _obj){
		this.obj = _obj;
	}
	
	//调用被代理的方法
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		Object result = method.invoke(this.obj, args);
		//如果是登录方法，则发送信息
		if(method.getName().equalsIgnoreCase("login")){
			System.out.println("有人在用我的账号登陆！");
		}
		return result;
	}
}
```

##### 动态代理模型

![](/uploads/design_patterns/08proxy/aopCommonClassDiagram.png)

两条独立发展线路

- 动态代理实现代理的职责
- 业务逻辑Subject 实现相关的逻辑功能。二者没有必然的相互耦合的关系
- 通知Advice 从另一个切面切入，最终在高层模块 也就是client进行耦合 ，完成逻辑的封装

```java
// 代码清单12-24 抽象主题
public interface Subject {
    //业务操作
    public void doSomething(String str);
}

// 代码清单12-25 真实主题
public class RealSubject implements Subject {
    //业务操作
    public void doSomething(String str) {
    	System.out.println("do something!---->" + str);
    }
}

// 重点是我们的MyInvocationHandler
public class MyInvocationHandler implements InvocationHandler {
    //被代理的对象
    private Object target = null;
    //通过构造函数传递一个对象
    public MyInvocationHandler(Object _obj){
    	this.target = _obj;
    }
    //代理方法
    public Object invoke(Object proxy, Method method, Object[] args)  throws Throwable {
        //执行被代理的方法
        return method.invoke(this.target, args);
    }
}

// 代码清单12-27 动态代理类
public class DynamicProxy<T> {
public static <T> T newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h){
    //寻找JoinPoint连接点，AOP框架使用元数据定义
    if(true){
        //执行一个前置通知
        (new BeforeAdvice()).exec();
    }
    //执行目标，并返回结果
    return (T)Proxy.newProxyInstance(loader,interfaces, h);
    }
}

public interface IAdvice {
    //通知只有一个方法，执行即可
    public void exec();
    }
public class BeforeAdvice implements IAdvice{
    public void exec(){
    	System.out.println("我是前置通知，我被执行了！");
    }
}

// 代码清单12-29 动态代理的场景类
public class Client {
    public static void main(String[] args) {
        //定义一个主题
        Subject subject = new RealSubject();
        //定义一个Handler
        InvocationHandler handler = new MyInvocationHandler(subject);
        //定义主题的代理
        Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(),handler);
        //代理的行为
        proxy.doSomething("Finish");
    }
}


// TODO
```

通过

```java
this.obj=Proxy.newProxyInstance(c.getClassLoader(),c.getInterfaces(),new MyInvocationHandler(_obj));
```

重新生成了一个代理对象 。c.getInterfaces()的作用是查找该类的所有接口，然后实现接口的所有方法。虽然方法内都是空的。 

 handler=new MyInvocationHandler(_obj) ，handler 对象 接管了这些方法。这个就是动态代理类

也就是由 InvocationHandler 的实现类实现所有的方法，由其 invoke 方法接管所有方法的实现。其动态调用的过程就是 

![](/uploads/design_patterns/08proxy/dynamicProxyProcess.png)

client --doSomethind--> DynamicProxy --invoke-->MyInvocationHandler --"invoke()"-->Subject对象

ps: 因为 DynamicProxy  是一个通用类，没有业务含义，我们可以新建一个实现类实现它，赋予业务含义

```java
// 代码清单12-30 具体业务的动态代理
public class SubjectDynamicProxy extends DynamicProxy{
    public static <T> T newProxyInstance(Subject subject){
    //获得ClassLoader
    ClassLoader loader = subject.getClass().getClassLoader();
    //获得接口数组
    Class<?>[] classes = subject.getClass().getInterfaces();
    //获得handler
    InvocationHandler handler = new MyInvocationHandler(subject);
    	return newProxyInstance(loader, classes, handler);
    }
}

// 代码清单12-31 场景类
public class Client {
    public static void main(String[] args) {
    //定义一个主题
    Subject subject = new RealSubject();
    //定义主题的代理
    Subject proxy = SubjectDynamicProxy.newProxyInstance(subject);
    //代理的行为
    proxy.doSomething("Finish");
    }
}
```



- 动态代理的主要意图就是： 横切面编程（AOP），在不改变已有代码结构的情况下 增强或者控制 对象的行为
- 实现动态代理的首要条件就是： 被代理类（realSubject）必须实现一个接口 。当然cglib 可以实现不需要接口也可以实现动态代理的方式

### 实践

代理模式 应用非常广泛， 事务处理，日志管理 都用到了代理模式。应该是 接触最多的模式，有了AOP 后写代理就更加简单了 。可以使用 springAOP 和 ASpectJ工具 。调试时候看到 $Proxy0 这种结构，就可以知道这个是 动态代理了。

学习AOP框架时候，弄清楚这几个名词： 切面（Aspect）、切入点（JoinPoint）、通知（Advice）、织入（Weave）

