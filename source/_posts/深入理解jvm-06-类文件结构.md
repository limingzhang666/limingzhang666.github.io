---
title: 深入理解jvm-06-类文件结构
copyright: true
related_posts: true
date: 2021-01-11 22:03:21
tags: 类文件结构
categories: jvm
---



# 类文件结构

## 无关性的基石

### 平台无关性：

- 各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石

### 语言无关性：

- Java技术发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，
- 他们在发布规范文档的时候，也刻意把Java的规范拆分成了：
- ***《Java语言规范》（The Java Language Specification）***
- ***及《Java虚拟机规范》（The Java Virtual Machine Specification）***



***在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上”***
***（In the future，we will consider bounded extensions to the Java virtual machine to provide better support for other languages）***



- ***作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，以Class文件作为他们产品的交付媒介。***

例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把它们的源程序代码编译成Class文件。虚拟机丝毫不关心Class的来源是什么语言

- Java语言中的各种语法、关键字、常量变量和运算符号的语义 最终都会由多条字节码指令组合来表达 ，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。（类似于 java语言的功能只是 字节码功能的一个子集）
- 因此有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于java的语言特性提供了发挥空间

![](/uploads/jvm/08-JVM-nobindLanguage.png)

## Class类文件的结构

注意：

- 任何一个Class文件都对应着唯一的一个类或接口的定义信息
- 类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）



- Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在
- 当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割成若干个8个字节进行存储。



***Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”***

- 无符号数： 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
- 表：  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表

![](/uploads/jvm/09-jvm-wufahao-info.png)

- 无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。

### 强调：

Class的结构不像XML等描述语言，由于它没有任何分隔符号，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变



### 魔数与Class文件的版本

魔数：

- 每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件

- 使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动
- Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE（咖啡宝贝？）
- 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，
- 高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。



### 常量池

#### 定义：

- 紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。

#### 常量池容量计数值

- 由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）

- 与Java语言习惯不同，这个容量计数器从1开始，而不是从0开始。

- 之所以从1开始是因为 ：  在Class文件格式规范制定之时，设计者将第0项常量控出来是有特殊考虑，目的在于 ***当某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义 ，可以把索引值设置为0***来表示。 

- 如下 图所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。

  ![](/uploads/jvm/10-jvm-constantPool.png)



#### 常量类型：

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。

- 字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。

- 符号引用则属于编译原理方面的概念，主要包括下面几类常量：

  - 被模块导出或者开放的包（Package）
  - 类和接口的全限定名（Fully Qualified Name）
  - 字段的名称和描述符（Descriptor）
  - 方法的名称和描述符
  - 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）
  - 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

  

#### JVM动态连接

- 在Class文件中不会保存各个方法、字段最终在内存中的布局信息
- 这些字段、方法的符号引用不经过虚拟机在运行期转换的话 是无法得到真正的内存入口地址，也就无法直接被虚拟机直接使用
- 当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中



#### 常量池的项目类型

- 常量池中每一项常量都是一个表，
- 最初常量表中共有11种结构 各不相同的表结构数据，后来为了更好的支持动态语言调用，额外增加了4种动态语言相关的常量（）
  - JDK 7时增加了前三种：**CONSTANT_MethodHandle_info**、**CONSTANT_MethodType_info**和**CONSTANT_InvokeDynamic_info**。出于性能和易用性的考虑（JDK 7设计时已经考虑到，预留了17个常量标志位），在JDK 11中又增加了第四种常量**CONSTANT_Dynamic_info**。
- 为了支持Java模块化系统（Jigsaw），又加入了**CONSTANT_Module_info**和**CONSTANT_Package_info**两个常量
- 截至JDK13，常量表中分别有17种不同类型的常量。

![](/uploads/jvm/12-jvm-constantPool-projectType.png)



#### 常量结构：

- 之所以说常量池时最烦琐的数据，是因为这**17种常量类型各自有着完全独立的数据结构**，两两之间被没有什么共性和联系

##### CONSTANT_Class_info

- 回头看看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，

- 查表6-3的标志列可知这个常量属于**CONSTANT_Class_info**类型，此类型的常量代表一个**类或者接口的符号引用**。

- CONSTANT_Class_info的结构比较简单，如表6-4所示。

| 类型 | 名称       | 数量 |
| ---- | ---------- | ---- |
| u1   | tag        | 1    |
| u2   | name_index | 1    |

- 其中 tag 是标志位，它用于区分常量类型；
- name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了整个类（或者接口）的全限定名。
- 本例中的 name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量。
- 继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个**CONSTANT_Utf8_info**类型的常量。

##### CONSTANT_Utf8_info

 CONSTANT_Utf8_info 类型的结构如表6-5所示。
| 类型 | 名称   | 数量   |
| ---- | ------ | ------ |
| u1   | tag    | 1      |
| u2   | length | 1      |
| u1   | bytes  | length |

- length值说明了这个UTF-8编码的字符串长度是多少字节，
- 它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串
- UTF-8缩略编码与普通UTF-8编码的区别是：
  从'\u0001'到'\u007f'之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，
  从'\u0080'到'\u07ff'之间的所有字符的缩略编码用两个字节表示，从'\u0800'开始到'\uffff'之间的所有字符
  的缩略编码就按照普通UTF-8编码规则使用三个字节表示。
- 由于Class文件中方法、字段等都需要引用 CONSTANT_Utf8_info 型常量来描述名称，所以 CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度（length的最大值），即u2类型能表达的最大值65535。
- ***所以Java程序中如果定义了超过64KB*** 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。



#### javap 工具

在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。

代码清单6-2中列出了使用javap工具的-verbose参数输出的TestClass.class文件字节码内容（为节省篇幅，此清单中省略了常量池以外的信息）。



***代码清单6-2　使用javap命令输出常量表***

![](/uploads/jvm/13-jvm-constantPool-javap.png)



- 从代码清单6-2中可以看到，计算机已经帮我们把整个常量池的21项常量都计算了出来
- 其中有些常量似乎从来没有在代码中出现过，如“I”“V”“<init>”“LineNumberTable”“LocalVariableTable”等，这些看起来在源代码中不存在的常量是哪里来的？
- 这部分常量的确不来源于Java源代码，它们都是编译器自动生成的。会被字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用，它们将会被用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么
- 因为Java中的“类”是无穷无尽的，无法通过简单的无符号数来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达



#### 常量池中的17种数据类型的结构总表

![](/uploads/jvm/14-jvm-constantPool-01.png)

![](/uploads/jvm/14-jvm-constantPool-02.png)

![](/uploads/jvm/14-jvm-constantPool-03.png)





### TODO ：访问标志

