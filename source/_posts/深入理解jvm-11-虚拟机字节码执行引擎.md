---
title: 深入理解jvm-11-虚拟机字节码执行引擎
copyright: true
related_posts: true
date: 2021-01-18 23:42:20
tags: 虚拟机字节码执行引擎
categories: jvm
---

# 虚拟机字节码执行引擎

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。



## 概述

- 执行引擎是Java虚拟机核心的组成部分之一。

- “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，

- 其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，

- 而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。



## 运行时栈帧结构

### 栈帧（Stack Frame）

- Java虚拟机以方法作为最基本的执行单元，而 **栈帧** （Stack Frame）则是用于java虚拟机进行方法调用和方法执行背后的数据结构， 它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。

- 栈帧存储了方法的**局部变量表**、**操作数栈**、**动态连接**和**方法返回地址** 等信息，
- 每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从**入栈到出栈**的过程
- 在编译Java程序源码的时候，栈帧需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。
- 一个栈帧需要分配多少内存，并不会收到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式



- 一个线程中的方法调用链 可能会很长，以java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。
- 而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame）,与这个栈帧关联的方法 被称为 “当前方法”（Current Method）。
- 执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，

### 栈帧的概念结构

![](/uploads/jvm/10StackFrame/01-StackFrameConstruct.png)

####  局部变量表（Local Variables Table）

- 局部变量表 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量表。 

- 在Java程序被编译成Class文件时，就在方法的Code属性中的**max_locals** 数据项中确定了该方法所需分配的局部变量表的最大容量

- 局部变量表的容量以 变量槽（Variable slot）为最小单位，

- 《Java虚拟机规范》被没有明确指出一个变量槽应占用的 内存空间大小，只有向导性的说每个变量槽 Variable Slot 都应该能存放一个  boolean 、 byte、 char、 short、 int、 float、 reference 或看return Address类型的数据

##### 局部变量表中的数据类型

- 一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference[1]和returnAddress这8种类型。
- 而第7种reference类型表示对一个对象实例的引用，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则将无法实现《Java语言规范》中定义的语法约定
- 第8种returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转，但现在也已经全部改为采用异常表来代替了
- 对于64位的数据类型，Java虚拟机会以 **高位对齐** 的方式为其分配 **两个连续的变量槽空间** 。Java语言中明确的64位的数据类型只有 long 和 double 两种。
- 这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中允许把一次long和double数据类型读写分割为两次32位读写的做法有些类
  似。
- 由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。



- Java虚拟机通过**索引定位**的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会**同时使用第N和N+1两个变量槽**.
- 对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机**不允许采用任何方式单独访问其中的某一个**，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。

- 当一个方法被调用时，Java虚拟机会使用局部变量表来完成**参数值到参数列表**的传递过程，即 **实参到形参**的传递。如果执行的时实例方法（没有被 static 修饰的方法），那局部变量表中的**第0 位索引**的变量槽 默认是 用于传递**方法实例的引用**，在方法中可以通过 关键字“this” 来访问到这个隐含的参数。 其余的参数 则是按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

##### 局部变量表的重用

- 为了尽可能的节省栈帧耗用的内存空间，**局部变量表中的变量槽是可以重用**的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体（就是一个方法体中的局部变量可能用到一半就不使用了，比如方法体有10行，而局部变量只在其中的3-4行被使用，那这个局部变量就没有覆盖整个方法体），如果当前字节码PC计数器的值 已经超过了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。
- 不过这样的设计除了节省栈帧空间外，还会伴随少量的**副作用**
- 例如 在某些情况下变量槽的复用会直接影响到系统的GC 行为，如下如代码所示

```java
/**
 * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M 
 * // -XX:+PrintGCDetails -XX:SurvivorRatio=8
 */
public class ReuseVariableSlot {
    public static void main(String[] args) {
        byte[] placeholder = new byte[64 * 1024 * 1024];
        System.gc();
    }
}


result: (我这里使用的JDK 9)
[0.028s][info][gc] Using G1
[0.142s][info][gc] GC(0) Pause Initial Mark (G1 Humongous Allocation) 2M->1M(80M) 1.368ms
[0.142s][info][gc] GC(1) Concurrent Cycle
[0.171s][info][gc] GC(1) Pause Remark 66M->66M(80M) 0.724ms
[0.171s][info][gc] GC(1) Pause Cleanup 66M->66M(80M) 0.174ms
[0.175s][info][gc] GC(2) Pause Full (System.gc()) 66M->66M(80M) 3.810ms
[0.175s][info][gc] GC(1) Concurrent Cycle 33.128ms

  
```

代码中可以看到：

向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上“-verbose：gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收掉这64MB的内存。

代码没有回收掉 placeHolder所占的内存说的过去，因为执行system.gc()时，变量 placeholder 还处于作用域之内，虚拟机自然不敢回收掉placeholder 的内存。

我们修改一下代码，改成这样

```java
/**
 * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M
 * // -XX:+PrintGCDetails -XX:SurvivorRatio=8
 */
public class ReuseVariableSlot {
    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
        System.gc();
    }
}

result： 同上
    [0.026s][info][gc] Using G1
[0.137s][info][gc] GC(0) Pause Initial Mark (G1 Humongous Allocation) 2M->1M(80M) 1.593ms
[0.137s][info][gc] GC(1) Concurrent Cycle
[0.162s][info][gc] GC(1) Pause Remark 66M->66M(80M) 0.727ms
[0.165s][info][gc] GC(2) Pause Full (System.gc()) 66M->66M(80M) 3.594ms
[0.166s][info][gc] GC(1) Pause Cleanup 66M->66M(80M) 0.001ms
[0.166s][info][gc] GC(1) Concurrent Cycle 28.351ms
```

加入了花括号之后，placeholder的作用域被限制在了 花括号之内，从代码逻辑上讲，在执行 system.gc()的时候，placeholder 已经不可能再被访问了，但执行这段程序的时候，发现 64M的内存 还是没有被回收掉，

为什么呢，解释之前我们再修改一下代码,先对这段代码进行第二次修改，在调用System.gc()之前加入一行“int  a=0；”，

```bash
/**
 * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M
 * // -XX:+PrintGCDetails -XX:SurvivorRatio=8
 */
public class ReuseVariableSlot {
    public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1024 * 1024];
        }
         int a = 0;
        System.gc();
    }
} 
 
 result: 
 [0.026s][info][gc] Using G1
[0.145s][info][gc] GC(0) Pause Initial Mark (G1 Humongous Allocation) 2M->1M(80M) 1.527ms
[0.145s][info][gc] GC(1) Concurrent Cycle
[0.170s][info][gc] GC(1) Pause Remark 66M->66M(80M) 0.789ms
[0.170s][info][gc] GC(1) Pause Cleanup 66M->66M(80M) 0.351ms
[0.170s][info][gc] GC(1) Concurrent Cycle 25.457ms
[0.174s][info][gc] GC(2) Pause Full (System.gc()) 66M->1M(80M) 3.362ms 

```

我们发现加上 int a = 0; 之后，发现内存被回收了 （[info][gc] GC(2) Pause Full (System.gc()) 66M->1M(80M) 3.362ms ）



##### 代码总结：

上面的代码 ，**placeholder 能否被回收** 的根本原因是：  

- 局部变量表的变量槽 是否还存有 关于placeholder数组对象的 **引用**
- 第一次修改中（加花括号），代码虽然 已经离开了placeholder的作用域，但在之后，在没有发生过任何对局部变量表的读写 操作，placeholder 原本所占用的变量槽  还没有被其他变量所复用，所以作为 GC ROOTs 一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断。再绝大部分情况下影响很轻微。 但如果遇到 一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大部分内存但实际已经不会再使用的变量， 手动 将其设置为 null值 （用来代替 int a=0，把变量对应的局部变量槽清空）便不见得是一个绝对无意义的操作 。这是**奇技淫巧** ，并不是很认同。
- 这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到即时编译器的编译条件）下的“奇技”来使用。Java语言的一本非常著名的书籍《Practical Java》中将把“不使用的对象应手动赋值为null”作为一条推荐的编码规则（笔者并不认同这条规则），但是并没有解释具体原因
- 这是**奇技淫巧** ，并不是很认同。因为：
  - 从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法
  - 更关键的是，从执行角度来讲，使用赋null操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，概念模型与实际执行过程是外部看起来等效，内部看上去则可以完全不同。当虚拟机使用解释器执行时，通常与概念模型还会比较接近，但经过即时编译器施加了各种编译优化措施以后，两者的差异就会非常大，只保证程序执行的结果与概念一致。在实际情况中，即时编译才是虚拟机执行代码的主要方式，赋null值的操作在经过即时编译优化后几乎是一定会被当作无效操作消除掉的，这时候将变量设置为null就是毫无意义的行为。字节码被即时编译为本地代码后，对GC Roots的枚举也与解释执行时期有显著差别，以前面的例子来看，经过第一次修改的代码（第二个方法）在经过即时编译后，System.gc()执行时就可以正确地回收内存，根本无须写成代码（第三个方法）的样子。



##### 局部变量表不存在准备阶段

- 局部变量表不像类变量那样存在“准备阶段”，
- 之前我们在《虚拟机的类加载过程》学过，类的字段变量 有2次赋初始值的过程，  一次是在 准备阶段，赋予系统初始值；另外一次是在 初始化阶段，赋予程序员在代码中定义的初始值。 因此 即使在初始化阶段 程序员没有为类变量赋值也没有关系，类变量仍然具有一个决定的初始值（零值，默认值），不会产生歧义。

- 但是 局部变量就不一样 了，如果一个局部变量定义了，但没有赋初始值，那它是完全不能使用的。
- 所以不要认为 Java中任何情况都存在 诸如 整型变量默认为0、布尔型变量默认为 false 等这样的默认值规则。
- 如果局部变量不赋初始值，编译期在编译期间能检查到并提示出来，ide工具是会报错的。
- 即使编译能通过或者 通过手动的方式生成字节码，在《虚拟机的类加载过程》的字节码验证阶段，也会被虚拟机发现，从而导致 类加载失败。

```java
public static void main(String[] args) {
        int a; //
        System.out.println(a);

    }

result:  编译期报错：  可能尚未初始化变量a
```



### 操作数栈（Operand Stack）

- 操作数栈 （Operand Stack）也常被称为操作栈，它是一个**先入后出** (Last In First Out,LIFO） 栈。 

- 同局部变量表一样， 操作数栈的最大深度也在编译的时候被写入到 Code 属性的 **max_stacks** 数据项之中。

- 操作数栈的每一个元素 都可以是包括long 和 double 在内的**任意java数据类型** 。32位 数据类型 所占的栈容量为 1，64 位数据类型所占的栈容量为  2。

- javac 编译器的数据流分析工作保证了 在方法执行的任何时候，操作数栈的深度 都不会超过 在 max_stacks 数据项设定的最大值。



##### 方法执行时的操作栈动作

- 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。  在方法的执行过程中，会有各种**字节码指令** 往  **操作数栈** 中写入和提取 内容， 也就是出栈和入栈操作。

 譬如 在做算术运算的时候 ，通过将运算涉及的操作数栈 压入栈顶后 ，然后 调用运算指令来执行。

又譬如 在调用其他方法的时候 ，通过操作数栈 来进行方法参数的传递。

举个例子， 例如整数加法 的字节码 iadd, 这条指令在运行的时候 ，要求操作数栈中最接近 栈顶的2个元素 已经存入了2个int 型的数值，当执行 iadd这个指令时候，会把这2 个int 值出栈 并相加，然后将 相加的结果重新入栈 。

##### 字节码指令严格匹配操作栈元素数据类型

操作数栈中元素的数据类型必须 与字节码指令的序列严格匹配，在编译程序代码的时候，编译期必须严格保证这一点，在类校验阶段的数据流分析中还要 再次验证这一点。

例如： iadd指令只能 用于整型数据的加法，该指令在执行时，最接近栈顶的2个元素的数据类型 必须为int 型，不能出现一个long 和一个float 使用iadd指令相加的 情况。

##### 栈帧的优化

- Java虚拟机的**解释执行引擎** 被称为“**基于栈的执行引擎**”, 里面的栈 就是操作数栈。后续还会对基于栈的代码执行过程进行更详细的讲解。介绍它与更常见的**基于寄存器的执行引擎**有那些差别

- 在概念 模型中，两个不同栈帧（Stack Frame）作为不同方法的虚拟机栈 元素，是**完全互相独立**的。  但是在大多数虚拟机的实现中，会对这块进行一些**优化处理** ，令2个 不同方法的栈帧出现一部分 **重叠**。让下面的栈帧的部分操作数栈 与 上面栈帧的部分局部变量表 重叠在一起，这样做不仅节约了 一些空间，更重要的是 在进行方法调用的时候 就可以直接共用 一部分数据，无需进行**额外的 参数 复制传递**了 。重叠的过程如下图所示： 

![](/uploads/jvm/10StackFrame/02-StackFrameOverlap.png)



### 动态连接（Dynamic Linking）

每个栈帧 都包含一个指向**运行时常量池** 中**该栈帧所属方法的引用**，持有这个引用 是为了支持方法调用过程中的**动态连接**。

通过之前文章，我们知道 Class文件 的常量池中存有 大量的符号引用，字节码中的**方法调用指令** 就以 常量池里**指向方法的符号连接** 作为参数。

- 这些符号引用一部分将在 **类加载阶段**或者**第一次使用的时候**就被转化为**直接引用**，这种转化称为  **静态解析**
- 另外一部分将在**每一次运行期间**都**转化 为直接引用**，这部分就称为 **动态连接**。后续后详细讲解



### 方法返回地址

当一个方法开始执行后，只有 2种 方式退出这个方法。

- 第一种退出方式是执行引擎遇到任意一个方法**返回的字节码指令**，这时候 可能会有返回值 传递给上层方法调用者 （调用当前方法的方法称为 **主调方法** 或者 “**调用者**”）， 方法是否有返回值 以及返回值的类型 将根据 何种方法返回指令来决定，这种退出方式 称为 “**正常调用完成（Normal Method Invocation Completion）**”
- 另外一种退出方式 就是方法执行过程中 遇到了异常，并且这个异常没有在方法体内得到妥善处理。  无论是Java虚拟机内部的异常，还是代码中**athrow字指令** 产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式 称为 “**异常调用完成(Abrupt Method Invocation Completion)**”  。一个方法使用异常完成出口的方式退出，是不会给他的上层调用者 提供任何返回值的。



无论采用何种退出方式，在方法退出之后，都必须**返回最初方法被调用的位置**，程序才能继续执行。

方法返回时 可能需要在栈帧中 保存一些信息，用来帮助**恢复它的上层主调方法的执行状态** 。 

一般来说，方法正常退出时，**主调方法的PC计数器的值 就可以作为返回地址**，栈帧中很可能 会保存这个计数器值。

而异常退出的时候，返回地址就是 通过异常处理器 来确定的，栈帧中 一般不会保存这部分信息 （主调方法的PC计数器值）

##### 方法退出的过程

方法退出的过程实际上等同于**把 当前栈帧出栈**，因此退出时可能执行的操作有：

- 恢复上层主调方法的局部变量表和操作数栈，
- 把返回值（如果有的话） 压入 调用者（主调方法对应的）栈帧的操作数栈中，
- 调整PC计数器值 以指向方法调用指令后面的 的一条指令等。

这些都是 基于概念模型的讨论，只有具体到某一款 java虚拟机实现，会执行哪些操作才能确定下来



### 附加信息

《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。

在讨论概念时候，一般会把 **动态连接，方法返回地址 与 其他附加信息**全部归为一类，称为**栈帧信息** 。



## 方法调用详解（TODO）

