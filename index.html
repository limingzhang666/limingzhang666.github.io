<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="HCj467TtuvFkAzzdCvYvbniAeNiUy7TUwp2hG1qGWQE">
  <meta name="baidu-site-verification" content="LppFIbSdZO">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limingzhang666.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","width":320,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="拨开云雾见青天">
<meta property="og:type" content="website">
<meta property="og:title" content="Yinshi&#39;s Blog">
<meta property="og:url" content="https://limingzhang666.github.io/index.html">
<meta property="og:site_name" content="Yinshi&#39;s Blog">
<meta property="og:description" content="拨开云雾见青天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yinshi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://limingzhang666.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yinshi's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yinshi's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yinshi"
      src="/images/yinshi01_avatar.jpg">
  <p class="site-author-name" itemprop="name">Yinshi</p>
  <div class="site-description" itemprop="description">拨开云雾见青天</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/limingzhang666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limingzhang666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:laimingcham@163.com" title="E-Mail → mailto:laimingcham@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/limingzhang666" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/11/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01-01-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/11/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01-01-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Spring源码解析-01-01-容器的基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 23:23:29" itemprop="dateCreated datePublished" datetime="2021-03-11T23:23:29+08:00">2021-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Sprig%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">Sprig源码解析</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/11/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01-01-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/11/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01-01-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="容器的基础（Bean的解析）"><a href="#容器的基础（Bean的解析）" class="headerlink" title="容器的基础（Bean的解析）"></a>容器的基础（Bean的解析）</h1><p>XmlBeanFactory： </p>
<h2 id="配置文件的封装："><a href="#配置文件的封装：" class="headerlink" title="配置文件的封装："></a>配置文件的封装：</h2><ul>
<li><p>文件资源统一抽象为： InputStreamSource 资源, Resource 继承 InputStreamSource，</p>
</li>
<li><p>然后 通过Resource资源，可以 拿到InputStream，</p>
</li>
</ul>
<p>xmlBeanFactory的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new XmlBeanFactory with the given resource,</span></span><br><span class="line"><span class="comment">	 * 创建一个xml</span></span><br><span class="line"><span class="comment">	 * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new XmlBeanFactory with the given input stream,</span></span><br><span class="line"><span class="comment">	 * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parentBeanFactory parent bean factory</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="comment">// 资源加载的真正实现</span></span><br><span class="line">		<span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="加载xmlBeanDefinitions"><a href="#加载xmlBeanDefinitions" class="headerlink" title="加载xmlBeanDefinitions"></a>加载xmlBeanDefinitions</h2><ul>
<li><p>在 XmlBeanFactory中 调用了 super(parentBeanFactory); 一直往上追可以看到 ,这段代码作用是：</p>
<ul>
<li>忽略给定接口的自动装配功能</li>
</ul>
</li>
<li><p>这样的目的是为什么呢，效果如何：</p>
<ul>
<li><p>举例子来说：当A中有属性B，那么当Spring在获取A的Bean的时候，如果其属性B还没有初始化，那么Spring会自动初始化B，这也是Sprnig  提供的一种特性，</p>
</li>
<li><p>但是某些情况下，B不会被初始化，其中的一种情况就是 B实现了BeanNameAware 接口。</p>
</li>
<li><p>spring是这么介绍的： 自动装配时 忽略给定的依赖接口，典型应用就是 通过其他方式解析 Application 上下文注册依赖，类似于 BeanFactory 通过BeanFactoryAware 进行注入 或者ApplicationContext通过ApplicationContextAware 进行注入</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AbstractAutowireCapableBeanFactory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">	ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">	ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> encodedResource the resource descriptor for the XML file,</span></span><br><span class="line"><span class="comment">	 * allowing to specify an encoding to use for parsing the file</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1.封装资源文件 ，首先 对参数Resource 使用 EncodedResource</span></span><br><span class="line">		Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2. 获得输入流</span></span><br><span class="line">		<span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">			InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.重点方法</span></span><br><span class="line">			<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			currentResources.remove(encodedResource);</span><br><span class="line">			<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取Document"><a href="#获取Document" class="headerlink" title="获取Document"></a>获取Document</h3><ul>
<li>xmlBeanFactoryReader 类对于文档并没有亲力亲为，而是委托 给了 DocumentLoader 去执行，这力的 DocumentLoader是个接口，而真正的调用的是 ： DefaultDocumentLoader </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">			<span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析并注册BeanDefinitions"><a href="#解析并注册BeanDefinitions" class="headerlink" title="解析并注册BeanDefinitions"></a>解析并注册BeanDefinitions</h3><ul>
<li>当把文件转换为Document之后，接下来的提取以及注册 bean。</li>
<li>这个方法很好的应用了 面向对象中单一职责的原则，将逻辑处理委托给单一的类 进行处理，而这个逻辑处理类就是 BeanDefinitionDocumentReader</li>
<li>BeanDefinitionDocumentReader 是一个接口，而实例化的工作是在 createBeanDefinitionDocumentReader（）中完成的，BeanDefinitionDocumentReader的最终类型是 DefaultBeanDefinitionDocumentReader</li>
<li>DefaultBeanDefinitionDocumentReader::doRegisterBeanDefinitions() 提取root，以便将root作为参数继续 BeanDefinition 的注册</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//使用 DefaultBeanDefinitionDocumentReader 实例化 BeanDefinitionDocumentReader</span></span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">// 将环境变量设置其中</span></span><br><span class="line">	<span class="comment">// 记录统计前BeanDefinition 的加载个数</span></span><br><span class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">// 加载以及注册 bean</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="comment">// 记录本次加载 的BeanDefinition 的个数</span></span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心方法-registerBeanDefinitions"><a href="#核心方法-registerBeanDefinitions" class="headerlink" title="核心方法 registerBeanDefinitions"></a>核心方法 registerBeanDefinitions</h3><ul>
<li>对profile 处理，然后开始解析 </li>
<li>跟进  preProcessXml(),postProcessXml(root);发现代码是空的，为啥是空的呢</li>
</ul>
<p><strong>面向对象常说的一句话： 一个类要么是面向继承的设计，要么就用final 修饰。因为 DefaultBeanDefinitionDocumentReader 不是final类，所以他是面向继承设计。</strong> </p>
<p><strong>这2个方法是为子类设计的 ，这个模板方法模式，如果继承自 DefaultBeanDefinitionDocumentReader 的子类需要在Bean解析前后 做一些处理的话，那么只需要 重写这2个方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 专门处理解析</span></span><br><span class="line">		BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">		<span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">			<span class="comment">//. 处理 profile 属性</span></span><br><span class="line">			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">				<span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">				<span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">				<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">								<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3. 解析前处理，留给子类实现</span></span><br><span class="line">		preProcessXml(root);</span><br><span class="line">		parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">		<span class="comment">// 4. 解析后处理，留给子类实现</span></span><br><span class="line">		postProcessXml(root);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.delegate = parent;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="parseBeanDefinitions-root-this-delegate"><a href="#parseBeanDefinitions-root-this-delegate" class="headerlink" title="parseBeanDefinitions(root, this.delegate)"></a>parseBeanDefinitions(root, this.delegate)</h3><ul>
<li>如何解析XML 的元素就跳过了，包含自定义标签之类的 。感觉也用不到，毕竟现在大部分都是注解开发 ，就先不看了,太繁琐了</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/11/redis%E5%85%A5%E9%97%A8-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/11/redis%E5%85%A5%E9%97%A8-01/" class="post-title-link" itemprop="url">redis入门-01</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 21:20:44" itemprop="dateCreated datePublished" datetime="2021-03-11T21:20:44+08:00">2021-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/11/redis%E5%85%A5%E9%97%A8-01/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/11/redis%E5%85%A5%E9%97%A8-01/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="传统的ACID"><a href="#传统的ACID" class="headerlink" title="传统的ACID"></a>传统的ACID</h2><p>关系型数据库遵循ACID规则<br>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p>
<p>1、A (Atomicity) 原子性<br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p>
<p>2、C (Consistency) 一致性<br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</p>
<p>3、I (Isolation) 独立性<br>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的</p>
<p>4、D (Durability) 持久性<br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>C:Consistency（强一致性）</p>
<p>A:Availability（可用性）</p>
<p>P:Partition tolerance（分区容错性）</p>
<h3 id="CAP的三进二"><a href="#CAP的三进二" class="headerlink" title="CAP的三进二"></a>CAP的三进二</h3><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。<br>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以</p>
<p><strong>分区容忍性是我们必须需要实现的。</strong></p>
<p><strong>所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点</strong>。</p>
<p><strong>C:强一致性 A：高可用性 P：分布式容忍性</strong></p>
<ul>
<li><p>CA 传统Oracle数据库 </p>
</li>
<li><p>AP 大多数网站架构的选择</p>
</li>
<li><p>CP Redis、Mongodb</p>
<p>注意：分布式架构的时候必须做出取舍。<br>一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向</p>
</li>
</ul>
<h4 id="一致性与可用性的决择"><a href="#一致性与可用性的决择" class="headerlink" title="一致性与可用性的决择"></a>一致性与可用性的决择</h4><p>​    对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地</p>
<h4 id="数据库事务一致性需求"><a href="#数据库事务一致性需求" class="headerlink" title="数据库事务一致性需求"></a>数据库事务一致性需求</h4><p>​    很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。</p>
<h4 id="数据库的写实时性和读实时性需求"><a href="#数据库的写实时性和读实时性需求" class="headerlink" title="数据库的写实时性和读实时性需求"></a>数据库的写实时性和读实时性需求</h4><p>​    对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</p>
<h4 id="对复杂的SQL查询，特别是多表关联查询的需求"><a href="#对复杂的SQL查询，特别是多表关联查询的需求" class="headerlink" title="对复杂的SQL查询，特别是多表关联查询的需求"></a>对复杂的SQL查询，特别是多表关联查询的需求</h4><p>　　任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p>
<h3 id="经典CAP图"><a href="#经典CAP图" class="headerlink" title="经典CAP图"></a>经典CAP图</h3><p> CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，<br>最多只能同时较好的满足两个。<br>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：<br>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。<br>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。<br>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p>
<p><img src="/uploads/redis/Image.bmp"></p>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<p>BASE其实是下面三个术语的缩写：<br>    基本可用（Basically Available）<br>    软状态（Soft state）<br>    最终一致（Eventually consistent）</p>
<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p>
<h1 id="REDIS-入门"><a href="#REDIS-入门" class="headerlink" title="REDIS 入门"></a>REDIS 入门</h1><h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><ul>
<li>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
<li>取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面</li>
<li>模拟类似于HttpSession这种需要设定过期时间的功能</li>
<li>发布、订阅消息系统</li>
<li>定时器、计数器</li>
</ul>
<h2 id="基础知识讲解"><a href="#基础知识讲解" class="headerlink" title="基础知识讲解"></a>基础知识讲解</h2><ul>
<li><p>单进程模型来处理客户端的请求。对读写等事件的响应是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</p>
</li>
<li><p>Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
</li>
<li><p>默认16个数据库，类似数组下表从零开始，初始默认使用零号库</p>
</li>
<li><p>Select命令切换数据库</p>
</li>
<li><p>Dbsize查看当前数据库的key的数量</p>
</li>
<li><p>Flushdb：清空当前库</p>
</li>
<li><p>Flushall；通杀全部库</p>
</li>
<li><p>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</p>
</li>
<li><p>Redis索引都是从零开始</p>
</li>
<li><p>为什么默认端口是6379</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
<h3 id="Hash（哈希，类似java里的Map）"><a href="#Hash（哈希，类似java里的Map）" class="headerlink" title="Hash（哈希，类似java里的Map）"></a>Hash（哈希，类似java里的Map）</h3><p>Hash（哈希）<br>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</p>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表</p>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</p>
<h3 id="Zset-sorted-set：有序集合"><a href="#Zset-sorted-set：有序集合" class="headerlink" title="Zset(sorted set：有序集合)"></a>Zset(sorted set：有序集合)</h3><p>zset(sorted set：有序集合)<br>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><p><a target="_blank" rel="noopener" href="http://redisdoc.com/">http://redisdoc.com/</a></p>
<h3 id="Redis-键-key"><a href="#Redis-键-key" class="headerlink" title="Redis 键(key)"></a>Redis 键(key)</h3><p><img src="/uploads/redis/redis_key.bmp"></p>
<ul>
<li> keys *</li>
<li> exists key的名字，判断某个key是否存在</li>
<li> move key db   —&gt;当前库就没有了，被移除了</li>
<li> expire key 秒钟：为给定的key设置过期时间</li>
<li> ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
<li> type key 查看你的key是什么类型</li>
</ul>
<h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h3><p><img src="/uploads/redis/redis-string01.bmp"></p>
<p><img src="/uploads/redis/redis-string02.bmp"></p>
<ul>
<li><p>set/get/del/append/strlen</p>
</li>
<li><p>Incr/decr/incrby/decrby,一定要是数字才能进行加减</p>
</li>
<li><p>getrange/setrange</p>
</li>
<li><p> setex(set with expire)键秒值/setnx(set if not exist)</p>
</li>
<li><p>mset/mget/msetnx</p>
</li>
<li><p>getset(先get再set)</p>
</li>
</ul>
<h3 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h3><p><img src="/uploads/redis/redis-list01.bmp"></p>
<p><img src="/uploads/redis/redis-list02.bmp"></p>
<ul>
<li>lpush/rpush/lrange</li>
<li> lpop/rpop</li>
<li> lindex，按照索引下标获得元素(从上到下)</li>
<li>llen</li>
<li> lrem key 删N个value</li>
<li> ltrim key 开始index 结束index，截取指定范围的值后再赋值给key</li>
<li> rpoplpush 源列表 目的列表</li>
<li> lset key index value</li>
<li> linsert key  before/after 值1 值2</li>
<li>它是一个字符串链表，left、right都可以插入添加；<br>如果键不存在，创建新的链表；<br>如果键已存在，新增内容；<br>如果值全移除，对应的键也就消失了。<br>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li>
</ul>
<h3 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h3><p><img src="/uploads/redis/redis-set.bmp"></p>
<ul>
<li>sadd/smembers/sismember</li>
<li> scard，获取集合里面的元素个数</li>
<li> srem key value 删除集合中元素</li>
<li> srandmember key 某个整数(随机出几个数)</li>
<li> spop key 随机出栈</li>
<li> smove key1 key2 在key1里某个值      作用是将key1里的某个值赋给key2</li>
<li>数学集合类<ul>
<li>差集：sdiff</li>
<li>交集：sinter</li>
<li>并集：sunion</li>
</ul>
</li>
</ul>
<h3 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h3><p><img src="/uploads/redis/redis-hash.bmp"></p>
<ul>
<li>hset/hget/hmset/hmget/hgetall/hdel</li>
<li>hlen</li>
<li> hexists key 在key里面的某个值的key</li>
<li>hkeys/hvals</li>
<li> hincrby/hincrbyfloat</li>
<li> hsetnx</li>
</ul>
<h3 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h3><p><img src="/uploads/redis/redis-zset01.bmp"></p>
<p><img src="/uploads/redis/redis-zset02.bmp"></p>
<ul>
<li>zadd/zrange</li>
<li> zrangebyscore key 开始score 结束score</li>
<li> zrem key 某score下对应的value值，作用是删除元素</li>
<li> zcard/zcount key score区间/zrank key values值，作用是获得下标值/zscore key 对应值,获得分数</li>
<li> zrevrank key values值，作用是逆序获得下标值</li>
<li> zrevrange</li>
<li> zrevrangebyscore  key 结束score 开始score</li>
</ul>
<h2 id="解析配置文件redis-conf"><a href="#解析配置文件redis-conf" class="headerlink" title="解析配置文件redis.conf"></a>解析配置文件redis.conf</h2><p>TODO</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-15-%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-15-%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">java高并发详解-15-监控任务的生命周期</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-09 16:20:40" itemprop="dateCreated datePublished" datetime="2021-03-09T16:20:40+08:00">2021-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-15-%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-15-%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>这个例子我已经用到了实际工作中，怎么说呢，效果还不错吧</li>
<li>既监控了任务的状态，也实现了单一职责，将任务task的逻辑 与监控 逻辑进行了分离</li>
<li>也方便统一 任务的状态，可以落数据库</li>
</ul>
<h2 id="1-Observable接口定义"><a href="#1-Observable接口定义" class="headerlink" title="1.Observable接口定义"></a>1.Observable接口定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务生命周期的枚举类型</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">        STARTED, RUNNING, DONE, ERROR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前任务的生命周期状态</span></span><br><span class="line">    <span class="function">Cycle <span class="title">getCycle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义启动线程的方法，作用是为了屏蔽 Thread的其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义线程的打断方法，作用于 start方法一样，也是为了屏蔽Thread的其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-TaskLifecycle-事件回调者"><a href="#2-TaskLifecycle-事件回调者" class="headerlink" title="2.TaskLifecycle 事件回调者"></a>2.TaskLifecycle 事件回调者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskLifecycle</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRunning</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(Thread thread, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Thread thread, Exception e)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Task函数接口定义"><a href="#3-Task函数接口定义" class="headerlink" title="3.Task函数接口定义"></a>3.Task函数接口定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Task</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 任务执行接口，该接口允许有返回值 </span></span><br><span class="line">    <span class="function">T <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-ObservableThread-事件发起者"><a href="#4-ObservableThread-事件发起者" class="headerlink" title="4.ObservableThread 事件发起者"></a>4.ObservableThread 事件发起者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableThread</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskLifecycle&lt;T&gt; lifecycle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Task&lt;T&gt; task;</span><br><span class="line">    <span class="keyword">private</span> Cycle cycle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableThread</span><span class="params">(TaskLifecycle&lt;T&gt; lifecycle, Task&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The task is required.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.update(Cycle.STARTED, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.update(Cycle.RUNNING, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            T result = <span class="keyword">this</span>.task.call();</span><br><span class="line">            <span class="keyword">this</span>.update(Cycle.DONE, result, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.update(Cycle.ERROR, <span class="keyword">null</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Cycle cycle, T result, Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.cycle = cycle;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (cycle) &#123;</span><br><span class="line">                <span class="keyword">case</span> STARTED:</span><br><span class="line">                    <span class="keyword">this</span>.lifecycle.onStart(currentThread());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">this</span>.lifecycle.onRunning(currentThread());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DONE:</span><br><span class="line">                    <span class="keyword">this</span>.lifecycle.onFinish(currentThread(), result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ERROR:</span><br><span class="line">                    <span class="keyword">this</span>.lifecycle.onError(currentThread(), e);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cycle == Cycle.ERROR) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cycle <span class="title">getCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-13-7%E7%A7%8D%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-13-7%E7%A7%8D%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">java高并发详解-13-7种单例设计模式设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-09 14:00:40" itemprop="dateCreated datePublished" datetime="2021-03-09T14:00:40+08:00">2021-03-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-13-7%E7%A7%8D%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-13-7%E7%A7%8D%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HungerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungerSingleton instance = <span class="keyword">new</span> HungerSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>instance 作为类变量在 类初始化的过程中会被收集进 <clinit>()方法中，该方法能够百分之百地保证同步，也就是说 instance 在多线程地情况下不可能被实例化两次，但是instance 被ClassLoader 加载后可能很长一段时间才被使用，那就意味着 instance 实例所开辟地堆内存会驻留更久地时间</li>
<li>如果一个类中地成员属性比较少，且占用的内存资源不多，饿汉的方式也未尝不可， </li>
<li>相反，如果一个类中的成员都是比较重的资源，那么这种方式就会有些不妥</li>
<li>总结起来，饿汉式的单例设计模式可以保证在多线程的情况下的唯一实例，getInstance的性能也比较高，</li>
<li>但是无法进行懒加载</li>
</ul>
<h2 id="懒汉式-同步方法"><a href="#懒汉式-同步方法" class="headerlink" title="懒汉式+同步方法"></a>懒汉式+同步方法</h2><p>所谓懒汉式就是在使用类实例的时候再去创建，这样就可以避免在类初始化时，提前创建，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果不加synchronized， 会出现多线程并发问题,</span></span><br><span class="line">        <span class="comment">//加上 synchronized后，单线程，效率问题</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意看 getInstance ()方法，如果此处不加 synchronized 同步，则可能存在多线程并发的问题，</li>
<li>但是加上 synchronized后，单线程，有可能存在效率问题</li>
</ul>
<h2 id="Volatile-Double-Check"><a href="#Volatile-Double-Check" class="headerlink" title="Volatile+Double-Check"></a>Volatile+Double-Check</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDoubleheckSingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> VolatileDoubleheckSingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    Connection conn;</span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">VolatileDoubleheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this.conn;</span></span><br><span class="line">        <span class="comment">//this.socket;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VolatileDoubleheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (VolatileDoubleheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> VolatileDoubleheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Double-Check 虽然是一种巧妙地程序设计，但是有可能引起类成员变量地实例化 conn 和socket 发生在instance 实例化之后，（因为JVM在运行时指令重排序导致的）</li>
<li>而 volatile关键字则可以防止这种重排序的发生 所以 private volatile static VolatileDoubleheckSingleton instance = null;</li>
</ul>
<h2 id="Holder方式"><a href="#Holder方式" class="headerlink" title="Holder方式"></a>Holder方式</h2><p>Holder 的方式完全是 借助了类加载的特点，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HolderSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在静态内部类中持有 HolderSingleton 的实例，并且可以直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> HolderSingleton instance = <span class="keyword">new</span> HolderSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 getInstance 方法，事实上是获得 Holder的instance 静态属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好处：</p>
<ul>
<li>在HolderSingleton类中 没有instance的静态成员，而是将其放到了静态内部类Holder之中，因此在Singleton类的 初始化过程中 并不会创建 Singleton 的实例，</li>
<li>Holder类中定义了Singleton的静态变量，并且直接进行了实例化。当Holder被主动引用的时候  则会创建Singleton的实例，Singleton实例的创建过程 在Java程序编译时期 收集至 <clinit>（） 方法中，该方法 又是同步方法， 同步方法可以保证内存的可见性，JVM指令的顺序性 和原子性、</li>
<li>Holder方式的单例设计是最好的设计之一</li>
</ul>
<h2 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h2><ul>
<li>使用枚举的方式实现单例模式 是 《effective java》作者力推的方式 </li>
<li>枚举类型不允许被继承，同样的是线程安全的且 只能被实例化一次，但是 枚举类型不能够懒加载，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    EnumSingleton() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;INIT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用该方法则会主动使用Singleton INSTANCE 将会被实例化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumHolder</span> </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">        EnumHolder() &#123;</span><br><span class="line">            <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumHolder.INSTANCE.getSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">java高并发详解-12-深入理解volatile关键字</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-08 18:19:34" itemprop="dateCreated datePublished" datetime="2021-03-08T18:19:34+08:00">2021-03-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li>Java内存模型（Java Memory Mode，JMM） 指定了Java虚拟机如何与计算机 的主存（RAM）进行工作。</li>
</ul>
<p>Java的内存模型决定了一个线程对共享变量的写入何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系。具体如下：</p>
<ol>
<li>共享变量存储与主内存之中，每个线程都可以访问</li>
<li>每个线程都有私有的工作内存或者称为本地内存</li>
<li>工作内存只存储该线程对共享变量的副本</li>
<li>线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存</li>
<li>工作内存和Java内存模型一样也是一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。</li>
</ol>
<h1 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h1><p>原子性、有序性、 可见性</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>所谓原子性是指在一次的操作和多次操作中，要么所有的操作全部都得到了执行并且不会受到 任何因素的干扰而中断，要么所有的操作都不执行</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>两个原子性的操作结合在一起未必还是原子性的，比如 i++ (其中get i，i+1，set i=x 三者都是原子性操作，但是不代表 i++就是原子性操作)</li>
<li>volatile 关键字不保证 数据的原子性，synchronized关键字保证，自从 JDK1.5 版本开始，其提供的原子类型变量也 可以保证原子性</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性是指 程序代码在执行过程中的先后顺序，由于Java 在编译器以及运行期的优化，导致了 代码的 执行顺序未必就是开发者编写代码时的顺序，</p>
<p>因为会存在 指令重排序的情况（Instruction Recorder）</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指，当一个线程对共享变量进行了修改，那么另外的线程 可以立即看到修改后的最新值 </p>
<h1 id="JMM如何保证三大特性"><a href="#JMM如何保证三大特性" class="headerlink" title="JMM如何保证三大特性"></a>JMM如何保证三大特性</h1><ul>
<li>JVM采用 内存模型的机制来 屏蔽各个平台和操作系统之间内存访问的差异，以实现让 Java程序在各种平台下达到一致的内存访问效果</li>
<li>Java的内存模型规定了所有的变量都是存在于 主内存（RAM）当中的，而每个线程都有自己的工作内存或者本地内存。线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接对主内存 进行操作，并且每一个线程都不能访问其他线程的工作内存或者本地内存 。</li>
</ul>
<h2 id="1-JMM与原子性"><a href="#1-JMM与原子性" class="headerlink" title="1.JMM与原子性"></a>1.JMM与原子性</h2><p>在Java语言中，对基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的，因此诸如此类的操作是  不可被中断的，要么执行，要么不执行，正所谓 一荣俱荣一损俱损。</p>
<p>（1） x=10； 赋值操作</p>
<p>x=10的操作是原子性的，执行线程首先会将x=10，写入工作内存中，然后再将其 写入主内存（）</p>
<p>（2）y=x； 赋值操作</p>
<p>这条操作时非原子性的，因为它 包含如下两个重要的步骤</p>
<ol>
<li>执行线程从主内存中 读取x的值（如果x 已经存在于 执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中</li>
<li>在执行线程的 工作内存中修改y的值为x，然后将y的值写入 主内存之中</li>
</ol>
<p>虽然第一步和第二步 都是原子类型的操作，但是合在 一起就不是原子操作了</p>
<p>（3）y++； 自增操作</p>
<p>这条操作语句时非原子性的，因为它包含3个重要的步骤，具体如下</p>
<ol>
<li><p>执行线程从主内存中读取y的值，然后将其存入当前线程的工作内存之中</p>
</li>
<li><p>在执行线程工作内存中为y执行加1操作</p>
</li>
<li><p>将y的值写入主内存</p>
</li>
</ol>
<p>（4）z=z+1； 加一操作（与自增操作等价）</p>
<p>这条操作语句时非原子性的，因为它包含3个重要的步骤，具体如下：</p>
<ol>
<li>执行线程从主内存中读取z的值（如果z已经存在于执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中</li>
<li>在执行线程工作内存中为z执行加1操作</li>
<li>将z的值写入主内存 </li>
</ol>
<p>总结：</p>
<ul>
<li>多个原子性的操作在一起就不再是原子性操作了</li>
<li>简单的读取与赋值操作时原子性的，将一个变量赋给另一个变量的操作不是原子性的</li>
<li>java内存模型（JMM）只保证了基本读取和赋值的原子性操作，其他的均不保证，</li>
<li><strong>如果想要使得某些代码片段具备原子性，需要使用关键字 synchronized，或者 JUC中的lock ，</strong></li>
<li>*<em>如果想要使得int 等类型自增操作具备原子性，可以使用JUC 包下的原子封装类型 java.util.concurrent.atomic.**</em></li>
<li><strong>volatile 关键字不具备保证 原子性的语义</strong></li>
</ul>
<h2 id="2-JMM与可见性"><a href="#2-JMM与可见性" class="headerlink" title="2.JMM与可见性"></a>2.JMM与可见性</h2><p>在多线程环境中，如果某个线程首次读取共享变量，则首先 到主内存中获取该变量，然后存入 工作内存中，以后只需要在工作内存中读取该变量即可。 </p>
<p>同样的，如果对该变量执行了修改的操作，则先 将新值写入工作内存中，然后再刷新至 主内存中， <strong>但是什么时候最新的值会被刷新至主内存中是不太确定的</strong>，</p>
<p>java提供了以下三种方式来保证可见性</p>
<ul>
<li>使用关键字 volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（当然也会缓存到线程自己的工作内存中，当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），对于共享资源的写操作当然是 先修改工作内存，但是修改结束后会立刻将其刷新到主内存中</li>
<li>通过synchronized 关键字能够保证可见性，synchronized 关键字能够保证同一时刻 ，只有一个线程获得锁，然后执行同步党法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存当中</li>
<li>通过JUC 提供的显示锁Lock也能保证可见性，Lock的lock方法能够保证 在同一时刻只有一个线程获得锁，然后执行同步方法，并且会确保在锁 释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存当中</li>
</ul>
<p>总结： <strong>volatile关键字具有保证可见性的语义</strong></p>
<h2 id="3-JMM与有序性"><a href="#3-JMM与有序性" class="headerlink" title="3.JMM与有序性"></a>3.JMM与有序性</h2><p>在Java内存模型中，允许编译器和处理器对指令进行重排序/。但是在多线程的情况下，重排序会影响到程序的正确运行，Java提供了3种保证有序性的方式</p>
<ul>
<li>使用volatile 关键字来保证有序性</li>
<li>使用 synchronized关键字来保证有序性、</li>
<li>使用  显示锁Lock 来保证有序性</li>
</ul>
<p>另外Java的内存模型具备一些天生的有序性规则，不需要任何同步手段就能够保证有序性，这个规则被称为Happens-before原则。</p>
<p>happens-before原则</p>
<ul>
<li>程序次序规则： 在一个线程内，代码按照编写的次序执行，编写在后面的操作发生于 编写在前面的操作之后</li>
<li>锁定规则： 一个unlock操作要先行发生于对同一个锁的lock操作</li>
<li>volatile变量规则：  对一个变量的写操作 要早于对这个变量之后的读操作</li>
<li>传递规则</li>
<li>线程启动规则： THread对象的start 方法先行于对该线程的任何动作，</li>
<li>线程中断规则：  对线程执行interrupt方法肯定要优先于捕获到中断信号 </li>
<li>线程的终结规则：</li>
</ul>
<p>总结： volatile关键字具有保证顺序性的语义</p>
<h1 id="volatile关键字深入解析"><a href="#volatile关键字深入解析" class="headerlink" title="volatile关键字深入解析"></a>volatile关键字深入解析</h1><p>被volatile 修饰的实例变量 或者类变量具备如下两层语义</p>
<ul>
<li>保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰的变量，另一个线程会立即看到最新的值</li>
<li>禁止对指令进行重排序操作</li>
<li>volatile 并不保证 原子性</li>
</ul>
<h2 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h2><p>通过对OpenJDK下 unsafe.cpp 源码的阅读会发现 被volatile修饰的变量存在于 一个 lock 的前缀，源码如下：</p>
<p>“lock；” 前缀实际上相当于是一个 内存屏障，该内存屏障会为 指令的执行 提供如下几个保障。</p>
<ul>
<li>确保指令重排序时不会将其后面的代码排到内存屏障之前</li>
<li>确保指令重排序时不会将其后面的代码派操内存屏障之后</li>
<li>确保在执行内存屏障修饰的指令时前面的代码全部执行完成</li>
<li>强制将线程工作内存中的值 修改刷新至主内存中</li>
<li>如果是写操作，则会导致其他线程工作内存（CPU Cache）中缓存数据失效</li>
</ul>
<h2 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h2><ol>
<li>开关控制利用可见性的特点</li>
<li>状态标记利用顺序性特点</li>
</ol>
<h2 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h2><p> 1.使用上的区别</p>
<ul>
<li>volatile关键字<strong>只能用于修饰实例变量或者类变量</strong>，不能用于修饰方法以及方法参数 和局部变量、常量等</li>
<li>synchronized 关键字不能用于对变量的修饰，只能用于修饰方法或者语句块 </li>
<li>volatile 修饰的变量可以为null ，synchronized 关键字同步语句块的monitor对象不能为null </li>
</ul>
<ol start="2">
<li>对原子性的保证</li>
</ol>
<ul>
<li>volatile无法保证原子性</li>
<li>由于synchronized 是一种排他的机制，因此被 synchronized 关键字修饰的同步代码 是无法被中途打断的，因此可以能够保证代码的原子性</li>
</ul>
<ol start="3">
<li>对可见性的保证</li>
</ol>
<ul>
<li>两者均可以保证共享资源在多线程间的可见性，但是实现机制完全不同</li>
<li>synchronized 借助于JVM指令 monitor enter 和 monitor exit 对通过排他的方式使得 同步代码串行化，在monitor exit时所有共享资源都将会被刷新到主内存中</li>
<li>volatile 使用机器指令“lock；”的方式迫使其他线程工作内存中的数据失效，不得到 主内存中进行再次加载</li>
</ul>
<ol start="4">
<li>对有序性的保证</li>
</ol>
<ul>
<li>volatile关键字禁止JVM 编译器以及处理器对其进行重排序，所以 它能够保证有序性</li>
<li>synchronized 关键字所修饰的同步方法 也可以保证顺序性，但是这种顺序性 是以程序的串行化执行换来的，  在synchronized 关键字所修饰的代码块中 代码指令也会发生指令重排序的情况</li>
</ul>
<ol start="5">
<li>其他</li>
</ol>
<ul>
<li>volatile不会使得线程陷入阻塞</li>
<li>synchronized 关键字会使得 线程进入阻塞状态</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>并发编程的3个重要特性： 原子性，可见性 和有序性</p>
</li>
<li><p>java 如何保证这3个重要特性，synchronized主要是 排他机制，确保每次都只有一个线程通过。volatile 主要是通过内存屏障“lock；”以及防止指令重排序的方式来实现</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">java高并发详解-11-线程上下文类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-08 15:16:35" itemprop="dateCreated datePublished" datetime="2021-03-08T15:16:35+08:00">2021-03-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前面讲java类加载器的知识为了解释线程的上下文类加载器原理和使用场景</p>
<h1 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h1><h2 id="为什么需要线程上下文类加载器"><a href="#为什么需要线程上下文类加载器" class="headerlink" title="为什么需要线程上下文类加载器"></a>为什么需要线程上下文类加载器</h2><p>根据Thread 类的文档 你会发现线程上下文方法是  从JDK1.2 开始引入的，getContextClassLoader() 和 setContextClassLoader（ClassLoader cl）分别用于获取和设置当前线程线程的上下文类加载器，如果当前线程没有设置上下文类加载器，那么它将和父线程保持同样的类加载器。</p>
<ul>
<li>站在开发者的角度，其他线程都是由Main线程，也就是main函数所在的线程派生的，它是其他线程的父线程或者祖先线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getContextClassLoader());</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果:</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">14d</span>ad5dc</span><br><span class="line">    </span><br><span class="line">    Loading <span class="class"><span class="keyword">class</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>&#x27;. <span class="title">This</span> <span class="title">is</span> <span class="title">deprecated</span>. <span class="title">The</span> <span class="title">new</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>&#x27;. <span class="title">The</span> <span class="title">driver</span> <span class="title">is</span> <span class="title">automatically</span> <span class="title">registered</span> <span class="title">via</span> <span class="title">the</span> <span class="title">SPI</span> <span class="title">and</span> <span class="title">manual</span> <span class="title">loading</span> <span class="title">of</span> <span class="title">the</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> <span class="title">generally</span> <span class="title">unnecessary</span>.</span></span><br></pre></td></tr></table></figure>



<p>为什么要有线程上下文类加载器呢，这就与<strong>JVM类加载器双亲委托机制自身的缺陷有关。</strong></p>
<ul>
<li>jdk的核心库中提供了很多SPI （Service Provider Interface），常见的SPI 包括JDBC、JCE、JNDI、JAXP 和JBI 等，JDK只规定了这些接口之间的逻辑关系，但不提供具体的实现，具体的实现需要由 第三方厂商来提供，</li>
<li>作为Java程序员 都写过JDBC的程序，在编写JDBC程序时几乎百分之百的都在与 java.sql 包下的类打交道</li>
</ul>
<p>如下图所示，Java使用JDBC这个SPI 完全透明了 应用程序和第三方厂商数据库驱动的具体实现， 不管数据库类型如何切换，应用程序只需要替换JDBC 的驱动jar包以及数据库的驱动名称即可，而不用进行任何更新 。</p>
<p><img src="/uploads/java-concurrency-master/JDBC_SPI.png"></p>
<p>这样做的好处是：</p>
<ul>
<li>JDBC 提供了高度抽象，应用程序只需要面向接口编程即可，不用关心各大数据厂商的具体实现 。</li>
<li>但是问题在于 java.lang.sql 中的所有接口都是JDK 提供，<strong>加载这些接口的类加载器是 根加载器</strong>,  但是 <strong>第三方厂商提供的类库驱动 是由系统类加载器加载的，</strong></li>
<li>由于JVM 类加载器的双亲委托机制，比如 Connections、 Statement、 RowSet 等 都是由 <strong>根加载器加载</strong>，第三方的JDBC 驱动包中的实现不会被加载 。</li>
</ul>
<p>通过分析 Mysql数据库的源码，来看看是如果解决这个 接口与实现类的 加载器不一致的问题</p>
<h2 id="数据库驱动的初始化源码分析"><a href="#数据库驱动的初始化源码分析" class="headerlink" title="数据库驱动的初始化源码分析"></a>数据库驱动的初始化源码分析</h2><p>在编写所有的 JDBC程序时，首先都需要 调用Class.forName(“xxxx.xxxx.xxxx.Driver”)对数据库驱动进行加载，打开 Mysql驱动 Driver源码，代码如清单11-2 所示</p>
<h3 id="Driver源码"><a href="#Driver源码" class="headerlink" title="Driver源码"></a>Driver源码</h3><ul>
<li>这个时老版本的 （com.mysql.jdbc.Driver）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backwards compatibility to support apps that call &lt;code&gt;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Loading class `com.mysql.jdbc.Driver&#x27;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#x27;. &quot;</span></span><br><span class="line">                + <span class="string">&quot;The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个是新版本的，推荐使用的（com.mysql.cj.jdbc.Driver）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在Mysql 的静态方法中 将Driver 实例注册到DriverManager中 </span></span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Driver类的静态代码块主要是 将Mysql 的Driver实例注册给 DriverManager，因此直接使用 DriverManager.registerDriver（new com.mysql.jdbc.Driver（））其作用与 Class.forName (“xxx.xxx.xxx.Driver”)是完全等价的 </li>
</ul>
<h3 id="DriverManager源码"><a href="#DriverManager源码" class="headerlink" title="DriverManager源码"></a>DriverManager源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//  Worker method called by the public getConnection() methods.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application&#x27;s</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 注释 1</span></span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//..................</span></span><br><span class="line"><span class="comment">// 注释 2</span></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">            <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">            <span class="comment">// skip it.</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">.。。。。。。。</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line"> <span class="comment">// 注释 3 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                aClass =  Class.forName(driver.getClass().getName(), <span class="keyword">true</span>, classLoader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             result = ( aClass == driver.getClass() ) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在注释1处 获取当前线程的上下文类加载器 ，该类就是调用Class.forName(“X”) 所在线程的线程上下文类加载器，通常是系统类加载器</li>
<li>注释2 中通过递归DriverManager 中已经注册的驱动类，然后验证 该数据库驱动 是否可以被指定的类加载器加载（线程上下文类加载器），如果验证通过，则返回Connection，此刻返回的 Connection 则是数据库厂商提供的实例</li>
<li>注释3 关键地方在于Class.forName(driver.getClass().getName(), true, classLoader);  其使用线程上下文类加载器及逆行数据库驱动的加载以及初始化  </li>
</ol>
<p>总结一下数据库驱动加载的整个过程，</p>
<ul>
<li>由于JDK 定义了SPI的标准接口，加之这些接口被作为 JDK 核心标准类库的一部分，既想要完全透明标准接口的实现，又想与JDK 核心库进行捆绑， 由于JVM 类加载器双亲委托机制的限制，启动类加载器不可能 加载得到第三方厂商提供的具体实现 。</li>
<li> 为了解决这一问题，JDK 只好提供一种不太优雅的设计-线程上下文类加载器 </li>
<li>有了线程上下文类加载器，启动类加载器（根加载器）反倒需要委托子类加载器去加载厂商提供的SPI 具体实现。父委托变成了子委托的方式</li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li><p>分析Mysql驱动加载过程的源码，清晰地理解线程上下文加载器所发挥地作用了 </p>
</li>
<li><p>在Thread 类中增加 getContextClassLoader() 和 setContextClassLoader（ClassLoader cl）方法实属无奈之举，它不仅破坏了类加载器地父委托机制，而且反其道行之，允许“子委托机制”，</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">java高并发详解-10-JVM类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-01 22:46:10" itemprop="dateCreated datePublished" datetime="2021-03-01T22:46:10+08:00">2021-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h1><ul>
<li>类加载器就是负责类的加载的职责，对于任意一个class，都需要由加载它的类加载器和这个类本身确立其在JVM中的唯一性，这也就是 运行时包</li>
<li>任何一个对象的class 在JVM中只存在唯一的一份，比如 String.class 、Object.class 在堆内存以及方法区中肯定是唯一的 。</li>
<li>但是绝不可以理解为我们自定义的类 在JVM中同样也是这样。</li>
</ul>
<h2 id="JVM内置三大类加载器"><a href="#JVM内置三大类加载器" class="headerlink" title="JVM内置三大类加载器"></a>JVM内置三大类加载器</h2><ul>
<li>JVM为我们提供了 三大内置的类加载器，不同的类加载器负责 将不同的类加载到JVM 内存之中，并且他们之间严格遵守着父委托的机制 </li>
</ul>
<p><img src="/uploads/java-concurrency-master/CLassLoader-father.png"></p>
<h2 id="根类加载器介绍"><a href="#根类加载器介绍" class="headerlink" title="根类加载器介绍"></a>根类加载器介绍</h2><p>根加载器又称为 Bootstrap类加载器，该类加载器是最为顶层的加载器，其没有任何父加载器，它是由 根加载器 所加载的，可以通过 -Xbootclasspath 来指定根加载器 的路径，也 可以通过系统属性来得知当前JVM 的根加载器都加载了哪些资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrapClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bootstrap:&quot;</span> + String.class.getClassLoader());</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">Bootstrap:<span class="keyword">null</span></span><br><span class="line">D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\resources.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\rt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\sunrsasign.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jsse.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jce.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\charsets.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfr.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\classes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="扩展类加载器介绍"><a href="#扩展类加载器介绍" class="headerlink" title="扩展类加载器介绍"></a>扩展类加载器介绍</h2><p>扩展类加载器的父加载器是根加载器，它主要用于加载 JAVA_HOME下的 jre\lib\ext 子目录里面的类库。扩展类加载器是由纯java语言实现的，它是 java.lang.URLClassLoader的子类，它的完整类名 是 sun.misc.Launcher$ExtClassLoader。扩展类加载器所加载的类库 可以通过系统属性 java.ext.dirs获得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        Class&lt;?&gt; helloClass = Class.forName(&quot;Hello&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(helloClass.getClassLoader());</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果： D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>

<h2 id="系统类加载器介绍"><a href="#系统类加载器介绍" class="headerlink" title="系统类加载器介绍"></a>系统类加载器介绍</h2><p>系统类加载器是一种常见的类加载器，其负责加载 classpath下的类库资源。我们在进行项目开发的时候引入的第三方jar包，<strong>系统类加载器的父类加载器 是扩展类加载器，同时它也是自定义类加载器的默认父加载器，</strong>  系统类加载器的加载路径一般通过 -classpath 或者 -cp指定，同样的也可以通过系统属性 java.class.path进行获取，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">        System.out.println(ApplicationClassLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line">    D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\charsets.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\deploy.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\cldrdata.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\dnsns.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\jaccess.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\jfxrt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\localedata.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\nashorn.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunec.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunjce_provider.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunmscapi.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunpkcs11.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\zipfs.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\javaws.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jce.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfr.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfxswt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jsse.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\management-agent.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\plugin.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\resources.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\rt.jar;H:\pdf\java-concurrency-master\java-concurrency-master\book\target\classes;C:\Users\yinshi\.m2\repository\mysql\mysql-connector-java\<span class="number">6.0</span>.<span class="number">6</span>\mysql-connector-java-<span class="number">6.0</span>.<span class="number">6.</span>jar;D:\Program Files\JetBrains\IntelliJ IDEA <span class="number">2020.1</span>.<span class="number">3</span>\lib\idea_rt.jar</span><br><span class="line"></span><br><span class="line">        sun.misc.Launcher$AppClassLoader@<span class="number">14d</span>ad5dc</span><br></pre></td></tr></table></figure>

<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>用程序实现自定义的类加载器，所有的自定义类加载都是ClassLoader的直接子类或者间接子类，java.lang.ClassLoader是一个抽象类，它里面并没有抽象方法，但是又findClass 方法，务必实现该方法，否则将会抛出 Class找不到的异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类加载器必须是ClassLoader 的直接或者间接子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义默认的class 存放路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Path DEFAULT_CLASS_DIR = Paths.get(<span class="string">&quot;H:\\pdf\\java-concurrency-master\\java-concurrency-master\\book\\target\\classes\\com\\wangwenjun\\concurrent\\chapter10&quot;</span></span><br><span class="line">            , <span class="string">&quot;classloader1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path classDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认的class路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = DEFAULT_CLASS_DIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许传入指定的class路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定class路径的同时，指定父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写父类的findClass 方法，这个是至关重要的step</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 读取class 的二进制数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">this</span>.readClassBytes(name);</span><br><span class="line">        <span class="comment">//如果数据为null，或者没有读到任何信息，则抛出 ClassNotFoundException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Can not load the class &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用defineClass 方法定义class（）</span></span><br><span class="line">        <span class="comment">//name 定义类的名字</span></span><br><span class="line">        <span class="comment">// classBytes class文件的二进制字节数组</span></span><br><span class="line">        <span class="comment">// 字节数组的偏移量</span></span><br><span class="line">        <span class="comment">// 从偏移量开始读取多长的byte数据</span></span><br><span class="line">        <span class="comment">// 问题： 第一个 阶段的加载主要是获取class的字节流信息，那么我们将整个字节流信息交给defineClass不就行 了吗，为什么还要指定偏移量和读取长度呢：</span></span><br><span class="line">        <span class="comment">// 因为class字节数组不一定是从一个class文件中获得的，有可能是来自网络的，也有可能是来自网络或者其他途径。</span></span><br><span class="line">        <span class="comment">//由此可见一个字节数组中很有可能存储多个class的字节信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将class文件读入内存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClassBytes(String name)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 将包名分隔符 转换为分拣路径分隔符</span></span><br><span class="line">        String classPath = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Path classFullPath = classDir.resolve(Paths.get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!classFullPath.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Files.copy(classFullPath, baos);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;load the class &quot;</span> + name + <span class="string">&quot; occur error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My ClassLoader&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个构造函数使用默认的文件路径</li>
<li>第二个构造函数允许外部指定一个特定的磁盘目录</li>
<li>第三个构造函数除了可以指定磁盘目录外，还可以指定该类加载的父加载器</li>
</ul>
<p>全路径格式有以下几种情况：</p>
<ul>
<li>java.lang.String:     包名.类名</li>
<li>javax.swing.JSpinner $DefaultEditor: 包名.类名 $内部类</li>
<li>java.security.KeyStor$Builder$FileBuilder$1 :包名.类名 $内部类 $内部类$匿名内部类</li>
<li>java.net.URLClassLoader$3$1: 包名.类名 $内部类$匿名内部类</li>
</ul>
<p>强调defineClass 方法，该方法的完整方法描述是  defineClass(String name, byte[] b, int off, int len) </p>
<ul>
<li>其中第一个是要定义类的名字，一般与findClass 方法中的类名保持一致即可</li>
<li>第二个是 class文件的二进制字节数组，</li>
<li>第三个是字节数组的偏移量</li>
<li>第4个是从偏移量开始读取多长的byte数据</li>
</ul>
<h2 id="双亲委托机制详细介绍"><a href="#双亲委托机制详细介绍" class="headerlink" title="双亲委托机制详细介绍"></a>双亲委托机制详细介绍</h2><ul>
<li>当一个类加载器被调用了loadClass之后，它并不会直接将其加载，而是先交给当前类加载器的 父加载器尝试加载直到最顶层的父加载器，然后一次向下进行加载。</li>
</ul>
<p><img src="/uploads/java-concurrency-master/classLoaderOfFather.png"></p>
<p>在解析loadClass 源码之前，思考一个问题，由于担心HelloWorld.class 被系统类加载器加载，所以删除了HelloWorld 的相关文件，那么有什么办法可以不用删除又可以使用 MyClassLoader对HelloWorld 进行加载的吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">     <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码片段是 java.lang.ClassLoader 的loadClass（name）和 loadClass（name，resolve）方法，由于loadClass （name）调用的是 loadClass（name，false），因此我们重点解释  loadClass（name，false）即可</p>
<ul>
<li>从当前类加载器的已加载类缓存中根据类的全路径名查询是否存在该类， 如果存在则直接返回 </li>
<li>如果当前类存在父类加载器，则 调用父类加载器的loadClass （name,false） 方法对其 进行加载</li>
<li>如果当前类加载不存在父类加载器，则直接调用根类加载器 对该类进行加载</li>
<li>如果 当前类的所有父类加载器都没有成功加载class ，则尝试 调用当前类加载器的 findClass 方法对其进行加载，该方法就是我们自定义加载器需要重写的方法</li>
<li>最后如果类被成功加载，则做一些性能数据的统计 </li>
<li>由于loadClass 指定了revolve 为false，所以不会 进行连接阶段的继续执行 ，这也就解释了  为什么通过类加载器 加载类并不会导致类的初始化</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何在不删除HelloWorld.class 文件的情况下 使用MyClassLoader 而不是系统类加载器进行HelloWorld 的加载，有如下两种方法可以做到。</p>
<ol>
<li>第一种方式 是绕过系统类加载器，直接将扩展类加载器 作为MyClassLoader 的父加载器，示例 代码如下： </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader extClassloader = MyClassLoaderTest.class.getClassLoader().getParent();</span><br><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classLoader1&quot;</span>,extClassloader);</span><br><span class="line">Class&lt;?&gt; aclass=classLoader.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.HelloWorld&quot;</span>);</span><br><span class="line">System.out.println(aClass);</span><br><span class="line">System.out.println(aClass.getClassLoader());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>首先我们通过MyClassLoaderTest.class 获取系统类加载器，然后再获取系统类加载器的父类加载器 扩展类加载器，使其成为MyClassLoader的父类加载器，这样一来，根加载器和扩展类加载器都无法对 G:\ classloader 类文件进行加载，自然而然就交给了MyClassLoader 对 HelloWorld 进行加载了，这种方式充分利用了类加载器 父类委托机制的特性</li>
</ul>
<ol start="2">
<li> 第二种方式实在构造 MyClassLoader 的时候指定其父类加载器为null ，示例代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader classLoader=<span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; aclass=classLoader.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.HelloWorld&quot;</span>);</span><br><span class="line">System.out.println(aClass);</span><br><span class="line">System.out.println(aClass.getClassLoader());</span><br><span class="line"></span><br><span class="line">根据对 loadClass方法的源码分析，当前类在没有父类加载器的情况下，会直接使用根加载器对该类进行加载 ，很显然，HelloWorld 在根加载器的加载路径下 是无法找到的，那么它 自然而然地就交给当前类加载器进行加载了</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="破坏双亲委托机制"><a href="#破坏双亲委托机制" class="headerlink" title="破坏双亲委托机制"></a>破坏双亲委托机制</h2><ul>
<li>我们发现类加载器的父委托机制的逻辑 主要是由loadClass来控制的，有些时候我们需要打破这种双亲委托的机制，比如 HelloWorld 这个类就是不希望通过系统类加载器对其进行加载。</li>
<li>JDk 提供的双亲委托机制并非一个强制性的模型，程序开发人员是可以对其进行 灵活发挥破坏这种委托机制的 </li>
</ul>
<p>比如： 如果我们想要在程序运行时进行某个模块功能的升级，甚至是 在不停止服务的前提下增加新的功能，这就是我们常说的热部署。</p>
<ul>
<li>热部署首先要卸载掉加载该模块所有Class的类加载器，卸载类加载器会导致所有类的卸载，</li>
<li>很显然我们无法对JVM 三大内置加载器进行卸载，我们只有通过控制 自定义类加载器才能做到这一点 </li>
</ul>
<p>我们可以通过破坏父委托机制的方式 来实现对HelloWorld类的加载，而不需要在工程中删除该文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerDelegateClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Path DEFAULT_CLASS_DIR = Paths.get(<span class="string">&quot;G:&quot;</span>, <span class="string">&quot;classloader1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path classDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = DEFAULT_CLASS_DIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">(String classDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">(String classDir, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">this</span>.readClassBytes(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Can not load the class &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1. 根据类的全路径名称进行加锁，确保每一个类在多线程 的情况下制备加载一次 </span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">//2. 到已加载类的缓存中查看该类是否已经被加载，如果已加载则直接返回</span></span><br><span class="line">            Class&lt;?&gt; klass = findLoadedClass(name);</span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">if</span> (klass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4. 假如缓存中没有被加载的类，则需要对其进行首次加载，如果类的全路径以java和javax开头，则直接委托给 系统类加载器对其进行加载 </span></span><br><span class="line">                <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;java.&quot;</span>) || name.startsWith(<span class="string">&quot;javax&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        klass = getSystemClassLoader().loadClass(name);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 5. 如果类不是以java 和javax 开头，则尝试用我们自定义的类加载进行加载 </span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        klass = <span class="keyword">this</span>.findClass(name);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 6. 如果 自定义类加载仍旧 没有完成对类的加载，则委托 给其父类加载器进行加载或者系统类加载器进行加载 </span></span><br><span class="line">                    <span class="keyword">if</span> (klass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            klass = getParent().loadClass(name);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            klass = getSystemClassLoader().loadClass(name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 经过诺干次的尝试后，如果还是无法对类进行加载，则抛出无法找到类的异常 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == klass) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(klass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> klass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClassBytes(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String classPath = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Path classFullPath = classDir.resolve(Paths.get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!classFullPath.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Files.copy(classFullPath, baos);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;load the class &quot;</span> + name + <span class="string">&quot; occur error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Broker Delegate ClassLoader&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类加载器命名空间、运行时包、类的卸载等"><a href="#类加载器命名空间、运行时包、类的卸载等" class="headerlink" title="类加载器命名空间、运行时包、类的卸载等"></a>类加载器命名空间、运行时包、类的卸载等</h2><h3 id="1-类的命名空间"><a href="#1-类的命名空间" class="headerlink" title="1.类的命名空间"></a>1.类的命名空间</h3><p>每一个类加载器都有各自的命名空间，命名空间时由该加载器及其所有父加载器所构成的，因此在每一个类加载器中同一个class 都是独一无二的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">       MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">       MyClassLoader classLoader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">       Class&lt;?&gt; aClass = classLoader1.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.Test&quot;</span>);</span><br><span class="line">       Class&lt;?&gt; bClass = classLoader2.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.Test&quot;</span>);</span><br><span class="line">       System.out.println(aClass.getClassLoader());</span><br><span class="line">       System.out.println(bClass.getClassLoader());</span><br><span class="line">       System.out.println(aClass.hashCode());</span><br><span class="line">       System.out.println(bClass.hashCode());</span><br><span class="line">       System.out.println(aClass == bClass);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，不论load多少次Test，都会发现他们始终时同一份class对象，这也完全符合我们在本书9.1节中的描述。 类被加载后的内存情况如图所示：</p>
<p><img src="/uploads/java-concurrency-master/classAfterLoader.png"></p>
<ul>
<li>但是，使用不同的类加载器，或者同一个类加载器的不同示例，去加载同一个class，则会在堆内存和方法区产生多个class对象 </li>
</ul>
<p>（1） 不同类加载器加载同一个class，输出的结果显示aclass 和 bclass不是同一个class示例 </p>
<p>（2）相同类加载器加载同一个class,输出的结果显示aclass 和 bclass不是同一个class示例 </p>
<p>分析JDK 中关于ClassLoader 的相关源代码，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            。。。</span><br><span class="line">                </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在类加载器进行类加载的时候，首先会到  加载记录表也就是缓存中，查看该类是否已经被加载过了，如果已经被加载过了，就不会重复加载，否则就会认为其是 首次加载， 下图就是同一个class 被不同类加载器加载之后的内存i情况 。</p>
<p><img src="/uploads/java-concurrency-master/differentClassLoaderLoadClass.png"></p>
<p>同一个class示例在同一个类加载器命名空间之下是唯一的。</p>
<h3 id="2-运行时包"><a href="#2-运行时包" class="headerlink" title="2. 运行时包"></a>2. 运行时包</h3><ul>
<li>我们在编写代码的时候，通常会给一个类指定一个包名，包的作用是为了组织类，防止不同包下同样名称的class 引起冲突，还能起到封装的作用，包名和类名构成了类的全限定名称。</li>
<li>在JVM运行时，class会由一个运行时包，<strong>运行时的包是类加载器的命名空间和类的全限定名称共同组成的</strong>。 例如:BootstrapClassLoader.ExtClassLoader.AppClassLoader.MyClassLoader.com.wangwenjun.concurrent.chapter10.Test</li>
<li>这样做的好处同样是 处于安全和封装的考虑，在java.lang.String中存在仅包可见的方法 void getChars（char[] var1,int var2），java.lang包以外的class 是无法直接对其访问的。  假设用户想自己定义一个类 java.lang.HackString。并且由自定义的类加载器进行加载，尝试访问getChars方法，由于 java.lang.HackString 和 java.lang.String是由不同的类加载器进行加载的，它们拥有各自不同的运行时包，因此 HackString 是无法访问java.lang.String 的包可见方法以及成员变量的 </li>
</ul>
<h3 id="3-初始化类加载器"><a href="#3-初始化类加载器" class="headerlink" title="3.初始化类加载器"></a>3.初始化类加载器</h3><p>由于运行时包的存在，JVM 规定了不同的运行时包下的类 彼此之间是不可以进行访问的。那么问题来了，为什么我们在开发的程序中可以访问java.lang包下的类呢。 我们直到java.lang包 是由根加载器进行加载的，而我们开发的程序或者第三方类库一般是 由系统类加载器进行加载的。</p>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>每一个类在经过ClassLoader 的加载之后，在虚拟机中都会 有对应的Class 实例，如果某个类C 被类加载器CL 加载，那么CL 就被成为C的初始类加载器。 </p>
<p>JVM 为每一个类加载器维护了一个列表，该列表中记录了 将该类加载器作为初始类加载器的所有class ，在加载一个类时，JVM 使用这些列表来判断该类是否已经被加载过了，是否需要首次加载 。</p>
<ul>
<li>根据JVM规范的规定，在类的加载过程中，所有 参与的类加载器，即使没有亲自记载过该类，也会被标识为该类的初始类加载器，比如 java.lang.String首先经过了 BrokerDelegateClassLoader类加载器，一次又经过了 系统类加载器、扩展类加载器、根类加载器，这些类加载器都是java.lang.String 的初始类加载器，JVM会在每一个类加载器维护的列表中添加该 class 类型，如下图所示。</li>
</ul>
<p><img src="/uploads/java-concurrency-master/InitClassLoaderWithClassList.png"></p>
<p>虽然SimpleClass 和 java.lang.String 由不同的类加载器加载，但是 在BrokerDelegate-Class Loader的class列表中维护了 SimpleClass.class  和String.class ，因此在SimpleClass中 是可以正常访问 rt.jar 中的class 的</p>
<h3 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4.类的卸载"></a>4.类的卸载</h3><ul>
<li>在jvm启动的过程中，jvm会加载很多的类，在运行期间同样会加载很多的类，比如用自定义的类加载器进行类的加载，或者像Apache Drools框架一样会在每一个DSL 文件解析成功之后生成相应的类文件。</li>
<li>关于JVM在运行期间到底加载了多少class，可以在启动JVM时 指定 -verbose：class 参数观察到，我们直到某个对象在堆内存中如果没有其他地方引用则会在垃圾回收器 线程进程GC的时候被回收掉，那么该对象在堆内存中的Class 对象以及Class 在方法区中的数据结构何时被回收呢?</li>
<li>JVM规定一个Class只有在满足下面三个条件的时候才会被GC回收，也就是类被卸载<ol>
<li>该类所有的实例都已经被GC ，比如SImple.class 的所有Simple实例都被回收掉</li>
<li>加载该类的ClassLoader实例被回收</li>
<li>该类的class实例 没有在其他地方被引用</li>
</ol>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>唉，为情所困，脑子都要炸了，这篇记录拖得太久了，<ol>
<li>介绍了JVM 内置的3大类加载器（根类加载器，扩展类加载器，系统类加载器）</li>
<li>通过继承ClassLoader重写findClass方法自定义了MyClassLoader，</li>
<li>通过堆loadClass方法的源码剖析详细分析了双亲委托机制的原理，双亲委托机制时一种包含关系，而并非继承关系。</li>
<li> 自定义一个与java.lang.String 同名的String类 ，但是JVM不允许这样做，会在JVM 的defineClass的时候做安全性检查。</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">java高并发详解-09-类的加载过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-25 22:29:27" itemprop="dateCreated datePublished" datetime="2021-02-25T22:29:27+08:00">2021-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>ClassLoader的主要职责是负责加载各种class文件到JVM中</li>
<li>ClassLoader是一个抽象的class ，给定一个class 的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存区域中</li>
</ul>
<h1 id="类的加载过程简介"><a href="#类的加载过程简介" class="headerlink" title="类的加载过程简介"></a>类的加载过程简介</h1><p>类的加载过程一般分为3个比较大的阶段，分别是 <strong>加载阶段、连接阶段、初始化阶段，</strong></p>
<p><img src="/uploads/java-concurrency-master/loadClassStep.png"></p>
<ul>
<li>加载阶段： 主要负责查找并加载类的二进制数据文件，其实就是class文件</li>
<li>连接阶段： 这个阶段所做的工作比较多，细分的话还可以分为以下3个阶段<ul>
<li>验证： 主要是确保类文件的正确性，比如class的版本，class文件的魔术因子是否正确</li>
<li>准备： 为类的静态变量分配内存，并且为其初始化默认值</li>
<li>解析： 把类中的符号引用转换为 直接引用</li>
</ul>
</li>
<li>初始化阶段： 为类的静态变量赋予正确的初始值 （代码编写阶段给定的值，也就是程序员的代码赋的值）</li>
</ul>
<p>当一个JVM在我们通过执行Java 命令启动后，其中可能包含的类非常多，并不是每个类都会被初始化。</p>
<ul>
<li>JVM对类的初始化时一个延迟的机制，即 ：使用的时 lazy的方式，当一个类在首次使用的时候才会被 初始化，同一个运行时包下，一个Class 只会被初始化一次 （运行时包和类的包是有区别的）</li>
</ul>
<h1 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h1><p>jvm虚拟机规范规定了，每个类或者接口被Java程序首次主动使用时，才会对其进行初始化。</p>
<h2 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h2><p>(下面的例子有问题，main方法应该写在别的类里面，因为main方法会导致类初始化)</p>
<p>jvm同时规范了以下6种主动使用类的场景，具体如下</p>
<ol>
<li><p>通过new 关键字会导致类的初始化： 这种是我们经常采用的初始化一个类的方式，它肯定会导致类的加载并且最终初始化。</p>
</li>
<li><p><strong>访问类的静态变量</strong>，包括读取和更新会导致类的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    I will be initialized</span><br><span class="line">	<span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>访问类的静态方法</strong>，会导致类的初始化 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">       <span class="comment">// System.out.println(x);</span></span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    I will be initialized</span><br><span class="line">test execute</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>对某个类进行反射操作，会导致类的初始化 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">       <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//        test();</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">I will be initialized</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>初始化子类会导致父类的初始化 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The parent is initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The child will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line">        System.out.println(Child.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    ActiveLoadTest test</span><br><span class="line">The parent is initialized</span><br><span class="line">The child will be initialized</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在测试类中调用了Child的静态变量，会使得Child被初始化，Child又是 Parent的子类， 子类的初始化会导致父类的初始化</p>
</li>
<li><p>需要注意的一点是，如果<strong>通过子类使用父类的 静态变量（输出Child.y）只会导致父类的初始化，子类则不会被初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line">        System.out.println(Child.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    </span><br><span class="line">ActiveLoadTest test</span><br><span class="line">The parent is initialized</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>启动类： 也就是执行main函数所在的类会导致该类的初始化， 比如使用java命令运行上文中的ActiveLoadTest类</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h2><p>除了上面的6种情况，其余的都称为被动使用，不会导致类的加载和初始化</p>
<ol>
<li><p>构造某个类的数组时，并不会导致该类的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line"><span class="comment">//        System.out.println(Child.y);</span></span><br><span class="line"></span><br><span class="line">        Simple[] simples = <span class="keyword">new</span> Simple[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//        System.out.println(simples);</span></span><br><span class="line">        <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//            test();</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li> 引用<strong>类的静态常量</strong>不会导致类的初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The GlobalConstants will be initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在其他类中使用 MAX 不会导致 GlobalConstants的初始化，静态代码块不会输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 虽然 RANDOM 是静态常量，但是由于计算复杂，只有初始化之后才能得到记过，因此在其他类中使用 RANDOM 会导致 GlobalConstants的初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RANDOM = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(GlobalConstants.MAX);</span><br><span class="line">        System.out.println(GlobalConstants.RANDOM);</span><br><span class="line"><span class="comment">//        System.out.println(Child.y);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">//        System.out.println(simples);</span></span><br><span class="line">        <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//            test();</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    ActiveLoadTest test</span><br><span class="line"><span class="number">100</span></span><br><span class="line">The GlobalConstants will be initialized.</span><br><span class="line"><span class="number">1357034692</span></span><br></pre></td></tr></table></figure>



<h1 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h1><h2 id="类的加载阶段"><a href="#类的加载阶段" class="headerlink" title="类的加载阶段"></a>类的加载阶段</h2><p>类的加载就是将class文件中的二进制数据读取到内存之中，然后将该字节流所代表的静态存储结构转换为方法区中 运行的数据结构，并且在堆内存中生成一个该类的 java.lang.Class 对象，作为访问方法区数据结构的入口。</p>
<p><img src="/uploads/java-concurrency-master/afterCLassLoader.png"></p>
<ul>
<li>类加载的最终产物就是堆内存中的class对象，对同一个ClassLoader来讲，不管某个类被加载了多少次，对应到堆内存中的class对象始终是同一个。</li>
<li>虚拟机规范中指出了类的加载是通过一个<strong>全限定名（包名+类名）</strong>来获取二进制数据流，</li>
<li>但是并没有限定必须通过某种方式去获得，例如常见的是  <strong>class二进制文件的形式</strong><ul>
<li>运行时动态生成，比如通过动态代理 java.lang.Proxy也可以生成代理类的二进制字节流</li>
<li>通过网络获取</li>
<li>通过读取zip文件获得类的二进制字节流，比如jar 、war</li>
<li>将类的二进制数据存储在数据库的BLOB字段类型中</li>
<li>运行时生成class文件，并且动态加载</li>
</ul>
</li>
<li>在某个类完成加载阶段之后，虚拟机会<strong>将这些二进制字节流按照虚拟机所需的格式存储在<em>方法区</em>中</strong>，然后形成特定的数据结构，随之<strong>又在堆内存中实例化一个 java.lang.Class类对象，</strong>在类加载的整个生命周期中，加载过程还没有结束，连接阶段是可以交叉工作的，比如连接阶段验证字节流信息的合法性。</li>
</ul>
<h2 id="类的连接阶段"><a href="#类的连接阶段" class="headerlink" title="类的连接阶段"></a>类的连接阶段</h2><p>类的连接阶段可以细分为3个小的过程，分别是<strong>验证、准备和解析</strong></p>
<h3 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h3><p>验证在连接阶段的主要目的是：  <strong>确保class文件的字节流所包含的内存符合当前JVM的规范要求，并且不会危害JVM 自身安全的代码</strong>，当字节流信息不符合要求时，则会抛出 VerifyError 这样的异常或者时子异常。</p>
<ul>
<li>验证文件格式（例如魔术因子 0xCAFEBABE, 主次版本号）</li>
<li>元数据的验证<ul>
<li>元数据的验证其实是对class的字节流进行语义分析的过程，确保class字节流符合JVM规范的要求</li>
<li>检查当前类是否存在父类，是否继承了某个接口，这些父类和接口是否合法</li>
<li>检查该类是否继承了被final修饰的类，被final修饰的类是不允许被继承并且其中的方法是不允许被 override的</li>
<li>检查该类是否为抽象类，如果不是抽象类，是否实现了父类的抽象方法或者接口中的所有方法</li>
<li>检查方法重载的合法性，比如相同的方法名称、相同的参数，但是返回类型不同，这都是不被允许的</li>
</ul>
</li>
<li>字节码验证<ul>
<li>主要是验证程序的控制流程，比如循环、分支。比如： 类型转换是否合法 ，程序计数器的指令不会跳转到不合法的字节码指令中去</li>
</ul>
</li>
<li>符号引用的验证<ul>
<li>验证符号引用转换为直接引用时的合法性</li>
<li>通过符号引用描述的字符串全限定名称是否能够顺利的找到相关的类</li>
<li>符号引用的类、字段、方法，是否能对当前类可见，比如不能访问引用类的私有方法</li>
<li>符号引用验证的目的是： 为了保证解析动作的顺利进行，比如某个类的字段不存在，则会抛出NoSuchFieldError ，若方法不存在 则抛出 NoSuchMethodError等，我们在使用反射的时候，会遇到这样的异常信息</li>
</ul>
</li>
</ul>
<h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h3><p>当一个class字节流通过了所有的验证过程后，就开始为该对象的类变量（静态变量）分配内存并设置初始值了。 </p>
<p>注意： <strong>类变量的内存会被分配到方法区中，</strong> 不同于实例变量会被分配到对内存中 。</p>
<ul>
<li>所谓的设置初始值，其实就是为相应的类变量 给定一个相关类型在没有设置值时的默认值，不同的数据类型以及其 初始值为：</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>（byte）0</td>
</tr>
<tr>
<td>Char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>Short</td>
<td>(short)0</td>
</tr>
<tr>
<td>Int</td>
<td>0</td>
</tr>
<tr>
<td>Float</td>
<td>0.0F</td>
</tr>
<tr>
<td>Double</td>
<td>0.0D</td>
</tr>
<tr>
<td>Long</td>
<td>0L</td>
</tr>
<tr>
<td>Boolean</td>
<td>False</td>
</tr>
<tr>
<td>引用类型</td>
<td>null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedPrepate</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>static int a=10,在准备阶段值为 初始值0，</li>
<li>final static int b则为10 ，因为在类的编译阶段javac 会将其Value 生成一个 ConstantValue属性，直接赋予10.</li>
</ul>
<h3 id="3-解析（TODO）"><a href="#3-解析（TODO）" class="headerlink" title="3.解析（TODO）"></a>3.解析（TODO）</h3><p>在连接阶段中经历了验证、准备之后，就可以顺利进入到解析过程了，当然在解析的过程中照样会交叉一些验证的过程，</p>
<ul>
<li>比如符号引用的验证，</li>
</ul>
<p>所谓解析就是在常量池中寻找类、接口、字段和方法的符号引用，并且将这些符号引用替换为直接引用的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassResolve</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Simple simple=<span class="keyword">new</span> Simple();</span><br><span class="line">    <span class="function">pulbic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(simple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机规范规定了，在anewarray，checkcast、getfield、getstatic，instanceof，invokeinterface，invokespecial、invokevirtual，multianewarray、new、putfiled、putstatic 这13个 操作符号引用的字节码指令之前，必须要对所有的符号提前进行解析 。</p>
<p>解析过程主要是 针对类接口、字段、类方法和接口方法这4类进行的，分别对应到常量池中的CONSTANT_Class_info、 Constant_Filldref_info、Constant_Methodref_info 和 Constant_InterfaceMethodref_info 这4中类型常量 。</p>
<h4 id="类接口解析"><a href="#类接口解析" class="headerlink" title="类接口解析"></a>类接口解析</h4><ul>
<li>假设前文代码中的Simple ，不是一个数组类型，则在加载的过程中，需要先完成对SImple 类的加载，同样需要经历所有的类加载阶段</li>
<li>如果SImple是一个数组类型，则虚拟机不需要完成对 SImple 的加载，只需要在虚拟机中生成一个能够代表该类型的数组对象，并且在堆内存中开辟一片连续的地址空间即可</li>
<li>在类接口的解析完成之后，还需要进行符号引用的验证</li>
</ul>
<h4 id="字段的解析"><a href="#字段的解析" class="headerlink" title="字段的解析"></a>字段的解析</h4><p>所谓字段的解析，就是解析你所访问类或者接口中的字段，在解析类或者变量的时候，如果该字段不存在，或者出现错误，则会抛出异常，不再进行下面的解析。</p>
<ul>
<li>如果Simple类本身就包含某个字段，则直接返回这个字段的引用，当然也要对该字段所属的类提前进行类加载</li>
<li>如果Simple 类中不存在该字段，则会根据继承关系自下而上，查找父类或者接口的字段，找到即可返回，同样需要提前对找到的字段进行类的加载过程 。</li>
<li>如果SImple类中没有字段，一直找到了最上层的java.lang.Object 还是没有，则表示 查找失败，也就不再进行任何解析，直接抛出了NoSuchFieldError 异常</li>
</ul>
<h4 id="类方法的解析"><a href="#类方法的解析" class="headerlink" title="类方法的解析"></a>类方法的解析</h4><p>类方法和接口方法有所不同，类方法可以直接使用该类进行调用，而接口方法必须要有相应的实现类继承才能够进行调用 。</p>
<ul>
<li>若在类方法表中发现class_index 中索引的Simple 是一个接口而不是一个类，则 直接返回错误</li>
<li>在SImple类中查找是否有方法描述和目标方法完全一致的方法，如果有，则直接返回这个方法的引用，否则直接继续向上查找。</li>
<li>如果父类中仍然没有找到，则意味着查找失败，程序会抛出NoSuchMethodError 异常</li>
<li>如果在当前类或者父类中找到了和目标方法一致的方法，但是它是一个抽象类，则会抛出AbstractMethodError 这个异常</li>
</ul>
<h4 id="接口方法的解析"><a href="#接口方法的解析" class="headerlink" title="接口方法的解析"></a>接口方法的解析</h4><p>接口不仅可以定义方法，还可以继承其他接口</p>
<ul>
<li>在接口方法表中发现 class_index 中索引的Simple是一个类而不是一个接口，则会直接 返回错误，因为方法接口表 和类接口表 所容纳的类型应该是 不一样的，所以常量池 中有 Constant_Methodref_info 和 Constant_InterfaceMethodref_info 两个不同的类型 </li>
<li>接下来的查找 和类方法的解析就比较类似了，自下而上的查找，直到找到为止，或者没找到 抛出NoSuchMethodError 异常 。</li>
</ul>
<h3 id="类的初始化阶段"><a href="#类的初始化阶段" class="headerlink" title="类的初始化阶段"></a>类的初始化阶段</h3><p>类的初始化阶段是整个类加载过程的最后一个阶段</p>
<ul>
<li>在初始化阶段做的最主要的一件事情就是执行 <clinit> () 方法中所有的类变量都会被 赋予正确的值，也就是在程序编写的时候指定的值 </li>
<li> <clinit> () 方法 实在编译阶段生成的，也就是说它 已经包含在 class文件中了，<clinit>中包含了所有类变量的赋值动作和静态语句块的执行代码 ，</li>
<li>编译器收集的顺序是 由执行语句在源文件中的出现顺序所决定的 （<clinit> 是能够保证顺序性）</li>
<li>静态 语句块只能对后面的静态变量进行赋值，但是 不能对其进行访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">static</span>&#123;</span><br><span class="line">         <span class="comment">// 静态代码块 只能对后面的静态变量进行赋值，但是不能对其访问 </span></span><br><span class="line">        System.out.println(x);<span class="comment">// 报错，Illegal forward reference </span></span><br><span class="line">        <span class="comment">//  </span></span><br><span class="line">        x=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外<clinit> 方法与类的构造函数有所不同，它不需要显示的调用父类的 构造器，虚拟机会保证父类的 <clinit>方法最先执行，因此父类的静态变量总是能够得到优先赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            value = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类使用父类的静态变量为自己的静态变量赋值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出的是： <span class="number">20</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟机会保证父类的 <clinit>方法最先执行，因此父类的静态变量总是 能够得到优先赋值  </li>
<li><clinit>() 方法虽然是真实存在的，但是它 只能被虚拟机执行，在主动使用触发了类的初始化之后就会调用这个方法  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The ClassInit static code block will be invoke.&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">                .forEach(i -&gt; <span class="keyword">new</span> Thread(ClassInit::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在同一时间，只能有一个线程执行到静态代码块中的内容，并且静态代码块仅仅只会被执行一次，JVM保证了 <clinit> 方法在多线程的执行环境下的同步语义，因此在单例设计模式下，采用 Holder的方式是一种最佳的设计方法 </li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li>类的加载过程 还是会围绕 二进制文件的加载，二进制数据的连接以及类的初始化这样的过程区进行 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">   <span class="comment">//1. </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton(); <span class="comment">// 2.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y+;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton singleton=Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton.x);</span><br><span class="line">        System.out.println(singleton.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    com.wangwenjun.concurrent.chapter09.Singleton@<span class="number">4554617</span>c</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先在连接阶段的准备过程中，每一个类变量都被赋予了相应的初始值  x=0，y=0， instance=null</p>
</li>
<li><p>类的初始化阶段，初始化阶段会为每一个类变量赋予正确的值，也就是执行 <clinit> 方法的过程 </p>
<p>x=0, y=0, instance =new Singleton()</p>
</li>
<li><p>然后在 new SIngleton 的时候，会执行类的构造函数，而在构造函数中 分别对 x和y 进行自增，结果为：</p>
<p>x=1，  y=1</p>
</li>
</ol>
<p>再看调换 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 调换Singleton顺序之后， </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton);</span><br><span class="line">        System.out.println(singleton.x);</span><br><span class="line">        System.out.println(singleton.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    </span><br><span class="line">    com.wangwenjun.concurrent.chapter09.Singleton@<span class="number">4554617</span>c</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">java高并发详解-08-线程池原理以及自定义线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-24 20:33:31" itemprop="dateCreated datePublished" datetime="2021-02-24T20:33:31+08:00">2021-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>线程池主要是为了重复利用线程，提高效率</li>
<li>因为线程是一个重量级的资源，创建、启动以及销毁都是比较耗费资源的，因此对线程重复利用是一种好的程序设计习惯</li>
<li>系统中可创建的线程数量是有限的，线程数量和系统性能是一种抛物线的关系</li>
<li>本章主要从原理入手，设计一个线程池，理解一个线程池应该具有哪些功能，需要注意哪些细节</li>
</ul>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p>一个完整的线程池应该具备如下要素</p>
<ul>
<li><p>任务队列： 用户缓存提交的任务</p>
</li>
<li><p>线程数量管理功能： 一个线程池必须能够很好的管理 和控制线程的数量，可以通过3个参数来实现：</p>
<ul>
<li>创建线程池时 初始的线程数量init</li>
<li>线程池自动扩充的最大线程数量max</li>
<li>在线程池空闲的时候需要释放线程，但是也要维护一定数量的活跃数量或者核心数量 core</li>
</ul>
<p>有了这3个参数，就能够很好的控制线程池中的线程数量，将其维护在一个合理的范围之内，三者关系是  init&lt;=core&lt;=max</p>
</li>
<li><p>任务拒绝策略： 如果线程数量已达到上限且任务队列已满，则需要有相应的拒绝策略来通知任务提交者。</p>
</li>
<li><p>线程工厂： 用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等</p>
</li>
<li><p>QueueSize： 任务队列主要存放 提交的Runnable，但是为了防止内存溢出，需要有limit 数量对其进行控制</p>
</li>
<li><p>KeepedAlive时间： 该时间主要决定线程各个重要参数自动维护的时间间隔</p>
</li>
</ul>
<p><img src="/uploads/java-concurrency-master/ThreadPoolPrinciple.png"></p>
<h1 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h1><p><img src="/uploads/java-concurrency-master/ThreadPoolImpl.png"></p>
<h2 id="线程池接口定义"><a href="#线程池接口定义" class="headerlink" title="线程池接口定义"></a>线程池接口定义</h2><ol>
<li><p>ThreadPool</p>
<p>ThreadPool主要顶一个了一个线程池应该具备的基本操作和方法，</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池大小,返回初始线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getInitSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池最大线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池的核心线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCoreSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中用户缓存任务队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中活跃线程的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//查看线程池是否已经被shutdown</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>RunnableQueue</p>
<p>RunnableQueue 用于存放提交的Runnable，该Runnable是一个BlockedQueue，并且有limit的限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务队列，用户缓存提交到线程池中的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当有新任务进来时候，首先会offer 到队列中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程通过take方法 获取Runnable</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Runnable <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务队列中任务的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>ThreadFactory</p>
<p>THreadFactory 提供创建线程的接口，以便于个性化的定制 Thread，比如应该被加入到哪个 group中，优先级，线程名字以及是否为守护线程等</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">createThread</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>DenyPolicy</p>
<p>DenyPolicy主要用于 当Queue中的runnable 达到了limit上限的时候， 决定采用何种策略通知提交者。该接口中默认定义了3中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现1： 直接将任务丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DiscardDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现2： 像任务提交者抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AbortDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RunnableDenyException(<span class="string">&quot;The runnable &quot;</span> + runnable + <span class="string">&quot; will be abort.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现3： 在提交者所在的线程中执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RunnerDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!threadPool.isShutdown()) &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>RunnableDenyException</p>
<p>RunnableDenyException 是RuntimeException的子类，主要用于通知 任务提交者，任务队列已无法再接受新的任务</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDenyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableDenyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>InternalTask</p>
<p>InternalTask 是 Runnable的一个实现，主要用于线程池内部，该类会使用到 RunnableQueue，然后不断地从queue中取出某个runnable ，并且运行runnable的 run方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RunnableQueue runnableQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalTask</span><span class="params">(RunnableQueue runnableQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runnableQueue = runnableQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前任务为 running ，并且没有被中断，</span></span><br><span class="line">        <span class="keyword">while</span> (running &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 则其将不断地 从queue中获取 runnable，然后执行run方法</span></span><br><span class="line">                Runnable task = runnableQueue.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                running = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止当前任务，主要会在 线程池的shutdown 方法中使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程池的详细实现"><a href="#线程池的详细实现" class="headerlink" title="线程池的详细实现"></a>线程池的详细实现</h2><ol>
<li><p>LinkedRunnableQueue (将runnableList 作为同步锁 对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedRunnableQueue</span> <span class="keyword">implements</span> <span class="title">RunnableQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务队列的最大容量，在构造时候传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="comment">// 假如任务队列中的任务满了，则需要执行拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DenyPolicy denyPolicy;</span><br><span class="line">    <span class="comment">// 用于存放任务的队列（双向循环列表）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; runnableList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPool threadPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedRunnableQueue</span><span class="params">(<span class="keyword">int</span> limit, DenyPolicy denyPolicy, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        <span class="keyword">this</span>.denyPolicy = denyPolicy;</span><br><span class="line">        <span class="keyword">this</span>.threadPool = threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runnableList.size() &gt;= limit) &#123;</span><br><span class="line">                <span class="comment">// 无法容纳新的任务时，执行拒绝策略</span></span><br><span class="line">                denyPolicy.reject(runnable, threadPool);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将任务假如到队尾，并且唤醒阻塞中的线程</span></span><br><span class="line">                runnableList.addLast(runnable);</span><br><span class="line">                runnableList.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="comment">// 如果任务队列中没有可执行的任务，则将当前线程挂起，进入 runnablelist 关联的wait set中等待唤醒</span></span><br><span class="line">            <span class="comment">// （有新任务假如时，会被唤醒）</span></span><br><span class="line">            <span class="keyword">while</span> (runnableList.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runnableList.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 被中断时，需要将该异常抛出，通知上游 InternalTask</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从任务队列头部移除一个任务</span></span><br><span class="line">            <span class="keyword">return</span> runnableList.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回当前任务队列中的任务数量</span></span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="keyword">return</span> runnableList.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>2.初始化线程池 (线程池本身也是一个线程)</p>
<p>线程池需要有数量控制属性（）、创建线程工厂（ThreadFactory）、任务队列策略（DenyPolicy） 等功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池本身自己也是一个线程，需要keepAlive，更新容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThreadPool</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initSize;</span><br><span class="line">    <span class="comment">//线程池最大线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//线程池核心线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 当前活跃的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> activeCount;</span><br><span class="line">    <span class="comment">// 创建线程工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RunnableQueue runnableQueue;</span><br><span class="line">    <span class="comment">// 线程池是否已经被shutdown</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isShutdown = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 工作线程队列（存放活跃线程）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;ThreadTask&gt; threadQueue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DenyPolicy DEFAULT_DENY_POLICY = <span class="keyword">new</span> DenyPolicy.DiscardDenyPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadFactory DEFAULT_THREAD_FACTORY = <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initSize  初始的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize   最大的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize  核心线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueSize 任务队列的最大数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicThreadPool</span><span class="params">(<span class="keyword">int</span> initSize, <span class="keyword">int</span> maxSize, <span class="keyword">int</span> coreSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> queueSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initSize, maxSize, coreSize, DEFAULT_THREAD_FACTORY,</span><br><span class="line">                queueSize, DEFAULT_DENY_POLICY, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造线程池需要传入的参数，更多</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initSize      初始的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize       最大的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize      核心线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 创建线程工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueSize     任务队列的最大数量（最大任务数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> denyPolicy    任务队列满后的拒绝策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicThreadPool</span><span class="params">(<span class="keyword">int</span> initSize, <span class="keyword">int</span> maxSize, <span class="keyword">int</span> coreSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory, <span class="keyword">int</span> queueSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           DenyPolicy denyPolicy, <span class="keyword">long</span> keepAliveTime, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initSize = initSize;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.runnableQueue = <span class="keyword">new</span> LinkedRunnableQueue(queueSize, denyPolicy, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时，先创建initSize 个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initSize; i++) &#123;</span><br><span class="line">            newThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务，只需要将 runnable插入任务队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">this</span>.runnableQueue.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的自动维护，具体逻辑看 InternalTask的run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalTask internalTask = <span class="keyword">new</span> InternalTask(runnableQueue);</span><br><span class="line">        Thread thread = <span class="keyword">this</span>.threadFactory.createThread(internalTask);</span><br><span class="line">        ThreadTask threadTask = <span class="keyword">new</span> ThreadTask(thread, internalTask);</span><br><span class="line">        threadQueue.offer(threadTask);</span><br><span class="line">        <span class="keyword">this</span>.activeCount++;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从线程池中 remove 某个线程</span></span><br><span class="line">        ThreadTask threadTask = threadQueue.remove();</span><br><span class="line">        threadTask.internalTask.stop();</span><br><span class="line">        <span class="keyword">this</span>.activeCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 主要用于维护线程数量，比如 扩容、回收等工作</span></span><br><span class="line">        <span class="keyword">while</span> (!isShutdown &amp;&amp; !isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                timeUnit.sleep(keepAliveTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                isShutdown = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShutdown)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(runnableQueue.size() + <span class="string">&quot;==&quot;</span> + activeCount);</span><br><span class="line">                <span class="comment">// 当前队列中 有任务尚未处理，并且 activeCount&lt; coreSize 则继续扩容</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() &gt; <span class="number">0</span> &amp;&amp; activeCount &lt; coreSize) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = initSize; i &lt; coreSize; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;--create&quot;</span>);</span><br><span class="line">                        newThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前队列中 有任务尚未处理，并且 activeCount&lt; maxSize 则继续扩容</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() &gt; <span class="number">0</span> &amp;&amp; activeCount &lt; maxSize) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = coreSize; i &lt; maxSize; i++) &#123;</span><br><span class="line">                        newThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果任务队列中 没有任务，则需要回收，回收至 coreSize 即可</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() == <span class="number">0</span> &amp;&amp; activeCount &gt; maxSize) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;remove...&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = coreSize; i &lt; maxSize; i++) &#123;</span><br><span class="line">                        removeThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShutdown) <span class="keyword">return</span>;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">            threadQueue.forEach(threadTask -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                threadTask.internalTask.stop();</span><br><span class="line">                threadTask.thread.interrupt();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">this</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInitSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.initSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCoreSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.coreSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> runnableQueue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.activeCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isShutdown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger GROUP_COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadGroup group = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;MyThreadPool-&quot;</span> + GROUP_COUNTER.getAndDecrement());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">createThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(group, runnable, <span class="string">&quot;thread-pool-&quot;</span> + COUNTER.getAndDecrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadTask 只是 InternalTask和Thread的一个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(Thread thread, InternalTask internalTask)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">            <span class="keyword">this</span>.internalTask = internalTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread;</span><br><span class="line"></span><br><span class="line">        InternalTask internalTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BasicThreadPool 同时也是Thread的子类，它在初始化的时候启动，在keepalive时间到了之后，再自动维护活动线程数量</li>
<li>TODO： BasicThreadPool 采用继承Thread的方式，不好的方式，会暴露Thread的方法，建议 改为组合关系，TODO 后面我这边会自行修改 </li>
</ul>
<h3 id="线程自动维护"><a href="#线程自动维护" class="headerlink" title="线程自动维护"></a>线程自动维护</h3><ul>
<li>自动维护线程的代码块（run方法） 是同步代码块，主要是为了阻止在线程维护过程中 线程池销毁引起的数据不一致的问题</li>
<li>任务队列中若存在积压任务，并且当前活动线程少于核心线程数，则新建 （CoreSize-initSize）数量的线程，并且将其假如到活动线程队列中，为了防止马上进行 （maxSize-coreSize）数量的扩充，建议使用 continue 终止本次循环</li>
<li>任务队列中有 积压任务，并且当前活动线程少于 最大线程数，则新建（maxSIze-coreSIze）数量的扩充，建议使用 continue 终止本次循环</li>
<li>当线程池不够繁忙时，则需要回收部分线程，回收到coreSize 数量即可，回收时调用removeThread（）方法，在该方法中需要考虑的一点是，如果被回收的线程恰巧从Runnable任务取出了某个任务，则会继续保持该线程的运行，知道完成了任务的运行为止 。详情见 InterTask 的run方法</li>
</ul>
<h3 id="线程池销毁shutdown"><a href="#线程池销毁shutdown" class="headerlink" title="线程池销毁shutdown"></a>线程池销毁shutdown</h3><ul>
<li>线程池的销毁同样需要同步机制的保护，主要是 为了防止与线程池本身的维护线程引起数据冲突</li>
</ul>
<h1 id="线程池的应用"><a href="#线程池的应用" class="headerlink" title="线程池的应用"></a>线程池的应用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadPool threadPool = <span class="keyword">new</span> BasicThreadPool(<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            threadPool.execute(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running and done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (; ; )</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getActiveCount:&quot; + threadPool.getActiveCount());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getQueueSize:&quot; + threadPool.getQueueSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getCoreSize:&quot; + threadPool.getCoreSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getMaxSize:&quot; + threadPool.getMaxSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;======================================&quot;);</span></span><br><span class="line"><span class="comment">//            TimeUnit.SECONDS.sleep(5);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">12</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>TODO： 看看 JDK 的 ExecutorService的原理和源码，据说是类似的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">java高并发详解-07-Hook线程以及捕获线程执行异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-23 21:30:24" itemprop="dateCreated datePublished" datetime="2021-02-23T21:30:24+08:00">2021-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>学习如何获取线程在运行时期的异常信息</li>
<li>学习如何向Java程序注入 Hook线程</li>
</ul>
<h1 id="获取线程运行时异常"><a href="#获取线程运行时异常" class="headerlink" title="获取线程运行时异常"></a>获取线程运行时异常</h1><p>在Thread类中，关于处理运行时异常的API总共有4个，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.  为某个特定线程 指定 UncaughtExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(</span><br><span class="line">                <span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setDefaultUncaughtExceptionHandler&quot;</span>)</span><br><span class="line">                    );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         defaultUncaughtExceptionHandler = eh;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//2. 设置全局的 UncaughtExceptionHandler</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//3.  获取特定线程的 UncaughtExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">            uncaughtExceptionHandler : group;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4.  获取全局的 UncaughtExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        uncaughtExceptionHandler = eh;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="UncaughtExceptionHandler的介绍"><a href="#UncaughtExceptionHandler的介绍" class="headerlink" title="UncaughtExceptionHandler的介绍"></a>UncaughtExceptionHandler的介绍</h2><ul>
<li>线程在执行单元中时不允许抛出checked异常的</li>
<li>线程运行在自己的上下文中，派生它的线程将无法直接获得它运行中出现的异常信息</li>
</ul>
<p>所以Java为我们提供了一个 UncaughtExceptionHandler 接口，</p>
<ul>
<li>当线程在运行过程中出现了异常时，会回调UncaughtExceptionHandler 接口，从而我们得知 哪个线程在运行时出错，以及错误类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Interface for handlers invoked when a &lt;tt&gt;Thread&lt;/tt&gt; abruptly</span></span><br><span class="line"><span class="comment">     * terminates due to an uncaught exception.</span></span><br><span class="line"><span class="comment">     （当一个线程突然的终结了由于一个未被捕获的异常，这个时候这个handler会被调用 ）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;When a thread is about to terminate due to an uncaught exception</span></span><br><span class="line"><span class="comment">     * the Java Virtual Machine will query the thread for its</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt; using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #getUncaughtExceptionHandler&#125; and will invoke the handler&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;uncaughtException&lt;/tt&gt; method, passing the thread and the</span></span><br><span class="line"><span class="comment">     * exception as arguments.</span></span><br><span class="line"><span class="comment">     （当线程由于未捕获的异常即将终止时，Java虚拟机将查询它的线程 为了给 UncaughtExceptionHandler做参数，JVM 传递线程和</span></span><br><span class="line"><span class="comment">*异常作为参数给 uncaughtException方法）</span></span><br><span class="line"><span class="comment">     * If a thread has not had its &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * explicitly set, then its &lt;tt&gt;ThreadGroup&lt;/tt&gt; object acts as its</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;. If the &lt;tt&gt;ThreadGroup&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment">     * has no</span></span><br><span class="line"><span class="comment">     * special requirements for dealing with the exception, it can forward</span></span><br><span class="line"><span class="comment">     * the invocation to the &#123;<span class="doctag">@linkplain</span> #getDefaultUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * default uncaught exception handler&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setDefaultUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ThreadGroup#uncaughtException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked when the given thread terminates due to the</span></span><br><span class="line"><span class="comment">         * given uncaught exception.</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Any exception thrown by this method will be ignored by the</span></span><br><span class="line"><span class="comment">         * Java Virtual Machine.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该回调接口会被Thread 中的dispatchUncaughtException方法调用，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 当线程在运行过程中出现异常时，JVM会调用dispatchUncaughtException方法，该方法会将对应的线程实例以及异常信息传递给回调接口</li>
</ul>
<h2 id="UncaughtExceptionHandler-实例"><a href="#UncaughtExceptionHandler-实例" class="headerlink" title="UncaughtExceptionHandler 实例"></a>UncaughtExceptionHandler 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureThreadException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler((t, e) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot; occur exception&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//here will throw unchecked exception.</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Test-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    Test-Thread occur exception</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.CaptureThreadException.lambda$main$<span class="number">1</span>(CaptureThreadException.java:<span class="number">22</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.CaptureThreadException$$Lambda$<span class="number">2</span>/<span class="number">1078694789.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这种设计方式是比较常见的，（在后面的设计模式也会讲到），尤其是那种异步执行方法，</li>
<li>比如Google 的guava toolkit就提供了 EventBus ，在EventBus 中事件源和实践的subscriber两者 借助EventBus 实现了完全的解耦合，但是在subscriber执行任务时有可能会出现异常i情况，EventBus也是借助于一个ExceptionHandler进行回调处理的 </li>
</ul>
<h2 id="UncaughtExceptionHandler-源码分析"><a href="#UncaughtExceptionHandler-源码分析" class="headerlink" title="UncaughtExceptionHandler 源码分析"></a>UncaughtExceptionHandler 源码分析</h2><p>当 没有主动的 向线程 注入UncaughtExceptionHandler 回调接口的情况下，线程加入出现了异常 又将如何处理呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the handler invoked when this thread abruptly terminates</span></span><br><span class="line"><span class="comment">  * due to an uncaught exception. If this thread has not had an</span></span><br><span class="line"><span class="comment">  * uncaught exception handler explicitly set then this thread&#x27;s</span></span><br><span class="line"><span class="comment">  * &lt;tt&gt;ThreadGroup&lt;/tt&gt; object is returned, unless this thread</span></span><br><span class="line"><span class="comment">  * has terminated, in which case &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the uncaught exception handler for this thread</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">         uncaughtExceptionHandler : group;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getUncaughtExceptionHandler 方法首先会判断当前线程是否设置了handler，</p>
<ul>
<li>如果有则执行线程自己的uncaughtException方法 ，</li>
<li>否则就到所在的ThreadGroup中获取</li>
</ul>
</li>
<li><p>ThreadGroup同样也实现了UncaughtExceptionHandler接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">            <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ueh.uncaughtException(t, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">                System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span></span><br><span class="line">                                 + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 ThreadGroup实现了  Thread.UncaughtExceptionHandler  接口</p>
<ol>
<li>该 ThreadGroup如果有父 ThreadGroup，则直接调用 父group的 uncaughtException方法</li>
<li>如果 设置了全局默认的 UncaughtExceptionHandler  ，则调用全局的 uncaughtException方法</li>
<li>如果既没有父 ThreadGroup，也没有全局默认的 UncaughtExceptionHandler  ， 则直接 将异常的堆栈信息定向到 System.err中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// get current thread&#x27;s thread group</span></span><br><span class="line">        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();</span><br><span class="line">        System.out.println(mainGroup.getName());</span><br><span class="line">        System.out.println(mainGroup.getParent());</span><br><span class="line">        System.out.println(mainGroup.getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//here will throw unchecked exception.</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Test-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果： </span><br><span class="line">    main</span><br><span class="line">java.lang.ThreadGroup[name=system,maxpri=<span class="number">10</span>]</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">Exception in thread <span class="string">&quot;Test-Thread&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.EmptyExceptionHandler.lambda$main$<span class="number">0</span>(EmptyExceptionHandler.java:<span class="number">21</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.EmptyExceptionHandler$$Lambda$<span class="number">1</span>/<span class="number">295530567.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码 既没有设置默认的Handler ,也没有对thread指定Handler，因此当thread出现异常时，会向上寻找 Group的 uncaughtException方法</li>
</ul>
<pre class="mermaid">graph LR
线程出现异常 -->MainGroup -->SystemGroup -->System.err</pre>

<pre class="mermaid">graph TD
线程出现异常 -->getUncaughtExceptionHandler{当前线程是否设置了异常处理器}
getUncaughtExceptionHandler -->|uncaughtExceptionHandler不为空| CurrThread[当前线程异常处理器处理]
getUncaughtExceptionHandler -->|uncaughtExceptionHandler为空| group[找所在 group]

group --> 父group{是否存在父group}
父group -->|父group存在| parent.uncaughtException[父group去处理]
父group -->|父group不存在| getDefaultUncaughtExceptionHandler[找全局默认的UncaughtExceptionHandler]

getDefaultUncaughtExceptionHandler -->DefaultUncaughtExceptionHandler{是否设置全局DefaultUncaughtExceptionHandler}
DefaultUncaughtExceptionHandler -->|DefaultUncaughtExceptionHandler不为空|Defaultueh.uncaughtException[DefaultUncaughtExceptionHandler处理]
DefaultUncaughtExceptionHandler -->|DefaultUncaughtExceptionHandler为空|System.err.print[输出异常堆栈]</pre>

<h1 id="注入钩子函数"><a href="#注入钩子函数" class="headerlink" title="注入钩子函数"></a>注入钩子函数</h1><h2 id="Hook线程介绍"><a href="#Hook线程介绍" class="headerlink" title="Hook线程介绍"></a>Hook线程介绍</h2><p>JVM进程的退出是由于： <strong>JVM进程中没有活跃的非守护线程，或者收到了系统中断信号</strong>，向JVM程序注入一个 Hook线程，在JVM进程退出的时候，Hook 线程会启动执行，<strong>通过Runtime可以为JVM注入多个Hook线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadHook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Hook线程1</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The hook thread 2 is running.&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;The program will exit.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// Hook线程2 </span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The hook thread 2 is running.&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;The hook thread 2 will exit.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// JVM 退出信号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;The program will is stopping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    The program will is stopping.</span><br><span class="line">The hook thread <span class="number">2</span> is running.</span><br><span class="line">The hook thread <span class="number">2</span> is running.</span><br><span class="line">The program will exit.</span><br><span class="line">The hook thread <span class="number">2</span> will exit.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>给Java程序注入了两个Hook线程，在main线程中结束，也就是JVM中没有了活动的非守护线程</li>
<li>jvm进程即将退出时，两个Hook线程会被启动并且运行 </li>
</ul>
<h2 id="Hook线程实战"><a href="#Hook线程实战" class="headerlink" title="Hook线程实战"></a>Hook线程实战</h2><p>我们在开发中经常会遇到Hook线程，比如：</p>
<ul>
<li>为了防止某个程序被重复启动，在启动时会创建一个lock文件，进程收到中断信号时候会删除lock文件，我们在mysql 服务器、zookeeper、kafka等系统都能看到lock文件的存在</li>
</ul>
<p>本代码利用hook线程的特点，模拟一个防止重复启动的程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreventDuplicated</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_PATH = <span class="string">&quot;/home/yinshi/locks/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_FILE = <span class="string">&quot;.lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PERMISSIONS = <span class="string">&quot;rw-------&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.注入hook线程，在程序退出时删除lock文件</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The program received kill SIGNAL.&quot;</span>);</span><br><span class="line">            getLockFile().toFile().delete();</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">// 2.检查是否存在 .lock文件</span></span><br><span class="line">        checkRunning();</span><br><span class="line">		<span class="comment">//3.简单模拟程序running</span></span><br><span class="line">        <span class="comment">//simulate the program is running.</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;program is running.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkRunning</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = getLockFile();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;The program already running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString(PERMISSIONS);</span><br><span class="line">        Files.createFile(path, PosixFilePermissions.asFileAttribute(perms));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Path <span class="title">getLockFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Paths.get(LOCK_PATH, LOCK_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行kill pid 或者 kill -1 pid 命令后，JVM进程会收到中断信号，并且启动hook线程 删除.lock文件</li>
</ul>
<h2 id="Hook线程应用场景以及注意事项"><a href="#Hook线程应用场景以及注意事项" class="headerlink" title="Hook线程应用场景以及注意事项"></a>Hook线程应用场景以及注意事项</h2><ul>
<li>hook线程只有在收到退出信号的时候会被执行，如果 是 kill -9 ，那么Hook线程不会得到执行，进程将会退出，因此 .lock文件将得不到清理</li>
<li>hook线程中也可以执行 一些资源释放的工作，比如 关闭文件句柄、socket链接、数据库connection等</li>
<li>尽量不要在 Hook线程中执行一些耗时非常长的操作，因为其会导致程序迟迟不能退出</li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li>知道了如何通过Handler回调的方式获取线程运行期间的异常信息， </li>
<li>分析了Thread的源码 和 ThreadGroup的源码，追踪uncaughtException的执行顺序</li>
<li>了解了Hook的执行时机，帮助程序获得进程中断的信号，有机会在进程退出之前做一些资源释放或者告警通知</li>
<li>如果强制杀死进程，（比如kill -9） 那么进程将不会收到任何中断信号</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinshi</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"4oBiQGiWDHdACABLWjT7ouaV-gzGzoHsz","appKey":"fr4vMSPUjcHLtIrF2hmRF6UE","serverURLs":"https://4obiqgiw.lc-cn-n1-shared.com","placeholder":"国王不动，手下怎么跟随? --反叛的鲁鲁修","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"cdh":"https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"}, {
      el: '#valine-comments',
      path: "/",
      serverURLs: "https://4obiqgiw.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>


</body>
</html>
