<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021todoList</title>
    <url>/2021/03/15/2021todoList/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>待办清单</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ-01-使用DockerCompose安装RocketMQ</title>
    <url>/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/</url>
    <content><![CDATA[<h1 id="使用DockerCompose安装RocketMQ"><a href="#使用DockerCompose安装RocketMQ" class="headerlink" title="使用DockerCompose安装RocketMQ"></a>使用DockerCompose安装RocketMQ</h1><p>安装Docker 和 Docker-Compose 过程略</p>
<h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 若没有目录，自行创建</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ  </span><br><span class="line">vi docker-compose.yml </span><br><span class="line"></span><br><span class="line">内容如下：</span><br><span class="line"></span><br><span class="line">version: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  rmqnamesrv:</span><br><span class="line">    image: foxiswho/rocketmq:server</span><br><span class="line">    container_name: rmqnamesrv</span><br><span class="line">    ports:</span><br><span class="line">      - 9876:9876</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/logs:/opt/logs</span><br><span class="line">      - ./data/store:/opt/store</span><br><span class="line">    networks:</span><br><span class="line">        rmq:</span><br><span class="line">          aliases:</span><br><span class="line">            - rmqnamesrv</span><br><span class="line"></span><br><span class="line">  rmqbroker:</span><br><span class="line">    image: foxiswho/rocketmq:broker</span><br><span class="line">    container_name: rmqbroker</span><br><span class="line">    ports:</span><br><span class="line">      - 10909:10909</span><br><span class="line">      - 10911:10911</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/logs:/opt/logs</span><br><span class="line">      - ./data/store:/opt/store</span><br><span class="line">      - ./data/brokerconf/broker.conf:/etc/rocketmq/broker.conf</span><br><span class="line">    environment:</span><br><span class="line">        NAMESRV_ADDR: <span class="string">&quot;rmqnamesrv:9876&quot;</span></span><br><span class="line">        JAVA_OPTS: <span class="string">&quot; -Duser.home=/opt&quot;</span></span><br><span class="line">        JAVA_OPT_EXT: <span class="string">&quot;-server -Xms128m -Xmx128m -Xmn128m&quot;</span></span><br><span class="line">    <span class="built_in">command</span>: mqbroker -c /etc/rocketmq/broker.conf</span><br><span class="line">    depends_on:</span><br><span class="line">      - rmqnamesrv</span><br><span class="line">    networks:</span><br><span class="line">      rmq:</span><br><span class="line">        aliases:</span><br><span class="line">          - rmqbroker</span><br><span class="line"></span><br><span class="line">  rmqconsole:</span><br><span class="line">    image: styletang/rocketmq-console-ng</span><br><span class="line">    container_name: rmqconsole</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    environment:</span><br><span class="line">        JAVA_OPTS: <span class="string">&quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - rmqnamesrv</span><br><span class="line">    networks:</span><br><span class="line">      rmq:</span><br><span class="line">        aliases:</span><br><span class="line">          - rmqconsole</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  rmq:</span><br><span class="line">    name: rmq</span><br><span class="line">    driver: bridge</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自行创建 目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ/data/brokerconf</span><br><span class="line"></span><br><span class="line">vi broker.conf</span><br><span class="line"><span class="comment"># 内容如下：</span></span><br><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">#  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">#  limitations under the License.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所属集群名字</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"><span class="comment"># 原因是默认配置下，不支持自定义属性，需要设置开启</span></span><br><span class="line">enablePropertyFilter=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker 名字，注意此处不同的配置文件填写的不一样，如果在 broker-a.properties 使用: broker-a,</span></span><br><span class="line"><span class="comment"># 在 broker-b.properties 使用: broker-b</span></span><br><span class="line">brokerName=broker-zhangliming</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 表示 Master，&gt; 0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># nameServer地址，分号分割</span></span><br><span class="line"><span class="comment"># namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动IP,如果 docker 报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;192.168.0.120:10909&gt; failed</span></span><br><span class="line"><span class="comment"># 解决方式1 加上一句 producer.setVipChannelEnabled(false);，解决方式2 brokerIP1 设置宿主机IP，不要使用docker 内部IP</span></span><br><span class="line">brokerIP1=192.168.62.90</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭 ！！！这里仔细看是 false，false，false</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件时间点，默认凌晨4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"></span><br><span class="line"><span class="comment"># commitLog 每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"></span><br><span class="line"><span class="comment"># ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"></span><br><span class="line"><span class="comment"># destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment"># redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment"># 检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line"><span class="comment"># storePathRootDir=/home/yinshi/rocketmq-all-4.1.0-incubating/store</span></span><br><span class="line"><span class="comment"># commitLog 存储路径</span></span><br><span class="line"><span class="comment"># storePathCommitLog=/home/yinshi/rocketmq-all-4.1.0-incubating/store/commitlog</span></span><br><span class="line"><span class="comment"># 消费队列存储</span></span><br><span class="line"><span class="comment"># storePathConsumeQueue=/home/yinshi/rocketmq-all-4.1.0-incubating/store/consumequeue</span></span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line"><span class="comment"># storePathIndex=/home/yinshi/rocketmq-all-4.1.0-incubating/store/index</span></span><br><span class="line"><span class="comment"># checkpoint 文件存储路径</span></span><br><span class="line"><span class="comment"># storeCheckpoint=/home/yinshi/rocketmq-all-4.1.0-incubating/store/checkpoint</span></span><br><span class="line"><span class="comment"># abort 文件存储路径</span></span><br><span class="line"><span class="comment"># abortFile=/home/yinshi/rocketmq-all-4.1.0-incubating/store/abort</span></span><br><span class="line"><span class="comment"># 限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"></span><br><span class="line"><span class="comment"># flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment"># flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment"># flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment"># flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker 的角色</span></span><br><span class="line"><span class="comment"># - ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment"># - SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment"># - SLAVE</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷盘方式</span></span><br><span class="line"><span class="comment"># - ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment"># - SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发消息线程池数量</span></span><br><span class="line"><span class="comment"># sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment"># 拉消息线程池数量</span></span><br><span class="line"><span class="comment"># pullMessageThreadPoolNums=128</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ </span><br><span class="line"></span><br><span class="line"><span class="comment"># pull 镜像太慢</span></span><br><span class="line">vi /etc/docker/daemon.json </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>,<span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,<span class="string">&quot;https://registry.docker-cn.com&quot;</span>],</span><br><span class="line">	<span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.62.90:5000&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 重启docker ，然后</span></span><br><span class="line">systemctl restart docker </span><br><span class="line">docker-compose up</span><br><span class="line">docker images</span><br><span class="line">docker  ps</span><br></pre></td></tr></table></figure>



<h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><p>访问控制台 RocketMQ 控制台</p>
<h3 id="访问-http-192-168-62-90-8080-登入控制台"><a href="#访问-http-192-168-62-90-8080-登入控制台" class="headerlink" title="访问 http://192.168.62.90:8080 登入控制台"></a>访问 <a href="http://192.168.62.90:8080/">http://192.168.62.90:8080</a> 登入控制台</h3>]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>安装RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ-03-保证消息可靠性</title>
    <url>/2021/04/12/RocketMQ-03-%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Rocketmq如何保证消息不丢失，如何保证消息不被重复消费"><a href="#Rocketmq如何保证消息不丢失，如何保证消息不被重复消费" class="headerlink" title="Rocketmq如何保证消息不丢失，如何保证消息不被重复消费"></a>Rocketmq如何保证消息不丢失，如何保证消息不被重复消费</h1><p>转载至：作者：Java余笙<br>链接：<a href="https://www.jianshu.com/p/cb414cf3f098">https://www.jianshu.com/p/cb414cf3f098</a></p>
<h2 id="1、消息整体处理过程"><a href="#1、消息整体处理过程" class="headerlink" title="1、消息整体处理过程"></a>1、消息整体处理过程</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjQyMTgyOS01ODhiNjNiYTM5ZTc3YjQ2LnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p>这里我们将消息的整体处理阶段分为3个阶段进行分析：</p>
<p><strong>Producer发送消息阶段。</strong></p>
<p><strong>Broker处理消息阶段。</strong></p>
<p><strong>Consumer消费消息阶段。</strong></p>
<h3 id="Producer发送消息阶段"><a href="#Producer发送消息阶段" class="headerlink" title="Producer发送消息阶段"></a>Producer发送消息阶段</h3><p>发送消息阶段涉及到Producer到broker的网络通信，因此丢失消息的几率一定会有，那RocketMQ在此阶段用了哪些手段保证消息不丢失了（或者说降低丢失的可能性）。</p>
<h4 id="手段一：提供SYNC的发送消息方式，等待broker处理结果。"><a href="#手段一：提供SYNC的发送消息方式，等待broker处理结果。" class="headerlink" title="手段一：提供SYNC的发送消息方式，等待broker处理结果。"></a>手段一：提供SYNC的发送消息方式，等待broker处理结果。</h4><p>RocketMQ提供了3种发送消息方式，分别是：</p>
<ul>
<li>同步发送：Producer 向 broker 发送消息，阻塞当前线程等待 broker 响应 发送结果。</li>
<li>异步发送：Producer 首先构建一个向 broker 发送消息的任务，把该任务提交给线程池，等执行完该任务时，回调用户自定义的回调函数，执行处理结果。</li>
<li>Oneway发送：Oneway 方式只负责发送请求，不等待应答，Producer只负责把请求发出去，而不处理响应结果。</li>
</ul>
<p>我们在调用producer.send方法时，不指定回调方法，则默认采用同步发送消息的方式，这也是丢失几率最小的一种发送方式。</p>
<h4 id="手段二：发送消息如果失败或者超时，则重新发送。"><a href="#手段二：发送消息如果失败或者超时，则重新发送。" class="headerlink" title="手段二：发送消息如果失败或者超时，则重新发送。"></a>手段二：发送消息如果失败或者超时，则重新发送。</h4><ul>
<li>发送重试源码如下，本质其实就是一个for循环，当发送消息发生异常的时候重新循环发送。默认重试3次，重试次数可以通过producer指定。</li>
</ul>
<h4 id="手段三：broker提供多master模式，即使某台broker宕机了，保证消息可以投递到另外一台正常的broker上。"><a href="#手段三：broker提供多master模式，即使某台broker宕机了，保证消息可以投递到另外一台正常的broker上。" class="headerlink" title="手段三：broker提供多master模式，即使某台broker宕机了，保证消息可以投递到另外一台正常的broker上。"></a>手段三：broker提供多master模式，即使某台broker宕机了，保证消息可以投递到另外一台正常的broker上。</h4><ul>
<li>如果broker只有一个节点，则broker宕机了，即使producer有重试机制，也没用，因此利用多主模式，当某台broker宕机了，换一台broker进行投递。</li>
</ul>
<p>总结</p>
<ul>
<li>producer消息发送方式虽然有3种，但为了减小丢失消息的可能性尽量采用同步的发送方式，同步等待发送结果，利用<strong>同步发送+重试机制+多个master节点</strong>，尽可能减小消息丢失的可能性。</li>
</ul>
<h3 id="Broker处理消息阶段"><a href="#Broker处理消息阶段" class="headerlink" title="Broker处理消息阶段"></a>Broker处理消息阶段</h3><h4 id="手段四：提供同步刷盘的策略"><a href="#手段四：提供同步刷盘的策略" class="headerlink" title="手段四：提供同步刷盘的策略"></a>手段四：提供同步刷盘的策略</h4><p>public enum FlushDiskType { SYNC_FLUSH, //同步刷盘 ASYNC_FLUSH//异步刷盘（默认） }</p>
<p>我们知道，当消息投递到broker之后，会先存到page cache，然后根据broker设置的刷盘策略是否立即刷盘，也就是如果刷盘策略为异步，broker并不会等待消息落盘就会返回producer成功，也就是说当broker所在的服务器突然宕机，则会丢失部分页的消息。</p>
<h4 id="手段五：提供主从模式，同时主从支持同步双写"><a href="#手段五：提供主从模式，同时主从支持同步双写" class="headerlink" title="手段五：提供主从模式，同时主从支持同步双写"></a><strong>手段五：提供主从模式，同时主从支持同步双写</strong></h4><p>即使broker设置了同步刷盘，如果主broker磁盘损坏，也是会导致消息丢失。 因此可以给broker指定slave，同时设置master为SYNC_MASTER，然后将slave设置为同步刷盘策略。</p>
<p>此模式下，producer每发送一条消息，都会等消息投递到master和slave都落盘成功了，broker才会当作消息投递成功，保证休息不丢失。</p>
<p>总结</p>
<p>在broker端，消息丢失的可能性主要在于刷盘策略和同步机制。<br>RocketMQ默认broker的刷盘策略为异步刷盘，如果有主从，同步策略也默认的是异步同步，这样子可以提高broker处理消息的效率，但是会有丢失的可能性。因此可以通过同步刷盘策略+同步slave策略+主从的方式解决丢失消息的可能。</p>
<h3 id="Consumer消费消息阶段"><a href="#Consumer消费消息阶段" class="headerlink" title="Consumer消费消息阶段"></a>Consumer消费消息阶段</h3><p>手段六：consumer默认提供的是At least Once机制</p>
<p>从producer投递消息到broker，即使前面这些过程保证了消息正常持久化，但如果consumer消费消息没有消费到也不能理解为消息绝对的可靠。因此RockerMQ默认提供了At least Once机制保证消息可靠消费。</p>
<p><strong>何为At least Once？</strong></p>
<p>Consumer先pull 消息到本地，消费完成后，才向服务器返回ack。</p>
<p>通常消费消息的ack机制一般分为两种思路：</p>
<p>1、先提交后消费；</p>
<p>2、先消费，消费成功后再提交；</p>
<p>思路一可以解决重复消费的问题但是会丢失消息，因此Rocketmq默认实现的是思路二，由各自consumer业务方保证幂等来解决重复消费问题。</p>
<h4 id="手段七：消费消息重试机制"><a href="#手段七：消费消息重试机制" class="headerlink" title="手段七：消费消息重试机制"></a>手段七：消费消息重试机制</h4><p>当消费消息失败了，如果不提供重试消息的能力，则也不能算完全的可靠消费，因此RocketMQ本身提供了重新消费消息的能力。</p>
<p>总结</p>
<p>consumer端要保证消费消息的可靠性，主要通过At least Once+消费重试机制保证。</p>
<h2 id="2、如何保证消息不被重复消费"><a href="#2、如何保证消息不被重复消费" class="headerlink" title="2、如何保证消息不被重复消费"></a>2、如何保证消息不被重复消费</h2><p>回答这个问题，首先你别听到重复消息这个事儿，就一无所知吧，<strong>你先大概说一说可能会有哪些重复消费的问题。</strong></p>
<p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。</p>
<p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，每隔一段时间（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p>
<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p>
<p>有这么个场景。数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 offset=153 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，kafka 也就不知道你已经消费了 offset=153 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjQyMTgyOS04YzJjZDA0NGYzOTIzMDE1LnBuZw?x-oss-process=image/format,png" alt="img"></p>
<p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p>
<p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，怎么保证<strong>幂等性</strong>。</p>
<p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p>
<p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p>
<p>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，不能出错。</p>
<h3 id="所以第二个问题来了，怎么保证消息队列消费的幂等性？"><a href="#所以第二个问题来了，怎么保证消息队列消费的幂等性？" class="headerlink" title="所以第二个问题来了，怎么保证消息队列消费的幂等性？"></a>所以第二个问题来了，怎么保证消息队列消费的幂等性？</h3><p>其实还是得结合业务来思考，我这里给几个思路：</p>
<p>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</p>
<p>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</p>
<p>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</p>
<p>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMjQyMTgyOS03NGNiNDg4ZTlmMzMzMGRmLnBuZw?x-oss-process=image/format,png" alt="img"></p>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>保证消息可靠性</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ-04-消息丢失场景及解决办法</title>
    <url>/2021/04/12/RocketMQ-04-%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E5%9C%BA%E6%99%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>文章转载至：<br>原文链接：<a href="https://blog.csdn.net/LO_YUN/article/details/103949317">https://blog.csdn.net/LO_YUN/article/details/103949317</a></p>
<h1 id="消息丢失场景及解决办法"><a href="#消息丢失场景及解决办法" class="headerlink" title="消息丢失场景及解决办法"></a>消息丢失场景及解决办法</h1><p>既然使用在项目中使用了MQ，那么就不可避免的需要考虑消息丢失问题。在一些涉及到了金钱交易的场景下，消息丢失还是很致命的。那么在RocketMQ中存在哪几种消息丢失的场景呢？<br>先来一张最简单的消费流程图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200112204152629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xPX1lVTg==,size_16,color_FFFFFF,t_70" alt="消费流程"></p>
<p>上图中大致包含了这么几种场景：</p>
<ol>
<li><p>生产者产生消息发送给RocketMQ</p>
</li>
<li><p>RocketMQ接收到了消息之后，必然需要存到磁盘中，否则断电或宕机之后会造成数据的丢失</p>
</li>
<li><p>消费者从RocketMQ中获取消息消费，消费成功之后，整个流程结束</p>
<p>这三种场景都可能会产生消息的丢失，如下图所示：</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200112205211423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xPX1lVTg==,size_16,color_FFFFFF,t_70" alt="消息丢失"></p>
<ol>
<li>场景1中生产者将消息发送给Rocket MQ的时候，如果出现了网络抖动或者通信异常等问题，消息就有可能会丢失</li>
<li>场景2中消息需要持久化到磁盘中，这时会有两种情况导致消息丢失<br>①RocketMQ为了减少磁盘的IO，会先将消息写入到os cache中，而不是直接写入到磁盘中，消费者从os cache中获取消息类似于直接从内存中获取消息，速度更快，过一段时间会由os线程异步的将消息刷入磁盘中，此时才算真正完成了消息的持久化。在这个过程中，如果消息还没有完成异步刷盘，RocketMQ中的Broker宕机的话，就会导致消息丢失<br>②如果消息已经被刷入了磁盘中，但是数据没有做任何备份，一旦磁盘损坏，那么消息也会丢失</li>
<li>消费者成功从RocketMQ中获取到了消息，还没有将消息完全消费完的时候，就通知RocketMQ我已经将消息消费了，然后消费者宕机，但是RocketMQ认为消费者已经成功消费了数据，所以数据依旧丢失了<br>那么如何保证消息的零丢失呢？</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200112211403650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xPX1lVTg==,size_16,color_FFFFFF,t_70" alt="保证消息零丢失"></p>
<ol>
<li><p>场景1中保证消息不丢失的方案是使用RocketMQ自带的事务机制来发送消息，大致流程为<br>①首先生产者发送half消息到RocketMQ中，此时消费者是无法消费half消息的，若half消息就发送失败了，则执行相应的回滚逻辑<br>②half消息发送成功之后，且RocketMQ返回成功响应，则执行生产者的核心链路<br>③如果生产者自己的核心链路执行失败，则回滚，并通知RocketMQ删除half消息<br>④如果生产者的核心链路执行成功，则通知RocketMQ commit half消息，让消费者可以消费这条数据<br>其中还有一些RocketMQ长时间没有收到生产者是要commit/rollback操作的响应，回调生产者接口的细节，感兴趣的可以参考我的这篇博文 RocketMQ分布式事务原理<br>在使用了RocketMQ事务将生产者的消息成功发送给RocketMQ，就可以保证在这个阶段消息不会丢失</p>
</li>
<li><p>在场景2中要保证消息不丢失，首先需要将os cache的异步刷盘策略改为同步刷盘，这一步需要修改Broker的配置文件，将flushDiskType改为SYNC_FLUSH同步刷盘策略，默认的是ASYNC_FLUSH异步刷盘。一旦同步刷盘返回成功，那么就一定保证消息已经持久化到磁盘中了；为了保证磁盘损坏不会丢失数据，我们需要对RocketMQ采用主从机构，集群部署，Leader中的数据在多个Follower中都存有备份，防止单点故障。</p>
</li>
<li><p>在场景3中，消息到达了消费者，RocketMQ在代码中就能保证消息不会丢失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册消息监听器处理消息</span></span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span></span>&#123; 		 						                        </span><br><span class="line">        <span class="comment">//对消息进行处理</span></span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上面这段代码中，RocketMQ在消费者中注册了一个监听器，当消费者获取到了消息，就会去回调这个监听器函数，去处理里面的消息<br>当你的消息处理完毕之后，才会返回ConsumeConcurrentlyStatus.CONSUME_SUCCESS<br>只有返回了CONSUME_SUCCESS，消费者才会告诉RocketMQ我已经消费完了，此时如果消费者宕机，消息已经处理完了，也就不会丢失消息了<br>如果消费者还没有返回CONSUME_SUCCESS时就宕机了，那么RocketMQ就会认为你这个消费者节点挂掉了，会自动故障转移，将消息交给消费者组的其他消费者去消费这个消息，保证消息不会丢失</p>
<p>为了保证消息不会丢失，在consumeMessage方法中就直接写消息消费的业务逻辑就可以了，如果非要搞一些骚操作，比如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册消息监听器处理消息</span></span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span></span>&#123; </span><br><span class="line">    	<span class="comment">//开启子线程异步处理消息</span></span><br><span class="line">    	<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">//对消息进行处理</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();		 						                        </span><br><span class="line">        <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果新开子线程异步处理消息的话，就有可能出现消息还没有被消费完，消费者告诉RocketMQ消息已经被消费了，结果宕机丢失消息的情况。</p>
<p>使用上面一整套的方案就可以在使用RocketMQ时保证消息零丢失，但是性能和吞吐量也将大幅下降</p>
<ol>
<li><p>使用事务机制传输消息，会比普通的消息传输多出很多步骤，耗费性能</p>
</li>
<li><p>同步刷盘相比异步刷盘，一个是存储在磁盘中，一个存储在内存中，速度完全不是一个数量级</p>
</li>
<li><p>主从架构的话，需要Leader将数据同步给Follower</p>
</li>
<li><p>消费时无法异步消费，只能等待消费完成再通知RocketMQ消费完成</p>
</li>
</ol>
<p>消息零丢失是一把双刃剑，要想用好，还是要视具体的业务场景而定，选择合适的方案才是最好的</p>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>消息丢失场景及解决办法</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-00-环境搭建</title>
    <url>/2021/02/01/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-00-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="Spring源码解析环境搭建"><a href="#Spring源码解析环境搭建" class="headerlink" title="Spring源码解析环境搭建"></a>Spring源码解析环境搭建</h1><p>1.首先需要下载spring源码，github </p>
<p>todo</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-01-01-容器的基础</title>
    <url>/2021/03/11/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01-01-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="容器的基础（Bean的解析）"><a href="#容器的基础（Bean的解析）" class="headerlink" title="容器的基础（Bean的解析）"></a>容器的基础（Bean的解析）</h1><p>XmlBeanFactory： </p>
<h2 id="配置文件的封装："><a href="#配置文件的封装：" class="headerlink" title="配置文件的封装："></a>配置文件的封装：</h2><ul>
<li><p>文件资源统一抽象为： InputStreamSource 资源, Resource 继承 InputStreamSource，</p>
</li>
<li><p>然后 通过Resource资源，可以 拿到InputStream，</p>
</li>
</ul>
<p>xmlBeanFactory的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new XmlBeanFactory with the given resource,</span></span><br><span class="line"><span class="comment">	 * 创建一个xml</span></span><br><span class="line"><span class="comment">	 * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Create a new XmlBeanFactory with the given input stream,</span></span><br><span class="line"><span class="comment">	 * which must be parsable using DOM.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> resource the XML resource to load bean definitions from</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parentBeanFactory parent bean factory</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="comment">// 资源加载的真正实现</span></span><br><span class="line">		<span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="加载xmlBeanDefinitions"><a href="#加载xmlBeanDefinitions" class="headerlink" title="加载xmlBeanDefinitions"></a>加载xmlBeanDefinitions</h2><ul>
<li><p>在 XmlBeanFactory中 调用了 super(parentBeanFactory); 一直往上追可以看到 ,这段代码作用是：</p>
<ul>
<li>忽略给定接口的自动装配功能</li>
</ul>
</li>
<li><p>这样的目的是为什么呢，效果如何：</p>
<ul>
<li><p>举例子来说：当A中有属性B，那么当Spring在获取A的Bean的时候，如果其属性B还没有初始化，那么Spring会自动初始化B，这也是Sprnig  提供的一种特性，</p>
</li>
<li><p>但是某些情况下，B不会被初始化，其中的一种情况就是 B实现了BeanNameAware 接口。</p>
</li>
<li><p>spring是这么介绍的： 自动装配时 忽略给定的依赖接口，典型应用就是 通过其他方式解析 Application 上下文注册依赖，类似于 BeanFactory 通过BeanFactoryAware 进行注入 或者ApplicationContext通过ApplicationContextAware 进行注入</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new AbstractAutowireCapableBeanFactory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="keyword">super</span>();</span><br><span class="line">	ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">	ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">	ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> encodedResource the resource descriptor for the XML file,</span></span><br><span class="line"><span class="comment">	 * allowing to specify an encoding to use for parsing the file</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">		Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 1.封装资源文件 ，首先 对参数Resource 使用 EncodedResource</span></span><br><span class="line">		Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2. 获得输入流</span></span><br><span class="line">		<span class="keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">			InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3.重点方法</span></span><br><span class="line">			<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">					<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			currentResources.remove(encodedResource);</span><br><span class="line">			<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取Document"><a href="#获取Document" class="headerlink" title="获取Document"></a>获取Document</h3><ul>
<li>xmlBeanFactoryReader 类对于文档并没有亲力亲为，而是委托 给了 DocumentLoader 去执行，这力的 DocumentLoader是个接口，而真正的调用的是 ： DefaultDocumentLoader </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">			<span class="keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Loaded &quot;</span> + count + <span class="string">&quot; bean definitions from &quot;</span> + resource);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">					<span class="string">&quot;Unexpected exception parsing XML document from &quot;</span> + resource, ex);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解析并注册BeanDefinitions"><a href="#解析并注册BeanDefinitions" class="headerlink" title="解析并注册BeanDefinitions"></a>解析并注册BeanDefinitions</h3><ul>
<li>当把文件转换为Document之后，接下来的提取以及注册 bean。</li>
<li>这个方法很好的应用了 面向对象中单一职责的原则，将逻辑处理委托给单一的类 进行处理，而这个逻辑处理类就是 BeanDefinitionDocumentReader</li>
<li>BeanDefinitionDocumentReader 是一个接口，而实例化的工作是在 createBeanDefinitionDocumentReader（）中完成的，BeanDefinitionDocumentReader的最终类型是 DefaultBeanDefinitionDocumentReader</li>
<li>DefaultBeanDefinitionDocumentReader::doRegisterBeanDefinitions() 提取root，以便将root作为参数继续 BeanDefinition 的注册</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">	<span class="comment">//使用 DefaultBeanDefinitionDocumentReader 实例化 BeanDefinitionDocumentReader</span></span><br><span class="line">	BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="comment">// 将环境变量设置其中</span></span><br><span class="line">	<span class="comment">// 记录统计前BeanDefinition 的加载个数</span></span><br><span class="line">	<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">	<span class="comment">// 加载以及注册 bean</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="comment">// 记录本次加载 的BeanDefinition 的个数</span></span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心方法-registerBeanDefinitions"><a href="#核心方法-registerBeanDefinitions" class="headerlink" title="核心方法 registerBeanDefinitions"></a>核心方法 registerBeanDefinitions</h3><ul>
<li>对profile 处理，然后开始解析 </li>
<li>跟进  preProcessXml(),postProcessXml(root);发现代码是空的，为啥是空的呢</li>
</ul>
<p><strong>面向对象常说的一句话： 一个类要么是面向继承的设计，要么就用final 修饰。因为 DefaultBeanDefinitionDocumentReader 不是final类，所以他是面向继承设计。</strong> </p>
<p><strong>这2个方法是为子类设计的 ，这个模板方法模式，如果继承自 DefaultBeanDefinitionDocumentReader 的子类需要在Bean解析前后 做一些处理的话，那么只需要 重写这2个方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 专门处理解析</span></span><br><span class="line">		BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">		<span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">			<span class="comment">//. 处理 profile 属性</span></span><br><span class="line">			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">				<span class="comment">// We cannot use Profiles.of(...) since profile expressions are not supported</span></span><br><span class="line">				<span class="comment">// in XML config. See SPR-12458 for details.</span></span><br><span class="line">				<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">								<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3. 解析前处理，留给子类实现</span></span><br><span class="line">		preProcessXml(root);</span><br><span class="line">		parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">		<span class="comment">// 4. 解析后处理，留给子类实现</span></span><br><span class="line">		postProcessXml(root);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.delegate = parent;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="parseBeanDefinitions-root-this-delegate"><a href="#parseBeanDefinitions-root-this-delegate" class="headerlink" title="parseBeanDefinitions(root, this.delegate)"></a>parseBeanDefinitions(root, this.delegate)</h3><ul>
<li>如何解析XML 的元素就跳过了，包含自定义标签之类的 。感觉也用不到，毕竟现在大部分都是注解开发 ，就先不看了,太繁琐了</li>
</ul>
]]></content>
      <categories>
        <category>Sprig源码解析</category>
      </categories>
      <tags>
        <tag>容器的基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-01-注解开发</title>
    <url>/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="Spring注解解析"><a href="#Spring注解解析" class="headerlink" title="Spring注解解析"></a>Spring注解解析</h2><p>最近在准备面试，翻出之前记录的笔记，再次回顾温习一下，快忘得差不多了。额</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><ul>
<li>@Configuration ==配置文件，告诉Spring框架，这是一个配置类 </li>
<li>@interface Configuration 之上，加上了</li>
</ul>
<h3 id="ComponentScans"><a href="#ComponentScans" class="headerlink" title="@ComponentScans"></a>@ComponentScans</h3><p> @ComponentScan  value:指定要扫描的包</p>
<p>excludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件<br>includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件<br>FilterType.ANNOTATION：按照注解<br>FilterType.ASSIGNABLE_TYPE：按照给定的类型；<br>FilterType.ASPECTJ：使用ASPECTJ表达式<br>FilterType.REGEX：使用正则指定<br>FilterType.CUSTOM：使用自定义规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//告诉Spring这是一个配置类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScans(</span></span><br><span class="line"><span class="meta">		value = &#123;</span></span><br><span class="line"><span class="meta">				@ComponentScan(value=&quot;com.atguigu&quot;,includeFilters = &#123;</span></span><br><span class="line"><span class="meta">/*						@Filter(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;),</span></span><br><span class="line"><span class="meta">						@Filter(type=FilterType.ASSIGNABLE_TYPE,classes&#123;BookService.class&#125;),*/</span></span><br><span class="line"><span class="meta">						@Filter(type=FilterType.CUSTOM,classes=&#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">				&#125;,useDefaultFilters = false)	</span></span><br><span class="line"><span class="meta">		&#125;</span></span><br><span class="line"><span class="meta">		)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id</span></span><br><span class="line">	<span class="meta">@Bean(&quot;person&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * metadataReader：读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">	 * metadataReaderFactory:可以获取到其他任何类信息的</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//获取当前类注解的信息</span></span><br><span class="line">		AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">		<span class="comment">//获取当前正在扫描的类的类信息</span></span><br><span class="line">		ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">		<span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line">		Resource resource = metadataReader.getResource();</span><br><span class="line">		</span><br><span class="line">		String className = classMetadata.getClassName();</span><br><span class="line">		System.out.println(<span class="string">&quot;---&gt;&quot;</span>+className);</span><br><span class="line">		<span class="keyword">if</span>(className.contains(<span class="string">&quot;er&quot;</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><ul>
<li>给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;person&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>@Scope(“prototype”)</p>
<p>系统默认是singleton   单实例</p>
<ul>
<li><p> prototype 多实例 （IOC容器启动并不会去调用方法创建对象放在容器中，每次获取的时候才会去调用方法 创建对象）</p>
</li>
<li><p>singleton  单实例 （默认值） ioc容器启动就会调用方法创建对象 放在ioc容器中，以后每次获取都是直接从容器中（map.get()）中拿</p>
</li>
</ul>
<h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>懒加载</p>
<ul>
<li>单实例bean：默认在容器启动的时候创建对象；</li>
<li>懒加载：容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化；</li>
</ul>
<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>@Conditional： 按照一定的条件 进行判断，满足条件给容器注册bean</p>
<p>//需要实现 Condition接口</p>
<ul>
<li>使用方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要实现 Condition接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context  判断条件能使用的上下文 （环境）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata 注释信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 能获取到ioc 使用的beanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">        <span class="comment">//2. 获取类加载器</span></span><br><span class="line">        ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">        <span class="comment">// 3. 获取当前的环境信息</span></span><br><span class="line">        Environment environment = context.getEnvironment();</span><br><span class="line">        <span class="comment">// 4. 能获取到bean定义的注册类</span></span><br><span class="line">        BeanDefinitionRegistry registry = context.getRegistry();</span><br><span class="line"></span><br><span class="line">        String property = environment.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (property.contains(<span class="string">&quot;linux&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Conditional(WindowCondition.class)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;bill&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> Person(<span class="string">&quot;Bill Gates&quot;</span>,<span class="number">62</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Conditional(LinuxCondition.class)</span></span><br><span class="line">    <span class="meta">@Bean(&quot;linus&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> Person(<span class="string">&quot;linus&quot;</span>,<span class="number">48</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-02-注册组件</title>
    <url>/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02-%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h2><ul>
<li>包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类]</li>
<li>@Bean[导入的第三方包里面的组件]</li>
<li>@Import[快速给容器中导入一个组件]<ul>
<li>@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名</li>
<li>ImportSelector:返回需要导入的组件的全类名数组；</li>
<li>ImportBeanDefinitionRegistrar:手动注册bean到容器中</li>
</ul>
</li>
<li>使用Spring提供的 FactoryBean（工厂Bean）;<ul>
<li>默认获取到的是工厂bean调用getObject创建的对象</li>
<li>要获取工厂Bean本身，我们需要给id前面加一个&amp;， 即<pre><code>    “&amp;colorFactoryBean&quot;</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>使用@Import 注解，内容包含 MyImportSelector</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 导入组件，id默认是组件的全类名（com.liming.bean.Color）</span></span><br><span class="line"><span class="meta">@Import(&#123;Color.class, Red.class, MyImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig2</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义逻辑返回需要导入的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回值，就是到导入到容器中的组件全类名</span></span><br><span class="line">	<span class="comment">//AnnotationMetadata:当前标注@Import注解的类的所有注解信息</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//importingClassMetadata</span></span><br><span class="line">		<span class="comment">//方法不要返回null值</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">&quot;com.bean.Blue&quot;</span>,<span class="string">&quot;com.bean.Yellow&quot;</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h4><p>使用 ImportBeanDefinitionRegistrar:手动注册bean到容器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * AnnotationMetadata：当前类的注解信息</span></span><br><span class="line"><span class="comment">	 * BeanDefinitionRegistry:BeanDefinition注册类；</span></span><br><span class="line"><span class="comment">	 * 		把所有需要添加到容器中的bean；调用</span></span><br><span class="line"><span class="comment">	 * 		BeanDefinitionRegistry.registerBeanDefinition手工注册进来</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> definition = registry.containsBeanDefinition(<span class="string">&quot;com.atguigu.bean.Red&quot;</span>);</span><br><span class="line">		<span class="keyword">boolean</span> definition2 = registry.containsBeanDefinition(<span class="string">&quot;com.atguigu.bean.Blue&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(definition &amp;&amp; definition2)&#123;</span><br><span class="line">			<span class="comment">//指定Bean定义信息；（Bean的类型，Bean。。。）</span></span><br><span class="line">			RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(RainBow.class);</span><br><span class="line">			<span class="comment">//注册一个Bean，指定bean名</span></span><br><span class="line">			registry.registerBeanDefinition(<span class="string">&quot;rainBow&quot;</span>, beanDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><p>实现FactoryBean接口, 然后加上@Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Spring定义的FactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//返回一个Color对象，这个对象会添加到容器中</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;ColorFactoryBean...getObject...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> Color.class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//是单例？</span></span><br><span class="line">	<span class="comment">//true：这个bean是单实例，在容器中保存一份</span></span><br><span class="line">	<span class="comment">//false：多实例，每次获取都会创建一个新的bean；</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ColorFactoryBean <span class="title">colorFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ColorFactoryBean();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printBeans(applicationContext);</span><br><span class="line">		<span class="comment">// ==》》》》》 这个实际 获取的是color对象，虽然id是 colorFactoryBean</span></span><br><span class="line">        Object colorFactoryBean2 = applicationContext.getBean(<span class="string">&quot;colorFactoryBean&quot;</span>);</span><br><span class="line">        Object colorFactoryBean3 = applicationContext.getBean(<span class="string">&quot;colorFactoryBean&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;colorFactoryBean==&gt;&quot;</span>+colorFactoryBean2);</span><br><span class="line">        System.out.println(colorFactoryBean2==colorFactoryBean3);</span><br><span class="line">		<span class="comment">// ======》 如果想要获取factoryBean本身，需要在id前面加上  &amp; 符号</span></span><br><span class="line">        Object colorFactoryBean4 = applicationContext.getBean(<span class="string">&quot;&amp;colorFactoryBean&quot;</span>);</span><br><span class="line">        System.out.println(colorFactoryBean4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result：</span><br><span class="line">colorFactoryBean</span><br><span class="line">===》colorFactoryBean==&gt;com.liming.bean.Color@<span class="number">159f</span>197</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">====》com.liming.condition.ColorFactoryBean@<span class="number">78</span>aab498</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注册组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-03-Bean的生命周期</title>
    <url>/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-03-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><ul>
<li><p>bean创建—初始化—-销毁的过程</p>
</li>
<li><p>容器管理bean的生命周期；</p>
<p>我们可以自定义初始化和销毁方法；</p>
<p>容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法</p>
</li>
</ul>
<h3 id="1-构造（对象创建）"><a href="#1-构造（对象创建）" class="headerlink" title="1.构造（对象创建）"></a>1.构造（对象创建）</h3><ul>
<li>单实例（Singleton）：在容器启动的时候创建对象</li>
<li>多实例(prototype )：在每次获取的时候创建对象</li>
</ul>
<h3 id="2-BeanPostProcessor-postProcessBeforeInitialization"><a href="#2-BeanPostProcessor-postProcessBeforeInitialization" class="headerlink" title="2.BeanPostProcessor.postProcessBeforeInitialization"></a>2.BeanPostProcessor.postProcessBeforeInitialization</h3><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h3><p>对象创建完成，并赋值好，调用初始化方法。。。</p>
<h3 id="4-BeanPostProcessor-postProcessAfterInitialization"><a href="#4-BeanPostProcessor-postProcessAfterInitialization" class="headerlink" title="4.BeanPostProcessor.postProcessAfterInitialization"></a>4.BeanPostProcessor.postProcessAfterInitialization</h3><h3 id="5-销毁"><a href="#5-销毁" class="headerlink" title="5.销毁"></a>5.销毁</h3><ul>
<li>单实例：容器关闭的时候</li>
<li>多实例：容器不会管理这个bean；容器不会调用销毁方法</li>
</ul>
<h2 id="BeanPostProcessor-后置处理器"><a href="#BeanPostProcessor-后置处理器" class="headerlink" title="BeanPostProcessor 后置处理器"></a>BeanPostProcessor 后置处理器</h2><ul>
<li>Bean 初始化前后进行处理工作</li>
<li>遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization，</li>
<li>一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessorsBeforeInitialization</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置处理器：初始化前后进行处理工作</span></span><br><span class="line"><span class="comment"> * 将后置处理器加入到容器中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liming</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;postProcessBeforeInitialization...&quot;</span>+beanName+<span class="string">&quot;=&gt;&quot;</span>+bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;postProcessAfterInitialization...&quot;</span>+beanName+<span class="string">&quot;=&gt;&quot;</span>+bean);</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>见： org.springframework.context.support.AbstractApplicationContext#refresh</p>
<p>【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">赋值之前：</span><br><span class="line">1）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class="line">	postProcessAfterInstantiation()；</span><br><span class="line">2）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class="line">	postProcessPropertyValues()；</span><br><span class="line">=====赋值之前：===</span><br><span class="line">3）、应用Bean属性的值；为属性利用setter方法等进行赋值；</span><br><span class="line">	applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);</span><br><span class="line">	执行xxxAware接口的方法</span><br><span class="line">		BeanNameAware\BeanClassLoaderAware\BeanFactoryAware</span><br><span class="line">	2）、【执行后置处理器初始化之前】</span><br><span class="line">	applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	BeanPostProcessor.postProcessBeforeInitialization（）;</span><br><span class="line">	3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		1）、是否是InitializingBean接口的实现；执行接口规定的初始化；</span><br><span class="line">		2）、是否自定义初始化方法；</span><br><span class="line">	4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization</span><br><span class="line">						 		BeanPostProcessor.postProcessAfterInitialization()；</span><br></pre></td></tr></table></figure>

<p>即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initializeBean</span><br><span class="line">&#123;</span><br><span class="line">applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化</span><br><span class="line">applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="指定Bean-初始化和销毁的方法"><a href="#指定Bean-初始化和销毁的方法" class="headerlink" title="指定Bean 初始化和销毁的方法"></a>指定Bean 初始化和销毁的方法</h2><ul>
<li>通过@Bean指定init-method和destroy-method；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.liming.bean&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean(initMethod=&quot;init&quot;,destroyMethod=&quot;detory&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>通过让Bean实现InitializingBean（定义初始化逻辑），DisposableBean（定义销毁逻辑）;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;cat constructor...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;cat...destroy...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;cat...afterPropertiesSet...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>可以使用JSR250；</li>
</ul>
<p>@PostConstruct：在bean创建完成并且属性赋值完成；来执行初始化方法</p>
<p>@PreDestroy：在容器销毁bean之前通知我们进行清理工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">	<span class="comment">//@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;dog constructor...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对象创建并赋值之后调用</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog....@PostConstruct...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//容器移除对象之前</span></span><br><span class="line">	<span class="meta">@PreDestroy</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detory</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Dog....@PreDestroy...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>BeanPostProcessor【interface】：bean的后置处理器</li>
</ul>
<p>在bean初始化前后进行一些处理工作；</p>
<ul>
<li><pre><code>    postProcessBeforeInitialization:在初始化之前工作</code></pre>
</li>
<li><pre><code>    postProcessAfterInitialization:在初始化之后工作</code></pre>
</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>Spring底层对 BeanPostProcessor 的使用包括：</p>
<p>bean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async,xxx BeanPostProcessor;</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Bean生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-04-属性赋值</title>
    <url>/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-04-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h3 id="使用-Value注解"><a href="#使用-Value注解" class="headerlink" title="使用@Value注解"></a>使用@Value注解</h3><ul>
<li><p>基本数值</p>
</li>
<li><p>可以写SpEL; #{}</p>
</li>
<li><p>可以写 ${} ;取出配置文件【properties】中的值 (在运行环境变量中的值)</p>
<p>ps: 这种方式 需要在添加 @PropertySource注解</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用@Value赋值；</span></span><br><span class="line">	<span class="comment">//1、基本数值</span></span><br><span class="line">	<span class="comment">//2、可以写SpEL； #&#123;&#125;</span></span><br><span class="line">	<span class="comment">//3、可以写$&#123;&#125;；取出配置文件【properties】中的值（在运行环境变量里面的值）</span></span><br><span class="line">	<span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="meta">@Value(&quot;#&#123;20-2&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;person.nickName&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String nickName;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getNickName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNickName</span><span class="params">(String nickName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用@PropertySource读取外部配置文件中的k/v保存到运行的环境变量中;加载完外部的配置文件以后使用$&#123;&#125;取出配置文件的值</span></span><br><span class="line"><span class="meta">@PropertySource(value=&#123;&quot;classpath:/person.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfPropertyValues</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h2><p>Spring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能；</p>
<p>开发环境、测试环境、生产环境；</p>
<p>数据源：(/A)(/B)(/C)；</p>
<p>@Profile：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件</p>
<ul>
<li>1）、加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中。默认是default环境</li>
<li>2）、写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效</li>
<li>3）、没有标注环境标识的bean在，任何环境下都是加载的；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:/dbconfig.properties&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfProfile</span> <span class="keyword">implements</span> <span class="title">EmbeddedValueResolverAware</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Value(&quot;$&#123;db.user&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String user;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> StringValueResolver valueResolver;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String  driverClass;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Yellow <span class="title">yellow</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Yellow();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line">	<span class="meta">@Bean(&quot;testDataSource&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceTest</span><span class="params">(<span class="meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span>String pwd)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(user);</span><br><span class="line">		dataSource.setPassword(pwd);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">		dataSource.setDriverClass(driverClass);</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">	<span class="meta">@Bean(&quot;devDataSource&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceDev</span><span class="params">(<span class="meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span>String pwd)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(user);</span><br><span class="line">		dataSource.setPassword(pwd);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/ssm_crud&quot;</span>);</span><br><span class="line">		dataSource.setDriverClass(driverClass);</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">	<span class="meta">@Bean(&quot;prodDataSource&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceProd</span><span class="params">(<span class="meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span>String pwd)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		dataSource.setUser(user);</span><br><span class="line">		dataSource.setPassword(pwd);</span><br><span class="line">		dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/scw_0515&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		dataSource.setDriverClass(driverClass);</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">this</span>.valueResolver = resolver;</span><br><span class="line">		driverClass = valueResolver.resolveStringValue(<span class="string">&quot;$&#123;db.driverClass&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>属性赋值</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-05-自动装配</title>
    <url>/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-05-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring利用依赖注入（DI），完成对IOC容器中中各个组件的依赖关系赋值；</p>
<h3 id="Autowired：自动注入"><a href="#Autowired：自动注入" class="headerlink" title="@Autowired：自动注入"></a>@Autowired：自动注入</h3><ul>
<li>默认优先按照类型去容器中找对应的组件:applicationContext.getBean(BookDao.class);找到就赋值</li>
<li>如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找 applicationContext.getBean(“bookDao”)</li>
<li>@Qualifier(“bookDao”)：使用@Qualifier指定需要装配的组件的id，而不是使用属性名</li>
<li>自动装配默认一定要将属性赋值好，没有就会报错；可以使用@Autowired(required=false);</li>
<li>@Primary：让Spring进行自动装配的时候，默认使用首选的bean；也可以继续使用@Qualifier指定需要装配的bean的名字</li>
</ul>
<h3 id="Resource-JSR250"><a href="#Resource-JSR250" class="headerlink" title="@Resource(JSR250)"></a>@Resource(JSR250)</h3><p>@Resource:</p>
<ul>
<li><p>默认是按照组件名称进行装配的；</p>
</li>
<li><p>可以和@Autowired一样实现自动装配功能；</p>
</li>
<li><p>没有能支持@Primary功能</p>
</li>
<li><p>没有支持@Autowired（reqiured=false）;</p>
</li>
</ul>
<h3 id="Inject-JSR330-java规范的注解"><a href="#Inject-JSR330-java规范的注解" class="headerlink" title="@Inject(JSR330)[java规范的注解]"></a>@Inject(JSR330)[java规范的注解]</h3><ul>
<li><p>需要导入javax.inject的包，</p>
</li>
<li><p>和Autowired的功能一样。</p>
</li>
<li><p>没有required=false的功能；</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h3></li>
</ul>
<p>@Autowired:Spring定义的； </p>
<p>@Resource、@Inject都是java规范</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><ul>
<li>AutowiredAnnotationBeanPostProcessor:解析完成自动装配功能；</li>
</ul>
<h3 id="Autowired位置"><a href="#Autowired位置" class="headerlink" title="@Autowired位置"></a>@Autowired位置</h3><p>@Autowired:构造器，参数，方法，属性 ，都是从容器中获取参数组件的值</p>
<ul>
<li><p>标注在set方法位置： @Bean+方法参数；参数从容器中获取;默认不写@Autowired效果是一样的；都能自动装配</p>
</li>
<li><p>标在构造器上：如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取</p>
</li>
<li><p>放在参数位置： </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认加在ioc容器中的组件，容器启动会调用无参构造器创建对象，再进行初始化赋值等操作</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Car car;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器要用的组件，都是从容器中获取</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">		System.out.println(<span class="string">&quot;Boss...有参构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//@Autowired </span></span><br><span class="line">	<span class="comment">//标注在方法，Spring容器创建当前对象，就会调用方法，完成赋值；</span></span><br><span class="line">	<span class="comment">//方法使用的参数，自定义类型的值从ioc容器中获取</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(// <span class="meta">@Autowired</span></span></span></span><br><span class="line"><span class="function"><span class="params">        Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Boss [car=&quot;</span> + car + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.liming.service&quot;,&quot;com.liming.dao&quot;,</span></span><br><span class="line"><span class="meta">	&quot;com.liming.controller&quot;,&quot;com.liming.bean&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConifgOfAutowired</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Primary</span></span><br><span class="line">	<span class="meta">@Bean(&quot;bookDao2&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">		BookDao bookDao = <span class="keyword">new</span> BookDao();</span><br><span class="line">		bookDao.setLable(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> bookDao;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Bean</span>标注的方法创建对象的时候，方法参数的值从容器中获取</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> car</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">		Color color = <span class="keyword">new</span> Color();</span><br><span class="line">		color.setCar(car);</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="把Spring底层一些组件注入到自定义的Bean中"><a href="#把Spring底层一些组件注入到自定义的Bean中" class="headerlink" title="把Spring底层一些组件注入到自定义的Bean中"></a>把Spring底层一些组件注入到自定义的Bean中</h3><p>自定义组件想要使用Spring容器底层的一些组件（ApplicationContext，BeanFactory，xxx）；</p>
<ul>
<li><pre><code>    自定义组件实现xxxAware；在创建对象的时候，会调用接口规定的方法注入相关组件；Aware；</code></pre>
</li>
<li><pre><code>    把Spring底层一些组件注入到自定义的Bean中；</code></pre>
</li>
<li><pre><code>    xxxAware：功能使用xxxProcessor；</code></pre>
</li>
<li><pre><code>        ApplicationContextAware==》ApplicationContextAwareProcessor. invokeAwareInterfaces ；会帮忙把spring底层逐渐传入到当前bean </code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>,<span class="title">BeanNameAware</span>,<span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot;传入的ioc：&quot;</span>+applicationContext);</span><br><span class="line">      <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot;当前bean的名字：&quot;</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      String resolveStringValue = resolver.resolveStringValue(<span class="string">&quot;你好 $&#123;os.name&#125; 我是 #&#123;20*18&#125;&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;解析的字符串：&quot;</span>+resolveStringValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-06-AOP动态代理源码解析</title>
    <url>/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-06-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="AOP动态代理"><a href="#AOP动态代理" class="headerlink" title="AOP动态代理"></a>AOP动态代理</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式；</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><p>导入aop模块；Spring AOP：(spring-aspects)</p>
</li>
<li><p>定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）</p>
</li>
<li><p>定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；</p>
<ul>
<li>前置通知(@Before)：logStart：在目标方法(div)运行之前运行</li>
<li>后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）</li>
<li>返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行</li>
<li>异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行</li>
<li>环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）</li>
</ul>
</li>
<li><p>给切面类的目标方法标注何时何地运行（通知注解）</p>
</li>
<li><p>将切面类和业务逻辑类（目标方法所在类）都加入到容器中;</p>
</li>
<li><p>必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)</p>
</li>
<li><p>给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】</p>
<p>ps:  在Spring中很多的 @EnableXXX;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 目标类 **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathCalculator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//目标方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;MathCalculator...div...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> i/j;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 切面类**/</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// @Aspect 告诉Spring当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//抽取公共的切入点表达式</span></span><br><span class="line">	<span class="comment">//1、本类引用</span></span><br><span class="line">	<span class="comment">//2、其他的切面引用</span></span><br><span class="line">	<span class="meta">@Pointcut(&quot;execution(public int com.atguigu.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）</span></span><br><span class="line">	<span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">		Object[] args = joinPoint.getArgs();</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;运行。。。@Before:参数列表是：&#123;&quot;</span>+Arrays.asList(args)+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@After(&quot;com.atguigu.aop.LogAspects.pointCut()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;结束。。。@After&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//JoinPoint一定要出现在参数表的第一位</span></span><br><span class="line">	<span class="meta">@AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;正常返回。。。@AfterReturning:运行结果：&#123;&quot;</span>+result+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;异常。。。异常信息：&#123;&quot;</span>+exception+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 配置类 **/</span> </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//开启基于注解的aop模式</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAOP</span> </span>&#123;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//业务逻辑类加入容器中</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MathCalculator <span class="title">calculator</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MathCalculator();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//切面类加入到容器中</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LogAspects <span class="title">logAspects</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LogAspects();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="分三步"><a href="#分三步" class="headerlink" title="分三步"></a>分三步</h3><ol>
<li>将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect）</li>
<li>在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</li>
<li>开启基于注解的aop模式；@EnableAspectJAutoProxy</li>
</ol>
<h3 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h3><ul>
<li>看给容器中注册了什么组件，</li>
<li>这个组件什么时候工作，</li>
<li>这个组件的功能是什么？</li>
</ul>
<h4 id="EnableAspectJAutoProxy-是什么？"><a href="#EnableAspectJAutoProxy-是什么？" class="headerlink" title="@EnableAspectJAutoProxy 是什么？"></a>@EnableAspectJAutoProxy 是什么？</h4><ul>
<li><p>@Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar</p>
</li>
<li><p>利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion</p>
<p>internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator </p>
</li>
<li><p>给容器中注册一个AnnotationAwareAspectJAutoProxyCreator；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">  <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line">  <span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">  	 * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">  	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	 * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment">  	 * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment">  	 * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment">  	 * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">  	<span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  * Registers an &#123;@link org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line">  * AnnotationAwareAspectJAutoProxyCreator&#125; against the current &#123;@link BeanDefinitionRegistry&#125;</span><br><span class="line">  * as appropriate based on a given @&#123;@link EnableAspectJAutoProxy&#125; annotation.</span><br><span class="line">  *</span><br><span class="line"></span><br><span class="line">* @author Chris Beams</span><br><span class="line">  * @author Juergen Hoeller</span><br><span class="line">  * @since 3.1</span><br><span class="line">  * @see EnableAspectJAutoProxy</span><br><span class="line">  */</span><br><span class="line">   class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line"></span><br><span class="line"> 	/**</span><br><span class="line"> 	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span><br><span class="line">       	 * of the @&#123;@link EnableAspectJAutoProxy<span class="comment">#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line">               	 * &#123;@code @Configuration&#125; class.</span><br><span class="line">             </span><br><span class="line">               	    	 */</span><br><span class="line">               	@Override</span><br><span class="line">               	public void registerBeanDefinitions(</span><br><span class="line">               			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line"> 		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line"> 		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line"> 				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line"> 		<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line"> 			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line"> 			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="AnnotationAwareAspectJAutoProxyCreator："><a href="#AnnotationAwareAspectJAutoProxyCreator：" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator："></a>AnnotationAwareAspectJAutoProxyCreator：</h4><p>溯源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator ;</span><br><span class="line">AspectJAwareAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator ;</span><br><span class="line">AbstractAdvisorAutoProxyCreator extends AbstractAutoProxyCreator ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory</p>
<ul>
<li>AbstractAutoProxyCreator.setBeanFactory()</li>
<li>AbstractAutoProxyCreator.有后置处理器的逻辑；</li>
<li>AbstractAdvisorAutoProxyCreator.setBeanFactory()-》initBeanFactory()</li>
<li>AnnotationAwareAspectJAutoProxyCreator.initBeanFactory()</li>
</ul>
<h4 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h4><p>AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()</p>
<ul>
<li><p>先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；只要创建好的Bean都会被缓存起来  </p>
</li>
<li><p>AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例</p>
<p>【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】</p>
<p>【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】</p>
</li>
<li><p>resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation </p>
<p>希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续</p>
</li>
</ul>
<h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>AnnotationAwareAspectJAutoProxyCreator[InstantiationAwareBeanPostProcessor] </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】	的作用：</span><br><span class="line"> * 1）、每一个bean创建之前，调用postProcessBeforeInstantiation()；</span><br><span class="line"> * 		关心MathCalculator和LogAspect的创建</span><br><span class="line"> * 		1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class="line"> * 		2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，</span><br><span class="line"> * 			或者是否是切面（@Aspect）</span><br><span class="line"> * 		3）、是否需要跳过</span><br><span class="line"> * 			1）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】</span><br><span class="line"> * 				每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；</span><br><span class="line"> * 				判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回<span class="literal">true</span></span><br><span class="line"> * 			2）、永远返回<span class="literal">false</span></span><br><span class="line"> * </span><br><span class="line"> * 2）、创建对象</span><br><span class="line"> * postProcessAfterInitialization；</span><br><span class="line"> * 		<span class="built_in">return</span> wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下</span><br><span class="line"> * 		1）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors</span><br><span class="line"> * 			1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）</span><br><span class="line"> * 			2、获取到能在bean使用的增强器。</span><br><span class="line"> * 			3、给增强器排序</span><br><span class="line"> * 		2）、保存当前bean在advisedBeans中；</span><br><span class="line"> * 		3）、如果当前bean需要增强，创建当前bean的代理对象；</span><br><span class="line"> * 			1）、获取所有增强器（通知方法）</span><br><span class="line"> * 			2）、保存到proxyFactory</span><br><span class="line"> * 			3）、创建代理对象：Spring自动决定</span><br><span class="line"> * 				JdkDynamicAopProxy(config);jdk动态代理；</span><br><span class="line"> * 				ObjenesisCglibAopProxy(config);cglib的动态代理；</span><br><span class="line"> * 		4）、给容器中返回当前组件使用cglib增强了的代理对象；</span><br><span class="line"> * 		5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</span><br><span class="line"> * 		</span><br><span class="line"> * 	</span><br><span class="line"> * 	3）、目标方法执行	；</span><br><span class="line"> * 		容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）；</span><br><span class="line"> * 		1）、CglibAopProxy.intercept();拦截目标方法的执行</span><br><span class="line"> * 		2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；</span><br><span class="line"> * 			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"> * 			1）、List&lt;Object&gt; interceptorList保存所有拦截器 5</span><br><span class="line"> * 				一个默认的ExposeInvocationInterceptor 和 4个增强器；</span><br><span class="line"> * 			2）、遍历所有的增强器，将其转为Interceptor；</span><br><span class="line"> * 				registry.getInterceptors(advisor);</span><br><span class="line"> * 			3）、将增强器转为List&lt;MethodInterceptor&gt;；</span><br><span class="line"> * 				如果是MethodInterceptor，直接加入到集合中</span><br><span class="line"> * 				如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；</span><br><span class="line"> * 				转换完成返回MethodInterceptor数组；</span><br><span class="line"> * </span><br><span class="line"> * 		3）、如果没有拦截器链，直接执行目标方法;</span><br><span class="line"> * 			拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制）</span><br><span class="line"> * 		4）、如果有拦截器链，把需要执行的目标对象，目标方法，</span><br><span class="line"> * 			拦截器链等信息传入创建一个 CglibMethodInvocation 对象，</span><br><span class="line"> * 			并调用 Object retVal =  mi.proceed();</span><br><span class="line"> * 		5）、拦截器链的触发过程;</span><br><span class="line"> * 			1)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法；</span><br><span class="line"> * 			2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</span><br><span class="line"> * 				拦截器链的机制，保证通知方法与目标方法的执行顺序；</span><br><span class="line"> * 		</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>@EnableAspectJAutoProxy 开启AOP功能</li>
<li>@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</li>
<li>AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</li>
<li>容器的创建流程：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象</span><br><span class="line">2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean</span><br><span class="line">	1）、创建业务逻辑组件和切面组件</span><br><span class="line">	2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程</span><br><span class="line">	3）、组件创建完之后，判断组件是否需要增强</span><br><span class="line">		是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行目标方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）、代理对象执行目标方法</span><br><span class="line">2）、CglibAopProxy.intercept()；</span><br><span class="line">	1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）</span><br><span class="line">	2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；</span><br><span class="line">	3）、效果：</span><br><span class="line">		正常执行：前置通知-》目标方法-》后置通知-》返回通知</span><br><span class="line">		出现异常：前置通知-》目标方法-》后置通知-》异常通知</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-07-关于Aware接口</title>
    <url>/2021/04/16/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-07-%E5%85%B3%E4%BA%8EAware%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>在Bean对象的生命周期的方法中有好几个接口是Aware接口的子接口，所以弄清楚Aware接口对于理解Spring框架还是很有帮助的。</p>
<h1 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h1><p>Aware系列接口，主要用于辅助Spring bean访问Spring容器</p>
<h1 id="Aware是什么："><a href="#Aware是什么：" class="headerlink" title="Aware是什么："></a>Aware是什么：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A marker superinterface indicating（指示） that a bean is eligible（合适的，符合条件的，有资格的） to be notified by the</span></span><br><span class="line"><span class="comment"> Spring container of a particular framework object through a callback-style method.</span></span><br><span class="line"><span class="comment"> The actual method signature is determined(决定) by individual（个体的） subinterfaces but should</span></span><br><span class="line"><span class="comment"> typically consist of just one void-returning method that accepts a single argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that merely（仅仅） implementing &#123;<span class="doctag">@link</span> Aware&#125; provides no default functionality.</span></span><br><span class="line"><span class="comment"> * Rather, processing must be done explicitly（明确的）, for example in a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor&#125;.</span></span><br><span class="line"><span class="comment"> * Refer to (参考，适用于)&#123;<span class="doctag">@link</span> org.springframework.context.support.ApplicationContextAwareProcessor&#125;</span></span><br><span class="line"><span class="comment"> * for an example of processing specific &#123;<span class="doctag">@code</span> *Aware&#125; interface callbacks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 可以发现该接口中并没有定义任何方法，所以这是个标识接口。该接口的子接口有如下：</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Aware的英文意思是“可感知”，它自身是一个空白的接口，但是它有很多实现类，所以它的功能其实就是可以让调用者获取到某些信息，例如：加载当前Bean的容器名，当前Bean在容器中的BeanName，获取一些文本信息和资源文件等等，去获取加载当前Bean的加载器信息，等等等等。<br>我们也可以自定义一些XXAware，去获取自己想要的信息。</li>
<li>Aware接口从字面上翻译过来是感知捕获的含义。单纯的bean（未实现Aware系列接口）是没有知觉的；实现了Aware系列接口的bean可以访问Spring容器。这些Aware系列接口增强了Spring bean的功能，但是也会造成对Spring框架的绑定，增大了与Spring框架的耦合度。（Aware是“意识到的，察觉到的”的意思，实现了Aware系列接口表明：可以意识到、可以察觉到）</li>
</ul>
<h2 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h2><p><img src="https://ask.qcloudimg.com/http-save/yehe-4919348/ztnwz2oobc.png?imageView2/2/w/1620" alt="img"></p>
<h2 id="Aware系列接口的共性"><a href="#Aware系列接口的共性" class="headerlink" title="Aware系列接口的共性"></a>Aware系列接口的共性</h2><ol>
<li>都以“Aware”结尾</li>
<li>都是Aware接口的子接口，即都继承了Aware接口</li>
<li>接口内均定义了一个set方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoaderAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanClassLoaderAware</span> <span class="keyword">extends</span> <span class="title">Aware</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>每个子接口都定义了set方法。而方法中的形参是接口Aware前面的内容，也就是当前Bean需要感知的内容。所以我们需要在Bean中声明相关的成员变量来接收。</li>
</ul>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.spring.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanClassLoaderAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwareTestBean</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String beanName;</span><br><span class="line">	<span class="keyword">private</span> String beanFactory;</span><br><span class="line">	<span class="keyword">private</span> String classLoader;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.classLoader = classLoader.getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beanFactory = beanFactory.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beanName = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBeanName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> beanName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> classLoader;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;AwareTestBean&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;beanName=&#x27;&quot;</span> + beanName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, beanFactory=&#x27;&quot;</span> + beanFactory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, classLoader=&#x27;&quot;</span> + classLoader + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConifgOfAutowired.class);</span><br><span class="line">		AwareTestBean bean = applicationContext.getBean(AwareTestBean.class);</span><br><span class="line">		System.out.println(bean.toString());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AwareTestBean&#123;beanName=<span class="string">&#x27;awareTestBean&#x27;</span>, beanFactory=<span class="string">&#x27;org.springframework.beans.factory.support.DefaultListableBeanFactory@5ab956d7: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,mainConifgOfAutowired,bookService,bookDao,bookController,awareTestBean,boss,car,cat,dog,myApplicationObjectSupport,myBeanPostProcessor,red,bookDao2,color]; root of factory hierarchy&#x27;</span>, classLoader=<span class="string">&#x27;app&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="可以看到是成功了。所以这就是Aware告知的作用。当需要获取当前Bean的一些信息，不需要硬编码或者注入的方式去拿，通过定义好的接口，直接获取"><a href="#可以看到是成功了。所以这就是Aware告知的作用。当需要获取当前Bean的一些信息，不需要硬编码或者注入的方式去拿，通过定义好的接口，直接获取" class="headerlink" title="可以看到是成功了。所以这就是Aware告知的作用。当需要获取当前Bean的一些信息，不需要硬编码或者注入的方式去拿，通过定义好的接口，直接获取"></a>可以看到是成功了。所以这就是Aware告知的作用。当需要获取当前Bean的一些信息，不需要硬编码或者注入的方式去拿，通过定义好的接口，直接获取</h6><p><img src="https://img-blog.csdnimg.cn/20201022183304977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doaXRlQmVhckNsaW1i,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>Aware接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-08-关于BeanPostProcessor生命周期</title>
    <url>/2021/04/16/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-08-%E5%85%B3%E4%BA%8EBeanPostProcessor%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>BeanPostProcessor：后置处理器<br>spring使用**<em>模板模式**</em>，在bean的创建过程中安插了许多锚点，用户寻找对应的锚点，通过重写方法介入到bean的创建过程当中。本节通过重写这些锚点，学习如何使用BeanPostProcessor、获取各类BeanAware并且理清bean的生命周期</p>
<h2 id="创建类LifeCycleBean"><a href="#创建类LifeCycleBean" class="headerlink" title="创建类LifeCycleBean"></a>创建类LifeCycleBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.spring.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleBean</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LifeCycleBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;2. 构造方法被调用，name：&quot;</span> + name);</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;5. BeanNameAware被调用, 获取到的beanName：&quot;</span> + name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">		System.out.println(<span class="string">&quot;6. BeanFactoryAware被调用，获取到beanFactory：&quot;</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">		System.out.println(<span class="string">&quot;7. ApplicationContextAware被调用，获取到ApplicationContextAware：&quot;</span> + applicationContext);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;9. afterPropertiesSet被调用&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;10. myInit自定义初始化方法被调用，name：&quot;</span> + getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;13. DisposableBean被调用&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;14. destroy-method自定义销毁方法被调用&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">///////////////////////////////////////////////////////////////</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;LifeCycleBean&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;beanFactory=&quot;</span> + beanFactory +</span><br><span class="line">				<span class="string">&quot;, applicationContext=&quot;</span> + applicationContext +</span><br><span class="line">				<span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="创建BeanPostProcessor后置处理器"><a href="#创建BeanPostProcessor后置处理器" class="headerlink" title="创建BeanPostProcessor后置处理器"></a>创建BeanPostProcessor后置处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.spring.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.PropertyValues;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeCycleBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 实例化之前</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanClass the class of the bean to be instantiated</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName  the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;1. postProcessBeforeInstantiation被调用&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 实例化之后</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;3. postProcessAfterInstantiation被调用&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;4. postProcessProperties被调用&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">			((LifeCycleBean) bean).setName(<span class="string">&quot;中中&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;8. postProcessBeforeInitialization被调用，把name改成中中&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (beanName.equals(<span class="string">&quot;lifeCycleBean&quot;</span>)) &#123;</span><br><span class="line">			((LifeCycleBean) bean).setName(<span class="string">&quot;大大&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;11. postProcessAfterInitialization被调用，把name改成大大&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.yinshi.spring.bean&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">MainConfigOfLifeCycle</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//@Scope(&quot;prototype&quot;)</span></span><br><span class="line">	<span class="meta">@Bean(initMethod=&quot;init&quot;,destroyMethod=&quot;detory&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean(initMethod = &quot;myInit&quot;, destroyMethod = &quot;myDestroy&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LifeCycleBean <span class="title">lifeCycleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LifeCycleBean(<span class="string">&quot;小小&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yinshi.spring.bean.LifeCycleBean;</span><br><span class="line"><span class="keyword">import</span> com.yinshi.spring.config.MainConfigOfLifeCycle;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOCTest_LifeCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">		AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfLifeCycle.class);</span><br><span class="line">		System.out.println(<span class="string">&quot;容器创建完成...&quot;</span>);</span><br><span class="line">		applicationContext.getBean(LifeCycleBean.class);</span><br><span class="line">		<span class="comment">// 关闭容器</span></span><br><span class="line">		applicationContext.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制台的输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> postProcessBeforeInstantiation被调用</span><br><span class="line"><span class="number">2.</span> 构造方法被调用，name：小小</span><br><span class="line"><span class="number">3.</span> postProcessAfterInstantiation被调用</span><br><span class="line"><span class="number">4.</span> postProcessProperties被调用</span><br><span class="line"><span class="number">5.</span> BeanNameAware被调用, 获取到的beanName：lifeCycleBean</span><br><span class="line"><span class="number">6.</span> BeanFactoryAware被调用，获取到beanFactory：org.springframework.beans.factory.support.DefaultListableBeanFactory@<span class="number">117e949d</span>: defining beans [lifeCycleBean,lifeCycleBeanPostProcessor]; root of factory hierarchy</span><br><span class="line"><span class="number">7.</span> ApplicationContextAware被调用，获取到ApplicationContextAware：org.springframework.context.support.ClassPathXmlApplicationContext@<span class="number">71e9d</span>db4, started on Sat Feb <span class="number">22</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">35</span> CST <span class="number">2020</span></span><br><span class="line"><span class="number">8.</span> postProcessBeforeInitialization被调用，把name改成中中</span><br><span class="line"><span class="number">9.</span> afterPropertiesSet被调用</span><br><span class="line"><span class="number">10.</span> myInit自定义初始化方法被调用，name：中中</span><br><span class="line"><span class="number">11.</span> postProcessAfterInitialization被调用，把name改成大大</span><br><span class="line"><span class="number">12.</span> bean创建完成 name： 大大</span><br><span class="line"><span class="number">13.</span> DisposableBean被调用</span><br><span class="line"><span class="number">14.</span> destroy-method自定义销毁方法被调用</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>BeanPostProcess</p>
<ul>
<li>实例化相关： postProcessBeforeInstantiation     postProcessAfterInstantiation</li>
<li>填充属性相关: postProcessProperties   </li>
<li>初始化相关： postProcessBeforeInitialization<code>、</code>postProcessAfterInitialization</li>
<li>通过重写BeanPostProcess 的方法，可以介入bean创建的不同环节。同时通过postProcessBeforeInitialization 将bean的name属性值 从“小小”改成了“中中”，又通过postProcessAfterInitialization 将“中中”改成了“大大”，成功介入了bean的创建，并且依据我们的意愿 修改了bean</li>
</ul>
</li>
<li><p>BeanNameAware、BeanFactoryAware、ApplicationContextAware<br>这3类不属于后置处理器的范畴，学名叫感知器，让bean能感知到整个容器上下文信息的接口。spring在创建过程中，通过回调子类的setBeanName, setBeanFactory, setApplicationContext实现了BeanName, BeanFactory, ApplicationContext的注入，让bean能够感知获取到spring上下文的相关信息。虽然实现的东西很牛逼，但是实现的原理一点不复杂。通过检测当前的bean是否实现相关Aware，如果实现则调用子类set方法，将当前的BeanFactory等作为参数传入，直接上源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">			((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">			ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">			<span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后贴出总结后的流程图</p>
</li>
</ol>
<p><img src="/uploads/springSource/BeanLifeCycle01.jpeg"></p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>BeanPostProcessor接口</tag>
        <tag>Spring生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>git提交统计-gitstats-java</title>
    <url>/2020/11/24/git%E6%8F%90%E4%BA%A4%E7%BB%9F%E8%AE%A1-gitstats-java/</url>
    <content><![CDATA[<h2 id="gitstats-java版"><a href="#gitstats-java版" class="headerlink" title="gitstats java版"></a>gitstats java版</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>年终总结总是要统计项目组 一年的代码提交情况，最早是使用gitstats -python版，github地址是：<br>[gitstats]: <a href="https://github.com/hoxu/gitstats">https://github.com/hoxu/gitstats</a></p>
<p>这个使用了python2.6 ，需要手动download项目下来，然后在本地配置执行，然后会生成一系列可视化的静态页面。这个过程是漫长的，并且页面展示的数据也有可能不是我们想要的。但是给我们提供了一个思路，我们只需要搞清楚 里面的py脚本的原理，便可用java实现 ，定制自己想要的效果 。</p>
<p>本文参考 ：文章[使用Git工具统计代码]: <a href="https://blog.cyeam.com/kaleidoscope/2015/01/17/gitstats#1-git-shortlog--s-since2013-12-01-before2015-12-10-head-no-merges">https://blog.cyeam.com/kaleidoscope/2015/01/17/gitstats#1-git-shortlog--s-since2013-12-01-before2015-12-10-head-no-merges</a>    “ “</p>
<p>原始脚本主要用到了8个 git 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git shortlog -s --since=2013-12-01 --before=2015-12-10 HEAD --no-merges</span><br><span class="line"></span><br><span class="line">git show-ref --tags</span><br><span class="line"></span><br><span class="line">git rev-list --pretty=format:<span class="string">&quot;%at %ai %aN (%aE)&quot;</span> --since=2013-12-01 --before=2015-12-10 HEAD | grep -v ^commit</span><br><span class="line"></span><br><span class="line">git rev-list --pretty=format:<span class="string">&quot;%at %T&quot;</span> --since=2013-12-01 --before=2015-12-10 HEAD | grep -v ^commit</span><br><span class="line"></span><br><span class="line">git ls-tree -r -l -z HEAD</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --shortstat --first-parent -m --pretty=format:<span class="string">&quot;%at %aN (%aE)&quot;</span> --since=2013-12-01 --before=2015-12-10 HEAD</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --shortstat --date-order --pretty=format:<span class="string">&quot;%at %aN (%aE)&quot;</span> --since=2013-12-01 --before=2015-12-10 HEAD</span><br><span class="line"></span><br><span class="line">git --git-dir=.git --work-tree=./ rev-parse --short HEAD</span><br></pre></td></tr></table></figure>

<p>具体的命令含义，可以参考原文，</p>
<p>我这边的思路，就是把所有的提交历史，影响行数，全部保存到数据库里，</p>
<p>使用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> git <span class="built_in">log</span> --shortstat --date-order  --no-merges --pretty=format:<span class="string">&quot;%H %at %an %s &quot;</span>   HEAD</span><br><span class="line"> （ --no-merges 代表： 只输出修改代码的 commit 的数据，开发分支merge到主分支的请求的commit 是不会被统计的）</span><br><span class="line"> 输出示例： </span><br><span class="line">7847dd178ffe1c50f7ae2ecc8dce4f671b6b0df4 1571158821 jackfrued 更新了第91天的文档和资源</span><br><span class="line"> 2 files changed, 108 insertions(+), 28 deletions(-)</span><br><span class="line"></span><br><span class="line">662318eadb8efaf86f0bc9ac4623d8c5b45c1657 1571146991 jackfrued 更新了第91天的内容</span><br><span class="line"> 7 files changed, 148 insertions(+), 42 deletions(-)</span><br><span class="line"></span><br><span class="line">24048b2e1be968750e18d8c2cc5031d6d0ad265e 1570969223 jackfrued 更新了README.md文件</span><br><span class="line"> 1 file changed, 1 insertion(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line">cef5d95041b1c1a6e03466325258d627386afbd2 1570969065 jackfrued 更新了最后10天的文档</span><br><span class="line"> 17 files changed, 1045 insertions(+), 254 deletions(-)</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>将所有的提交记录输出到txt文件上，再去读txt文件，写入数据库，后续展示 只需要看如何写sql就行，可以实现定制化</p>
<h3 id="后续思路（已实现）："><a href="#后续思路（已实现）：" class="headerlink" title="后续思路（已实现）："></a>后续思路（已实现）：</h3><ul>
<li><p>将需要统计的项目信息配置在数据库中</p>
</li>
<li><p>使用egit 自动git clone代码或者 git checkout  and pull最新分支的代码</p>
</li>
<li><p>自动将git log 信息写入文件，再读取并解析文件信息写入数据库中 </p>
<p><img src="/uploads/gitstats-vue/data-back.png"></p>
<p><img src="/uploads/gitstats-vue/back-code.png"></p>
<h3 id="todo-（前端echart-图标可视化展示-）"><a href="#todo-（前端echart-图标可视化展示-）" class="headerlink" title="todo （前端echart  图标可视化展示 ）"></a>todo （前端echart  图标可视化展示 ）</h3></li>
</ul>
<p><img src="/uploads/gitstats-vue/front-page.png"></p>
<p><img src="/uploads/gitstats-vue/front-page02.png"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitlog统计</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  </span><br><span class="line"></span><br><span class="line"> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
  </entry>
  <entry>
    <title>Hexo+NexT(v7.0+) 搭建博客：功能强化</title>
    <url>/2019/05/19/hexo-function-optimization/</url>
    <content><![CDATA[<p><img src="https://image.chingow.cn/background/20190602023505_JefG9q_6DE1E34E-037D-4EA6-A8CC-68280E0EAC1D-1264-00000122BCC398FB_tmp.jpeg" alt="Photo in Chongqing Fengjie" title="Photo in Chongqing Fengjie"></p>
<p>开源的力量让第三方插件的支持越来越多，本文介绍了在如何利用插件来加强网站的功能，主要包括:</p>
<ul>
<li>分类时间线</li>
<li>DaoVoice</li>
<li>站内搜索</li>
<li>文章推荐</li>
<li>Valine评论</li>
<li>图片灯箱<a id="more"></a>

</li>
</ul>
<h2 id="分类时间线"><a href="#分类时间线" class="headerlink" title="分类时间线"></a>分类时间线</h2><p>归档页面的时间线会让文章显示得很有条理，但是分类里却没有，可以通过修改布局自己实现这个时间线功能。</p>
<p><img src="https://image.chingow.cn/images/20190602012728_SmUFAI_Screenshot.jpeg?400x" alt="分类时间线" title="分类时间线"></p>
<p>在主题的分类布局文件中添加以下代码：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/category.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">	&#123;% for post in page.posts %&#125;</span><br><span class="line"><span class="addition">+		&#123;# Show year #&#125;</span></span><br><span class="line"><span class="addition">+			&#123;% set year %&#125;</span></span><br><span class="line"><span class="addition">+			&#123;% set post.year = date(post.date, &#x27;YYYY&#x27;) %&#125;</span></span><br><span class="line"><span class="addition">+			&#123;% if post.year !== year %&#125;</span></span><br><span class="line"><span class="addition">+			&#123;% set year = post.year %&#125;</span></span><br><span class="line"><span class="addition">+			&lt;div class=&quot;collection-title&quot;&gt;</span></span><br><span class="line"><span class="addition">+			&lt;h2 class=&quot;archive-year motion-element&quot; id=&quot;archive-year-&#123;&#123; year &#125;&#125;&quot;&gt;&#123;&#123; year &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="addition">+			&lt;/div&gt;</span></span><br><span class="line"><span class="addition">+			&#123;% endif %&#125;</span></span><br><span class="line"><span class="addition">+		&#123;# endshow #&#125;</span></span><br><span class="line">		&#123;&#123; post_template.render(post) &#125;&#125;</span><br><span class="line">	&#123;% endfor %&#125;</span><br><span class="line">	</span><br><span class="line">	……</span><br><span class="line">	</span><br><span class="line">&#123;% block sidebar %&#125;</span><br><span class="line">  &#123;&#123; sidebar_template.render(false) &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+&#123;% block script_extra %&#125;</span></span><br><span class="line"><span class="addition">+  &#123;% if theme.use_motion %&#125;</span></span><br><span class="line"><span class="addition">+		&lt;script type=&quot;text/javascript&quot; id=&quot;motion.page.archive&quot;&gt;</span></span><br><span class="line"><span class="addition">+			$(&#x27;.archive-year&#x27;).velocity(&#x27;transition.slideLeftIn&#x27;);</span></span><br><span class="line"><span class="addition">+		&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+	&#123;% endif %&#125;</span></span><br><span class="line"><span class="addition">+&#123;% endblock %&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="在线联系DaoVoice"><a href="#在线联系DaoVoice" class="headerlink" title="在线联系DaoVoice"></a>在线联系DaoVoice</h2><p>该功能由 <a href="http://dashboard.daovoice.io/">DaoVoice</a> 插件提供，效果如图：<br><img src="https://image.chingow.cn/images/20190603010423_YeqmzM_Screenshot.jpeg?300x" alt="DaoVoice" title="DaoVoice"></p>
<p>首先去 <a href="http://dashboard.daovoice.io/get-started?invite_code=3d64b7fd">DaoVoice官网</a> 注册，输入邀请码 3d64b7fd，注册后查看<strong>app_id</strong> 并复制，在 <span id="inline-purple">主题配置文件</span> _config.yml 中添加daovoice的配置：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Online contact</span></span><br><span class="line"><span class="attr">daovoice:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">daovoice_app_id:</span> &#123;<span class="string">your</span> <span class="string">app_id</span>&#125;</span><br></pre></td></tr></table></figure>

<p>按照官网开发文档说明里 <strong>应用设置</strong>—&gt;<strong>安装到网站</strong>的设置，在head的布局模板中插入相关 JavaScript 代码：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_partials/head.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="addition">+&#123;% if theme.daovoice %&#125;</span></span><br><span class="line"><span class="addition">+	&lt;script&gt;</span></span><br><span class="line"><span class="addition">+		(function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&#x27;https:&#x27; == document.location.protocol ? &#x27;https:&#x27; : &#x27;http:&#x27;) + &quot;//widget.daovoice.io/widget/$&#123;your_app_id&#125;.js&quot;,&quot;daovoice&quot;)</span></span><br><span class="line"><span class="addition">+		daovoice(&#x27;init&#x27;, &#123;</span></span><br><span class="line"><span class="addition">+			app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot;</span></span><br><span class="line"><span class="addition">+		&#125;);</span></span><br><span class="line"><span class="addition">+		daovoice(&#x27;update&#x27;);</span></span><br><span class="line"><span class="addition">+	&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+&#123;% endif %&#125;</span></span><br><span class="line"></span><br><span class="line">&#123;# Export some HEXO Configurations to Front-End #&#125;</span><br><span class="line">&lt;script id=&quot;hexo.configurations&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>具体样式设计可以在 <strong>应用设置</strong> -&gt; <strong>聊天设置</strong> 后边改。</p>
<h2 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h2><p>该功能由 <a href="https://github.com/theme-next/hexo-generator-searchdb">hexo-generator-searchdb</a> 提供，效果如图：</p>
<p><img src="https://image.chingow.cn/images/20190602014351_let2yO_Screenshot.jpeg?650x" alt="站内搜索" title="站内搜索"></p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>在 <span id="inline-purple">主题配置文件</span> _config.yml 中修改配置<code>local_search</code>：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>		<span class="comment"># 开启站内搜索</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span>		<span class="comment"># 自动和手动触发</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">3</span>  <span class="comment"># 每篇文章显示的搜索结果数量</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>搜索弹框的页边距有点点挤，在自定义样式文件中添加样式规则来增加页边距：</p>
<figure class="highlight css"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//增加搜索弹窗的页边距</span><br><span class="line"><span class="selector-class">.local-search-popup</span> <span class="selector-id">#local-search-result</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">40px</span></span><br><span class="line">  height: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">95px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2><p>该功能由 <a href="https://github.com/tea3/hexo-related-popular-posts">hexo-related-popular-posts</a> 插件提供，效果如图：</p>
<p><img src="https://image.chingow.cn/images/20190602014455_EGjrzz_Screenshot.jpeg?350x%22%E6%96%87%E7%AB%A0%E6%8E%A8%E8%8D%90%22" alt="文章推荐"></p>
<p>在站点根目录中执行以下命令安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure>

<p>在 <span id="inline-purple">主题配置文件</span> _config.yml 中开启相关文章推荐功能：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span>  <span class="comment"># custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>此时会在每篇文章结尾根据标签相关性和内容相关性来推荐相关文章。</p>
<p>事实上并非每篇文章都需要开启该功能，可在文章 Front-Matter 中设置 <code>related_posts</code> 字段来控制是否在文末显示相关文章，然后修改文章布局模板中相关的判定条件：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) and post.related_posts %&#125;</span></span><br><span class="line">    &#123;% include &#x27;post-related.swig&#x27; with &#123; post: post &#125; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便可在草稿模板 scaffolds\draft.md 中统一添加 <code>related_posts</code> 字段默认值：</p>
<figure class="highlight diff"><figcaption><span>scaffolds/draft.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: &#123;&#123; title &#125;&#125;</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line"><span class="addition">+ related_posts: true</span></span><br></pre></td></tr></table></figure>

<h2 id="Valine评论"><a href="#Valine评论" class="headerlink" title="Valine评论"></a>Valine评论</h2><p><img src="https://image.chingow.cn/images/20190602015658_Y7Rj8t_Screenshot.jpeg?650x%22Valine%E8%AF%84%E8%AE%BA%22" alt="Valine评论"></p>
<blockquote>
<p>Valine 诞生于 2017 年 8 月 7 日，是一款基于 <a href="https://leancloud.cn/">LeanCloud</a> 提供后端数据服务的快速、简洁且高效的无后端评论系统，支持匿名评论、持Markdown、Emoji等都是它的绝对优势，而且 Next 主题也已经内置了 Valine 组件，使用起来非常方便。</p>
</blockquote>
<p>首先，在LeanCloud上注册账号并创建应用，设置LeanCloud的信息。</p>
<p>在 <strong>存储</strong> -&gt; <strong>数据</strong> 中 新建一个名为<code> Counter</code> 的 Class，<code>ACL</code>权限设置为 <strong>无限制</strong>：<br>在 <strong>设置</strong> -&gt; <strong>安全中心</strong> 中添加博客域名到 Web 安全域名中，以保护LeanCloud应用的数据安全。</p>
<div class="note info"><p>在LeanCloud中的Class可以理解为数据库中的数据表。Counter用于存储记录文章访问量，记录是以url作为唯一依据的，所以根据默认的permalink组成结构，如果你更改了文章的发布日期和标题中的任意一个，都会造成文章阅读数值的清零重计。</p>
</div>

<p>然后，在 <span id="inline-purple">主题配置文件</span> _config.yml 开启评论功能即可：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>    <span class="comment"># 开启 Valine 评论</span></span><br><span class="line">  <span class="comment"># 设置应用 id 和 key</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="comment"># 关闭提醒与验证</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">placeholder:</span>  <span class="comment"># 文本框默认文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span>  <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail</span> <span class="comment"># 需要填写的信息字段</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span>  <span class="comment"># 每页评论数</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 开启文章阅读次数统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">false</span> <span class="comment"># 首页是否开启评论数</span></span><br></pre></td></tr></table></figure>

<p>有时候我们并不想在文章标题下显示评论数量，如要隐藏，可在自定义样式文件中添加如下代码：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//屏蔽标题下的评论数量</span><br><span class="line"><span class="selector-class">.post-comments-count</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评论区会显示评论人的浏览器和操作系统版本号等信息，如果只想要一个干净的评论界面，而没有多余其他的信息，可在自定义样式文件中添加如下代码：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//屏蔽评论组件的多余信息</span><br><span class="line"><span class="selector-id">#comments</span> <span class="selector-class">.info</span>, <span class="selector-id">#comments</span> <span class="selector-class">.vsys</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，集成评论服务后，所有的页面也会带有评论，包括标签、关于等页面。这里需要在添加字段<code>comments</code>并将值设置为 false 即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="图片灯箱"><a href="#图片灯箱" class="headerlink" title="图片灯箱"></a>图片灯箱</h2><p>添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 <a href="https://github.com/fancyapps/fancybox">fancyBox</a> 提供。</p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-fancybox3 themes/next/<span class="built_in">source</span>/lib/fancybox</span><br></pre></td></tr></table></figure>

<p>在 <span id="inline-purple">主题配置文件</span> _config.yml 中设置 <code>fancybox: true</code>：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>刷新浏览器即可生效。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>文章中大量的优化方案都参照了 <a href="yearito.cn">yearito</a> 的优化精髓，在集成第三方插件或者自定义新功能的过程中尽量做到：</p>
<ul>
<li>可以在站点配置 / 主题配置文件中方便快捷的开启 / 关闭插件服务</li>
<li>可以在语言包 zh-CN.yml 中快速修改页面中的自定义文案，而不是在代码中将文字表述写死</li>
<li>尽量在自定义样式文件 custom.styl 和自定义布局文件 custom.swig 中添加代码，而非修改主题源码<br>新增文件统一放在 _custom 目录下</li>
<li>所有以上这些原则，尽管实现起来可能更复杂，需要更多的代码，但都是为了让站点更好维护，更灵活方便。</li>
</ul>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+NexT(v7.0+) 搭建博客：性能优化</title>
    <url>/2019/05/20/hexo-performance-optimization/</url>
    <content><![CDATA[<p>在访问很多博客的时候，页面加载和响应速度往往都要上十秒，严重影响用户的体验。<br>本文将探究如何利用常用的方案来进行性能优化，主要包括:</p>
<ul>
<li>CDN加速</li>
<li>Nginx压缩、缓存</li>
<li>图床</li>
</ul>
<a id="more"></a>

<p>首先，可利用 <a href="https://developers.google.com/speed/pagespeed/insights/">Google PageSpeed Insights</a> 帮助分析网页加载速度，根据报告结果和优化建议进行针对性的优化。<br>常见的网站提速方案有：cdn加速，压缩源文件，nginx gzip压缩，减少网站一些不必要的引入，图片大小等。</p>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>在阅读下文之前，如果你还不知道 CDN 是什么，请先移步<a href="https://baike.baidu.com/item/CDN">百度百科：CDN词条</a> 进行一些了解。<br>在所有静态资源中，对加载速度影响较大且存在大幅优化空间的主要还是「JavaScript 第三方库」脚本，设定成合适的 CDN 地址，此特性可以加速静态资源的加载。<br>对于我 Hexo 博客来说，NexT 主题已经做好了配置，只需添加 CDN 加载源，将其改为从公共 CDN 加载即可。<br>在 <span id="inline-purple">主题配置文件</span> _config.yml 中修改<code>vendors</code>：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment"># jquery: //cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js</span></span><br><span class="line"><span class="comment"># jquery: //cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">//cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span>  </span><br></pre></td></tr></table></figure>

<p>比较常用的开源项目 CDN 服务商主要有 unpkg、bootcdn、 cdnjs、jsdelivr 和 cloudflare，本站主要使用 jsdelivr 提供的 CDN 加速服务。</p>
<h3 id="上云"><a href="#上云" class="headerlink" title="上云"></a>上云</h3><div class="note info"><p>国内的 CDN服务 要求网站必须备案，但是有些服务商是不支持备案的，于是云主机就是我们需要的了，可以一键备案直接上云。</p>
</div>

<p>研究了一下各个云服务的价格，1核1G的云主机一年大概都是500+，不过阿里云针对新用户都有很给力的活动：</p>
<table>
<thead>
<tr>
<th align="center">产品名称</th>
<th align="center">性能</th>
<th align="center">配置</th>
<th align="center">时长</th>
<th align="center">原价</th>
<th>现价</th>
<th>折扣</th>
</tr>
</thead>
<tbody><tr>
<td align="center">阿里云t5</td>
<td align="center"><strong>+20%突发性能</strong></td>
<td align="center">1核2G内存1M带宽</td>
<td align="center">一年</td>
<td align="center">992</td>
<td>89</td>
<td>9%</td>
</tr>
<tr>
<td align="center">阿里云t6</td>
<td align="center"><strong>+10%突发性能</strong></td>
<td align="center">2核1G内存1M带宽</td>
<td align="center">一年</td>
<td align="center">745</td>
<td>99</td>
<td>13%</td>
</tr>
<tr>
<td align="center">阿里云t5</td>
<td align="center"><strong>+20%突发性能</strong></td>
<td align="center">1核2G内存1M带宽</td>
<td align="center">三年</td>
<td align="center">2977</td>
<td>229</td>
<td>7%</td>
</tr>
<tr>
<td align="center">阿里云n4</td>
<td align="center">100%性能</td>
<td align="center">2核4G内存3M带宽</td>
<td align="center">一年</td>
<td align="center">3389</td>
<td>399</td>
<td>12%</td>
</tr>
<tr>
<td align="center">阿里云n4</td>
<td align="center">100%性能</td>
<td align="center">2核4G内存3M带宽</td>
<td align="center">两年</td>
<td align="center">6766</td>
<td>469</td>
<td>7%</td>
</tr>
<tr>
<td align="center">阿里云n4</td>
<td align="center">100%性能</td>
<td align="center">2核4G内存3M带宽</td>
<td align="center">三年</td>
<td align="center">10148</td>
<td>799</td>
<td>8%</td>
</tr>
<tr>
<td align="center">阿里云t5</td>
<td align="center"><strong>+20%突发性能</strong></td>
<td align="center">2核4G内存1M带宽</td>
<td align="center">三年</td>
<td align="center">7236</td>
<td>639</td>
<td>9%</td>
</tr>
<tr>
<td align="center">阿里云t5</td>
<td align="center"><strong>+20%突发性能</strong></td>
<td align="center">1核1G内存1M带宽（香港）</td>
<td align="center">一年</td>
<td align="center">972</td>
<td>119</td>
<td>12%</td>
</tr>
</tbody></table>
<p>看起来的话 <a href="https://www.aliyun.com/minisite/goods?userCode=wdpvvh4p&share_source=copy_link">阿里云1核2G的云主机</a> 三年只要229 ，简直太白菜价了。建议一次性买三年的，新用户优惠可是只有这一次。</p>
<p>Tips：香港主机的优势在于无需备案，且可以访问墙外的网络，要注意正规建站用途。</p>
<h3 id="Nginx压缩、缓存"><a href="#Nginx压缩、缓存" class="headerlink" title="Nginx压缩、缓存"></a>Nginx压缩、缓存</h3><div class="note info"><p>Nginx 是一个高性能的 Web 服务器，可以适当地分配流量（负载均衡器）、流媒体、动态调整图像大小、缓存内容等等，合理配置可以有效提高网站的响应速度。</p>
</div>

<h4 id="开启gzip"><a href="#开启gzip" class="headerlink" title="开启gzip"></a>开启gzip</h4><p>gzip压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。<br>修改nginx.conf，在http模块中增加gzip配置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#开启gzip压缩;</span><br><span class="line">gzip  on;</span><br><span class="line"></span><br><span class="line">#设置允许压缩的页面最小字节数;</span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line">#设置压缩缓冲区大小，此处设置为4个16K内存作为压缩结果流缓存</span><br><span class="line">gzip_buffers 4 16k;</span><br><span class="line"></span><br><span class="line">#压缩版本</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line"></span><br><span class="line">#设置压缩比率，最小为1，处理速度快，传输速度慢；9为最大压缩比，处理速度慢，传输速度快;级别越高，压缩就越小</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"></span><br><span class="line">#制定压缩的类型</span><br><span class="line">gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript application/json image/svg+xml application/x-font-ttf font/opentype image/x-icon;</span><br><span class="line"></span><br><span class="line">#配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）</span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"></span><br><span class="line">#选择支持vary header；改选项可以让前端的缓存服务器缓存经过gzip压缩的页面; 这个可以不写</span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h4><p>修改nginx.conf，在server中配置缓存和失效时间：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">    access_log off;</span><br><span class="line">    expires 30d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">    access_log off;</span><br><span class="line">    expires 24h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* ^.+\.(html|htm)$ &#123;</span><br><span class="line">     expires 1h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><div class="note info"><p>目前各大云服务商都提供了对象存储服务，如七牛云 QINIU、又拍云 USS、腾讯云 COS、阿里云 OSS 等。我们可以使用这些服务器来存储图片信息，并将其称为图床。</p>
</div>

<p>使用图床的好处：</p>
<ul>
<li>可以减轻服务器的存储压力；</li>
<li>减轻应为图片带来的额外的流量消耗；</li>
<li>图床一般都是具有cdn加速的，可以让你的网页变得更快。</li>
</ul>
<p>我主要是看中了cdn加速这点，这个对网站的性能提升太重要了。</p>
<p>常用的云存储服务费用对比：</p>
<table>
<thead>
<tr>
<th align="center">限定符</th>
<th align="center">免费存储空间</th>
<th align="center">免费下载流量</th>
<th align="center">免费请求</th>
<th align="center">免费时间</th>
<th align="center">HTTPS</th>
<th align="center">CDN</th>
</tr>
</thead>
<tbody><tr>
<td align="center">微博图床</td>
<td align="center">无限</td>
<td align="center">无限</td>
<td align="center">无限</td>
<td align="center">永久</td>
<td align="center"><i class="fa fa-close"/></td>
<td align="center"><i class="fa fa-check"/></td>
</tr>
<tr>
<td align="center">七牛云</td>
<td align="center">10G</td>
<td align="center">10G</td>
<td align="center">PUT: 10万次 <br/>GET: 100万次</td>
<td align="center">永久</td>
<td align="center"><i class="fa fa-check"/></td>
<td align="center"><i class="fa fa-check"/></td>
</tr>
<tr>
<td align="center">青云QingStor</td>
<td align="center">30G</td>
<td align="center">11G</td>
<td align="center">PUT: 10万次 <br/>GET: 100万次</td>
<td align="center">12个月</td>
<td align="center"><i class="fa fa-check"/></td>
<td align="center"><i class="fa fa-check"/></td>
</tr>
<tr>
<td align="center">又拍云USS</td>
<td align="center">10G</td>
<td align="center">15G</td>
<td align="center">无限</td>
<td align="center">12个月</td>
<td align="center"><i class="fa fa-check"/></td>
<td align="center"><i class="fa fa-check"/></td>
</tr>
<tr>
<td align="center">阿里云OSS</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center"><i class="fa fa-check"/></td>
<td align="center"><i class="fa fa-check"/></td>
</tr>
<tr>
<td align="center">腾讯云COS</td>
<td align="center">50G</td>
<td align="center">无</td>
<td align="center">无</td>
<td align="center">6个月</td>
<td align="center"><i class="fa fa-check"/></td>
<td align="center"><i class="fa fa-check"/></td>
</tr>
<tr>
<td align="center">Github</td>
<td align="center">100G</td>
<td align="center">无限</td>
<td align="center">无限</td>
<td align="center">永久</td>
<td align="center"><i class="fa fa-check"/></td>
<td align="center"><i class="fa fa-close"/></td>
</tr>
</tbody></table>
<ul>
<li>七牛云是专业云服务商，提供比较完备的服务，且免费额度足够个人博客使用。</li>
<li>七牛云的定位就是 CDN，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源，且CDN加速也不会产生太多的费用。</li>
<li>微博图床是匿名图床，如果有一天禁止外链访问的话，图片将全部丢失。想着辛辛苦苦制作的图片有丢失的风险，马上就放弃了。【2019年4月微博图床开启了防盗链，对图片 CDN 添加了引用来源<code>Referer</code>检测，对于非微博站内引用的请求统统拒绝访问】</li>
<li>GitHub 看起来是个不错的选择，但是网络访问速度不是很理想，随即放弃了。</li>
<li>阿里云OSS也是个不错的选择，有个9元包年40G存储空间，无限流量。</li>
</ul>
<h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><p>综合比较之后：我选择了七牛云的对象存储作为图床(高效、快速、有保障)。<br><img src="https://image.chingow.cn/images/20190610215145_FVk4s5_Screenshot.jpeg" alt="七牛云对象存储" title="七牛云对象存储"></p>
<h4 id="注册账号并实名认证"><a href="#注册账号并实名认证" class="headerlink" title="注册账号并实名认证"></a>注册账号并实名认证</h4><p>注册 <a href="https://portal.qiniu.com/signup?code=1hjtnnywndb9u">七牛开发者平台</a> 账号，并前往 <strong>个人中心</strong>  -&gt;  <strong>个人信息</strong> 实名认证。</p>
<h4 id="新建存储空间"><a href="#新建存储空间" class="headerlink" title="新建存储空间"></a>新建存储空间</h4><ul>
<li><p>进入控制台，打开 <strong>对象存储</strong>  -&gt; <strong>新建存储空间</strong>， 即可创建新的Bucket。<br>【存储区域】：建议选择一个离你较近的CDN<br>【访问控制】：这里必须选择“公开空间”，因为设置为私有空间，图片的外链是无法访问的。</p>
</li>
<li><p>进入新创建的存储空间，在 <strong>空间概览</strong>里点击 <strong>自定义域名</strong> 为空间绑定融合cdn加速域名。详细的参数解释可以参考 <a href="https://developer.qiniu.com/fusion/manual/4939/the-domain-name-to-access">官方域名接入文档</a> 。<br><img src="https://image.chingow.cn/images/20190610224405_2DZajr_Screenshot.jpeg" alt="自定义域名" title="自定义域名"><br>【域名类型】：如果没有特殊需求，选择普通域名即可。<br>【加速域名】：建议填写的是，您未在使用的二级或三级域名等，请勿轻易绑定www域名避免影响您的源站服务。<br>【源站配置】：当您为存储空间绑定自定义域名的时候，源站配置默认为七牛云存储空间即可。</p>
</li>
<li><p>配置CNAME<br>创建加速域名成功后，七牛云会提供CNAME地址，需要在域名服务提供商处将加速域名指向分配的CNAME地址，配置生效后，即可享受CDN加速服务。根据控制台的引导文档并参考 <a href="https://developer.qiniu.com/fusion/kb/1322/how-to-configure-cname-domain-name">官方配置域名CNAME文档</a> 。</p>
</li>
</ul>
<h4 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h4><p>进入新创建的存储空间，在 <strong>内容管理</strong> 中上传、下载、访问、修改资源，这样就可以使用资源的外链了。<br>上传图片文件以后，复制外链连接就可以利用这个链接访问这个图片了。<br><img src="https://image.chingow.cn/images/20190610224604_5uT2oa_Screenshot.jpeg" alt="使用资源外链" title="使用资源外链"></p>
<h3 id="上传工具"><a href="#上传工具" class="headerlink" title="上传工具"></a>上传工具</h3><p>如果每次都需要在web端点击上传图片，然后复制外链的操作就比较麻烦了，使用工具可以让我们更加方便地上传资源。<br>Mac平台上有多款图床工具，找到了几个优秀的工具，做了个对比：</p>
<style>
table th:nth-of-type(2){
width: 15%;;
}
table th:nth-of-type(5){
width: 15%;
}

</style>

<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">收费标准</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">推荐指数</th>
<th align="center">下载链接</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ipic</td>
<td align="center">60元/年</td>
<td align="center">剪贴板、压缩、拖拽上传，功能强大，支持多种云服务</td>
<td align="center">免费版只支持微博图床</td>
<td align="center"><i class="fa fa-star"/></td>
<td align="center"><a href="https://itunes.apple.com/cn/app/ipic-markdown-%E5%9B%BE%E5%BA%8A-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B7%A5%E5%85%B7/id1101244278?mt=12">Mac App Store</a></td>
</tr>
<tr>
<td align="center">PicGo</td>
<td align="center">免费</td>
<td align="center">链接上传，支持相册管理</td>
<td align="center">不支持清除上传历史</td>
<td align="center"><i class="fa fa-star"/> <i class="fa fa-star"/> <i class="fa fa-star-half-o"/></td>
<td align="center"><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo.dmg</a></td>
</tr>
<tr>
<td align="center">PicUploader</td>
<td align="center">免费</td>
<td align="center">压缩上传，多文件、文件夹同时上传</td>
<td align="center">不支持顶部菜单</td>
<td align="center"><i class="fa fa-star"/> <i class="fa fa-star"/></td>
<td align="center"><a href="https://github.com/xiebruce/PicUploader/releases">PicUploader.zip</a></td>
</tr>
<tr>
<td align="center">云存储管理</td>
<td align="center">免费</td>
<td align="center">链接上传，可视化相册管理</td>
<td align="center">上传速度太慢，会卡死（不能忍受(°⌓°;）</td>
<td align="center"><i class="fa fa-star"/> <i class="fa fa-star"/> <i class="fa fa-star"/></td>
<td align="center"><a href="https://github.com/willnewii/qiniuClient">云存储管理客户端</a></td>
</tr>
<tr>
<td align="center">cuImage</td>
<td align="center">免费</td>
<td align="center">剪贴板、压缩、拖拽上传，与ipic类似</td>
<td align="center">仅支持七牛云<br/>不支持链接上传</td>
<td align="center"><i class="fa fa-star"/> <i class="fa fa-star"/> <i class="fa fa-star"/> <i class="fa fa-star"/>  <i class="fa fa-star-half-o"/></td>
<td align="center"><a href="https://github.com/hulizhen/cuImage/releases">Mac App Store</a></td>
</tr>
</tbody></table>
<p>如果是使用七牛云图床我推荐cuImage，它的功能完善，使用剪贴板、拖曳、甚至是快捷键都可以直接将图片上传到云存储，并直接生成Markdown外链，操作十分简便。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>阿里云</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+NexT(v7.0+) 搭建博客：基础安装</title>
    <url>/2019/04/29/hexo-satrted/</url>
    <content><![CDATA[<p><img src="https://image.chingow.cn/background/006tNc79gy1g37jxk0kq5j327a0ki0th.jpg" alt="Hexo" title="Hexo"></p>
<p>关于如何搭建Hexo博客的文章已经有很多人写过了，并且有很多人已经写的很深刻很到位了，为什么还要重复写一遍呢？直到我看到了这位同学的博客 <a href="yearito.cn">yearito</a> <strong>（ ps：本站的建站优化大都参考自这里）</strong> ，我有了说服自己的理由：</p>
<ul>
<li>你可以参考别人的技术方案，集众所长，亲自实践，然后融入自己的思考写出一篇新文章</li>
<li>即使并没有做出创新性的贡献，自己重新归纳一遍也有助于梳理流程，深化理解</li>
</ul>
<a id="more"></a>
<p id="div-border-left-red">现在百度 Google 很方便，动动手指就可以搜索到想要的答案，但是太多人都是**『顺手拈来、过目就忘』**，下次遇到同样的问题再搜索一遍。
为什么会这样呢？不善于总结，不情愿动手思考，时而久之就会变成所谓的 “代码搬运工” ！<p>

<p>闲话不多说了，我们开始吧！</p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>在 <a href="https://nodejs.org/en/download/">官方下载网站</a> 下载源代码，选择最后一项 <code>Source Code</code><br>解压到某一目录, 然后进入此目录,依次执行以下 3 条命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>安装完后查看<code>node.js</code>版本，检验是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure>

<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在命令行中通过 <strong>npm</strong> 来安装 hexo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h3 id="本地启动hexo"><a href="#本地启动hexo" class="headerlink" title="本地启动hexo"></a>本地启动hexo</h3><p>创建一个博客目录（例如 <code>/my-blog</code>），在此目录下，执行初始化命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p my-blog</span><br><span class="line">$ <span class="built_in">cd</span> my-blog</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>执行完毕后，将会生成以下文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- node_modules       &#x2F;&#x2F;依赖安装目录</span><br><span class="line">|-- scaffolds          &#x2F;&#x2F;模板文件夹，新建的文章将会从此目录下的文件中继承格式</span><br><span class="line">|-- source             &#x2F;&#x2F;资源文件夹，用于放置图片、数据、文章等资源</span><br><span class="line">|   |-- _posts          &#x2F;&#x2F;文章目录</span><br><span class="line">|-- themes             &#x2F;&#x2F;主题文件夹</span><br><span class="line">|   |-- landscape      &#x2F;&#x2F;默认主题</span><br><span class="line">|-- .gitignore         &#x2F;&#x2F;指定不纳入git版本控制的文件</span><br><span class="line">|-- _config.yml        &#x2F;&#x2F;站点配置文件</span><br><span class="line">|-- db.json</span><br><span class="line">|-- package.json</span><br><span class="line">&#96;-- package-lock.json</span><br></pre></td></tr></table></figure>

<p>在根目录下执行如下命令启动<strong>hexo</strong>内置的web容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate     <span class="comment"># 生成静态文件</span></span><br><span class="line">$ hexo server       <span class="comment"># 在本地服务器运行</span></span><br></pre></td></tr></table></figure>

<p>在浏览器输入IP地址 <a href="http://localhost:4000/">http://localhost:4000</a>  就可以看到我们熟悉的** Hello Word **了。</p>
<p><img src="https://image.chingow.cn/images/d7cced3b-950e-6d7b-6edc-dc3058646ddb.png" alt="Hello Word" title="Hello Word"></p>
<h3 id="常用命令简化和组合"><a href="#常用命令简化和组合" class="headerlink" title="常用命令简化和组合"></a>常用命令简化和组合</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g    <span class="comment"># 等同于hexo generate</span></span><br><span class="line">$ hexo s    <span class="comment"># 等同于hexo server</span></span><br><span class="line">$ hexo p    <span class="comment"># 等同于hexo port </span></span><br><span class="line">$ hexo d    <span class="comment"># 等同于hexo deploy </span></span><br></pre></td></tr></table></figure>

<p>当本地不想使用默认的4000端口时（比如在服务器上，默认使用80端口），可以使用 port 命令更改启动端口<br>另外，<strong>hexo</strong>支持命令合并，比方说 生成静态文件 → 本地启动80端口，我们可以执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s -g -p 80</span><br></pre></td></tr></table></figure>

<h2 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h2><p>hexo 安装主题的方式非常简单, 只需几个简单的命令即可。<br>将NexT主题文件拷贝至<strong>themes</strong>目录下，然后修改 <span id="inline-blue">站点配置文件</span> _config.yml 中的 <code>theme</code>字段为<code>next</code>即可。</p>
<p>cd 到博客的根目录下执行以下命令下载主题文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> my-blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next.git themes/next</span><br><span class="line"></span><br><span class="line">$ vim _config.yml</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>清除 <strong>hexo</strong>缓存，重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo s -g</span><br></pre></td></tr></table></figure>

<p>大部分的设定都能在 <a href="http://theme-next.iissnan.com/getting-started.html">NexT官方文档</a> 里找到, 如主题设定、侧栏、头像、友情链接、打赏等等，在此就不多讲了，照着文档走就行了。</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-01-快速认识线程</title>
    <url>/2021/02/02/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-01-%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="快速认识线程"><a href="#快速认识线程" class="headerlink" title="快速认识线程"></a>快速认识线程</h1><p>其实蛮早时候就看过这本书，当时对其中的知识也是一知半解，当时的工作并发量也不是很大，对并发的问题也没有太多的考虑。后面慢慢的认识到了高并发的重要性，加上看完了jvm的原理，带着jvm的一些知识点，重读一遍这本书，相信会解开之前的一些疑问。总之，书读百遍，其意自现。每一遍都会得到不一样的收获。<br>在此记录一下</p>
<h2 id="1-1-线程的介绍"><a href="#1-1-线程的介绍" class="headerlink" title="1.1 线程的介绍"></a>1.1 线程的介绍</h2><p>线程是程序执行的一个路径，每一个线程都有自己的局部变量表、程序计数器以及各自的生命周期</p>
<h2 id="1-2-线程的生命周期"><a href="#1-2-线程的生命周期" class="headerlink" title="1.2 线程的生命周期"></a>1.2 线程的生命周期</h2><p><img src="/uploads/java-concurrency-master/thread-lifecycle.png"></p>
<p>线程可以大致分为5个阶段</p>
<ul>
<li>NEW</li>
<li>RUNNABLE</li>
<li>RUNNING</li>
<li>BLOCKED</li>
<li>TERMINATED</li>
</ul>
<h3 id="1-2-1-线程的new状态"><a href="#1-2-1-线程的new状态" class="headerlink" title="1.2.1 线程的new状态"></a>1.2.1 线程的new状态</h3><p>当我们用关键字new 创建一个Thread 对象时，此时它并不处于执行状态，因为没有调用start方法启动该线程，那么该线程的状态为new状态。</p>
<p>准确的来说，它只是Thread对象的状态，因为再没有start之前，该线程根本不存在。</p>
<p>new状态通过start方法进入Runnable状态</p>
<h3 id="1-2-2-线程的RUNNABLE-状态"><a href="#1-2-2-线程的RUNNABLE-状态" class="headerlink" title="1.2.2 线程的RUNNABLE 状态"></a>1.2.2 线程的RUNNABLE 状态</h3><ul>
<li>线程对象必须调用start方法 进入RUNNABLE状态，那么此时 才是真正的再JVM进程中创建了一个线程。</li>
<li>并不是线程一启动就直接得到执行的，线程的运行与否和进程一样都要听令于CPU的调用。我们把这个中间状态 称为 <strong>可执行状态（RUNNABLE）</strong></li>
<li>也就是说 它具备执行的资格，但是并没有真正的执行起来，而是在等待CPU的调度</li>
<li>由于存在Running状态，所以不会直接进入 BLOCKED 状态和 TERMINATED状态，<strong>即使是在线程的执行逻辑中调用wait、sleep或者其他block的 IO操作等，也必须要先获得 CPU的调度执行权才可以</strong>，严格来讲，RUNNABLE的线程只能意外终止或者进入RUNNING状态</li>
</ul>
<h3 id="1-2-3-线程的RUNNING状态"><a href="#1-2-3-线程的RUNNING状态" class="headerlink" title="1.2.3 线程的RUNNING状态"></a>1.2.3 线程的RUNNING状态</h3><p>cpu通过轮询或者其他方式从任务可执行队列中选中了线程，那么此时它才能真正地执行自己的逻辑代码，</p>
<p>running状态的线程，可以发生以下的状态转换：</p>
<ul>
<li>直接进入TERMINATED 状态，比如调用jdk已经不推荐使用的stop方法或者判断某个逻辑标识</li>
<li>进入BLOCKED状态，比如 调用了sleep 或者wait方法而加入了waitSet中</li>
<li>进行某个阻塞的IO操作，比如因网络数据的读写而进入了BLOCKED状态</li>
<li>获取某个锁资源，从而加入到该锁的阻塞队列中，从而进入了BOLCKED状态</li>
<li>由于CPU的调度器轮询使得该线程放弃执行，进入RUNNABLE状态</li>
<li>线程主动调用yield方法，放弃CPU执行权，进入RUNNABLE状态</li>
</ul>
<h3 id="1-2-4-线程的BLOCKED状态"><a href="#1-2-4-线程的BLOCKED状态" class="headerlink" title="1.2.4 线程的BLOCKED状态"></a>1.2.4 线程的BLOCKED状态</h3><p>线程在BLOCKED状态中可以切换至如下几个状态：</p>
<ul>
<li>直接进入TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者意外死亡（jvm  Crash）</li>
<li>线程阻塞的操作结束，比如读取了想要的数据字节进入到RUNNABLE状态</li>
<li>线程完成了指定时间的休眠，进入到了RUNNABLE状态</li>
<li>wait中的线程被其他线程 notify /notify all 唤醒，进入runnable状态 </li>
<li>线程获取到了某个锁资源，进入到 RUNNABLE 状态</li>
<li>线程在阻塞过程中被打断，比如其他线程调用了interrupt方法，进入RUNABLE 状态</li>
</ul>
<h3 id="1-2-5-线程的TERMINATED状态"><a href="#1-2-5-线程的TERMINATED状态" class="headerlink" title="1.2.5 线程的TERMINATED状态"></a>1.2.5 线程的TERMINATED状态</h3><p>TERMINATED 是一个线程的最终状态，在该状态中线程将不会切换到其他任何状态，线程进入 TERMINATED 状态，意味着该线程的整个生命周期都结束了，</p>
<p>下面这些情况将会使线程进入 TERMINATED状态。</p>
<ul>
<li>线程运行正常结束，结束生命周期</li>
<li>线程运行出错意外结束</li>
<li>JVM Crash，导致所有 的线程都结束</li>
</ul>
<h2 id="1-3-线程start方法剖析：模板设计模式在Thread中的应用"><a href="#1-3-线程start方法剖析：模板设计模式在Thread中的应用" class="headerlink" title="1.3 线程start方法剖析：模板设计模式在Thread中的应用"></a>1.3 线程start方法剖析：模板设计模式在Thread中的应用</h2><p>Thread start方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Causes this thread to begin execution; the Java Virtual Machine</span></span><br><span class="line"><span class="comment">    * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The result is that two threads are running concurrently: the</span></span><br><span class="line"><span class="comment">    * current thread (which returns from the call to the</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;run&lt;/code&gt; method).</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * It is never legal to start a thread more than once.</span></span><br><span class="line"><span class="comment">    * In particular, a thread may not be restarted once it has completed</span></span><br><span class="line"><span class="comment">    * execution.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class="line"><span class="comment">    *               started.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #run()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #stop()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">        * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>解释：  start方法的源码非常简单，其实最核心的部分是 start0这个本地方法，也就是JNI方法： </p>
<p> private native void start0(); </p>
<p>也就是说在start方法中 会调用本地方法 start0方法 </p>
<p>通过start方法的注释说明： Causes this thread to begin execution; the Java Virtual Machine   calls the <code>run</code> method of this thread.  </p>
<p><strong>在开始执行这个线程的时候，JVM将会调用调用该线程的run方法</strong>，换言之，**<em>run方法是被JNI方法start0（）调用的**</em>，。</p>
<p>总结如下几个知识要点：</p>
<ul>
<li>Thread被构造后的NEW状态，事实上threadStatus这个内部属性为0 </li>
<li>不能两次启动Thread，否则就会出现 IllegalThreadStatusException 异常</li>
<li>线程启动后将会被加入到一个ThreadGroup中，</li>
<li>一个线程生命周期结束，也就是到了TERMINATED状态，再次调用start方法是不允许的，也就是说 TERMINATED状态时没有办法回到 RUNNABLE/RUNNING 状态的。</li>
</ul>
<h3 id="1-3-2-模板设计模式在Thread中的应用"><a href="#1-3-2-模板设计模式在Thread中的应用" class="headerlink" title="1.3.2  模板设计模式在Thread中的应用"></a>1.3.2  模板设计模式在Thread中的应用</h3><p>通过上面分析我们知道，线程的真正执行逻辑时在 run方法中，通常 将run方法称为线程的执行单元，</p>
<p>Thread中run方法的代码如下：</p>
<p>（重写run方法，用start方法启动线程）</p>
<p>如果我们没有使用Runnable 接口对其改造，则可以认为Thread的run方法本身就是一个空的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">   * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">   * &lt;code&gt;Runnable&lt;/code&gt; object&#x27;s &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">   * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实 Thread的run 和 start 就是一个比较典型的模板设计模式，父类编写算法结构代码 ，子类实现逻辑细节  ，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;################&quot;</span>);</span><br><span class="line">        wrapPrint(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;################&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TemplateMethod t1 = <span class="keyword">new</span> TemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;*&quot;</span>+message+<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.print(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TemplateMethod t2 = <span class="keyword">new</span> TemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;+&quot;</span>+message+<span class="string">&quot;+&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t2.print(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>print  方法类似于Thread 的start 方法，而 wrapPrint 则类似于 run方法，这样做的好处是： </p>
<ul>
<li>程序结构由父类控制，并且是final 修饰的，不允许被重写 </li>
<li>子类只需要实现想要的逻辑任务即可 </li>
</ul>
<h2 id="Runnable-接口的引入以及策略模式在Thread中的使用"><a href="#Runnable-接口的引入以及策略模式在Thread中的使用" class="headerlink" title="Runnable 接口的引入以及策略模式在Thread中的使用"></a>Runnable 接口的引入以及策略模式在Thread中的使用</h2><h3 id="1-5-1-Runnable的职责"><a href="#1-5-1-Runnable的职责" class="headerlink" title="1.5.1 Runnable的职责"></a>1.5.1 Runnable的职责</h3><p>Runnable 接口只定义了一个无参数无返回值的run方法 ，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在很多软文以及一些书籍中，经常会提到：创建线程有两种方式：</p>
<ul>
<li>第一种是构建一个Thread</li>
<li>第二种是实现Runnable接口，</li>
</ul>
<p>这种说法是错误的，最起码是不严谨的，在JDK 种代表线程的只有 Thread这个类。线程的执行单元是 run方法，</p>
<ul>
<li>我们可以通过继承Thread，然后重写run方法实现自己的业务逻辑</li>
<li>也可以实现 Runnable 接口实现自己的业务逻辑，代码如下： </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;Runnable&lt;/code&gt; object&#x27;s &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">    * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 如果构造 Thread时 传递了Runnable，则会执行 runnable的run方法</span></span><br><span class="line">       <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//否则 需要重写 Thread类的run方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>准确的讲， 创建线程只有一种方式，那就是构造Thread类 ，而实现线程的执行单元有2种方式 ： 一种是重写Thread的run方法，另一种 是实现Runnable接口的run方法，并且将Runnable 实例用作构造Thread的参数 。</p>
<h3 id="1-5-2-策略模式在Thread-中的应用"><a href="#1-5-2-策略模式在Thread-中的应用" class="headerlink" title="1.5.2 策略模式在Thread 中的应用"></a>1.5.2 策略模式在Thread 中的应用</h3><p>无论是 Runnable的run方法，还是Thread类本身的run方法（事实上Thread类也是实现了Runnable接口） 都是想将线程的控制本身 和业务逻辑的运行分离开来，达到职责分明、功能单一的原则，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RowHandler</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">handle</span><span class="params">(ResultSet rs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RowHandler 接口只负责对从数据中查询出来的结果集 进行操作，至于最终返回成什么样的数据结构，那就需要自己去实现，类似于Runable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordQuery</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecordQuery</span><span class="params">(Connection connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 只负责将数据查询 出来 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(RowHandler&lt;T&gt; handler, String sql, Object... params)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PreparedStatement stmt = connection.prepareStatement(sql))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (Object param : params)</span><br><span class="line">            &#123;</span><br><span class="line">                stmt.setObject(index++, param);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ResultSet resultSet = stmt.executeQuery();</span><br><span class="line">            <span class="comment">// 调用 RowHandler进行数据封装</span></span><br><span class="line">            <span class="keyword">return</span> handler.handle(resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的好处是，可以用query方法应对任何数据库的查询，返回结果的不同指挥因为 传入的RowHandler 的不同而不同，同样 RecordQuery只负责数据的获取，而 RowHander则负责数据的加工，职责分明，每个类均功能单一 </p>
<ul>
<li>重写Thread类的run方法和实现Runnable 接口的run方法还有一个很重要的不同 ，那就是 <strong>Thread类的run方法是不能共享的</strong>，</li>
<li>也就是说 A线程不能把 B线程的run方法当作自己的执行单元，而使用Runnable接口则 很容易实现这一点，使用同一个RUnnable的实例构造不同的Thread实例。</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>线程的概念</li>
<li>如何创建一个线程，并且通过重写Thread的run方法和实现Runnable接口的run方法进而实现线程的执行单元</li>
<li>了解模板设计模式 以及 策略设计模式。</li>
<li>通过 Thread 以及 Runnable的结合，了解如何实现线程控制和业务执行解耦分离</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-02-Thread构造函数</title>
    <url>/2021/02/17/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-02-Thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Thread的构造函数详解"><a href="#Thread的构造函数详解" class="headerlink" title="Thread的构造函数详解"></a>Thread的构造函数详解</h1><p><img src="/uploads/java-concurrency-master/thread-construct.png"></p>
<h2 id="线程的命名"><a href="#线程的命名" class="headerlink" title="线程的命名"></a>线程的命名</h2><p>再构造线程的时候，推荐给线程起一个 有特殊意义的名字，这样有助于 排查问题和线程追踪。</p>
<ol>
<li><h3 id="线程的默认命名"><a href="#线程的默认命名" class="headerlink" title="线程的默认命名"></a>线程的默认命名</h3></li>
</ol>
<ul>
<li>Thread（）</li>
<li>Thread（Runnable target）</li>
<li>Thread ( ThreadGroup group , Runnable target )</li>
</ul>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new &#123;<span class="doctag">@code</span> Thread&#125; object. This constructor has the same</span></span><br><span class="line"><span class="comment"> * effect as &#123;<span class="doctag">@linkplain</span> #Thread(ThreadGroup,Runnable,String) Thread&#125;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> (null, target, gname)&#125;, where &#123;<span class="doctag">@code</span> gname&#125; is a newly generated</span></span><br><span class="line"><span class="comment"> * name. Automatically generated names are of the form</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> &quot;Thread-&quot;+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  target</span></span><br><span class="line"><span class="comment"> *         the object whose &#123;<span class="doctag">@code</span> run&#125; method is invoked when this thread</span></span><br><span class="line"><span class="comment"> *         is started. If &#123;<span class="doctag">@code</span> null&#125;, this classes &#123;<span class="doctag">@code</span> run&#125; method does</span></span><br><span class="line"><span class="comment"> *         nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For autonumbering anonymous threads. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有为线程显示的指定一个名字，那么线程将会<strong>以“Thread-” 作为前缀与 一个自增数字进行组合</strong>，这个自增数字（threadInitNumber）在整个JVM进程中将会不断自增。</p>
<ol start="2">
<li><h3 id="命名线程"><a href="#命名线程" class="headerlink" title="命名线程"></a>命名线程</h3></li>
</ol>
<ul>
<li>Thread(Runnable target,String name)</li>
<li>Thread(String name)</li>
<li>Thread(ThreadGroup group,Runnable target,String name)</li>
<li>Thread(ThreadGroup group,Runnable target,String name，long stackSize)</li>
<li>Thread(ThreadGroup group,String name)</li>
</ul>
<ol start="3">
<li><h3 id="修改线程的名字"><a href="#修改线程的名字" class="headerlink" title="修改线程的名字"></a>修改线程的名字</h3></li>
</ol>
<p>不论使用的是默认的函数命名规则，还是指定了一个特殊的名字，在线程启动之前还有一个记会可以对其进行修改，一旦线程启动，名字将不再被修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Changes the name of this thread to be equal to the argument</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;name&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called</span></span><br><span class="line"><span class="comment">    * with no arguments. This may result in throwing a</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;SecurityException&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      name   the new name for this thread.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span>  SecurityException  if the current thread cannot modify this</span></span><br><span class="line"><span class="comment">    *               thread.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #getName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #checkAccess()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">       <span class="comment">//线程不是NEW 状态，对其的修改将不会生效 </span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123; </span><br><span class="line">           setNativeName(name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程的父子关系"><a href="#线程的父子关系" class="headerlink" title="线程的父子关系"></a>线程的父子关系</h2><p>Thread的所有构造函数，最终都会去调用一个静态方法init （）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">	<span class="comment">///////////////////////////////// 获取当前线程作为父线程</span></span><br><span class="line">       Thread parent = currentThread();</span><br><span class="line">       SecurityManager security = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line">           <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">              what to do. */</span></span><br><span class="line">           <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">               g = security.getThreadGroup();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">              use the parent thread group. */</span></span><br><span class="line">           <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">               g = parent.getThreadGroup();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">          explicitly passed in. */</span></span><br><span class="line">       g.checkAccess();</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">               security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       g.addUnstarted();</span><br><span class="line">       <span class="keyword">this</span>.group = g;</span><br><span class="line">       <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">       <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">       <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">           <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">       <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">               acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">       setPriority(priority);</span><br><span class="line">       <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">               ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">       <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">       <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">       <span class="comment">/* Set thread ID */</span></span><br><span class="line">       tid = nextThreadID();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Thread parent = currentThread(); 获取当前线程作为创建的父线程 。</p>
</li>
<li><p>线程的最初的状态是 NEW ，没有执行start方法之前，只能算一个Thread实例，并不意味着一个新的线程被创建，因此 parent 代表的将会是创建它的那个线程</p>
</li>
<li><p>一个线程的创建肯定是由另一个线程完成的</p>
</li>
<li><p>被创建线程的父线程 是创建它的线程。</p>
</li>
<li><p>main函数 所在的线程是由 JVM创建的，也就是main线程。</p>
</li>
</ul>
<h2 id="Thread-与-ThreadGroup"><a href="#Thread-与-ThreadGroup" class="headerlink" title="Thread 与 ThreadGroup"></a>Thread 与 ThreadGroup</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init 方法 片段</span></span><br><span class="line"><span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g.addUnstarted();</span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在构造Thread的时候没有显示指定一个ThreadGroup，那么子线程将会被加入到父线程所在的线程组。</li>
<li>main线程所在的 ThreadGroup 称为 main</li>
</ul>
<h2 id="Thread-与-Runnable"><a href="#Thread-与-Runnable" class="headerlink" title="Thread 与 Runnable"></a>Thread 与 Runnable</h2><p>Thread 负责线程本身相关的职责和控制，而 Runnable 则负责逻辑执行单元的部分</p>
<h2 id="Thread与JVM虚拟机栈"><a href="#Thread与JVM虚拟机栈" class="headerlink" title="Thread与JVM虚拟机栈"></a>Thread与JVM虚拟机栈</h2> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * The requested stack size for this thread, or 0 if the creator did</span></span><br><span class="line"><span class="comment">   * not specify a stack size.  It is up to the VM to do whatever it</span></span><br><span class="line"><span class="comment">   * likes with this number; some VMs will ignore it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> stackSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initializes a Thread.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> g the Thread group</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target the object whose run() method gets called</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name the name of the new Thread</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stackSize the desired stack size for the new thread, or</span></span><br><span class="line"><span class="comment">   *        zero to indicate that this parameter is to be ignored.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class="line"><span class="comment">   *            AccessController.getContext() if null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">         ...</span><br><span class="line">         		...</span><br><span class="line">      <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">      <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Set thread ID */</span></span><br><span class="line">      tid = nextThreadID();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>stackSize=0时，代表忽略该参数 </p>
</li>
<li><p>一般情况下，创建线程的时候不会手动指定栈内存的地址空间字节数组，同一通过xss 参数进行设置即可</p>
</li>
<li><p>stacksize越大，则代表着 正在线程内方法调用递归的深度越深</p>
</li>
<li><p>stacksize越小，代表者创建的线程数量越多。</p>
</li>
<li><p>栈内存划分的大小，将直接决定一个JVM进程中可以创建多少个线程（栈内存越大，可创建的线程数量越少，反比）</p>
</li>
<li><p>进程的内存大小为：  堆内存+ 线程数量*栈内存</p>
</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>问题： JVM程序在正常情况下什么时候退出</p>
<p>答案： The java virtual machine exits when the only threads running are all daemon threads</p>
<p>在正常情况下，若JVM中没有一个非守护线程，则JVM的进程会退出。  </p>
<p>异常情况就是使用System.exit()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Marks this thread as either a &#123;<span class="doctag">@linkplain</span> #isDaemon daemon&#125; thread</span></span><br><span class="line"><span class="comment">   * or a user thread. The Java Virtual Machine exits when the only</span></span><br><span class="line"><span class="comment">   * threads running are all daemon threads.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; This method must be invoked before the thread is started.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  on</span></span><br><span class="line"><span class="comment">   *         if &#123;<span class="doctag">@code</span> true&#125;, marks this thread as a daemon thread</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  IllegalThreadStateException</span></span><br><span class="line"><span class="comment">   *          if this thread is &#123;<span class="doctag">@linkplain</span> #isAlive alive&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">   *          if &#123;<span class="doctag">@link</span> #checkAccess&#125; determines that the current</span></span><br><span class="line"><span class="comment">   *          thread cannot modify this thread</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">      checkAccess();</span><br><span class="line">      <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">      &#125;</span><br><span class="line">      daemon = on;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Whether or not the thread is a daemon thread. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span>     daemon = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>setDaemon 方法只在线程启动之前生效，</li>
<li>如果线程已经死亡，那么再设置setDaemon则会抛非法线程状态异常</li>
<li>守护线程经常用作与执行一些后台任务，因此也叫 后台线程 </li>
<li>当希望关闭某些线程的时候或者退出JVM进程的时候，一些线程能自动关闭， 可以使用守护线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// main 线程开始</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2_000L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished lifecycle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不设置 thread.setDaemon(true);，则 JVM 一直无法关闭</span></span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>详细了解Thread的构造函数，挖掘里面的各类细节，如 threadStatus =0代表 new状态，构造函数调用init函数，尤其是 stacksize  对Thread的影响</li>
<li>了解了线程的父子关系， 默认情况下子线程从父线程那里 继承了守护线程、优先级、ThreadGroup等特性</li>
<li>守护线程的特性以及使用场景</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>Thread构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-04-线程安全与数据同步</title>
    <url>/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<ul>
<li>从字节码指令维度掌握 synchronized 关键字的原理,以及互斥同步的 流程</li>
<li>还有一点很重要的是,通过画时序图 分析数据不一致的场景 和原因</li>
</ul>
<h1 id="4-1数据同步-Todo"><a href="#4-1数据同步-Todo" class="headerlink" title="4.1数据同步(Todo)"></a>4.1数据同步(Todo)</h1><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源:"></a>共享资源:</h3><p>多个线程同时对同一份资源进行访问(读写操作),被多个线程访问的资源,<strong>就称为共享资源</strong></p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>如何保证多个线程访问到的数据是一致的,则被称为<strong>数据同步或者资源同步</strong></p>
<h3 id="4-1-1-数据不一致问题的引入"><a href="#4-1-1-数据不一致问题的引入" class="headerlink" title="4.1.1 数据不一致问题的引入"></a>4.1.1 数据不一致问题的引入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindownRunnableError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;的号码是：&quot;</span> + (index++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TicketWindownRunnableError task = <span class="keyword">new</span> TicketWindownRunnableError();</span><br><span class="line">        Thread 一号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;一号窗口&quot;</span>);</span><br><span class="line">        Thread 二号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;二号窗口&quot;</span>);</span><br><span class="line">        Thread 三号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;三号窗口&quot;</span>);</span><br><span class="line">        Thread 四号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;四号窗口&quot;</span>);</span><br><span class="line">        一号窗口.start();</span><br><span class="line">        二号窗口.start();</span><br><span class="line">        三号窗口.start();</span><br><span class="line">        四号窗口.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h4><p>多次运行上面程序，会大致出现3类问题，具体如下：</p>
<ul>
<li>某个号码被略过，没有出现</li>
<li>某个号码被多次显示</li>
<li>号码超过了最大值500</li>
</ul>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;的号码是：&quot;</span> + (index++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-号码被掠过"><a href="#1-号码被掠过" class="headerlink" title="1. 号码被掠过"></a>1. 号码被掠过</h5><p>线程的执行是由CPU时间片轮询调度的，假设此时线程1.线程2 都执行到了index =65 的位置，其中线程2 将index 修改为66后未输出前，cpu调度将执行权力交给了线程1，线程1 将其累加到了 67， 那么66就被忽略了</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=65
Thread1 ->> Thread1 :thread 停顿
Thread2 ->> Thread2 : index+1 =65+1
Thread2 ->> Thread2 : index=66
Thread2 ->> Thread2 : thread停顿,问题点，此处忽略了print66，
Thread1 ->> Thread1 :index+1=66+1
Thread1 ->> Thread1 :index=67
Thread1 ->> Thread1 :print 67
Thread1 ->> Thread1 : index+1=67+1
Thread1 ->> Thread1 :index=68
Thread1 ->> Thread1 : print 68</pre>



<h5 id="2-号码重复出现"><a href="#2-号码重复出现" class="headerlink" title="2. 号码重复出现"></a>2. 号码重复出现</h5><p>线程1 执行index+1，然后cpu 执行权落入线程2手里，由于线程1 并没有给index 赋值301， 所以线程2 执行index+1的 结果也是 301，</p>
<p>所以出现了 重复号码的情况</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=300
Thread1 ->> Thread1 :index +1=300+1
Thread1 ->> Thread1 : 线程停顿
Thread2 ->> Thread2 : index+1 =300+1
Thread2 ->> Thread2 : index=301
Thread1 ->> Thread1 : index=301
Thread1 ->> Thread1 : print 301
Thread2 ->> Thread2 : 问题点-print 301</pre>

<h5 id="3-号码超过了最大值"><a href="#3-号码超过了最大值" class="headerlink" title="3. 号码超过了最大值"></a>3. 号码超过了最大值</h5><p>当 index=499 的时候，线程1 和线程2 都看到条件满足。线程2短暂停顿，线程1 将index增加到了500，线程2恢复运行后，又将 500+1 ，此时就出现了超过MAX 的情况。</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=499
Thread1 ->> Thread1 :进入while 循环条件满足
Thread2 ->> Thread2 :进入while 循环条件满足
Thread1 ->> Thread1 : index+1 =499+1
Thread2 ->> Thread2 : 线程停顿
Thread1 ->> Thread1 : index=500
Thread1 ->> Thread1 : print 500
Thread2 ->> Thread2 : index+1=500+1
Thread2 ->> Thread2 : index =501
Thread2 ->> Thread2 : 问题点-print 501</pre>

<h1 id="4-2-初始synchronized关键字"><a href="#4-2-初始synchronized关键字" class="headerlink" title="4.2 初始synchronized关键字"></a>4.2 初始synchronized关键字</h1><h2 id="4-2-1-什么是synchronized"><a href="#4-2-1-什么是synchronized" class="headerlink" title="4.2.1 什么是synchronized"></a>4.2.1 什么是synchronized</h2><p>JDK官网对synchronized关键字的权威解释：</p>
<p>Synchronized keyword enable a simple strategy for preventing thread interference and memory consistency errors:  if an object is visible to more than one thread,all reads or writes to that object’s  variables are done through synchronized methods.</p>
<p>Synchronized关键字启用了一种简单的策略来防止线程干扰和内存一致性错误:如果一个对象对多个线程可见，那么对该对象变量的所有读或写操作都通过Synchronized同步的方法完成。 </p>
<p>同步互斥： 互斥是方式，同步是结果</p>
<p>具体表现为：</p>
<ul>
<li>synchronized 关键字提供了一种锁机制，能够确保共享变量的互斥访问，从而防止数据不一致问题的出现</li>
<li>synchronized 关键字包括 monitor enter 和 monitor exit 两个JVM 指令，它能够保证在任何时候任何线程执行到 monitor enter成功之前都必须从主内存获取数据，而不是从缓存中， 在monitor exit运行成功之后，共享变量被更新后的值 必须刷入回之内存 （简单来说，就是 执行 monitor enter之前，从主内存中获取共享变量的值，在执行 monitor exit之后，将更新后的共享变量的值 同步回主内存，解决缓存一致性的问题）</li>
<li>synchronized 的指令严格遵守 java 的先行发生原则（happens-before），一个monitor exit 指令之前 一定由一个 monitor enter 指令，成对出现 。</li>
</ul>
<h2 id="4-2-2-synchronized-关键字的用法"><a href="#4-2-2-synchronized-关键字的用法" class="headerlink" title="4.2.2 synchronized 关键字的用法"></a>4.2.2 synchronized 关键字的用法</h2><p>synchronized 可以用于对 方法块 或者方法进行修饰， 不能够用于对class 或者变量进行修饰</p>
<h3 id="1-同步方法"><a href="#1-同步方法" class="headerlink" title="1. 同步方法"></a>1. 同步方法</h3><p>同步方法的语法  ： [default | public | private | protected] <strong>synchronized</strong> [static ] type methods().</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticSync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2. 同步代码块"></a>2. 同步代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object MUTEX=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(MUTEX)&#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-深入理解synchronized关键字"><a href="#4-3-深入理解synchronized关键字" class="headerlink" title="4.3 深入理解synchronized关键字"></a>4.3 深入理解synchronized关键字</h2><ul>
<li>synchronized 提供了一种互斥机制，在同一时刻，只能由一个线程访问同步资源</li>
<li>不应该将MUTEX称为锁，严谨的说法，应该是 某线程 获取到了 MUTEX关联的 monitor锁</li>
</ul>
<h3 id="Monitor-enter"><a href="#Monitor-enter" class="headerlink" title="Monitor enter"></a>Monitor enter</h3><p>每个对象都与一个monitor 相关联，一个monitor的lock的锁 只能被一个线程在同一时间获得，在一个线程尝试获得与 对象关联monitor的所有权时候回发生如下几件事情。</p>
<ul>
<li>如果monitor 的计数器为0，则意味着 该monitor的lock 还没有被获得，某个线程获得之后 将立即对该计数器加一 ，从此该线程就是这个monitor 的所有者了</li>
<li>如果一个已经拥有该monitor所有权的线程重入 ，则会导致 monitor计数器再次累加</li>
<li>如果monitor已经被其他线程 所拥有，则 其他线程尝试获取该monitor 的所有权时，会被陷入阻塞状态知道monitor计数器 变为0，才能再次尝试 获取对 monitor的所有权 。</li>
</ul>
<h3 id="Monitor-exit"><a href="#Monitor-exit" class="headerlink" title="Monitor exit"></a>Monitor exit</h3><ul>
<li>释放对 monitor的所有权，想要释放对 某个对象关联的 monitor的所有权的前提是 ，你曾经获得了所有权。</li>
<li>释放monitor锁的过程比较简单，就是将 monitor的计数器减一， </li>
<li>如果monitor的计数器 结果为0，那就意味着 该线程不再拥有对 该monitor的所有权，通俗的讲 就是解锁。</li>
<li>与此同时，被该 monitor block的线程将再次尝试 获得对该monitor的所有权</li>
</ul>
<h3 id="使用-synchronized需要注意的问题"><a href="#使用-synchronized需要注意的问题" class="headerlink" title="使用 synchronized需要注意的问题"></a>使用 synchronized需要注意的问题</h3><ul>
<li>与monitor关联的对象不能为空,  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mutex=<span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">        、、、</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">每一个对象和一个 monitor 关联，对象都为<span class="keyword">null</span>了，monitor 肯定无从谈起</span><br></pre></td></tr></table></figure>

<ul>
<li>synchronized作用域太大，synchronized 应该尽可能地只作用于  <strong>共享资源地读写作用域</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">由于<span class="keyword">synchronized</span> 关键字存在排他性，也就是所有线程必须串行的经过<span class="keyword">synchronized</span>保护的共享区域，</span><br><span class="line">    如果<span class="keyword">synchronized</span> 作用域越大，则代表其效率越低，甚至丧失并发的优势</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不同的monitor 企图锁相同的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mutex=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">         <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">        、、、</span><br><span class="line">   	 &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(Task::<span class="keyword">new</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造了5个线程，同时也构造了5个 Runnable实例， Runnable作为逻辑单元传递给Thread，然后将发现：</span></span><br><span class="line"><span class="keyword">synchronized</span> 无法同步互斥， 因为 线程之间的monitor lock争抢只能发生在 monitor 关联的同一个引用上。</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>多个锁的交叉导致死锁</li>
</ul>
<h3 id="4-4-This-Monitor和Class-Monitor"><a href="#4-4-This-Monitor和Class-Monitor" class="headerlink" title="4.4 This Monitor和Class Monitor"></a>4.4 This Monitor和Class Monitor</h3><p>synchronized 的用法可以从两个维度上面分类：</p>
<h3 id="1-根据修饰对象分类"><a href="#1-根据修饰对象分类" class="headerlink" title="1.根据修饰对象分类"></a>1.根据修饰对象分类</h3><p>synchronized 可以修饰方法和代码块</p>
<ul>
<li>修饰代码块<ul>
<li>synchronized(this|object) {}</li>
<li>synchronized(类.class) {}</li>
</ul>
</li>
<li>修饰方法<ul>
<li>修饰非静态方法</li>
<li>修饰静态方法</li>
</ul>
</li>
</ul>
<h2 id="2-根据获取的锁分类"><a href="#2-根据获取的锁分类" class="headerlink" title="2. 根据获取的锁分类"></a>2. 根据获取的锁分类</h2><ul>
<li><p>获取对象锁</p>
<ul>
<li>synchronized(this|object) {}</li>
<li>修饰非静态方法</li>
</ul>
</li>
<li><p>获取类锁</p>
<ul>
<li>synchronized(类.class) {}</li>
<li>修饰静态方法，非静态方法</li>
</ul>
</li>
</ul>
<h4 id="This-Monitor（-对象锁）"><a href="#This-Monitor（-对象锁）" class="headerlink" title="This Monitor（ 对象锁）:"></a>This Monitor（ 对象锁）:</h4><ul>
<li>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，<strong>通常会被称为“内置锁”或“对象锁”</strong>。<strong>类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</strong></li>
</ul>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>synchronized 关键字修饰了同一个实例对象的两个不同方法，那么与之对应的monitor 是什么？ 两个 monitor是否一致呢。</p>
<p>实例锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisMonitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getName() + <span class="string">&quot; enter to method1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(currentThread().getName() + <span class="string">&quot; enter to method2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThisMonitor thisMonitor = <span class="keyword">new</span> ThisMonitor();</span><br><span class="line">        <span class="keyword">new</span> Thread(thisMonitor::method1, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thisMonitor::method2, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/thread-thisMonitor.png"></p>
<p><img src="/uploads/java-concurrency-master/thread-thisMonitor2.png"></p>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul>
<li>由上图可以看出 T1获取了 monitor lock  并处于休眠状态，而 T2 线程企图获取 monitor 的lock时陷入了 BLOCKED 状态，可见 使用synchronized 关键字同步类的不同实例方法，争抢的时 同一个monitor的lock ，而 与之关联的引用则是 ThisMonitor 的实例引用</li>
<li>其中 method1 保持方法同步的方式，method2 则采用了同步代码块 的方式，并且使用的是 this的monitor</li>
</ul>
<p>when a thread invokes a synchronized method, it automatically acquires the intrinsic lock  for that method’s object and releases it when the method returns .  The lock release occurs even if the return was caused by an uncaught exception .</p>
<h4 id="Class-Monitor（类锁）"><a href="#Class-Monitor（类锁）" class="headerlink" title="Class Monitor（类锁）:"></a>Class Monitor（类锁）:</h4><ul>
<li>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</li>
</ul>
<p>对象锁，static修饰 ,有两个类方法（静态方法）分别使用 synchronized对其进行同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassMonitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getName() + <span class="string">&quot; enter to method1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ClassMonitor.class)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(currentThread().getName() + <span class="string">&quot; enter to method2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(ClassMonitor::method1, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ClassMonitor::method2, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/thread-classMonitor.png"></p>
<p><img src="/uploads/java-concurrency-master/thread-classMonitor2.png"></p>
<ul>
<li> 从上图可以看出 用synchronized 同步某个类的不同静态方法争抢的也是 同一个 monitor的lock ，</li>
<li>与 This monitor 信息不一样的地方在于 （a java.lang.Class for ……..）</li>
<li>由此推断与 该 monitor关联的引用是 ClassMonitor.class  实例</li>
</ul>
<p>since  a static method is associated with a class, not an object  . In this case, the thread acquires the intrinstic lock for the Class  object associated with the class . Thus access to class’s static fields is controlled by a lock that’s distinct from the lock for any instance of the class .</p>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><ul>
<li><strong>对于非静态方法，同一个实例的线程访问会被拦截，非同一实例可以同时访问。 即此时是默认对象锁（this）。</strong></li>
<li><strong>静态方法默认类锁。</strong></li>
<li><strong>对于静态方法，由于此时对象还未生成，所以只能采用类锁；</strong></li>
<li><strong>只要采用类锁，就会拦截所有线程，只能让一个线程访问。</strong></li>
<li><strong>对于对象锁（this），如果是同一个实例，就会按顺序访问，但是如果是不同实例，就可以同时访问。</strong></li>
<li><strong>如果对象锁跟访问的对象没有关系，那么就会都同时访问。</strong></li>
</ul>
<h3 id="4-5-程序死锁的原因以及如何诊断"><a href="#4-5-程序死锁的原因以及如何诊断" class="headerlink" title="4.5 程序死锁的原因以及如何诊断"></a>4.5 程序死锁的原因以及如何诊断</h3><ol>
<li><p>交叉锁可导致程序出现死锁</p>
<p>典型的哲学家吃面问题，</p>
</li>
<li><p>内存不足</p>
<p>当并发请求系统可用内存时，如果此时系统内存不足，则可能会出现死锁的情况，举个例子，两个线程 T1 和 T2，执行某个任务，其中T1 已经获取了10MB内存， T2 获取了20MB内存，如果每个线程都需要30MB的内存，但是剩余可用内存刚好为20MB，那么两个线程 有可能都在等待彼此能够释放内存资源。</p>
</li>
<li><p>一问一答式的数据交换</p>
</li>
<li><p>数据库锁</p>
<p>无论是数据库表级别的锁，还是行级别的锁， 比如 某个线程执行 for update语句退出了事务，其他线程访问该数据库时 都将陷入死锁。</p>
</li>
<li><p>文件锁</p>
<p>某线程获得了文件锁意外退出，其他读取该文件的线程也将会 进入死锁知道系统释放文件句柄资源</p>
</li>
<li><p>死循环引起的死锁</p>
</li>
</ol>
<h4 id="死锁诊断"><a href="#死锁诊断" class="headerlink" title="死锁诊断"></a>死锁诊断</h4><ol>
<li>交叉锁引起的死锁</li>
</ol>
<ul>
<li>打开jstack 工具或者 jconsole工具，一般交叉锁引起的死锁线程都会进入 BLOCKED状态，CPU资源占用不高，很容易借助工具来发现</li>
</ul>
<p><img src="/uploads/java-concurrency-master/deadLock_read.png"></p>
<p><img src="/uploads/java-concurrency-master/deadLock_write.png"></p>
<ol start="2">
<li>死循环引起的死锁（假死）</li>
</ol>
<ul>
<li>工作的线程并未BLOCKED ,而是始终处于 RUNNABLE状态，CPU使用率高居不下，</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><p>synchronized 关键字在Java 中提供了同步语义，它可以保证在同一时间 只允许一个线程访问 共享数据资源。</p>
</li>
<li><p>本章介绍了synchronized的详细用法，修饰 方法，或者修饰代码块，</p>
<ul>
<li>如果修饰的是  static 方法或者static 方法快，那么 使用的就是 CLASS monitor，是 class 实例的monitor</li>
<li>如果修饰的不带static ，那就是 this monitor，使用的是某个对象的 monitor</li>
</ul>
</li>
<li><p>介绍死锁场景，以及定位死锁问题</p>
</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>线程安全与数据同步</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-06-ThreadGroup详解</title>
    <url>/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<ul>
<li>创建线程的时候如果没有显示得指定ThreadGroup，那么新的线程会被加入到父线程相同的ThreadGroup中</li>
<li>其实这里主要就是看ThreadGroup的源码，以及Thread的源码，就可以知道关于Thread的一些规则，比如 Thread的优先级 的范围，以及不能超过ThreadGroup的MAX</li>
</ul>
<h1 id="ThreadGroup-与Thread"><a href="#ThreadGroup-与Thread" class="headerlink" title="ThreadGroup 与Thread"></a>ThreadGroup 与Thread</h1><h2 id="创建ThreadGroup"><a href="#创建ThreadGroup" class="headerlink" title="创建ThreadGroup"></a>创建ThreadGroup</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是private ，不对外暴露</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.daemon;</span><br><span class="line">        <span class="keyword">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        parent.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个构造函数为 ThreadGroup赋予了名字，它的默认父 ThreadGroup是创建它的线程所在的ThreadGroup</li>
<li>第二构造函数赋予group名字的同时，显示指定了父ThreadGroup</li>
</ul>
<h2 id="复制Thread数组和ThreadGroup数组"><a href="#复制Thread数组和ThreadGroup数组" class="headerlink" title="复制Thread数组和ThreadGroup数组"></a>复制Thread数组和ThreadGroup数组</h2><h3 id="复制Thread数组"><a href="#复制Thread数组" class="headerlink" title="复制Thread数组"></a>复制Thread数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies into the specified array every active thread in this</span></span><br><span class="line"><span class="comment">     * thread group and its subgroups.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment">     * way as the invocation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> #enumerate(Thread[], boolean) enumerate&#125;&#123;<span class="doctag">@code</span> (list, true)&#125;</span></span><br><span class="line"><span class="comment">     * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  list</span></span><br><span class="line"><span class="comment">     *         an array into which to put the list of threads</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the number of threads put into the array</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">     *          if &#123;<span class="doctag">@linkplain</span> #checkAccess checkAccess&#125; determines that</span></span><br><span class="line"><span class="comment">     *          the current thread cannot access this thread group</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[])</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies into the specified array every active thread in this</span></span><br><span class="line"><span class="comment">     * thread group. If &#123;<span class="doctag">@code</span> recurse&#125; is &#123;<span class="doctag">@code</span> true&#125;,</span></span><br><span class="line"><span class="comment">     * this method recursively enumerates all subgroups of this</span></span><br><span class="line"><span class="comment">     * thread group and references to every active thread in these</span></span><br><span class="line"><span class="comment">     * subgroups are also included. If the array is too short to</span></span><br><span class="line"><span class="comment">     * hold all the threads, the extra threads are silently ignored.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; An application might use the &#123;<span class="doctag">@linkplain</span> #activeCount activeCount&#125;</span></span><br><span class="line"><span class="comment">     * method to get an estimate of how big the array should be, however</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;if the array is too short to hold all the threads, the extra threads</span></span><br><span class="line"><span class="comment">     * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active</span></span><br><span class="line"><span class="comment">     * thread in this thread group, the caller should verify that the returned</span></span><br><span class="line"><span class="comment">     * int value is strictly less than the length of &#123;<span class="doctag">@code</span> list&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Due to the inherent race condition in this method, it is recommended</span></span><br><span class="line"><span class="comment">     * that the method only be used for debugging and monitoring purposes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层私有逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">int</span> n, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ngroupsSnapshot = <span class="number">0</span>;</span><br><span class="line">        ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nt = nthreads;</span><br><span class="line">            <span class="keyword">if</span> (nt &gt; list.length - n) &#123;</span><br><span class="line">                nt = list.length - n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (threads[i].isAlive()) &#123;</span><br><span class="line">                    list[n++] = threads[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">                ngroupsSnapshot = ngroups;</span><br><span class="line">                <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">                n = groupsSnapshot[i].enumerate(list, n, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的public 的2个方法，会将ThreadGroup 中active线程全部复制到Thread数组中，</li>
<li>其中recurse参数如果为True，则方法会将所有子 group的active线程全部递归到Thread数组中，</li>
<li>enumerate（list ）实际上等价于 enumerate（list，true）</li>
</ul>
<h3 id="复制ThreadGroup数组"><a href="#复制ThreadGroup数组" class="headerlink" title="复制ThreadGroup数组"></a>复制ThreadGroup数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[])</span> </span>&#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和复制Thread数组类似，上面方法用于复制当前ThreadGroup的子 Group，同样recurse会决定是否以递归的方式复制</li>
</ul>
<h2 id="ThreadGroup操作"><a href="#ThreadGroup操作" class="headerlink" title="ThreadGroup操作"></a>ThreadGroup操作</h2><p>Threadgroup 并不能提供对线程的管理，主要功能是对线程提供组织</p>
<h3 id="ThreadGroup基本操作"><a href="#ThreadGroup基本操作" class="headerlink" title="ThreadGroup基本操作"></a>ThreadGroup基本操作</h3><ul>
<li>activeCount（）： 用于获取group中活跃的线程，只是一个估计值，该方法会递归获取其他子group中的活跃线程</li>
<li>activeGroupCount（）： 用于获取group中活跃的子group，只是一个估计值，该方法也会递归获取所有的子 group</li>
<li>getMaxPriority() 用于获取group的优先级，默认情况下，Group的优先级为10，在该group中，所有线程的优先级不能大于group的优先级</li>
<li>getName() 用于获取group的名字</li>
<li>getParent（）用于获取group的父 group，如果父group不存在，则会返回null ，比如system group的父group就是 null</li>
<li>list（）该方法没有返回值，执行该方法会将group中所有的活跃线程信息全部输出到控制台，也就是 System.out</li>
<li>parentOf（ThreadGroup g）会判断当前group是不是给定的group的父group ，另外如果给定的group就是本身，那么也返回true</li>
<li>setMaxPriority(int pri)会指定group的最大优先级 ，最大优先级不能超过父 group的最大优先级。执行该方法不仅仅会改变当前group的最大优先级，还会改变所有子goup的最大优先级</li>
</ul>
<p>ThreadGroup的interrupt</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Interrupts all threads in this thread group.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is</span></span><br><span class="line"><span class="comment">   * called with no arguments; this may result in a security exception.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * This method then calls the &lt;code&gt;interrupt&lt;/code&gt; method on all the</span></span><br><span class="line"><span class="comment">   * threads in this thread group and in all of its subgroups.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span>  SecurityException  if the current thread is not allowed</span></span><br><span class="line"><span class="comment">   *               to access this thread group or any of the threads in</span></span><br><span class="line"><span class="comment">   *               the thread group.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.SecurityException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.ThreadGroup#checkAccess()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span>      1.2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">      ThreadGroup[] groupsSnapshot;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          checkAccess();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">              threads[i].interrupt();</span><br><span class="line">          &#125;</span><br><span class="line">          ngroupsSnapshot = ngroups;</span><br><span class="line">          <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">              groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">          groupsSnapshot[i].interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>interrupt一个thread group会导致 该group中所有的active 线程都被interrupt ，</li>
<li>也就说该 group中的每一个interrupt 标识都被设置了 </li>
<li>通过源码分析，可以看出interrupt内部会执行所有thread 的interrupt方法，并且会递归获取子 group，然后执行他们各自的interrupt方法</li>
</ul>
<h3 id="ThreadGroup的destory"><a href="#ThreadGroup的destory" class="headerlink" title="ThreadGroup的destory"></a>ThreadGroup的destory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroys this thread group and all of its subgroups. This thread</span></span><br><span class="line"><span class="comment"> * group must be empty, indicating that all threads that had been in</span></span><br><span class="line"><span class="comment"> * this thread group have since stopped.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is</span></span><br><span class="line"><span class="comment"> * called with no arguments; this may result in a security exception.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread group is not</span></span><br><span class="line"><span class="comment"> *               empty or if the thread group has already been destroyed.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  SecurityException  if the current thread cannot modify this</span></span><br><span class="line"><span class="comment"> *               thread group.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.ThreadGroup#checkAccess()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>      JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (destroyed || (nthreads &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            destroyed = <span class="keyword">true</span>;</span><br><span class="line">            ngroups = <span class="number">0</span>;</span><br><span class="line">            groups = <span class="keyword">null</span>;</span><br><span class="line">            nthreads = <span class="number">0</span>;</span><br><span class="line">            threads = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i += <span class="number">1</span>) &#123;</span><br><span class="line">        groupsSnapshot[i].destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>destory 用于销毁 ThreadGroup ，该方法只是针对一个没有任何active线程的group 进行一个 destory标记，调用该方法的结果是在父 group中将自己移除</li>
</ul>
<h3 id="守护ThreadGroup"><a href="#守护ThreadGroup" class="headerlink" title="守护ThreadGroup"></a>守护ThreadGroup</h3><ul>
<li>线程可以设置为守护线程，ThreadGroup也可以设置为 守护ThreadGroup，</li>
<li>但是将一个THreadGroup 设置为 daemon ，也并不会影响线程的daemon属性</li>
<li>如果一个 ThreadGroup 的daemon被设置为  true，那么在group中没有任何active线程的时候，该group将自动destory </li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>ThreadGroup</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-07-Hook线程以及捕获线程执行异常</title>
    <url>/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<ul>
<li>学习如何获取线程在运行时期的异常信息</li>
<li>学习如何向Java程序注入 Hook线程</li>
</ul>
<h1 id="获取线程运行时异常"><a href="#获取线程运行时异常" class="headerlink" title="获取线程运行时异常"></a>获取线程运行时异常</h1><p>在Thread类中，关于处理运行时异常的API总共有4个，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.  为某个特定线程 指定 UncaughtExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(</span><br><span class="line">                <span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setDefaultUncaughtExceptionHandler&quot;</span>)</span><br><span class="line">                    );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         defaultUncaughtExceptionHandler = eh;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//2. 设置全局的 UncaughtExceptionHandler</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//3.  获取特定线程的 UncaughtExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">            uncaughtExceptionHandler : group;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4.  获取全局的 UncaughtExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        uncaughtExceptionHandler = eh;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="UncaughtExceptionHandler的介绍"><a href="#UncaughtExceptionHandler的介绍" class="headerlink" title="UncaughtExceptionHandler的介绍"></a>UncaughtExceptionHandler的介绍</h2><ul>
<li>线程在执行单元中时不允许抛出checked异常的</li>
<li>线程运行在自己的上下文中，派生它的线程将无法直接获得它运行中出现的异常信息</li>
</ul>
<p>所以Java为我们提供了一个 UncaughtExceptionHandler 接口，</p>
<ul>
<li>当线程在运行过程中出现了异常时，会回调UncaughtExceptionHandler 接口，从而我们得知 哪个线程在运行时出错，以及错误类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Interface for handlers invoked when a &lt;tt&gt;Thread&lt;/tt&gt; abruptly</span></span><br><span class="line"><span class="comment">     * terminates due to an uncaught exception.</span></span><br><span class="line"><span class="comment">     （当一个线程突然的终结了由于一个未被捕获的异常，这个时候这个handler会被调用 ）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;When a thread is about to terminate due to an uncaught exception</span></span><br><span class="line"><span class="comment">     * the Java Virtual Machine will query the thread for its</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt; using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #getUncaughtExceptionHandler&#125; and will invoke the handler&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;uncaughtException&lt;/tt&gt; method, passing the thread and the</span></span><br><span class="line"><span class="comment">     * exception as arguments.</span></span><br><span class="line"><span class="comment">     （当线程由于未捕获的异常即将终止时，Java虚拟机将查询它的线程 为了给 UncaughtExceptionHandler做参数，JVM 传递线程和</span></span><br><span class="line"><span class="comment">*异常作为参数给 uncaughtException方法）</span></span><br><span class="line"><span class="comment">     * If a thread has not had its &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * explicitly set, then its &lt;tt&gt;ThreadGroup&lt;/tt&gt; object acts as its</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;. If the &lt;tt&gt;ThreadGroup&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment">     * has no</span></span><br><span class="line"><span class="comment">     * special requirements for dealing with the exception, it can forward</span></span><br><span class="line"><span class="comment">     * the invocation to the &#123;<span class="doctag">@linkplain</span> #getDefaultUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * default uncaught exception handler&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setDefaultUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ThreadGroup#uncaughtException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked when the given thread terminates due to the</span></span><br><span class="line"><span class="comment">         * given uncaught exception.</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Any exception thrown by this method will be ignored by the</span></span><br><span class="line"><span class="comment">         * Java Virtual Machine.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该回调接口会被Thread 中的dispatchUncaughtException方法调用，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 当线程在运行过程中出现异常时，JVM会调用dispatchUncaughtException方法，该方法会将对应的线程实例以及异常信息传递给回调接口</li>
</ul>
<h2 id="UncaughtExceptionHandler-实例"><a href="#UncaughtExceptionHandler-实例" class="headerlink" title="UncaughtExceptionHandler 实例"></a>UncaughtExceptionHandler 实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureThreadException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler((t, e) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot; occur exception&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//here will throw unchecked exception.</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Test-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    Test-Thread occur exception</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.CaptureThreadException.lambda$main$<span class="number">1</span>(CaptureThreadException.java:<span class="number">22</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.CaptureThreadException$$Lambda$<span class="number">2</span>/<span class="number">1078694789.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这种设计方式是比较常见的，（在后面的设计模式也会讲到），尤其是那种异步执行方法，</li>
<li>比如Google 的guava toolkit就提供了 EventBus ，在EventBus 中事件源和实践的subscriber两者 借助EventBus 实现了完全的解耦合，但是在subscriber执行任务时有可能会出现异常i情况，EventBus也是借助于一个ExceptionHandler进行回调处理的 </li>
</ul>
<h2 id="UncaughtExceptionHandler-源码分析"><a href="#UncaughtExceptionHandler-源码分析" class="headerlink" title="UncaughtExceptionHandler 源码分析"></a>UncaughtExceptionHandler 源码分析</h2><p>当 没有主动的 向线程 注入UncaughtExceptionHandler 回调接口的情况下，线程加入出现了异常 又将如何处理呢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the handler invoked when this thread abruptly terminates</span></span><br><span class="line"><span class="comment">  * due to an uncaught exception. If this thread has not had an</span></span><br><span class="line"><span class="comment">  * uncaught exception handler explicitly set then this thread&#x27;s</span></span><br><span class="line"><span class="comment">  * &lt;tt&gt;ThreadGroup&lt;/tt&gt; object is returned, unless this thread</span></span><br><span class="line"><span class="comment">  * has terminated, in which case &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the uncaught exception handler for this thread</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">         uncaughtExceptionHandler : group;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getUncaughtExceptionHandler 方法首先会判断当前线程是否设置了handler，</p>
<ul>
<li>如果有则执行线程自己的uncaughtException方法 ，</li>
<li>否则就到所在的ThreadGroup中获取</li>
</ul>
</li>
<li><p>ThreadGroup同样也实现了UncaughtExceptionHandler接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">            <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ueh.uncaughtException(t, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">                System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span></span><br><span class="line">                                 + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 ThreadGroup实现了  Thread.UncaughtExceptionHandler  接口</p>
<ol>
<li>该 ThreadGroup如果有父 ThreadGroup，则直接调用 父group的 uncaughtException方法</li>
<li>如果 设置了全局默认的 UncaughtExceptionHandler  ，则调用全局的 uncaughtException方法</li>
<li>如果既没有父 ThreadGroup，也没有全局默认的 UncaughtExceptionHandler  ， 则直接 将异常的堆栈信息定向到 System.err中</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// get current thread&#x27;s thread group</span></span><br><span class="line">        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();</span><br><span class="line">        System.out.println(mainGroup.getName());</span><br><span class="line">        System.out.println(mainGroup.getParent());</span><br><span class="line">        System.out.println(mainGroup.getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//here will throw unchecked exception.</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Test-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果： </span><br><span class="line">    main</span><br><span class="line">java.lang.ThreadGroup[name=system,maxpri=<span class="number">10</span>]</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">Exception in thread <span class="string">&quot;Test-Thread&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.EmptyExceptionHandler.lambda$main$<span class="number">0</span>(EmptyExceptionHandler.java:<span class="number">21</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.EmptyExceptionHandler$$Lambda$<span class="number">1</span>/<span class="number">295530567.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码 既没有设置默认的Handler ,也没有对thread指定Handler，因此当thread出现异常时，会向上寻找 Group的 uncaughtException方法</li>
</ul>
<pre class="mermaid">graph LR
线程出现异常 -->MainGroup -->SystemGroup -->System.err</pre>

<pre class="mermaid">graph TD
线程出现异常 -->getUncaughtExceptionHandler{当前线程是否设置了异常处理器}
getUncaughtExceptionHandler -->|uncaughtExceptionHandler不为空| CurrThread[当前线程异常处理器处理]
getUncaughtExceptionHandler -->|uncaughtExceptionHandler为空| group[找所在 group]

group --> 父group{是否存在父group}
父group -->|父group存在| parent.uncaughtException[父group去处理]
父group -->|父group不存在| getDefaultUncaughtExceptionHandler[找全局默认的UncaughtExceptionHandler]

getDefaultUncaughtExceptionHandler -->DefaultUncaughtExceptionHandler{是否设置全局DefaultUncaughtExceptionHandler}
DefaultUncaughtExceptionHandler -->|DefaultUncaughtExceptionHandler不为空|Defaultueh.uncaughtException[DefaultUncaughtExceptionHandler处理]
DefaultUncaughtExceptionHandler -->|DefaultUncaughtExceptionHandler为空|System.err.print[输出异常堆栈]</pre>

<h1 id="注入钩子函数"><a href="#注入钩子函数" class="headerlink" title="注入钩子函数"></a>注入钩子函数</h1><h2 id="Hook线程介绍"><a href="#Hook线程介绍" class="headerlink" title="Hook线程介绍"></a>Hook线程介绍</h2><p>JVM进程的退出是由于： <strong>JVM进程中没有活跃的非守护线程，或者收到了系统中断信号</strong>，向JVM程序注入一个 Hook线程，在JVM进程退出的时候，Hook 线程会启动执行，<strong>通过Runtime可以为JVM注入多个Hook线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadHook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Hook线程1</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The hook thread 2 is running.&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;The program will exit.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// Hook线程2 </span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The hook thread 2 is running.&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;The hook thread 2 will exit.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// JVM 退出信号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;The program will is stopping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    The program will is stopping.</span><br><span class="line">The hook thread <span class="number">2</span> is running.</span><br><span class="line">The hook thread <span class="number">2</span> is running.</span><br><span class="line">The program will exit.</span><br><span class="line">The hook thread <span class="number">2</span> will exit.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>给Java程序注入了两个Hook线程，在main线程中结束，也就是JVM中没有了活动的非守护线程</li>
<li>jvm进程即将退出时，两个Hook线程会被启动并且运行 </li>
</ul>
<h2 id="Hook线程实战"><a href="#Hook线程实战" class="headerlink" title="Hook线程实战"></a>Hook线程实战</h2><p>我们在开发中经常会遇到Hook线程，比如：</p>
<ul>
<li>为了防止某个程序被重复启动，在启动时会创建一个lock文件，进程收到中断信号时候会删除lock文件，我们在mysql 服务器、zookeeper、kafka等系统都能看到lock文件的存在</li>
</ul>
<p>本代码利用hook线程的特点，模拟一个防止重复启动的程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreventDuplicated</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_PATH = <span class="string">&quot;/home/yinshi/locks/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_FILE = <span class="string">&quot;.lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PERMISSIONS = <span class="string">&quot;rw-------&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.注入hook线程，在程序退出时删除lock文件</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The program received kill SIGNAL.&quot;</span>);</span><br><span class="line">            getLockFile().toFile().delete();</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">// 2.检查是否存在 .lock文件</span></span><br><span class="line">        checkRunning();</span><br><span class="line">		<span class="comment">//3.简单模拟程序running</span></span><br><span class="line">        <span class="comment">//simulate the program is running.</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;program is running.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkRunning</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = getLockFile();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;The program already running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString(PERMISSIONS);</span><br><span class="line">        Files.createFile(path, PosixFilePermissions.asFileAttribute(perms));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Path <span class="title">getLockFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Paths.get(LOCK_PATH, LOCK_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行kill pid 或者 kill -1 pid 命令后，JVM进程会收到中断信号，并且启动hook线程 删除.lock文件</li>
</ul>
<h2 id="Hook线程应用场景以及注意事项"><a href="#Hook线程应用场景以及注意事项" class="headerlink" title="Hook线程应用场景以及注意事项"></a>Hook线程应用场景以及注意事项</h2><ul>
<li>hook线程只有在收到退出信号的时候会被执行，如果 是 kill -9 ，那么Hook线程不会得到执行，进程将会退出，因此 .lock文件将得不到清理</li>
<li>hook线程中也可以执行 一些资源释放的工作，比如 关闭文件句柄、socket链接、数据库connection等</li>
<li>尽量不要在 Hook线程中执行一些耗时非常长的操作，因为其会导致程序迟迟不能退出</li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li>知道了如何通过Handler回调的方式获取线程运行期间的异常信息， </li>
<li>分析了Thread的源码 和 ThreadGroup的源码，追踪uncaughtException的执行顺序</li>
<li>了解了Hook的执行时机，帮助程序获得进程中断的信号，有机会在进程退出之前做一些资源释放或者告警通知</li>
<li>如果强制杀死进程，（比如kill -9） 那么进程将不会收到任何中断信号</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>Hook线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-11-线程上下文类加载器</title>
    <url>/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<p>前面讲java类加载器的知识为了解释线程的上下文类加载器原理和使用场景</p>
<h1 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h1><h2 id="为什么需要线程上下文类加载器"><a href="#为什么需要线程上下文类加载器" class="headerlink" title="为什么需要线程上下文类加载器"></a>为什么需要线程上下文类加载器</h2><p>根据Thread 类的文档 你会发现线程上下文方法是  从JDK1.2 开始引入的，getContextClassLoader() 和 setContextClassLoader（ClassLoader cl）分别用于获取和设置当前线程线程的上下文类加载器，如果当前线程没有设置上下文类加载器，那么它将和父线程保持同样的类加载器。</p>
<ul>
<li>站在开发者的角度，其他线程都是由Main线程，也就是main函数所在的线程派生的，它是其他线程的父线程或者祖先线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getContextClassLoader());</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果:</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">14d</span>ad5dc</span><br><span class="line">    </span><br><span class="line">    Loading <span class="class"><span class="keyword">class</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>&#x27;. <span class="title">This</span> <span class="title">is</span> <span class="title">deprecated</span>. <span class="title">The</span> <span class="title">new</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>&#x27;. <span class="title">The</span> <span class="title">driver</span> <span class="title">is</span> <span class="title">automatically</span> <span class="title">registered</span> <span class="title">via</span> <span class="title">the</span> <span class="title">SPI</span> <span class="title">and</span> <span class="title">manual</span> <span class="title">loading</span> <span class="title">of</span> <span class="title">the</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> <span class="title">generally</span> <span class="title">unnecessary</span>.</span></span><br></pre></td></tr></table></figure>



<p>为什么要有线程上下文类加载器呢，这就与<strong>JVM类加载器双亲委托机制自身的缺陷有关。</strong></p>
<ul>
<li>jdk的核心库中提供了很多SPI （Service Provider Interface），常见的SPI 包括JDBC、JCE、JNDI、JAXP 和JBI 等，JDK只规定了这些接口之间的逻辑关系，但不提供具体的实现，具体的实现需要由 第三方厂商来提供，</li>
<li>作为Java程序员 都写过JDBC的程序，在编写JDBC程序时几乎百分之百的都在与 java.sql 包下的类打交道</li>
</ul>
<p>如下图所示，Java使用JDBC这个SPI 完全透明了 应用程序和第三方厂商数据库驱动的具体实现， 不管数据库类型如何切换，应用程序只需要替换JDBC 的驱动jar包以及数据库的驱动名称即可，而不用进行任何更新 。</p>
<p><img src="/uploads/java-concurrency-master/JDBC_SPI.png"></p>
<p>这样做的好处是：</p>
<ul>
<li>JDBC 提供了高度抽象，应用程序只需要面向接口编程即可，不用关心各大数据厂商的具体实现 。</li>
<li>但是问题在于 java.lang.sql 中的所有接口都是JDK 提供，<strong>加载这些接口的类加载器是 根加载器</strong>,  但是 <strong>第三方厂商提供的类库驱动 是由系统类加载器加载的，</strong></li>
<li>由于JVM 类加载器的双亲委托机制，比如 Connections、 Statement、 RowSet 等 都是由 <strong>根加载器加载</strong>，第三方的JDBC 驱动包中的实现不会被加载 。</li>
</ul>
<p>通过分析 Mysql数据库的源码，来看看是如果解决这个 接口与实现类的 加载器不一致的问题</p>
<h2 id="数据库驱动的初始化源码分析"><a href="#数据库驱动的初始化源码分析" class="headerlink" title="数据库驱动的初始化源码分析"></a>数据库驱动的初始化源码分析</h2><p>在编写所有的 JDBC程序时，首先都需要 调用Class.forName(“xxxx.xxxx.xxxx.Driver”)对数据库驱动进行加载，打开 Mysql驱动 Driver源码，代码如清单11-2 所示</p>
<h3 id="Driver源码"><a href="#Driver源码" class="headerlink" title="Driver源码"></a>Driver源码</h3><ul>
<li>这个时老版本的 （com.mysql.jdbc.Driver）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backwards compatibility to support apps that call &lt;code&gt;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Loading class `com.mysql.jdbc.Driver&#x27;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#x27;. &quot;</span></span><br><span class="line">                + <span class="string">&quot;The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个是新版本的，推荐使用的（com.mysql.cj.jdbc.Driver）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在Mysql 的静态方法中 将Driver 实例注册到DriverManager中 </span></span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Driver类的静态代码块主要是 将Mysql 的Driver实例注册给 DriverManager，因此直接使用 DriverManager.registerDriver（new com.mysql.jdbc.Driver（））其作用与 Class.forName (“xxx.xxx.xxx.Driver”)是完全等价的 </li>
</ul>
<h3 id="DriverManager源码"><a href="#DriverManager源码" class="headerlink" title="DriverManager源码"></a>DriverManager源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//  Worker method called by the public getConnection() methods.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application&#x27;s</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 注释 1</span></span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//..................</span></span><br><span class="line"><span class="comment">// 注释 2</span></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">            <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">            <span class="comment">// skip it.</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">.。。。。。。。</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line"> <span class="comment">// 注释 3 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                aClass =  Class.forName(driver.getClass().getName(), <span class="keyword">true</span>, classLoader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             result = ( aClass == driver.getClass() ) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在注释1处 获取当前线程的上下文类加载器 ，该类就是调用Class.forName(“X”) 所在线程的线程上下文类加载器，通常是系统类加载器</li>
<li>注释2 中通过递归DriverManager 中已经注册的驱动类，然后验证 该数据库驱动 是否可以被指定的类加载器加载（线程上下文类加载器），如果验证通过，则返回Connection，此刻返回的 Connection 则是数据库厂商提供的实例</li>
<li>注释3 关键地方在于Class.forName(driver.getClass().getName(), true, classLoader);  其使用线程上下文类加载器及逆行数据库驱动的加载以及初始化  </li>
</ol>
<p>总结一下数据库驱动加载的整个过程，</p>
<ul>
<li>由于JDK 定义了SPI的标准接口，加之这些接口被作为 JDK 核心标准类库的一部分，既想要完全透明标准接口的实现，又想与JDK 核心库进行捆绑， 由于JVM 类加载器双亲委托机制的限制，启动类加载器不可能 加载得到第三方厂商提供的具体实现 。</li>
<li> 为了解决这一问题，JDK 只好提供一种不太优雅的设计-线程上下文类加载器 </li>
<li>有了线程上下文类加载器，启动类加载器（根加载器）反倒需要委托子类加载器去加载厂商提供的SPI 具体实现。父委托变成了子委托的方式</li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li><p>分析Mysql驱动加载过程的源码，清晰地理解线程上下文加载器所发挥地作用了 </p>
</li>
<li><p>在Thread 类中增加 getContextClassLoader() 和 setContextClassLoader（ClassLoader cl）方法实属无奈之举，它不仅破坏了类加载器地父委托机制，而且反其道行之，允许“子委托机制”，</p>
</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>线程上下文类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-12-深入理解volatile关键字</title>
    <url>/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li>Java内存模型（Java Memory Mode，JMM） 指定了Java虚拟机如何与计算机 的主存（RAM）进行工作。</li>
</ul>
<p>Java的内存模型决定了一个线程对共享变量的写入何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系。具体如下：</p>
<ol>
<li>共享变量存储与主内存之中，每个线程都可以访问</li>
<li>每个线程都有私有的工作内存或者称为本地内存</li>
<li>工作内存只存储该线程对共享变量的副本</li>
<li>线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存</li>
<li>工作内存和Java内存模型一样也是一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。</li>
</ol>
<h1 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h1><p>原子性、有序性、 可见性</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>所谓原子性是指在一次的操作和多次操作中，要么所有的操作全部都得到了执行并且不会受到 任何因素的干扰而中断，要么所有的操作都不执行</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>两个原子性的操作结合在一起未必还是原子性的，比如 i++ (其中get i，i+1，set i=x 三者都是原子性操作，但是不代表 i++就是原子性操作)</li>
<li>volatile 关键字不保证 数据的原子性，synchronized关键字保证，自从 JDK1.5 版本开始，其提供的原子类型变量也 可以保证原子性</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性是指 程序代码在执行过程中的先后顺序，由于Java 在编译器以及运行期的优化，导致了 代码的 执行顺序未必就是开发者编写代码时的顺序，</p>
<p>因为会存在 指令重排序的情况（Instruction Recorder）</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指，当一个线程对共享变量进行了修改，那么另外的线程 可以立即看到修改后的最新值 </p>
<h1 id="JMM如何保证三大特性"><a href="#JMM如何保证三大特性" class="headerlink" title="JMM如何保证三大特性"></a>JMM如何保证三大特性</h1><ul>
<li>JVM采用 内存模型的机制来 屏蔽各个平台和操作系统之间内存访问的差异，以实现让 Java程序在各种平台下达到一致的内存访问效果</li>
<li>Java的内存模型规定了所有的变量都是存在于 主内存（RAM）当中的，而每个线程都有自己的工作内存或者本地内存。线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接对主内存 进行操作，并且每一个线程都不能访问其他线程的工作内存或者本地内存 。</li>
</ul>
<h2 id="1-JMM与原子性"><a href="#1-JMM与原子性" class="headerlink" title="1.JMM与原子性"></a>1.JMM与原子性</h2><p>在Java语言中，对基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的，因此诸如此类的操作是  不可被中断的，要么执行，要么不执行，正所谓 一荣俱荣一损俱损。</p>
<p>（1） x=10； 赋值操作</p>
<p>x=10的操作是原子性的，执行线程首先会将x=10，写入工作内存中，然后再将其 写入主内存（）</p>
<p>（2）y=x； 赋值操作</p>
<p>这条操作时非原子性的，因为它 包含如下两个重要的步骤</p>
<ol>
<li>执行线程从主内存中 读取x的值（如果x 已经存在于 执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中</li>
<li>在执行线程的 工作内存中修改y的值为x，然后将y的值写入 主内存之中</li>
</ol>
<p>虽然第一步和第二步 都是原子类型的操作，但是合在 一起就不是原子操作了</p>
<p>（3）y++； 自增操作</p>
<p>这条操作语句时非原子性的，因为它包含3个重要的步骤，具体如下</p>
<ol>
<li><p>执行线程从主内存中读取y的值，然后将其存入当前线程的工作内存之中</p>
</li>
<li><p>在执行线程工作内存中为y执行加1操作</p>
</li>
<li><p>将y的值写入主内存</p>
</li>
</ol>
<p>（4）z=z+1； 加一操作（与自增操作等价）</p>
<p>这条操作语句时非原子性的，因为它包含3个重要的步骤，具体如下：</p>
<ol>
<li>执行线程从主内存中读取z的值（如果z已经存在于执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中</li>
<li>在执行线程工作内存中为z执行加1操作</li>
<li>将z的值写入主内存 </li>
</ol>
<p>总结：</p>
<ul>
<li>多个原子性的操作在一起就不再是原子性操作了</li>
<li>简单的读取与赋值操作时原子性的，将一个变量赋给另一个变量的操作不是原子性的</li>
<li>java内存模型（JMM）只保证了基本读取和赋值的原子性操作，其他的均不保证，</li>
<li><strong>如果想要使得某些代码片段具备原子性，需要使用关键字 synchronized，或者 JUC中的lock ，</strong></li>
<li>*<em>如果想要使得int 等类型自增操作具备原子性，可以使用JUC 包下的原子封装类型 java.util.concurrent.atomic.**</em></li>
<li><strong>volatile 关键字不具备保证 原子性的语义</strong></li>
</ul>
<h2 id="2-JMM与可见性"><a href="#2-JMM与可见性" class="headerlink" title="2.JMM与可见性"></a>2.JMM与可见性</h2><p>在多线程环境中，如果某个线程首次读取共享变量，则首先 到主内存中获取该变量，然后存入 工作内存中，以后只需要在工作内存中读取该变量即可。 </p>
<p>同样的，如果对该变量执行了修改的操作，则先 将新值写入工作内存中，然后再刷新至 主内存中， <strong>但是什么时候最新的值会被刷新至主内存中是不太确定的</strong>，</p>
<p>java提供了以下三种方式来保证可见性</p>
<ul>
<li>使用关键字 volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（当然也会缓存到线程自己的工作内存中，当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），对于共享资源的写操作当然是 先修改工作内存，但是修改结束后会立刻将其刷新到主内存中</li>
<li>通过synchronized 关键字能够保证可见性，synchronized 关键字能够保证同一时刻 ，只有一个线程获得锁，然后执行同步党法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存当中</li>
<li>通过JUC 提供的显示锁Lock也能保证可见性，Lock的lock方法能够保证 在同一时刻只有一个线程获得锁，然后执行同步方法，并且会确保在锁 释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存当中</li>
</ul>
<p>总结： <strong>volatile关键字具有保证可见性的语义</strong></p>
<h2 id="3-JMM与有序性"><a href="#3-JMM与有序性" class="headerlink" title="3.JMM与有序性"></a>3.JMM与有序性</h2><p>在Java内存模型中，允许编译器和处理器对指令进行重排序/。但是在多线程的情况下，重排序会影响到程序的正确运行，Java提供了3种保证有序性的方式</p>
<ul>
<li>使用volatile 关键字来保证有序性</li>
<li>使用 synchronized关键字来保证有序性、</li>
<li>使用  显示锁Lock 来保证有序性</li>
</ul>
<p>另外Java的内存模型具备一些天生的有序性规则，不需要任何同步手段就能够保证有序性，这个规则被称为Happens-before原则。</p>
<p>happens-before原则</p>
<ul>
<li>程序次序规则： 在一个线程内，代码按照编写的次序执行，编写在后面的操作发生于 编写在前面的操作之后</li>
<li>锁定规则： 一个unlock操作要先行发生于对同一个锁的lock操作</li>
<li>volatile变量规则：  对一个变量的写操作 要早于对这个变量之后的读操作</li>
<li>传递规则</li>
<li>线程启动规则： THread对象的start 方法先行于对该线程的任何动作，</li>
<li>线程中断规则：  对线程执行interrupt方法肯定要优先于捕获到中断信号 </li>
<li>线程的终结规则：</li>
</ul>
<p>总结： volatile关键字具有保证顺序性的语义</p>
<h1 id="volatile关键字深入解析"><a href="#volatile关键字深入解析" class="headerlink" title="volatile关键字深入解析"></a>volatile关键字深入解析</h1><p>被volatile 修饰的实例变量 或者类变量具备如下两层语义</p>
<ul>
<li>保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰的变量，另一个线程会立即看到最新的值</li>
<li>禁止对指令进行重排序操作</li>
<li>volatile 并不保证 原子性</li>
</ul>
<h2 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h2><p>通过对OpenJDK下 unsafe.cpp 源码的阅读会发现 被volatile修饰的变量存在于 一个 lock 的前缀，源码如下：</p>
<p>“lock；” 前缀实际上相当于是一个 内存屏障，该内存屏障会为 指令的执行 提供如下几个保障。</p>
<ul>
<li>确保指令重排序时不会将其后面的代码排到内存屏障之前</li>
<li>确保指令重排序时不会将其后面的代码派操内存屏障之后</li>
<li>确保在执行内存屏障修饰的指令时前面的代码全部执行完成</li>
<li>强制将线程工作内存中的值 修改刷新至主内存中</li>
<li>如果是写操作，则会导致其他线程工作内存（CPU Cache）中缓存数据失效</li>
</ul>
<h2 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h2><ol>
<li>开关控制利用可见性的特点</li>
<li>状态标记利用顺序性特点</li>
</ol>
<h2 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h2><p> 1.使用上的区别</p>
<ul>
<li>volatile关键字<strong>只能用于修饰实例变量或者类变量</strong>，不能用于修饰方法以及方法参数 和局部变量、常量等</li>
<li>synchronized 关键字不能用于对变量的修饰，只能用于修饰方法或者语句块 </li>
<li>volatile 修饰的变量可以为null ，synchronized 关键字同步语句块的monitor对象不能为null </li>
</ul>
<ol start="2">
<li>对原子性的保证</li>
</ol>
<ul>
<li>volatile无法保证原子性</li>
<li>由于synchronized 是一种排他的机制，因此被 synchronized 关键字修饰的同步代码 是无法被中途打断的，因此可以能够保证代码的原子性</li>
</ul>
<ol start="3">
<li>对可见性的保证</li>
</ol>
<ul>
<li>两者均可以保证共享资源在多线程间的可见性，但是实现机制完全不同</li>
<li>synchronized 借助于JVM指令 monitor enter 和 monitor exit 对通过排他的方式使得 同步代码串行化，在monitor exit时所有共享资源都将会被刷新到主内存中</li>
<li>volatile 使用机器指令“lock；”的方式迫使其他线程工作内存中的数据失效，不得到 主内存中进行再次加载</li>
</ul>
<ol start="4">
<li>对有序性的保证</li>
</ol>
<ul>
<li>volatile关键字禁止JVM 编译器以及处理器对其进行重排序，所以 它能够保证有序性</li>
<li>synchronized 关键字所修饰的同步方法 也可以保证顺序性，但是这种顺序性 是以程序的串行化执行换来的，  在synchronized 关键字所修饰的代码块中 代码指令也会发生指令重排序的情况</li>
</ul>
<ol start="5">
<li>其他</li>
</ol>
<ul>
<li>volatile不会使得线程陷入阻塞</li>
<li>synchronized 关键字会使得 线程进入阻塞状态</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>并发编程的3个重要特性： 原子性，可见性 和有序性</p>
</li>
<li><p>java 如何保证这3个重要特性，synchronized主要是 排他机制，确保每次都只有一个线程通过。volatile 主要是通过内存屏障“lock；”以及防止指令重排序的方式来实现</p>
</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>volatile关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-13-7种单例设计模式设计</title>
    <url>/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-13-7%E7%A7%8D%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HungerSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungerSingleton instance = <span class="keyword">new</span> HungerSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>instance 作为类变量在 类初始化的过程中会被收集进 <clinit>()方法中，该方法能够百分之百地保证同步，也就是说 instance 在多线程地情况下不可能被实例化两次，但是instance 被ClassLoader 加载后可能很长一段时间才被使用，那就意味着 instance 实例所开辟地堆内存会驻留更久地时间</li>
<li>如果一个类中地成员属性比较少，且占用的内存资源不多，饿汉的方式也未尝不可， </li>
<li>相反，如果一个类中的成员都是比较重的资源，那么这种方式就会有些不妥</li>
<li>总结起来，饿汉式的单例设计模式可以保证在多线程的情况下的唯一实例，getInstance的性能也比较高，</li>
<li>但是无法进行懒加载</li>
</ul>
<h2 id="懒汉式-同步方法"><a href="#懒汉式-同步方法" class="headerlink" title="懒汉式+同步方法"></a>懒汉式+同步方法</h2><p>所谓懒汉式就是在使用类实例的时候再去创建，这样就可以避免在类初始化时，提前创建，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果不加synchronized， 会出现多线程并发问题,</span></span><br><span class="line">        <span class="comment">//加上 synchronized后，单线程，效率问题</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意看 getInstance ()方法，如果此处不加 synchronized 同步，则可能存在多线程并发的问题，</li>
<li>但是加上 synchronized后，单线程，有可能存在效率问题</li>
</ul>
<h2 id="Volatile-Double-Check"><a href="#Volatile-Double-Check" class="headerlink" title="Volatile+Double-Check"></a>Volatile+Double-Check</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDoubleheckSingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> VolatileDoubleheckSingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    Connection conn;</span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">VolatileDoubleheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this.conn;</span></span><br><span class="line">        <span class="comment">//this.socket;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VolatileDoubleheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (VolatileDoubleheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> VolatileDoubleheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Double-Check 虽然是一种巧妙地程序设计，但是有可能引起类成员变量地实例化 conn 和socket 发生在instance 实例化之后，（因为JVM在运行时指令重排序导致的）</li>
<li>而 volatile关键字则可以防止这种重排序的发生 所以 private volatile static VolatileDoubleheckSingleton instance = null;</li>
</ul>
<h2 id="Holder方式"><a href="#Holder方式" class="headerlink" title="Holder方式"></a>Holder方式</h2><p>Holder 的方式完全是 借助了类加载的特点，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HolderSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在静态内部类中持有 HolderSingleton 的实例，并且可以直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> HolderSingleton instance = <span class="keyword">new</span> HolderSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 getInstance 方法，事实上是获得 Holder的instance 静态属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好处：</p>
<ul>
<li>在HolderSingleton类中 没有instance的静态成员，而是将其放到了静态内部类Holder之中，因此在Singleton类的 初始化过程中 并不会创建 Singleton 的实例，</li>
<li>Holder类中定义了Singleton的静态变量，并且直接进行了实例化。当Holder被主动引用的时候  则会创建Singleton的实例，Singleton实例的创建过程 在Java程序编译时期 收集至 <clinit>（） 方法中，该方法 又是同步方法， 同步方法可以保证内存的可见性，JVM指令的顺序性 和原子性、</li>
<li>Holder方式的单例设计是最好的设计之一</li>
</ul>
<h2 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h2><ul>
<li>使用枚举的方式实现单例模式 是 《effective java》作者力推的方式 </li>
<li>枚举类型不允许被继承，同样的是线程安全的且 只能被实例化一次，但是 枚举类型不能够懒加载，</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    EnumSingleton() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;INIT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用该方法则会主动使用Singleton INSTANCE 将会被实例化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumHolder</span> </span>&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">        EnumHolder() &#123;</span><br><span class="line">            <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumHolder.INSTANCE.getSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>单例设计模式设计</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-15-监控任务的生命周期</title>
    <url>/2021/03/09/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-15-%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<ul>
<li>这个例子我已经用到了实际工作中，怎么说呢，效果还不错吧</li>
<li>既监控了任务的状态，也实现了单一职责，将任务task的逻辑 与监控 逻辑进行了分离</li>
<li>也方便统一 任务的状态，可以落数据库</li>
</ul>
<h2 id="1-Observable接口定义"><a href="#1-Observable接口定义" class="headerlink" title="1.Observable接口定义"></a>1.Observable接口定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务生命周期的枚举类型</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">        STARTED, RUNNING, DONE, ERROR</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前任务的生命周期状态</span></span><br><span class="line">    <span class="function">Cycle <span class="title">getCycle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义启动线程的方法，作用是为了屏蔽 Thread的其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义线程的打断方法，作用于 start方法一样，也是为了屏蔽Thread的其他方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-TaskLifecycle-事件回调者"><a href="#2-TaskLifecycle-事件回调者" class="headerlink" title="2.TaskLifecycle 事件回调者"></a>2.TaskLifecycle 事件回调者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TaskLifecycle</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRunning</span><span class="params">(Thread thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(Thread thread, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Thread thread, Exception e)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Task函数接口定义"><a href="#3-Task函数接口定义" class="headerlink" title="3.Task函数接口定义"></a>3.Task函数接口定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Task</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 任务执行接口，该接口允许有返回值 </span></span><br><span class="line">    <span class="function">T <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-ObservableThread-事件发起者"><a href="#4-ObservableThread-事件发起者" class="headerlink" title="4.ObservableThread 事件发起者"></a>4.ObservableThread 事件发起者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableThread</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TaskLifecycle&lt;T&gt; lifecycle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Task&lt;T&gt; task;</span><br><span class="line">    <span class="keyword">private</span> Cycle cycle;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableThread</span><span class="params">(TaskLifecycle&lt;T&gt; lifecycle, Task&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;The task is required.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.update(Cycle.STARTED, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.update(Cycle.RUNNING, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            T result = <span class="keyword">this</span>.task.call();</span><br><span class="line">            <span class="keyword">this</span>.update(Cycle.DONE, result, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.update(Cycle.ERROR, <span class="keyword">null</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Cycle cycle, T result, Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">this</span>.cycle = cycle;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (cycle) &#123;</span><br><span class="line">                <span class="keyword">case</span> STARTED:</span><br><span class="line">                    <span class="keyword">this</span>.lifecycle.onStart(currentThread());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RUNNING:</span><br><span class="line">                    <span class="keyword">this</span>.lifecycle.onRunning(currentThread());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DONE:</span><br><span class="line">                    <span class="keyword">this</span>.lifecycle.onFinish(currentThread(), result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ERROR:</span><br><span class="line">                    <span class="keyword">this</span>.lifecycle.onError(currentThread(), e);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cycle == Cycle.ERROR) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cycle <span class="title">getCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cycle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>监控任务的生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-16-Future设计模式</title>
    <url>/2021/04/07/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-16-Future%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Future设计模式"><a href="#Future设计模式" class="headerlink" title="Future设计模式"></a>Future设计模式</h1><p>下面是Future设计模式涉及的关键接口以及它们之间的关系UML 图</p>
<p><img src="/uploads/java-concurrency-master/design_future.png"></p>
<h1 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h1><h2 id="1-Future接口定义"><a href="#1-Future接口定义" class="headerlink" title="1.Future接口定义"></a>1.Future接口定义</h2><p>Future提供了获取计算结果和判断任务是否完成的两个接口，其中获取计算结果将会导致调用阻塞（在任务还未完成的情况下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 返回计算后的结果，该方法会陷入阻塞的状态</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断任务是否 已经被执行完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">done</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-FutureService接口设计"><a href="#2-FutureService接口设计" class="headerlink" title="2.FutureService接口设计"></a>2.FutureService接口设计</h2><p>FutureService 主要用于提交任务，提交任务主要有2种，第一种不需要返回值，第二种则需要获得最终的计算结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FutureService</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交不需要返回值的任务 ，future.get方法返回的将会是 null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable runnable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交需要返回值的任务，其中task接口代替了RUnnable 接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Future&lt;OUT&gt; <span class="title">submit</span><span class="params">(Task&lt;IN, OUT&gt; task, IN input, Callback&lt;OUT&gt; callback)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用静态方法 创建一个FutureService 的实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T, R&gt; <span class="function">FutureService&lt;T, R&gt; <span class="title">newService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureServiceImpl&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Task接口设计"><a href="#3-Task接口设计" class="headerlink" title="3.Task接口设计"></a>3.Task接口设计</h2><p>Task接口主要是提供给调用者实现计算逻辑使用的，可以接受一个参数并且返回最终的计算结果，这一点非常类似于 JDK1.5中的Callable接口，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Task</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定一个参数，经过计算返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">OUT <span class="title">get</span><span class="params">(IN input)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>FutureTask 是Future的一个实现，除了实现Future 中定义的方法，还额外增加了 finish ，该方法主要用于接收任务被完成的通知，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;   <span class="comment">//计算结果</span></span><br><span class="line">    <span class="keyword">private</span> T result;</span><br><span class="line">    <span class="comment">//任务是否完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDone = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 定义对象锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="comment">// 当任务还没有完成时，调用get方法会被挂起而进入阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (!isDone) &#123;</span><br><span class="line">                LOCK.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回最终计算结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * finish 方法主要用于为 FutureTask 设置计算结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="comment">// balking设计模式</span></span><br><span class="line">            <span class="keyword">if</span> (isDone)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//计算完成，为result 指定结果，并且将isDone 设为true，同时唤醒阻塞中的线程</span></span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">            <span class="keyword">this</span>.isDone = <span class="keyword">true</span>;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前任务是否已经完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="FutureServiceImpl"><a href="#FutureServiceImpl" class="headerlink" title="FutureServiceImpl"></a>FutureServiceImpl</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要作用在于当提交任务时，创建一个新的线程来受理该任务，进而达到任务异步执行的效果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;IN&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;OUT&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureServiceImpl</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt; <span class="keyword">implements</span> <span class="title">FutureService</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 为执行的线程执行名字前缀，（再三强调，为线程起一个特殊的名字是一个非常好的编程习惯）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String FUTURE_THREAD_PREFIX = <span class="string">&quot;FUTURE-&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger nextCounter = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getNextName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FUTURE_THREAD_PREFIX + nextCounter.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable runnable) &#123;</span><br><span class="line">        <span class="keyword">final</span> FutureTask&lt;Void&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">            <span class="comment">// 任务执行结束之后将null作为结果传给future</span></span><br><span class="line">            future.finish(<span class="keyword">null</span>);</span><br><span class="line">        &#125;, getNextName()).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;OUT&gt; <span class="title">submit</span><span class="params">(Task&lt;IN, OUT&gt; task, IN input, Callback&lt;OUT&gt; callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> FutureTask&lt;OUT&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            OUT result = task.get(input);</span><br><span class="line">            <span class="comment">// 任务执行结束之后，将真实的结果通过finish方法 传递给future</span></span><br><span class="line">            future.finish(result);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != callback)</span><br><span class="line">                callback.call(result);</span><br><span class="line">        &#125;, getNextName()).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        FutureService&lt;String, Integer&gt; service = FutureService.newService();</span><br><span class="line">        service.submit(input -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> input.length();</span><br><span class="line">        &#125;, <span class="string">&quot;Hello&quot;</span>, System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>todo 优化</p>
<ul>
<li>将提交的任务交给线程池运行，</li>
<li>get方法没有超时功能，如果获取一个计算结果在规定时间内没有返回，则可以抛出异常通知调用线程</li>
<li>Future未提供Cancel功能，当任务提交之后还可以对其进行取消</li>
<li>任务运行时出错未提供回调方式</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>Future设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>redis入门-01</title>
    <url>/2021/03/11/redis%E5%85%A5%E9%97%A8-01/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="传统的ACID"><a href="#传统的ACID" class="headerlink" title="传统的ACID"></a>传统的ACID</h2><p>关系型数据库遵循ACID规则<br>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p>
<p>1、A (Atomicity) 原子性<br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</p>
<p>2、C (Consistency) 一致性<br>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</p>
<p>3、I (Isolation) 独立性<br>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的</p>
<p>4、D (Durability) 持久性<br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</p>
<h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>C:Consistency（强一致性）</p>
<p>A:Availability（可用性）</p>
<p>P:Partition tolerance（分区容错性）</p>
<h3 id="CAP的三进二"><a href="#CAP的三进二" class="headerlink" title="CAP的三进二"></a>CAP的三进二</h3><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。<br>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以</p>
<p><strong>分区容忍性是我们必须需要实现的。</strong></p>
<p><strong>所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点</strong>。</p>
<p><strong>C:强一致性 A：高可用性 P：分布式容忍性</strong></p>
<ul>
<li><p>CA 传统Oracle数据库 </p>
</li>
<li><p>AP 大多数网站架构的选择</p>
</li>
<li><p>CP Redis、Mongodb</p>
<p>注意：分布式架构的时候必须做出取舍。<br>一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向</p>
</li>
</ul>
<h4 id="一致性与可用性的决择"><a href="#一致性与可用性的决择" class="headerlink" title="一致性与可用性的决择"></a>一致性与可用性的决择</h4><p>​    对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地</p>
<h4 id="数据库事务一致性需求"><a href="#数据库事务一致性需求" class="headerlink" title="数据库事务一致性需求"></a>数据库事务一致性需求</h4><p>​    很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。</p>
<h4 id="数据库的写实时性和读实时性需求"><a href="#数据库的写实时性和读实时性需求" class="headerlink" title="数据库的写实时性和读实时性需求"></a>数据库的写实时性和读实时性需求</h4><p>​    对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</p>
<h4 id="对复杂的SQL查询，特别是多表关联查询的需求"><a href="#对复杂的SQL查询，特别是多表关联查询的需求" class="headerlink" title="对复杂的SQL查询，特别是多表关联查询的需求"></a>对复杂的SQL查询，特别是多表关联查询的需求</h4><p>　　任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p>
<h3 id="经典CAP图"><a href="#经典CAP图" class="headerlink" title="经典CAP图"></a>经典CAP图</h3><p> CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，<br>最多只能同时较好的满足两个。<br>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：<br>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。<br>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。<br>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p>
<p><img src="/uploads/redis/Image.bmp"></p>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p>
<p>BASE其实是下面三个术语的缩写：<br>    基本可用（Basically Available）<br>    软状态（Soft state）<br>    最终一致（Eventually consistent）</p>
<p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p>
<h1 id="REDIS-入门"><a href="#REDIS-入门" class="headerlink" title="REDIS 入门"></a>REDIS 入门</h1><h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><ul>
<li>内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，同时不影响继续服务</li>
<li>取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面</li>
<li>模拟类似于HttpSession这种需要设定过期时间的功能</li>
<li>发布、订阅消息系统</li>
<li>定时器、计数器</li>
</ul>
<h2 id="基础知识讲解"><a href="#基础知识讲解" class="headerlink" title="基础知识讲解"></a>基础知识讲解</h2><ul>
<li><p>单进程模型来处理客户端的请求。对读写等事件的响应是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</p>
</li>
<li><p>Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
</li>
<li><p>默认16个数据库，类似数组下表从零开始，初始默认使用零号库</p>
</li>
<li><p>Select命令切换数据库</p>
</li>
<li><p>Dbsize查看当前数据库的key的数量</p>
</li>
<li><p>Flushdb：清空当前库</p>
</li>
<li><p>Flushall；通杀全部库</p>
</li>
<li><p>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</p>
</li>
<li><p>Redis索引都是从零开始</p>
</li>
<li><p>为什么默认端口是6379</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p>
<p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
<h3 id="Hash（哈希，类似java里的Map）"><a href="#Hash（哈希，类似java里的Map）" class="headerlink" title="Hash（哈希，类似java里的Map）"></a>Hash（哈希，类似java里的Map）</h3><p>Hash（哈希）<br>Redis hash 是一个键值对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象</p>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表</p>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的，</p>
<h3 id="Zset-sorted-set：有序集合"><a href="#Zset-sorted-set：有序集合" class="headerlink" title="Zset(sorted set：有序集合)"></a>Zset(sorted set：有序集合)</h3><p>zset(sorted set：有序集合)<br>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><p><a href="http://redisdoc.com/">http://redisdoc.com/</a></p>
<h3 id="Redis-键-key"><a href="#Redis-键-key" class="headerlink" title="Redis 键(key)"></a>Redis 键(key)</h3><p><img src="/uploads/redis/redis_key.bmp"></p>
<ul>
<li> keys *</li>
<li> exists key的名字，判断某个key是否存在</li>
<li> move key db   —&gt;当前库就没有了，被移除了</li>
<li> expire key 秒钟：为给定的key设置过期时间</li>
<li> ttl key 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li>
<li> type key 查看你的key是什么类型</li>
</ul>
<h3 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a>Redis字符串(String)</h3><p><img src="/uploads/redis/redis-string01.bmp"></p>
<p><img src="/uploads/redis/redis-string02.bmp"></p>
<ul>
<li><p>set/get/del/append/strlen</p>
</li>
<li><p>Incr/decr/incrby/decrby,一定要是数字才能进行加减</p>
</li>
<li><p>getrange/setrange</p>
</li>
<li><p> setex(set with expire)键秒值/setnx(set if not exist)</p>
</li>
<li><p>mset/mget/msetnx</p>
</li>
<li><p>getset(先get再set)</p>
</li>
</ul>
<h3 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h3><p><img src="/uploads/redis/redis-list01.bmp"></p>
<p><img src="/uploads/redis/redis-list02.bmp"></p>
<ul>
<li>lpush/rpush/lrange</li>
<li> lpop/rpop</li>
<li> lindex，按照索引下标获得元素(从上到下)</li>
<li>llen</li>
<li> lrem key 删N个value</li>
<li> ltrim key 开始index 结束index，截取指定范围的值后再赋值给key</li>
<li> rpoplpush 源列表 目的列表</li>
<li> lset key index value</li>
<li> linsert key  before/after 值1 值2</li>
<li>它是一个字符串链表，left、right都可以插入添加；<br>如果键不存在，创建新的链表；<br>如果键已存在，新增内容；<br>如果值全移除，对应的键也就消失了。<br>链表的操作无论是头和尾效率都极高，但假如是对中间元素进行操作，效率就很惨淡了。</li>
</ul>
<h3 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h3><p><img src="/uploads/redis/redis-set.bmp"></p>
<ul>
<li>sadd/smembers/sismember</li>
<li> scard，获取集合里面的元素个数</li>
<li> srem key value 删除集合中元素</li>
<li> srandmember key 某个整数(随机出几个数)</li>
<li> spop key 随机出栈</li>
<li> smove key1 key2 在key1里某个值      作用是将key1里的某个值赋给key2</li>
<li>数学集合类<ul>
<li>差集：sdiff</li>
<li>交集：sinter</li>
<li>并集：sunion</li>
</ul>
</li>
</ul>
<h3 id="Redis哈希-Hash"><a href="#Redis哈希-Hash" class="headerlink" title="Redis哈希(Hash)"></a>Redis哈希(Hash)</h3><p><img src="/uploads/redis/redis-hash.bmp"></p>
<ul>
<li>hset/hget/hmset/hmget/hgetall/hdel</li>
<li>hlen</li>
<li> hexists key 在key里面的某个值的key</li>
<li>hkeys/hvals</li>
<li> hincrby/hincrbyfloat</li>
<li> hsetnx</li>
</ul>
<h3 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h3><p><img src="/uploads/redis/redis-zset01.bmp"></p>
<p><img src="/uploads/redis/redis-zset02.bmp"></p>
<ul>
<li>zadd/zrange</li>
<li> zrangebyscore key 开始score 结束score</li>
<li> zrem key 某score下对应的value值，作用是删除元素</li>
<li> zcard/zcount key score区间/zrank key values值，作用是获得下标值/zscore key 对应值,获得分数</li>
<li> zrevrank key values值，作用是逆序获得下标值</li>
<li> zrevrange</li>
<li> zrevrangebyscore  key 结束score 开始score</li>
</ul>
<h2 id="解析配置文件redis-conf"><a href="#解析配置文件redis-conf" class="headerlink" title="解析配置文件redis.conf"></a>解析配置文件redis.conf</h2><p>TODO</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-01-自动内存管理</title>
    <url>/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-01-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h1><h2 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h2><p><img src="/uploads/jvm/01-runtimedatazone.png"></p>
<h3 id="程序计数器-（线程私有的）"><a href="#程序计数器-（线程私有的）" class="headerlink" title="程序计数器  （线程私有的）"></a>程序计数器  （线程私有的）</h3><p>Program Counter Register， 可以看作是当前线程执行字节码的行号指示器</p>
<ul>
<li><p><strong><em>字节码解释器</em></strong>  工作时 通过改变**<em>程序计数器**</em> 的值，来选取下一条需要执行的字节码指令 。</p>
<p>相当于时程序控制流的 指示器，告诉jvm 下一条要执行的命令是什么 。 分支、循环、跳转、异常处理、线程恢复等 都依赖 改变 程序计数器 值来完成  </p>
</li>
</ul>
<ul>
<li><p>jvm 的多线程是通过线程 轮流切换、分配处理器执行时间的方式实现的。 </p>
</li>
<li><p>在任何一个确定的时间，处理器只会处理某一个线程中的指令。为了确保线程切换回去后，能恢复到之前 线程的正确执行位置，</p>
<p>所以每条线程都有独立的 <strong><em>程序计数器</em></strong> ，各个线程之间的程序计数器 互相隔离，互不影响干扰，独立存储</p>
<p><strong>所以 说 程序计数器是 线程私有的</strong></p>
</li>
<li><p>如果A线程执行 的是java方法，计数器记录的是 字节码指令的地址 。</p>
</li>
<li><p>如果B线程执行的是 本地Native 方法，计数器记录的是 空 undefined</p>
</li>
</ul>
<h3 id="Java虚拟机栈（线程私有的）"><a href="#Java虚拟机栈（线程私有的）" class="headerlink" title="Java虚拟机栈（线程私有的）"></a>Java虚拟机栈（线程私有的）</h3><p>Java Virtual Machine Stack 也是线程私有的。所以它的生命周期 和线程相同</p>
<ul>
<li><p><strong>为 执行Java 方法 服务</strong></p>
</li>
<li><p><strong><em>java虚拟机栈</em></strong>  描述的是java方法执行的<strong>线程内存模型</strong> </p>
</li>
<li><p>每个方法被执行的时候，jvm都会同步创建一个<strong>栈帧 （stack frame）</strong>，用于存储 <strong>局部变量表</strong>、操作数栈、动态连接、方法出口等信息</p>
</li>
<li><p>一个方法从 被调用执行 到 执行完毕的过程，对应这一个 栈帧 从虚拟机栈从 入栈到 出栈的过程 </p>
</li>
<li><p>ps : 程序员口中 笼统的 将java 内存分为 堆内存（Heap）和 栈内存（Stack） 。栈内存指的就是  <strong><em>java虚拟机栈</em></strong>  ，再具体一点就是 其中的 <strong><em>局部变量表</em></strong></p>
</li>
<li><p><strong><em>栈帧（Stack Frame）是方法运行期很重要的 基本数据结构</em></strong></p>
</li>
</ul>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul>
<li><p>存放 了编译期可知的 各种java 基本数据类型 （boolean、byte、char、short、int、long、float、double）</p>
</li>
<li><p>存放了各类对象引用类型 （reference）（不是真的对象，是对象的地址 或者句柄）</p>
</li>
<li><p>存放了 returnAdress 类型 （指向了一条 字节码指令 的地址）</p>
</li>
</ul>
<ul>
<li>存储空间的单位 用 局部变量槽（Slot）来表示， 所以 局部变量表的大小，指的 就是 变量槽 的数量，比如 64位长度的long 和double占用2个 Slot，其他类型1个Slot </li>
</ul>
<ul>
<li>在该区域，存在2中异常情况<ul>
<li>如果线程请求的栈深度 大于jvm 允许的深度， 抛出 StackOverflowError</li>
<li>如果java虚拟机栈 允许 动态扩展，但是申请不到足够内存，抛出 OutofMemoryErrory </li>
</ul>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>Native Method Stack</p>
<ul>
<li><strong><em>为执行本地方法 (Native Method)服务</em></strong></li>
<li> 也会报 栈深度溢出 （Stack Overflow error）和 栈扩展异常 （OutOfMemoryError）</li>
</ul>
<h3 id="Java-堆（Heap）（线程共享）"><a href="#Java-堆（Heap）（线程共享）" class="headerlink" title="Java 堆（Heap）（线程共享）"></a>Java 堆（Heap）（线程共享）</h3><ul>
<li>java 堆是JVM 管理的内存中 <strong><em>最大的一块</em></strong> </li>
<li><strong><em>所有线程共享</em></strong>的 内存区域</li>
<li>用于存放对象实例，Java世界里 **“几乎” **所有的对象实例都在这里分配内存 </li>
<li>因为有可能未来出现 <strong><em>值类型</em></strong>，并且 因为**<em>逃逸分析**</em>技术的发展，栈上分配、标量替换优化手段 ，所以 不是全部java对象都在Heap上分配内存</li>
</ul>
<ul>
<li><p>java 堆是GC管理的内存区域，所以也称为 <strong><em>GC堆</em></strong></p>
</li>
<li><p>以前的GC 器 大部分使用的是 <strong>经典分代收集</strong> 理论设计的，所以 将java堆 化为为 新生代、老年代、永久代、Eden区，2个Survivor 。但是现在 也存在不使用 分代收集的 GC器 </p>
</li>
<li><p>所有线程共享的java堆 可以划分出 多个线程私有的  <strong><em>分配缓冲区******（Thread Local Allocation Buffer，TLAB）</em></strong>，用于  <strong>提高分配内存的效率</strong></p>
</li>
<li><p>不管如果将 java堆细分，java堆都是<strong>存储 对象的实例</strong>，更细的划分只是为了<strong>更好的回收内存或者更好的分配内存</strong>  </p>
</li>
<li><p>java堆 即可设计成固定大小的，也可以 设计成 可扩展的 ，</p>
</li>
<li><p>当前大部分 JVM都是设计成 可扩展的 ，通过 <strong>（-Xmx 和-Xms ）</strong>设定</p>
</li>
<li><p>如果堆 没有内存完成 实例分配，并且 堆也不可扩展时候，JVM 会抛出 OutOfMemoryError  (OOM)</p>
</li>
</ul>
<h3 id="方法区-非堆-Non-Heap-（线程共享）"><a href="#方法区-非堆-Non-Heap-（线程共享）" class="headerlink" title="方法区 (非堆 Non-Heap)（线程共享）"></a>方法区 (非堆 Non-Heap)（线程共享）</h3><p>Method Area</p>
<ul>
<li><p>用于存储已经被JVM加载的类型信息 、常量、静态变量、即时编译器编译后的代码缓存等数据  </p>
</li>
<li><p>《java虚拟机规范》将方法区描述为 堆的一个逻辑部分，别名为  <strong><em>“非堆”</em></strong>（**<em>Non-Heap）**</em>，用于和 java堆 区分开来</p>
</li>
<li><p>在Java8以前，把 方法区成为 “永久代（Permanent Generation）” ，但本质上2者 并不是等价的。   </p>
</li>
<li><p>因为当时 团队把GC的分代设计  扩展到了方法区， 使用了 永久代 来实现方法区的收集 。当时 希望像管理 java堆 一样的方式管理 方法区这一部分内存 。这样就可以 <strong><em>不用专门为 方法区 编写内存管理的代码</em></strong> ， </p>
</li>
<li><p>但是后面经过验证发现 永久代的实现更容易引起 OOM，永久代有 （-XX: MaxPermSize的上限 ，即使不设置也会有默认值）</p>
</li>
<li><p>所以java8的版本 完全废弃了 永久代的概念， 使用**<em>元空间**</em> （Meta-space） 来代替 。（使用本地内存管理的 方式 实现）</p>
</li>
<li><p>对方法区的内存回收目标：主要是针对 常量池的回收和类型的卸载 。回收效果不是很棒，但是又不能不管</p>
</li>
<li><p>GC 操作在该区域的频率是很少的 ，如同它的前称 “永久代”的名字一样 </p>
</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>runtime constant pool ，是方法区的一部分 。</p>
<ul>
<li>Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是 <strong><em>常量池表（Constant Pool Table）</em></strong>，用于 存放编译期生成的各种字面量和 符号引用。</li>
<li>常量池表 就是放在 运行时常量池 中</li>
<li>运行时常量池  具备 动态性，java 语言并不要求常量一定在编译期才能产生，运行时也可以将新的常量放在池中 ，如： String的 intern()方法</li>
<li>因为  运行时常量池 是方法区的一部分，所以也受 方法区的内存现在，当申请不到内存的时候，也会报  OOM</li>
<li></li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>Direct Memory ,并不是JVM运行时数据区的一部分 ，也不是《java虚拟机规范》中定义的内存区域，但是这部分内存频繁被使用， 也可能抛出 OOM </p>
<ul>
<li><p>JDK 1.4中假如 NIO（new Input/Output）类，引入了一种基于通道（Channel）与缓冲区的 I/O方式 ，它可以使用Native 函数库 直接分配 堆外内存，然后</p>
<p>通过一个存储在java堆 里面的DirectByBuffer 对象作为 这块内存的引用进行操作，这样 避免java堆 和Native堆中 来回复制对象 。</p>
</li>
</ul>
<ul>
<li>直接内存的分配不会受 java堆大小的限制，但是 受到 计算机总内存 大小的限制 。</li>
<li>一般 服务器管理员管理虚拟机配置的时候 ，会更根据实际内存 设置 -Xmx的大小，但经常忽略掉 直接内存。  导致 各个内存区域 总和 大于 物理内存限制 。 从而动态扩展的时候出现  OOM</li>
</ul>
<h2 id="Java对象的创建"><a href="#Java对象的创建" class="headerlink" title="Java对象的创建"></a>Java对象的创建</h2><p>jvm 会进行类加载操作，类加载操作完成后，对象实例所需的内存大小就已经确定了 ，然后就需要对java对象实例 进行 内存分配了。 </p>
<h3 id="分配内存的方式"><a href="#分配内存的方式" class="headerlink" title="分配内存的方式"></a>分配内存的方式</h3><p>为对象分配内存任务的操作，就等同于 把一块确定大小的 内存 从java堆中分配出来 </p>
<h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><ul>
<li><p>如果 java堆中 内存时决定规整的，所有被使用的内存 都被放在 一边，空闲的内存被放在另一边，中间放着一个**<em>指针**</em>   为分界点的指示器 ，</p>
</li>
<li><p>那所分配内存就仅仅时把 指针 往空闲空间方向挪动一段与 对象大小相等的距离 ，这种分配称为 <strong><em>指针碰撞（Bump The Pointer）</em></strong></p>
</li>
</ul>
<h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><ul>
<li><p>如果java堆中的内存不是规整的 ，已经被使用的内存 和空闲的内存相互交错在一起， 那么虚拟机就需要 维护一个列表，记录那些内存块 时可用的。</p>
</li>
<li><p> 在分配内存 的时候，找到一块足够大的空间划分给 对象实例，并更新列表上的记录，这种方式称为 <strong><em>空闲列表（Free List）</em></strong></p>
</li>
</ul>
<p>java堆是否规整，取决于 GC器是否带有空间压缩整理（Compact）的能力决定，因此</p>
<p>因此，</p>
<ul>
<li>当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；</li>
<li>当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。</li>
</ul>
<h3 id="解决-分配内存空间的并发问题"><a href="#解决-分配内存空间的并发问题" class="headerlink" title="解决 分配内存空间的并发问题"></a>解决 分配内存空间的并发问题</h3><ul>
<li><p>对进行分配内存空间的操作进行同步处理，保证更新操作的原子性</p>
</li>
<li><p>把内存分配动作安装线程划分在不同的 空间中进行。即 每个线程在 java堆中预先分配一小块内存 ，称为 本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）。线程分配内存的时候，先在该线程的本地缓冲区 中分配。当本地缓冲区用完了，分配新的缓冲区时候，才需要同步锁定 。</p>
<p>使用 -XX: +/-UseTLAB 参数来设定</p>
</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在堆内存中的存储布局分为3部分</p>
<ul>
<li><p>对象头（Header）</p>
<p>对象头部分包含2类信息</p>
<ul>
<li>“Mark Word” ：用于存储对象自身的运行时数据 ，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li>
<li>类型指针： 即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例</li>
</ul>
</li>
<li><p>实例数据（Instance Data）</p>
<ul>
<li><p>实例数据是  对象真正存储的有效信息，即 程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
</li>
<li><p>这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。</p>
</li>
<li><p>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs），</p>
</li>
<li><p>从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</p>
</li>
</ul>
</li>
<li><p>对齐填充（Padding）</p>
<ul>
<li><p>这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</p>
</li>
<li><p>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。</p>
</li>
<li><p>对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），</p>
</li>
<li><p>因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
</li>
</ul>
</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>创建对象自然是为了后续使用该对象，java通过栈上的reference数据来操作堆上的具体对象。 </p>
<p>主流的访问方式使用使用 句柄 和 直接指针 这两种：</p>
<h3 id="句柄的方式"><a href="#句柄的方式" class="headerlink" title="句柄的方式"></a>句柄的方式</h3><p>java堆中划出 一块内存作为句柄池，reference 中存储的就是对象的句柄地址 。而 句柄中包含对象的实例数据与类型数据各自的具体地址信息 </p>
<p><img src="/uploads/jvm/02-handlePool.png"></p>
<h3 id="直接使用指针的方式："><a href="#直接使用指针的方式：" class="headerlink" title="直接使用指针的方式："></a>直接使用指针的方式：</h3><p>java堆中的内存布局 必须考虑如何放置 类型数据的相关信息 。reference 存储的直接就是对象地址 。如果只是访问对象本身的话，不需要多一次间接访问的开销 。</p>
<p><img src="/uploads/jvm/03-redirectPointer.png"></p>
<h3 id="两种方式各有优势"><a href="#两种方式各有优势" class="headerlink" title="两种方式各有优势"></a>两种方式各有优势</h3><ul>
<li>使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（GC时候移动对象是非常普遍的行为）时，只会改变句柄中的实例数据指针，而reference本身不需要被修改 </li>
<li>使用直接指针的好处就是 速度更快，节省了一次指针定位的时间开销，由于对象访问非常频繁，因为这类开销积少成多后是 非常可观的执行成本</li>
<li>hotspot 使用的就是  直接指针</li>
</ul>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>方法区和java堆 是线程共享的 ，虚拟机栈、本地方法栈、程序计数器都是线程私有的 </li>
<li>虚拟机栈描述了java 方法执行的 线程内存模型，一个java方法被调用，jvm就会创建一个对应的栈帧（stackFrame），方法的执行开始到结束对应这一个栈帧的入栈和出栈。</li>
<li>局部变量表是 虚拟机栈的一部分，里面存储了 编译期 可知的8种基本数据类型（short，int，long，double，float，byte，char，boolean）、引用类型reference（存储对象的地址 或者句柄），returnAdress返回地址类型（存储的是一个字节码的指令地址 ）</li>
<li>java 堆是gc管理的区域，将gc堆进行精细的划分区域是分了更高效的分配和回收内存 。</li>
<li>以前的GC 器 大部分使用的是 <strong>经典分代收集</strong> 理论设计的，所以 将java堆 化为为 新生代、老年代、永久代、Eden区，2个Survivor 。但是现在 也存在不使用 分代收集的 GC器 </li>
<li>java堆用于存储对象实例 </li>
<li>方法区用于存储类型信息、常量、静态变量， java8以前使用永久代的方式 收集该区域内存 ，后面使用<strong>本地内存方式实现的元空间</strong>代替永久代 , GC的行为在这个区域发生的频率很低，这个区域的回收目标主要是针对 常量池的回收和对类型的卸载 。所以称为 永久代一点不为过</li>
<li>分配内存的2种方式 ：指针碰撞（内存区域是否规整，GC器是否具有空间压缩功能）、空闲列表（）</li>
<li>分配内存时候如何防止并发：<ul>
<li>1种 是对分配内存空间的操作进行同步处理（cas配上失败重试的方式保证原子性）</li>
<li>本地线程分配缓冲（THread local allocation buffer），先预先给每个线程分配一小块内存，线程需要创建对象分配内存是否，先在线程的缓冲区分配，不够了再分配新的缓冲区 </li>
</ul>
</li>
<li>访问定位对象的2种方式： <ul>
<li>句柄，在java堆划出一个句柄池区域，java栈本地变量表 reference 存储句柄池的地址 ，句柄中存储 到对象实例数据和对象类型数据的  指针 。  这样的好处在于 当对象发生移动时候，java栈中存储的reference 不需要改变，只需要改变句柄的指针就可以 </li>
<li>直接指针 ：java方法栈 reference存储的就是 对象的地址 ，好处就是定位迅速 </li>
</ul>
</li>
<li>元空间的异常 有可能发生在 ：spring或者hirbernate 的动态增强，生成大量的 动态类的场景中。</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>自动内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-03-垃圾收集器</title>
    <url>/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-03-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="垃圾收集需要完成的3件事情"><a href="#垃圾收集需要完成的3件事情" class="headerlink" title="垃圾收集需要完成的3件事情"></a>垃圾收集需要完成的3件事情</h2><ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如果回收</li>
</ul>
<h2 id="为什么要了解gc-和内存分配："><a href="#为什么要了解gc-和内存分配：" class="headerlink" title="为什么要了解gc 和内存分配："></a>为什么要了解gc 和内存分配：</h2><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="运行时数据区域："><a href="#运行时数据区域：" class="headerlink" title="运行时数据区域："></a>运行时数据区域：</h2><h3 id="线程隔离区域"><a href="#线程隔离区域" class="headerlink" title="线程隔离区域"></a>线程隔离区域</h3><ul>
<li><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。</p>
</li>
<li><p>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，</p>
</li>
<li><p>当方法结束或者线程结束时，内存自然就跟随着回收了。</p>
</li>
</ul>
<h3 id="线程共享区域"><a href="#线程共享区域" class="headerlink" title="线程共享区域"></a>线程共享区域</h3><ul>
<li><p>Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，</p>
</li>
<li><p>只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的</p>
</li>
<li><p>所以 GC 关注的就是这部分区域的内存管理 （分配和回收）</p>
</li>
</ul>
<h2 id="判断对象“死亡”"><a href="#判断对象“死亡”" class="headerlink" title="判断对象“死亡”"></a>判断对象“死亡”</h2><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul>
<li>在对象中添加一个**<em>引用计数器**</em>，</li>
<li>每当有一个地方引用它时，计数器值就加一；</li>
<li>当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的</li>
</ul>
<p>主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p>
<p>举个简单的例子，请看代码中的testGC()方法：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * testGC()方法执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testGC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">14622</span>K-&gt;<span class="number">1008</span>K(<span class="number">153088</span>K)] <span class="number">14622</span>K-&gt;<span class="number">1016</span>K(<span class="number">502784</span>K), <span class="number">0.0007592</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap after GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">153088</span>K, used <span class="number">1008</span>K [<span class="number">0x0000000715980000</span>, <span class="number">0x0000000720400000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space <span class="number">131584</span>K, <span class="number">0</span>% used [<span class="number">0x0000000715980000</span>,<span class="number">0x0000000715980000</span>,<span class="number">0x000000071da00000</span>)</span><br><span class="line">  from space <span class="number">21504</span>K, <span class="number">4</span>% used [<span class="number">0x000000071da00000</span>,<span class="number">0x000000071dafc040</span>,<span class="number">0x000000071ef00000</span>)</span><br><span class="line">  to   space <span class="number">21504</span>K, <span class="number">0</span>% used [<span class="number">0x000000071ef00000</span>,<span class="number">0x000000071ef00000</span>,<span class="number">0x0000000720400000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">349696</span>K, used <span class="number">8</span>K [<span class="number">0x00000005c0c00000</span>, <span class="number">0x00000005d6180000</span>, <span class="number">0x0000000715980000</span>)</span><br><span class="line">  object space <span class="number">349696</span>K, <span class="number">0</span>% used [<span class="number">0x00000005c0c00000</span>,<span class="number">0x00000005c0c02000</span>,<span class="number">0x00000005d6180000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3118</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 338<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>从运行结果中可以清楚看到内存回收日志，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li><p>基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为<strong>“引用链”（Reference Chain）</strong></p>
</li>
<li><p><strong>如果某个对象到GC Roots间没有任何引用链相连</strong>，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
</li>
</ul>
<p><img src="/uploads/jvm/04-gcRoot.png"></p>
<p>在Java技术体系里面，固定可作为**<em>GC Roots**</em>的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p>ps:  当只针对 java堆中的某一块区域发起GC的时候，  使用局部回收 或者 分代回收 ，需要想到 各个区域并不是孤立封闭的，某个区域里 的对象很有可能被 堆中的其他区域对象引用，所以 这些关联区域的对象也要一起 加入到 GC Roots集合中 去，才能保证 可达性分析的正确性</p>
<h2 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用 reference"></a>引用 reference</h2><ul>
<li><p>无论是通过计数器法 判断对象的引用数量，还是通过可达性分析算法 判断对象是否引用链可达。 判断对象是否存活 都和 “引用” 离不开关系 。</p>
</li>
<li><p>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用</p>
</li>
</ul>
<h3 id="强引用（Strongly-Re-ference）"><a href="#强引用（Strongly-Re-ference）" class="headerlink" title="强引用（Strongly Re-ference）"></a>强引用（Strongly Re-ference）</h3><ul>
<li><p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Objectobj=new Object()”这种引用关系。</p>
</li>
<li><p>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
</li>
</ul>
<h3 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h3><ul>
<li><p>用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，</p>
</li>
<li><p>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，</p>
</li>
<li><p>如果这次回收还没有足够的内存，才会抛出内存溢出异常</p>
</li>
</ul>
<h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h3><ul>
<li>用来描述那些非必须对象，但是它的强度比软引用更弱一些，</li>
<li>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</li>
<li>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li>
</ul>
<h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h3><h2 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h2><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，</p>
<p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ul>
<li><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，</p>
</li>
<li><p>随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。</p>
</li>
<li><p>假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
</li>
</ul>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。</p>
<p>原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> * 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, i am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">    finalize method executed!</span><br><span class="line">yes, i am still alive :)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure>

<p>运行结果可以看到，</p>
<ul>
<li>SAVE_HOOK对象的finalize()方法确实被垃圾收集器触发过，并且在被收集前成功逃脱了。</li>
<li>另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。</li>
<li>这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><ul>
<li>方法区垃圾收集的“性价比”通常也是比较低的：</li>
</ul>
<p>在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p>
<ul>
<li>方法区的垃圾收集主要回收两部分内容：<strong>废弃的常量</strong> 和<strong>不再使用的类型</strong></li>
</ul>
<p>关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClass-Loading、</p>
<p>-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，</p>
<ul>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压<br>力。</li>
</ul>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>对于线程私有的 本地方法栈、虚拟机栈、程序计数器 跟随线程的生命周期 ，每个方法的调用和退出对应着一个栈帧的入栈和出栈，栈帧的大小在类结构确定的时候，分配内存的大小就已经确认了，此处的内存回收是已知的，不用过多考虑</li>
<li>对于线程公有的区域： 方法区，java堆。 因为一个接口可能存在多个实现类，方法的不同分支产生的对象数量不等 ，所需的内存大小也不同。 这些都是动态的，只有在运行时期，我们才能确认这部分的数据。所以GC 主要管理的就是这部分的 内存（分配和回收）</li>
<li>判断对象是否死亡2种算法： 引用计数器，GCRoots可达性分析</li>
<li>引用：狭隘的引用概念： 如果reference类型的数据中存储的数值代表着  另一块内存的起始地址，就称 该 reference数据是 某块内存，某个对象的引用 。 后面又分 强引用，软引用，弱引用，虚引用 。</li>
<li>分代收集理论： 弱分代假说，</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-04-垃圾收集算法</title>
    <url>/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>两个分代假说：</p>
<h4 id="弱分代假说（Weak-Generational-Hypothesis）："><a href="#弱分代假说（Weak-Generational-Hypothesis）：" class="headerlink" title="弱分代假说（Weak Generational Hypothesis）："></a>弱分代假说（Weak Generational Hypothesis）：</h4><ul>
<li> 绝大多数对象都是朝生夕灭的 </li>
</ul>
<h4 id="强分代假说（Strong-Generaional-Hypothesis）："><a href="#强分代假说（Strong-Generaional-Hypothesis）：" class="headerlink" title="强分代假说（Strong Generaional Hypothesis）："></a>强分代假说（Strong Generaional Hypothesis）：</h4><ul>
<li> 熬过越多次GC过程的对象 就越难以消亡</li>
</ul>
<p>这两个分代假说共同奠定了多款常用GC器一致的设计原则：</p>
<ul>
<li>GC器应该将Java 堆Heap 划分出不同的区域，然后将回收对象依据其 年龄（对象熬过GC收集的次数） 分配到不同的区域进行存储 。</li>
<li>而不同的区域 因为其对象的不同特性，可以采用不同的垃圾收集算法 。</li>
<li>如果区域对象 大多数对象都是朝生夕灭 的，难以熬过GC过程的 ，那把他们放在一起，每次回收只标记那些少量存活的对象实例，这样就可以用少量代价回收大量空间</li>
<li>如果剩下的都是难以消亡的对象，就把这个年龄大的对象 集中放在一起，jvm使用低频率区回收这个区域。  </li>
<li>这样就兼顾了GC的时间开销 和内存空间的有效利用</li>
</ul>
<p>将java堆进行划分成 不同区域后，gc器 才可以每次只收集其中某一个 或某些部分的区域， 因此 出现了  MInor GC , Major GC, Full GC</p>
<p>这样的回收类型划分，</p>
<p>针对不同区域的，安排与里面存储对象存亡特征相匹配的 GC 算法，如 标记删除，标记复制，标记整理 </p>
<p>因为存在 跨代引用的场景，老年代与新生代 可能存在互相引用的情况，这样 纪要通过GCRoot的可达性分析 ，也要额外遍历整个老年代的对象 来确保可达性分析结果的正确性， 这样由很大的性能负担</p>
<p> 所以出行第三条经验法则</p>
<h4 id="跨代引用假说（Intergenerational-Reference-Hypothesis）："><a href="#跨代引用假说（Intergenerational-Reference-Hypothesis）：" class="headerlink" title="跨代引用假说（Intergenerational Reference Hypothesis）："></a>跨代引用假说（Intergenerational Reference Hypothesis）：</h4><ul>
<li><p>跨代引用相对于同代引用来说 仅仅占极少数</p>
</li>
<li><p>这其实是通过强分代假说和 弱分代假说逻辑推理得出的推论： </p>
</li>
<li><p>存在互相引用关系的2个对象，应该是倾向于同时生存和同时消亡的，</p>
</li>
<li><p>如果某个新生代对象存在跨代引用，那么由于老年代对象难以消亡，所以 新生代对象在GC过程的时候也难以消亡，从而得以存活。慢慢的随着 之前新生代对象的年龄的增长，它也会被 晋升到老年代之中，这时候就不存在 跨代引用了</p>
</li>
<li><p>ps:  依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描</p>
</li>
</ul>
<h2 id="GC-名词字典"><a href="#GC-名词字典" class="headerlink" title="GC 名词字典"></a>GC 名词字典</h2><ul>
<li><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li><p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p>
</li>
</ul>
<h2 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark-Sweep）算法"></a>标记-清除（Mark-Sweep）算法</h2><p>算法分为“标记”和“清除”两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，</li>
<li>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li>
<li>标记过程就是对象是否属于垃圾的判定过程，</li>
<li>后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过<br>程的执行效率都随对象数量增长而降低</li>
<li>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ul>
<p><img src="/uploads/jvm/05-mark-sweep.png"></p>
<h2 id="标记-复制（Mark-Copy）算法"><a href="#标记-复制（Mark-Copy）算法" class="headerlink" title="标记-复制（Mark-Copy）算法"></a>标记-复制（Mark-Copy）算法</h2><h3 id="半区复制-（Semispace-Copying）"><a href="#半区复制-（Semispace-Copying）" class="headerlink" title="半区复制 （Semispace Copying）"></a>半区复制 （Semispace Copying）</h3><ul>
<li><p>将可用内存按容量分为大小相等的2块 ，每次只使用其中1块 。 </p>
</li>
<li><p>当这一块的内存用完了，就将还存活的对象复制到另一块上面 ，</p>
</li>
<li><p>然后就将还存活的对象复制到另一块上面，</p>
</li>
<li><p>然后再把已经使用过的内存空间一次清理掉。 </p>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>如果内存中多数对象都是存活的，这种算法会产生大量的内存间的复制 开销</p>
</li>
<li><p><strong><em>但是</em></strong>   在新生代这个 内存区域，98%的对象实例都熬不过第一轮收集，所以 不是算法有问题，是将算法 没有用到对的区域</p>
</li>
<li><p> 因为多数对象都是可回收的状态，所以算法复制的就是占少数的存活对象 </p>
</li>
<li><p>而且因为每次都是针对整个半区进行回收，分配内存时候也不用考虑 空间碎片整理的情况，只需要移动堆顶指针，按顺序分配即可，简单 高效</p>
</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>复制回收算法的代价是 将内存缩小一半，空间浪费未免太多了一点</li>
</ul>
<p><img src="/uploads/jvm/06-mark_copy.png"></p>
<h3 id="优化半区复制-（Appel式回收）"><a href="#优化半区复制-（Appel式回收）" class="headerlink" title="优化半区复制 （Appel式回收）"></a>优化半区复制 （Appel式回收）</h3><p>因为IBM 对 对象的朝生夕灭 特点做了调研，新生代中的对象 98% 熬不过第一轮收集，所以 提出了优化版的半区复制算法，即： </p>
<p>Appel 式回收：</p>
<h4 id="具体做法："><a href="#具体做法：" class="headerlink" title="具体做法："></a>具体做法：</h4><ul>
<li>将新生代  分为一块较大的Eden区（80%）  + Survivor_1（10%）+Survivor_2（10%）</li>
<li>每次分配内存时候，只使用 Eden（80%） 和 Survivor_1（10%），而 Survivor_2（10%）就暂时浪费掉</li>
<li>当 发生 GC的时候，就将 Eden（80%） 和 Survivor_1（10%）中的存活对象 复制到 Survivor_2（10%） 中</li>
<li>然后直接清理掉Eden（80%） 和 Survivor_1（10%）</li>
</ul>
<h4 id="逃生门”的安全设计（分配担保）："><a href="#逃生门”的安全设计（分配担保）：" class="headerlink" title="逃生门”的安全设计（分配担保）："></a>逃生门”的安全设计（分配担保）：</h4><p>98%的对象都熬不过第一轮GC 这个是 普通场景， 没有人能保证 每一次 GC后 ，继续存活的对象 不超过10% ，所以 Survivor_2（10%） 有可能装不下了。</p>
<p>这个时候 Appel 有一个 “逃生门”的安全设计 ：</p>
<ul>
<li>当 Survivor_2（10%）容纳不了一次  Minor GC （新生代GC，Young GC）存活对象， </li>
<li>就需要 依赖其他内存区域（实际上大多数是老年代） 进行分配担保，就将一部分 存活对象移入 老年代</li>
</ul>
<h4 id="分配担保-（Todo）"><a href="#分配担保-（Todo）" class="headerlink" title="分配担保 （Todo）"></a>分配担保 （Todo）</h4><ul>
<li>内存的分配担保好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有什么风险了。</li>
<li>内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代，这对虚拟机来说就是安全的</li>
</ul>
<h2 id="标记整理（Mark-Compact）算法"><a href="#标记整理（Mark-Compact）算法" class="headerlink" title="标记整理（Mark-Compact）算法"></a>标记整理（Mark-Compact）算法</h2><ul>
<li><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种标记-复制算法 .</p>
</li>
<li><p>针对老年代对象的存亡特征，提出了 有针对性的 “标记-整理”（Mark-Compact）算法</p>
</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li>首先标记出所有需要回收的对象，</li>
<li>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如图3-4所示。</li>
</ul>
<p><img src="/uploads/jvm/07-mark-compact.png"></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p>如果移动存活对象，尤其是在老年代 这种每次回收都有大量对象存活区域 ，移动存活对象并更新所有 引用这些对象的地方将会是一种极为负重的操作 ，</p>
<p>而且这种对象移动操作必须全程暂停用户应用程序才能进行。 Stop The World</p>
</li>
<li><p>如果不考虑移动和整理存活对象的话，，存活对象倒置 的空间碎片化问题就 只能依赖更为复杂的内存分配器和内存访问器来解决。</p>
</li>
<li><p>内存的访问 是用户程序最频繁的操作，如果这个环节上增加了额外的负担，势必影响用户程序的吞吐量</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p>
</li>
<li><p>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿</p>
</li>
<li><p>但是从整个程序的吞吐量来看，移动对象会更划算。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的</p>
</li>
<li><p>HotSpot虚拟机里面关注吞吐量的ParallelScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的</p>
</li>
<li><p>还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p>
</li>
</ul>
<h2 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h2><ul>
<li><p>枚举根节点的时候，用户线程必须要停顿。</p>
</li>
<li><p>根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</p>
</li>
<li><p>这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因</p>
</li>
</ul>
<ul>
<li>虚拟机应当是有办法直接得到哪些地方存放着对象引用的。</li>
<li>在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，</li>
<li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</li>
</ul>
<h3 id="安全点（SafePoint）"><a href="#安全点（SafePoint）" class="headerlink" title="安全点（SafePoint）"></a>安全点（SafePoint）</h3><ul>
<li>实际上HotSpot也的确没有为每条指令都生成OopMap,只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）</li>
<li>安全点的设定，决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停</li>
<li>安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。</li>
</ul>
<h4 id="抢先式中断（Preemptive-Suspension）："><a href="#抢先式中断（Preemptive-Suspension）：" class="headerlink" title="抢先式中断（Preemptive Suspension）："></a>抢先式中断（Preemptive Suspension）：</h4><p>抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>
<p>现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</p>
<h4 id="主动式中断（Voluntary-Suspension）"><a href="#主动式中断（Voluntary-Suspension）" class="headerlink" title="主动式中断（Voluntary Suspension）:"></a>主动式中断（Voluntary Suspension）:</h4><ul>
<li>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</li>
<li>轮询标志的地方和安全点是重合的，</li>
<li>另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li>
</ul>
<h3 id="安全区域（Safe-Region）："><a href="#安全区域（Safe-Region）：" class="headerlink" title="安全区域（Safe Region）："></a>安全区域（Safe Region）：</h3><ul>
<li><p>用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p>
</li>
<li><p>对于这种情况，就必须引入安全区域（Safe Region）来解决。</p>
</li>
<li><p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
</li>
<li><p>我们也可以把安全区域看作被扩展拉伸了的安全点 </p>
</li>
</ul>
<p>当用户线程执行到安全区域里面的代码时，</p>
<ul>
<li>首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li>
<li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），</li>
<li>如果完成了，那线程就当作没事发生过，继续执行；</li>
<li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li>
</ul>
<h3 id="记忆集与卡表（Remembered-Set）："><a href="#记忆集与卡表（Remembered-Set）：" class="headerlink" title="记忆集与卡表（Remembered Set）："></a>记忆集与卡表（Remembered Set）：</h3><ul>
<li><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围</p>
</li>
<li><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</p>
</li>
<li><p>在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节</p>
</li>
</ul>
<h4 id="卡精度："><a href="#卡精度：" class="headerlink" title="卡精度："></a>卡精度：</h4><p>  每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>垃圾收集算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-10-Java模块化系统</title>
    <url>/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="Java模块化系统-TODO-DODO"><a href="#Java模块化系统-TODO-DODO" class="headerlink" title="Java模块化系统(TODO DODO)"></a>Java模块化系统(TODO DODO)</h1><p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p>
<ul>
<li>依赖其他模块的列表。</li>
<li>导出的包列表，即其他模块可以使用的列表。</li>
<li>开放的包列表，即其他模块可反射访问模块的列表。</li>
<li>使用的服务列表。</li>
<li>提供服务的实现列表</li>
</ul>
<h2 id="可配置的封装隔离机制"><a href="#可配置的封装隔离机制" class="headerlink" title="可配置的封装隔离机制"></a>可配置的封装隔离机制</h2><ul>
<li>可配置的封装隔离机制首先要解决JDK 9之前基于<strong>类路径（ClassPath）来查找依赖</strong>的可靠性问题。此前，如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常</li>
<li>而在JDK 9以后，如果启用了<strong>模块化进行封装</strong>，模块就可以声明对其他模块的<strong>显式依赖</strong>，这样Java虚拟机就能够在<strong>启动时验证</strong>应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分[1]由于类型依赖而引发的运行时异常</li>
<li>可配置的封装隔离机制还<strong>解决了原来类路径上跨JAR文件的public类型的可访问性问题</strong>。JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更<strong>精细的可访问性控制</strong>，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种<strong>访问控制也主要是在类加载过程中</strong>完成的</li>
</ul>
<h2 id="模块的兼容性"><a href="#模块的兼容性" class="headerlink" title="模块的兼容性"></a>模块的兼容性</h2><ul>
<li>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9提出了与“<strong>类路径</strong>”（ClassPath）相对应的“<strong>模块路径</strong>”（ModulePath）的概念</li>
<li>就是某个类库到底是模块还是传统的JAR包，只取决于<strong>它存放在哪种路径上</strong>。</li>
<li>只要是放在<strong>类路径上的JAR文件</strong>，无论其中是否包含模块化信息（是否包含了module-info.class文件），它都会被当作<strong>传统的JAR包</strong>来对待；</li>
<li>相应地，只要放在<strong>模块路径上的JAR文件</strong>，即使没有使用JMOD后缀，甚至说其中并不包含module-info.class文件，它也仍然会被当作一个<strong>模块</strong>来对待。</li>
</ul>
<h3 id="保障规则："><a href="#保障规则：" class="headerlink" title="保障规则："></a>保障规则：</h3><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上，即使这些版本的JDK已经使用模块来封装了Java SE的标准类库，模块化系统的这套规则也仍然保证了传统程序可以访问到所有标准类库模块中导出的包</p>
<h4 id="JAR文件在类路径的访问规则"><a href="#JAR文件在类路径的访问规则" class="headerlink" title="JAR文件在类路径的访问规则"></a>JAR文件在类路径的访问规则</h4><ul>
<li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li>
</ul>
<h4 id="模块在模块路径的访问规则"><a href="#模块在模块路径的访问规则" class="headerlink" title="模块在模块路径的访问规则"></a>模块在模块路径的访问规则</h4><ul>
<li>模块在模块路径的访问规则：模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</li>
</ul>
<h4 id="JAR文件在模块路径的访问规则"><a href="#JAR文件在模块路径的访问规则" class="headerlink" title="JAR文件在模块路径的访问规则"></a>JAR文件在模块路径的访问规则</h4><ul>
<li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li>
</ul>
<p>以上3条规则保证了即使Java应用依然使用传统的类路径，升级到JDK 9对应用来说几乎（类加载器上的变动还是可能会导致少许可见的影响，将在下节介绍）不会有任何感觉，项目也不需要专门为了升级JDK版本而去把传统JAR包升级成模块。</p>
<p>除了向后兼容性外，随着JDK 9模块化系统的引入，更值得关注的是它本身面临的模块间的管理和兼容性问题：如果同一个模块发行了多个不同的版本，那只能由开发者在编译打包时人工选择好正确版本的模块来保证依赖的正确性。Java模块化系统目前不支持在模块定义中加入版本号来管理和约束依赖，本身也不支持多版本号的概念和版本选择功能。</p>
<p>我们不论是在Java命令、Java类库的API抑或是《Java虚拟机规范》定义的Class文件格式里都能轻易地找到证据，表明模块版本应是编译、加载、运行期间<br>都可以使用的。譬如输入“java–list-modules”，会得到明确带着版本号的模块列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java.base@12.0.1</span><br><span class="line">java.compiler@12.0.1</span><br><span class="line">java.datatransfer@12.0.1</span><br><span class="line">java.desktop@12.0.1</span><br><span class="line">java.instrument@12.0.1</span><br><span class="line">java.logging@12.0.1</span><br><span class="line">java.management@12.0.1</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>在JDK 9时加入Class文件格式的<strong>Module属性</strong>，里面有<strong>module_version_index</strong>这样的字段，用户可以在编译时使用“<strong>javac–module-version</strong>”来指定模块版本，在Java类库API中也存在java.lang.module.ModuleDescriptor.Version这样的接口可以在运行时获取到模块的版本号。这一切迹象都证明了<strong>Java模块化系统对版本号的支持本可以不局限在编译期</strong>。</p>
<h2 id="模块化下的类加载器"><a href="#模块化下的类加载器" class="headerlink" title="模块化下的类加载器"></a>模块化下的类加载器</h2><p>为了保证兼容性，JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架构以及双亲委派模型。但是为了模块化系统的顺利施行，模块化下的类加载器仍然发生了一些应该被注意到变动，主要包括以下几个方面。</p>
<h3 id="扩展类加载器被取代"><a href="#扩展类加载器被取代" class="headerlink" title="扩展类加载器被取代"></a>扩展类加载器被取代</h3><ul>
<li>首先，是扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。</li>
<li>这其实是一个很顺理成章的变动，既然整个JDK都基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留**<JAVA_HOME>\lib\ext**目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了，用来加载这部分类库的扩展类加载器也完成了它的历史使命。</li>
<li>类似地，在新版的JDK中也<strong>取消了<JAVA_HOME>\jre</strong>目录，因为随时可以组合构建出程序运行所需的JRE来，譬如假设我们只使用java.base模块中的类型，那么随时可以通过以下命令打包出一个“JRE”：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jlink -p <span class="variable">$JAVA_HOME</span>/jmods --add-modules java.base --output jre</span><br></pre></td></tr></table></figure>

<h3 id="BuiltinClassLoade"><a href="#BuiltinClassLoade" class="headerlink" title="BuiltinClassLoade"></a>BuiltinClassLoade</h3><ul>
<li>其次，平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK 9及更高版本的JDK中崩溃。</li>
<li>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</li>
</ul>
<p><img src="/uploads/jvm/09ClassLoader/01-ClassLoader_before.png"></p>
<p><img src="/uploads/jvm/09ClassLoader/02-ClassLoader_after.png"></p>
<p>图7-6中有“BootClassLoader”存在，启动类加载器现在是在Java虚拟机内部和Java类库共同协作实现的类加载器，尽管有了BootClassLoader这样的Java类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景（譬如Object.class.getClassLoader()）中仍然会返回null来代替，而不会得到BootClassLoader的实例。</p>
<h3 id="类加载的委派关系发生了变动"><a href="#类加载的委派关系发生了变动" class="headerlink" title="类加载的委派关系发生了变动"></a>类加载的委派关系发生了变动</h3><p><img src="source/uploads/jvm/09ClassLoader/03-ClassLoader_Parentnew.png"></p>
<p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。</p>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，也许这可以算是对双亲委派的第四次破坏。</p>
<h4 id="类加载器负责加载的模块"><a href="#类加载器负责加载的模块" class="headerlink" title="类加载器负责加载的模块"></a>类加载器负责加载的模块</h4><h5 id="启动类加载器负责加载的模块"><a href="#启动类加载器负责加载的模块" class="headerlink" title="启动类加载器负责加载的模块"></a>启动类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java.base java.security.sasl</span><br><span class="line">java.datatransfer java.xml</span><br><span class="line">java.desktop jdk.httpserver</span><br><span class="line">java.instrument jdk.internal.vm.ci</span><br><span class="line">java.logging jdk.management</span><br><span class="line">java.management jdk.management.agent</span><br><span class="line">java.management.rmi jdk.naming.rmi</span><br><span class="line">java.naming jdk.net</span><br><span class="line">java.prefs jdk.sctp</span><br><span class="line">java.rmi jdk.unsupported</span><br></pre></td></tr></table></figure>



<h5 id="平台类加载器负责加载的模块"><a href="#平台类加载器负责加载的模块" class="headerlink" title="平台类加载器负责加载的模块"></a>平台类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java.activation* 					jdk.accessibility</span><br><span class="line">java.compiler* 						jdk.charsets</span><br><span class="line">java.corba* 						jdk.crypto.cryptoki</span><br><span class="line">java.scripting 						jdk.crypto.ec</span><br><span class="line">java.se 							jdk.dynalink</span><br><span class="line">java.se.ee 							jdk.incubator.httpclient</span><br><span class="line">java.security.jgss					jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio 					jdk.jsobject</span><br><span class="line">java.sql 							jdk.localedata</span><br><span class="line">java.sql.rowset						jdk.naming.dns</span><br><span class="line">java.transaction* 					jdk.scripting.nashorn</span><br><span class="line">java.xml.bind* 						jdk.security.auth</span><br><span class="line">java.xml.crypto 					jdk.security.jgss</span><br><span class="line">java.xml.ws* 						jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation* 			jdk.zipfs</span><br></pre></td></tr></table></figure>

<h5 id="应用程序类加载器负责加载的模块"><a href="#应用程序类加载器负责加载的模块" class="headerlink" title="应用程序类加载器负责加载的模块"></a>应用程序类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jdk.aot 						jdk.jdeps</span><br><span class="line">jdk.attach 						jdk.jdi</span><br><span class="line">jdk.compiler 					jdk.jdwp.agent</span><br><span class="line">jdk.editpad 					jdk.jlink</span><br><span class="line">jdk.hotspot.agent 				jdk.jshell</span><br><span class="line">jdk.internal.ed					jdk.jstatd</span><br><span class="line">jdk.internal.jvmstat 			jdk.pack</span><br><span class="line">jdk.internal.le 				jdk.policytool</span><br><span class="line">jdk.internal.opt 				jdk.rmic</span><br><span class="line">jdk.jartool 					jdk.scripting.nashorn.shell</span><br><span class="line">jdk.javadoc 					jdk.xml.bind*</span><br><span class="line">jdk.jcmd 						jdk.xml.ws*</span><br><span class="line">jdk.jconsole</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>Java模块化系统</tag>
      </tags>
  </entry>
  <entry>
    <title>算法图解-01-二分查找</title>
    <url>/2020/12/22/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3-01-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul>
<li><p>二分查找最多需要log2 n 步</p>
</li>
<li><p>对数是幂运算的 逆运算</p>
</li>
<li><p>数组： 将一系列元素存储再一系列相邻的桶（bucket）。即 数组中。 这些桶从0开始编号</p>
<h3 id="大O运行时间："><a href="#大O运行时间：" class="headerlink" title="大O运行时间："></a>大O运行时间：</h3></li>
</ul>
<p>大O表示法 指出了算法又多快， 让你能够比较操作数，他指出了算法运行时间的增速。</p>
<p>大O表示的是最糟的情况 </p>
<h3 id="一些常见的大O运行时间"><a href="#一些常见的大O运行时间" class="headerlink" title="一些常见的大O运行时间"></a>一些常见的大O运行时间</h3><ul>
<li>O(log n) ，也叫对数时间 ，这样的算法包括二分查找</li>
<li>O（n） 也叫线性时间 ，这样的算法包括简单查找。</li>
<li>O(n* log n)快速排序</li>
<li>O(n**2) 选择排序</li>
<li>o(n !) 这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非<br>常慢的算法。</li>
</ul>
<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><ul>
<li><p>算法的速度指的并非 时间，而是  操作数的增速</p>
</li>
<li><p>谈论算法的速度是，我们说的是 随着输入的增加，其运行时间将 以什么 样的速度增加</p>
</li>
<li><p>算法的运行时间 用 大O法表示</p>
</li>
<li><p>O (log n)比 O(n) 快，当需要搜索的元素越多时，前者比后者 快的多</p>
</li>
<li><p>旅行商 算法，多个城市的排序：O(n!) 阶乘时间</p>
</li>
</ul>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ol>
<li><p>二分查找比 简单查找 快的多</p>
</li>
<li><p>O（log n）比O(n) 快，需要搜索的元素越多，前者比后者越快的多</p>
</li>
<li><p>算法的运行时间并不是 以 秒为单位</p>
</li>
<li><p>算法的运行时间是从 它的增速的角度考虑的 </p>
</li>
<li><p>算法 的运行时间可以 用大O表示法 来表示</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法图解</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-01-类图</title>
    <url>/2020/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-01-%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="设计模式之禅-类图"><a href="#设计模式之禅-类图" class="headerlink" title="设计模式之禅-类图"></a>设计模式之禅-类图</h1><p>最近一段时间，又看了一遍设计模式，发现和以前有了不一样的理解。<br>以前看设计模式感觉更像是死记硬背，没有掌握方法，只是觉得这个很重要，可是不是很理解。</p>
<p>但是 其实学习设计模式，</p>
<p><strong>前提</strong>一定是要先会看和画 <strong>类图</strong>，这也是一门语言，很直观的可以看出各个类之间的关系，然后再去想为什么这么设计</p>
<p><img src="/uploads/design_patterns/01classDiagram/mermaid_relation.png" alt="mermaid_relation.png"></p>
<p>ps: 使用  <a href="https://mermaid-js.github.io/mermaid/#/classDiagram"> mermaid </a>  画类图</p>
<h2 id="常见的类图关系："><a href="#常见的类图关系：" class="headerlink" title="常见的类图关系："></a>常见的类图关系：</h2><h3 id="泛化（Generalization）："><a href="#泛化（Generalization）：" class="headerlink" title="泛化（Generalization）："></a>泛化（Generalization）：</h3><p>泛化包含继承（Inheritance）和实现（Realization）</p>
<h4 id="继承（Inheritance）："><a href="#继承（Inheritance）：" class="headerlink" title="继承（Inheritance）："></a>继承（Inheritance）：</h4><p>在UML类图中，继承通常使用 <strong>空心三角+实线</strong> 表示</p>
<p><img src="https://img-blog.csdnimg.cn/20200224104704397.png" alt="在这里插入图片描述"></p>
<pre class="mermaid">classDiagram
 classDog--|> classAnimal : 继承</pre>



<h4 id="实现（Realization）："><a href="#实现（Realization）：" class="headerlink" title="实现（Realization）："></a>实现（Realization）：</h4><p>在UML类图中，实现通常使用<code>空心三角+虚线</code>表示</p>
<p><img src="https://img-blog.csdnimg.cn/20200224105008943.png" alt="在这里插入图片描述"></p>
<pre class="mermaid">classDiagram
classA ..> InterfaceA : 实现</pre>

<h3 id="依赖（Dependence）："><a href="#依赖（Dependence）：" class="headerlink" title="依赖（Dependence）："></a>依赖（Dependence）：</h3><ul>
<li><p>简单理解就是一个类A 使用到类B，这种关系很弱，关系临时且偶然</p>
</li>
<li><p>依赖关系在Java语言中体现为<code>成员变量、局域变量、方法的形参、方法返回值</code>，或者对静态方法的调用。</p>
</li>
<li><p>在代码层面就是类B 作为参数在类A 的某个方法中使用</p>
</li>
<li><p>在UML类图中，依赖通常使用<code>虚线箭头</code>表示</p>
<p><img src="https://img-blog.csdnimg.cn/2020022411080829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre class="mermaid">  classDiagram
classA ..> classB :依赖</pre>
<h3 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）:"></a>关联（Association）:</h3></li>
<li><p>强依赖关系，类似与朋友关系，是平等的</p>
</li>
<li><p>关联是单向或者双向的，可以是1：1，或者1：N</p>
</li>
<li><p>关联关系以实线箭头表示</p>
</li>
<li><p>表现在代码层面就是被关联对象B 以 类属性的形式 出现在类A 中， 或者List<B>出现在 类A中  </p>
<p><img src="https://img-blog.csdnimg.cn/2020022411311616.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200224121447839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3OTg5OTgw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
  <pre class="mermaid">  classDiagram
  classA --> classB : 关联</pre>



<h3 id="聚合（Aggregation）："><a href="#聚合（Aggregation）：" class="headerlink" title="聚合（Aggregation）："></a>聚合（Aggregation）：</h3><p><img src="https://img-blog.csdnimg.cn/2020022412311785.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>集体和个体的关系（雁群和大雁）</p>
</li>
<li><p>has a的关系，如List<A> 和A的关系</p>
</li>
<li><p>聚合关系表示整体和个体的关系，整体和个体可以相互独立存在，一定是有两个模块分别管理整体和个体。</p>
</li>
<li><p>在UML类图中，聚合通常使用<code>空心菱形+实线箭头</code>表示</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200224123306820.png" alt="在这里插入图片描述"></p>
<pre class="mermaid">classDiagram
大雁群 o-- 大雁: 聚合</pre>

<h3 id="组合（Composition）："><a href="#组合（Composition）：" class="headerlink" title="组合（Composition）："></a>组合（Composition）：</h3><ul>
<li>组合关系是<code>关联关系的一种特例</code>，他体现的是一种<code>contains-a</code>(包含)的关系，这种关系比聚合更强，也称为强聚合。它要求普通的聚合关系中代表整体的对象负责代表部分对象的生命周期，组合关系是不能共享的 </li>
<li>大雁和 翅膀的关系，汽车和 发动机的关系，拥有同一个生命周期</li>
<li>整体和个体不能独立存在，一定是在一个模块中同时管理整体和个体，生命周期必须相同(级联)。</li>
<li>在UML类图中，组合通常使用<code>实心菱形+实线箭头</code>表示</li>
<li>体现在代码层面就是 B是A的构造函数 的参数</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200224123131234.png" alt="在这里插入图片描述"></p>
<pre class="mermaid">classDiagram
classCar *-- classEngine : 组合</pre>





<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>当我们了解了这些基础的关系后，后面参考类图看设计模式，心里就会有一个大的思路，这个时候就只需要去想 ，这么设计的好处是什么就可以了</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>类图</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-02-六大设计原则</title>
    <url>/2020/11/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-02-%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p> (SRP)Single Responsibility Principle:<br> There should never be more than one reason for a class to change.<br> 我觉得这个单一职责原则看起来很简单，就是说一个接口对应一个职责，一个接口只做一件事情。<br> 就比如 老外饭桌上吃饭餐具分刀和叉。刀用来切割食物，叉用来固定和移动食物，分工很明确。而我们的筷子就全部把这些事情做完了。<br> 再比如 厨房刀具分水果刀、切肉刀等等，屠夫杀猪也会准备很多刀，功能都不一，这就是单一职责。</p>
<p>应用到项目开发， 可是职责的划分其实很不确定，这个因项目而异，因环境而异。</p>
<ul>
<li><p>对于接口，我们在设计的时候一定要做到单一职责，但是对于实现类我们就需要多考虑。生搬硬套单一职责，就会引起类的剧增，制造了系统的复杂性。</p>
</li>
<li><p>对于方法，单一职责也适用。一个方法做一件事情，方法名体现了方法的功能。这样既愉悦自己，也愉悦自己的同事，一眼就可以知道这个方法做了什么事情。</p>
</li>
<li><p>现实有现实的难处，我们要考虑很多因素，工期，成本，人员技术水平等，可能会很难实施</p>
<p>But 建议就是接口尽量单一职责，方法一定要单一职责</p>
</li>
</ul>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>定义一：如果对每一个类型为S的对象o1 ，都有类型为T的对象o2，使得以T定义的所有程序P在所有对象o1 都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型 。</p>
<p>定义二：  所有引用基类的地方都必须能透明地 使用其子类的对象</p>
<p>简单讲就是： 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或者异常。使用者根本不需要知道是父类还是子类。</p>
<p>举个例子，定义了一个通用的接口方法， 方法参数就设置为一个抽象方法，只有在具体实现使用的时候，才会传子类进去。</p>
<p>里氏替换原则为良好的继承定义了一个规范，包含了4层含义</p>
<ul>
<li><p>子类必须完全 实现父类的方法</p>
<p>（如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生”畸变“，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承）</p>
</li>
<li><p>子类可以有自己的特性</p>
<p>(如果某个方法中显式的指出参数就是子类，那么传父类进来肯定就编译不通过了)</p>
</li>
<li><p>覆盖或实现父类的方法是，输入参数可以被放大</p>
<p>todo: （应该从jvm字节码层面去思考为什么可以这么做）</p>
<ul>
<li>假如父类的方法参数是HashMap,子类的方法参数是Map，子类方法参数范围变大了，那么子类就是 重载（Overload）了这方法。<br>这个时候，子类的输入参数类型范围扩大了，子类代替父类传递到调用者中，子类的方法永远不会被执行。这个是正常的。如果是想要子类的方法被执行，那么请和子类参数一样，这是 覆写（Override）</li>
<li>假如父类的方法入参是Map，子类的方法参数是HashMap，子类方法参数范围变小了。这样的话，子类在没有覆写 父类方法的前提下，却被执行了，这样会引起业务关系的紊乱，歪曲了父类的意图。</li>
</ul>
</li>
</ul>
<ul>
<li><p>覆写或实现父类的方法时，输出结果可以被缩小 </p>
<ul>
<li>如果是覆写（Override），父类和子类同名方法的输入类型是相同的，子类方法的返回值S范围  小于等于 父类的返回值范围F</li>
<li>如果是重载（OverLoad）,则方法的输入参数类型或者数量不相同</li>
</ul>
</li>
</ul>
<ul>
<li><p>总结：</p>
<p>尽量避免子类的‘’个性”，一旦子类有个性，子类和父类之间的关系就难调和，出现混乱了。尽量把子类当作父类来使用。</p>
<p>把子类单独作为一个业务来使用，则会让代码的耦合扑朔迷离，却反类替换标准</p>
</li>
</ul>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>（Dependence Inversion Principle,DIP）</p>
<p>​    High level modules should not depend upon low level modules,Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions</p>
<p>翻译过来包含3层含义：</p>
<ul>
<li>高层模块不应该依赖底层模块，两者都应该依赖其抽象</li>
</ul>
<p>不可分割的原子逻辑就是底层模块，原子逻辑的再次组装就是高层模块。</p>
<ul>
<li>抽象不应该依赖细节</li>
<li>细节应该依赖抽象</li>
</ul>
<p>抽象指的是抽象类或者接口，细节指的是其实现类或者继承者，特点是可以被实例化。</p>
<p>其实最精简的解释就是：面向接口编程。</p>
<ul>
<li>模块之间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是 通过接口或者抽象类产生的</li>
<li>接口或抽象类不依赖实现类</li>
<li>实现类依赖 接口或抽象类</li>
</ul>
<ul>
<li><p>好处： </p>
<ul>
<li><p>依赖倒置有利于并行开发，2个类具有依赖关系，只要指定出2者之间的接口（或者抽象类）就可以独立开发了，而且项目之间的单元测试也可以独立进行了。</p>
</li>
<li><p>TDD（测试驱动开发）开发模式就是依赖倒置的最高级运用，丢给你一个接口，就可以自行Mock了 </p>
</li>
</ul>
</li>
</ul>
<p><img src="/uploads/design_patterns/02SixPrinciple/DependenceInversionPrincipl.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Driver ..&gt; IDriver : 实现</span><br><span class="line">IDriver --&gt; ICar : 依赖</span><br><span class="line">ICar&lt;.. BenzCar : 实现</span><br><span class="line">ICar ..&gt; BMWCar : 实现</span><br><span class="line">class IDriver&#123;</span><br><span class="line">    &lt;&lt;interface&gt;&gt;</span><br><span class="line">     +driver(ICar car)  void</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">class ICar&#123;</span><br><span class="line">  	&lt;&lt;interface&gt;&gt;</span><br><span class="line">     +run()  void</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>依赖的3中写法<ul>
<li>构造函数传递依赖对象</li>
<li>Setter方法传递依赖对象</li>
<li>接口声明依赖对象，接口注入</li>
</ul>
</li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>简单概述就是2个重点：</p>
<ul>
<li><p>Cilents should not be forced to depend upon interfaces that they donot use (客户端不应依赖它不需要的接口)</p>
</li>
<li><p>The dependency of one class to another one should depend on the smallest possible interface(类间的依赖关系应该建立在最小的接口上)</p>
<p>需要对接口进行细化，保证它的纯洁性</p>
<p>要求接口 中的方法尽量少 </p>
<p>如果多个模块依赖一个接口的功能，那我们应该给每个模块提供单独的接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问</p>
<p><img src="/uploads/design_patterns/02SixPrinciple/InterfaceIsolation01.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">AbstractSearcher o--&gt; IPettyGirl : 聚合</span><br><span class="line">Searcher --|&gt; AbstractSearcher : 继承</span><br><span class="line">IPettyGirl &lt;.. PettyGirl :实现</span><br><span class="line"></span><br><span class="line">class IPettyGirl&#123;</span><br><span class="line">    &lt;&lt;interface&gt;&gt;</span><br><span class="line">     +goodLooking()  void</span><br><span class="line">     +niceFiggure()  void</span><br><span class="line">     +greatTemperment()  void</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">class AbstractSearcher&#123;</span><br><span class="line">	&lt;&lt;abstract&gt;&gt;</span><br><span class="line">	+AbstractSearcher(IPettyGirl _pettyGirl)</span><br><span class="line">	 show()* void</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上图： 这里 IPettyGirl 接口就 过于臃肿了，我们的审美观点都在改变，美女的定义也在变化。有些女生虽然长的不是很出众，但是气质好，也属于美女，大家也都喜欢，所以这里：</p>
<p>可以把IPettyGirl  拆分成：外形美的美女IGoodBodyGirl、 气质美的美女IGreatTemperamentGirl  </p>
<p><img src="/uploads/design_patterns/02SixPrinciple/InterfaceIsolation02.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">AbstractSearcher o--&gt; IGoodBodyGirl : 聚合</span><br><span class="line">AbstractSearcher o--&gt; IGreatTemperamentGirl  : 聚合</span><br><span class="line">Searcher --|&gt; AbstractSearcher : 继承</span><br><span class="line">IGreatTemperamentGirl   &lt;.. PettyGirl :实现</span><br><span class="line">IGoodBodyGirl   &lt;.. PettyGirl :实现</span><br><span class="line"></span><br><span class="line">class IGoodBodyGirl&#123;</span><br><span class="line">    &lt;&lt;interface&gt;&gt;</span><br><span class="line">     +goodLooking()  void</span><br><span class="line">     +niceFiggure()  void</span><br><span class="line">&#125;</span><br><span class="line">class IGreatTemperamentGirl  &#123;</span><br><span class="line">    &lt;&lt;interface&gt;&gt;</span><br><span class="line">     +greatTemperment()  void</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AbstractSearcher&#123;</span><br><span class="line">	&lt;&lt;abstract&gt;&gt;</span><br><span class="line">	+AbstractSearcher(IGoodBodyGirl _goodBodyGirl)</span><br><span class="line">	+AbstractSearcher(IGreatTemperamentGirl _greatTemperamentGirl)</span><br><span class="line">	 show()* void</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>ps：</p>
<p>以上把一个臃肿的接口 变更为两个独立的接口 就是 接口隔离原则的表现形式。 让 AbstractSearcher依赖2个装用的接口比依赖一个综合的接口要更灵活。</p>
<p>接口是我们设计阶段对外提供的 契约，通过分散定义多个接口，可以预防未来变更的扩展，提供系统的灵活性和可维护性</p>
</li>
<li><p>总结</p>
<ul>
<li><p> 接口要尽量小 ，小是有粒度的，要符合  单一职责原则，不要过度拆分</p>
</li>
<li><p>接口要高内聚，就是接口中尽量少公布public方法，接口是对外的承诺，承诺越少，变更的风险就越少。</p>
<p>就是不讲任何条件，立刻完成任务的行为就是高内聚的表现。</p>
</li>
<li><p>定制服务，假如 项目作为服务方 为各个接入方 提供了 各个接入方（互相隔离）专用的查询接口，本系统内部还有 不隔离的混合查询方式。该混合查询方式也能满足各个接入方的查询需求，但是就不能对外公布 。</p>
</li>
<li><p>接口设计是有粒度的 ，粒度越小系统越灵活，但是灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低。所以这个衡量度，需要根据 实践，经验，领悟 去判断 。</p>
</li>
</ul>
</li>
</ul>
<h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>迪米特法则（Law of Demeter,LoD）也叫 最少知识原则（Least Knowledge Principle，LKP）</p>
<p>:一个对象应该对其他对象有最少的了解，一个类应该对自己需要调用的类知道的最少，被调用的类内部如何复杂与我无关，我只关心你提供的public的方法，其他的一概不关心。</p>
<p>换句话说，外部只需要一个获取结果的方法就行，不需要知道接口是具体如何实现的细节，我给你一个结果，你不必关注我的实现方式。细节的方法不需要提供出去</p>
<ul>
<li><p> 只和直接朋友交流 （only talk to your immediate friends ） ： 类与类之间的关系是建立在类间的，而不是方法间的，因此一个方法尽量不要引入一个类中不存在的对象</p>
</li>
<li><p>朋友间也是有距离的，一个类公开的public属性或者方法越多，修改时 涉及的面就越大，变更引起的风险扩散就越大。因此为了保持朋友类间的距离，需要尽量收敛，多用private 、package-private. protected等访问权限</p>
</li>
<li><p> 是自己的就是自己的 ： 如果一个方法放在本类中也可以，放在其他类中也可以。判断方法是：  如果一个方法放在本类中，既不增加类间关系，也不对本类产生负面影响，就放在本类中 。（当然前提一定也是 符合单一职责原则的，不要放一个不相干的方法进来)</p>
</li>
</ul>
<p>核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。读者在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>Software entities like classes,modules and  functions should be open for extension but closed for modifications .(一个软件实体如类、模块和函数应该对扩展开放，对修改关闭)</p>
<p>尽量不修改原有的已经上线的代码， 通过扩展的方式 适应新的需求。</p>
<h3 id="开闭原则的重要性："><a href="#开闭原则的重要性：" class="headerlink" title="开闭原则的重要性："></a>开闭原则的重要性：</h3><ul>
<li><p>开发原则对测试的影响</p>
<p>已经投产的代码都是有意义的，都是接受系统规则的约束，都是经过几轮测试的。 因此有变化提出的时候，就需要考虑原来的健壮代码是否可以不修改，仅仅通过扩展实现 。否则修改了原有代码就需要各种回归测试 ，提高了 成本</p>
</li>
<li><p>开闭原则提高了复用性</p>
<p>面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的 ，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越细，被复用的可能性越大。  怎么提高复用率，缩小逻辑粒度，直到一个逻辑不可再拆分为止</p>
</li>
<li><p>开闭原则可以提高可维护性</p>
<p>一款软件投产后，维护人员的工作不仅是对数据进行维护，还可能要对程序进行扩展。扩展一个类很简单，因为修改一个类，就得需要读懂原有的代码，牵扯的模块，怕的就是牵一发动全身。</p>
</li>
</ul>
<h3 id="开闭原则的使用方式"><a href="#开闭原则的使用方式" class="headerlink" title="开闭原则的使用方式"></a>开闭原则的使用方式</h3><p>1.抽象约束</p>
<ul>
<li><p>接口抽象</p>
</li>
<li><p>参数类型及引用对象抽象、</p>
</li>
<li><p>抽象层保持稳定</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-03-单例模式</title>
    <url>/2020/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-03-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="comment">//限制产生多个对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过该方法获得实例对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类中其他方法，尽量是static</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例模式(SingleTon Pattern):<br> Ensure a class has only one instance,and provide a global point of access to it<br> (确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例)</p>
<p><img src="/uploads/design_patterns/03Singleton/Singleton01.png"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>减少了内存的开支，特别是一个对象需要频繁创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势十分明显</li>
<li>可以避免对资源的多重占用，如一个写文件的动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>扩展很困难，除了修改代码基本没有第二种途径。</li>
<li>对测试不利，如果在并行开发的环境，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>要求生成唯一序列号的环境</li>
<li>在整个项目中需要一个共享访问点或者共享数据，如web页面的计数器，</li>
<li>需要定义大量的静态常量和静态方法（如 工具类）的环境，可以采用单例模式，当然也可以直接声明为 static的方式</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton ==<span class="keyword">null</span> )&#123;</span><br><span class="line">            singleton=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在高并发的情况下，单例模式需要考虑并发问题，解决不安全 的方法有很多，可以在getSingleton方法前加synchronized 关键字</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>有上限数量的单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emperor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义最多能产生的实例数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxNumOfEmperor = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//每个皇帝都有名字，使用一个ArrayList来容纳，每个对象的私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; nameList=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">//定义一个列表，容纳所有的皇帝实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Emperor&gt; emperorList=<span class="keyword">new</span> ArrayList&lt;Emperor&gt;();</span><br><span class="line">    <span class="comment">//当前皇帝序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> countNumOfEmperor =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//产生所有的对象</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxNumOfEmperor;i++)&#123;</span><br><span class="line">        	emperorList.add(<span class="keyword">new</span> Emperor(<span class="string">&quot;皇&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;帝&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Emperor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//世俗和道德约束你，目的就是不产生第二个皇帝</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入皇帝名称，建立一个皇帝对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Emperor</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    	nameList.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//随机获得一个皇帝对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机拉出一个皇帝，只要是个精神领袖就成</span></span><br><span class="line">        countNumOfEmperor = random.nextInt(maxNumOfEmperor);</span><br><span class="line">        <span class="keyword">return</span> emperorList.get(countNumOfEmperor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//皇帝发话了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">   		 System.out.println(nameList.get(countNumOfEmperor));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="TODO-各种线程-安全的单例模式"><a href="#TODO-各种线程-安全的单例模式" class="headerlink" title="TODO: 各种线程 安全的单例模式"></a>TODO: 各种线程 安全的单例模式</h3><ol>
<li>如 枚举Enum 等</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-04-工厂模式</title>
    <url>/2020/11/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-04-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>Define an interface for creating an object,but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.(定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。)</p>
<p><img src="/uploads/design_patterns/04Factory/factory01.png"></p>
<p>在工厂方法模式中，抽象产品类Product负责定义产品的共性，实现对事物最抽象的定义；</p>
<p>Creator为抽象创建类，也就是抽象工厂，具体如何创建产品类是由具体的实现工厂ConcreteCreator完成的。</p>
<ul>
<li>抽象产品类 与 具体产品类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="comment">//产品类的公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>抽象工厂类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator</span></span>&#123;</span><br><span class="line">	 <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 创建一个产品对象，其输入参数类型可以自行设置</span></span><br><span class="line"><span class="comment">        * 通常为String、Enum、Class等，当然也可以为空</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>具体工厂类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCreator</span> <span class="keyword">extends</span> <span class="title">Creator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Product&gt; <span class="function">T <span class="title">createProduct</span><span class="params">(Class&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">    Product product=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	product = (Product)Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> (T)product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>良好的封装性，代码结构清晰。只需要知道产品的类名就可以了，不需要创建对象的过程，减低模块的耦合性</li>
<li>扩展性优秀。下次需要增加一个产品时候，只需要适当的修改具体工厂类或者扩展一个工厂类，就可以拥抱变化。或者只是单纯的增加产品类</li>
<li>屏蔽产品类。 产品类的实现如何变化，调用者都不需要关心，只需要关心产品的接口。</li>
<li>解耦</li>
</ul>
</li>
<li><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>工厂模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重考虑是否需要增加一个工厂类进行管理，增加代码复杂度</li>
<li>需要灵活、可扩展的框架时，可以考虑采用工厂方法模式 。</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><h4 id="简单工厂模式图"><a href="#简单工厂模式图" class="headerlink" title="简单工厂模式图"></a>简单工厂模式图</h4><p>当一个模块只需要一个工厂类时候，就可以去除抽象工厂类AbstractHumanFactory </p>
<p><img src="/uploads/design_patterns/04Factory/simple_factory.png"></p>
</li>
<li><h4 id="升级为多个工厂类"><a href="#升级为多个工厂类" class="headerlink" title="升级为多个工厂类"></a>升级为多个工厂类</h4><p>当初始化一个对象很耗费精力，各个产品有自己独特得逻辑，放在同一个工厂方法中会使得代码结构不清晰，这个时候就可以多设置几个具体的工厂类。</p>
<p><img src="/uploads/design_patterns/04Factory/multipleConcreteFactory.png"></p>
<p>注意： 抽象方法中已经不再需要传递相关参数了，因为每一个具体的工厂都已经非常明确自己的职责： 创建自己负责的产品类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多工厂模式的抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Human <span class="title">createHuman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  白色人种的创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">whiteHumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WhiteHuman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><h4 id="替代单例模式"><a href="#替代单例模式" class="headerlink" title="替代单例模式"></a>替代单例模式</h4><p>单例模式的核心要求是 ： 在内存中只有一个对象，通过工厂方法 也可以只在内存中生产一个对象。</p>
<p><img src="/uploads/design_patterns/04Factory/factory_singleton.png"></p>
<p>单例对象 构造函数肯定是私有的，目的就是 不允许通过new的方式创建一个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不允许通过new产生一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//业务处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<pre><code>所以单例工厂可以通过反射的方式去创建对象，然后提供给外部访问，从而保证内存中对象唯一

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class cl= Class.forName(Singleton.class.getName());</span><br><span class="line">        <span class="comment">//获得无参构造</span></span><br><span class="line">        Constructor constructor=cl.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//设置无参构造是可访问的</span></span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//产生一个实例对象</span></span><br><span class="line">        singleton = (Singleton)constructor.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    	<span class="comment">//异常处理</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><h4 id="延迟初始化（lazy-init）"><a href="#延迟初始化（lazy-init）" class="headerlink" title="延迟初始化（lazy_init）"></a>延迟初始化（lazy_init）</h4><p>类似于缓存一样，当一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。</p>
<p><img src="/uploads/design_patterns/04Factory/lazy_init_factory.png" alt="lazy_init_factory.png"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Product&gt; prMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Product <span class="title">createProduct</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    	Product product =<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果Map中已经有这个对象</span></span><br><span class="line">        <span class="keyword">if</span>(prMap.containsKey(type))&#123;</span><br><span class="line">       		product = prMap.get(type);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;Product1&quot;</span>))&#123;</span><br><span class="line">        	product = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	product = <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">     	&#125;</span><br><span class="line">            <span class="comment">//同时把对象放到缓存容器中</span></span><br><span class="line">            prMap.put(type,product);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>延迟加载 可以扩展，比如限制某个产品类的最大实例化数量，可以通过判断Map中已有的对象数量来实现，这样的处理是非常有意义的。如JDBC链接数据库都会要求设置一个最大连接数量（MaxConnections）</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-05-抽象工厂模式</title>
    <url>/2020/11/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-05-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h2><p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes. （为创建一组相关的或者相互依赖的对象 提供一个接口，而且无须指定他们的具体类）</p>
<p>抽象工厂模式的通用类图如下所示：</p>
<p><img src="/uploads/design_patterns/05abstractFactory/universe_abstract_factory.png"></p>
<p><img src="/uploads/design_patterns/05abstractFactory/abstract_factory_source.png"></p>
<p>其实就是将 结果（product） 抽象化了，具体的结果由 creator指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 代码清单<span class="number">9</span>-<span class="number">11</span> 抽象产品类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个产品共有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shareMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//每个产品相同方法，不同实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">代码清单<span class="number">9</span>-<span class="number">12</span> 产品A1的实现类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;产品A1的实现方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">代码清单<span class="number">9</span>-<span class="number">13</span> 产品A2的实现类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;产品A2的实现方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码清单<span class="number">9</span>-<span class="number">14</span> 抽象工厂类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建A产品家族</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//创建B产品家族</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">代码清单<span class="number">9</span>-<span class="number">15</span> 产品等级<span class="number">1</span>的实现类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creator1</span> <span class="keyword">extends</span> <span class="title">AbstractCreator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只生产产品等级为1的A产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> ProductA1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只生产产品等级为1的B产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>封装性，每个产品的实现类不是高层模块需要关心的 。高层模块只关心接口，抽象，不关心具体的实现创建过程 ，</p>
<p> 创建的工作由工厂类负责 </p>
</li>
<li><p> 产品族内的约束为非公开状态 。就是各个产品之间的一些比例关系，具体产品类的约束是在工厂内实现的。</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>产品族的扩展非常困难，假如再增加一个  AbstractProductC,改动很大，具有侵入性</li>
</ul>
<h3 id="抽象工厂模式的使用场景"><a href="#抽象工厂模式的使用场景" class="headerlink" title="抽象工厂模式的使用场景"></a>抽象工厂模式的使用场景</h3><p>使用场景定义非常简单：  一个对象族（或者是 一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式 。</p>
<h3 id="抽象工厂模式的注意事项"><a href="#抽象工厂模式的注意事项" class="headerlink" title="抽象工厂模式的注意事项"></a>抽象工厂模式的注意事项</h3><ul>
<li>产品族扩展比较困难，但是产品等级( Creator1 )扩展时非常容易的 ,增加一个createor3 extends AbstractCreator 就行了。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-06-模板方法模式</title>
    <url>/2020/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-06-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="模板方法模式-Template-Method-Pattern"><a href="#模板方法模式-Template-Method-Pattern" class="headerlink" title="模板方法模式(Template Method Pattern)"></a>模板方法模式(Template Method Pattern)</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p> Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.</p>
<p>Template Method lets subclasses redefine certain steps of an algotithm without changing the algorithm’s structure</p>
<p>(定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构 就可以重新定义算发的某些特定步骤)</p>
<p><img src="/uploads/design_patterns/06templateMethod/templateMethodPattern01.png"></p>
<pre class="mermaid">classDiagram
class AbstractClass{
    #doanything() void 
    #dosomething() void 
    +templateMthod() void 
}
class ConcreteClass1{

}
class ConcreteClass2{

}

AbstractClass <|-- ConcreteClass1

AbstractClass <|-- ConcreteClass2</pre>

<p>模板方法非常简单，仅仅使用了java的继承机制，但是应用非常广泛的模式</p>
<h4 id="AbstractClass-抽象模板"><a href="#AbstractClass-抽象模板" class="headerlink" title="AbstractClass 抽象模板"></a>AbstractClass 抽象模板</h4><p>它的方法分为2类：</p>
<ul>
<li><p>基本方法（基本操作）: 由子类实现的方法，并在模板方法中被调用</p>
</li>
<li><p>模板方法： 可以由一个或几个，一般是一个具体方法，也就是一个框架</p>
<p>ps: 注意： 为了防止恶意操作，一般模板方法上都加上一个final关键字，不允许被覆写</p>
</li>
</ul>
<h4 id="具体模板"><a href="#具体模板" class="headerlink" title="具体模板"></a>具体模板</h4><p>ConcreteClass1 和 ConcreteClass2 属于具体模板 ，实现父类所定义的一个或者多个抽象方法，</p>
<p>也就是父类定义的基本方法在子类中得以实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基本方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//基本方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 调用基本方法，完成相关的逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">this</span>.doAnything();</span><br><span class="line">        <span class="keyword">this</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码清单10-7 具体模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现基本方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现基本方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>注意： 抽象模板中的基本方法尽量设计为 protected类型，符合迪米特法则，不需要暴露的属性和方法尽量不要设置为protected类型。</p>
<p>实现类若非必要，尽量不要扩大父类中的访问权限 </p>
<h2 id="模板方法模式的应用"><a href="#模板方法模式的应用" class="headerlink" title="模板方法模式的应用"></a>模板方法模式的应用</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>封装不变的部分，扩展可变的部分 </li>
</ul>
<p>不变的部分封装在父类中实现，可变的部分则可以通过继承来继续扩展。</p>
<p>非常容易扩展，增加一个子类，实现父类的基本方法就可以</p>
<ul>
<li><p>提取公共的部分代码，便于维护</p>
<p>如果不抽取公共的代码，那当需要修改一个逻辑的时候，就需要到处查找类似的代码</p>
</li>
<li><p>行为由父类控制，子类实现</p>
<p>基本方法是子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>设计习惯一般是 ： 抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。</p>
<p>但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果。</p>
<p>也就是子类对父类产生了影响。</p>
<p>导致了在复杂的项目中，增加了代码的阅读的难度，让人感到不适</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>多个子类由公有的方法，并且逻辑基本相同时</li>
<li>重要的复杂的算法，可以把核心算法设计为 Template method，周边的相关细节功能，则由各个子类实现</li>
<li>重构时，把相同的代码抽取到父类中，然后通过钩子函数 约束其行为</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>增加钩子函数</p>
<p><img src="/uploads/design_patterns/06templateMethod/templateMethod02.png"></p>
<p>在抽象类中，isAlarm 是一个实现方法，其作用是模板方法 根据其返回值决定是否要 响 喇叭，子类可以覆写该返回值。</p>
<p>isAlarm  的返回值影响了模板方法的执行结果，这就是 钩子方法（Hook Method）。有了钩子方法 模板方法模式才算完美，</p>
<ul>
<li><p>模板方法模式就是在模板方法中按照一定的规则和顺序调用基本方法，具体到前面的例子，就是run 方法按照 规定的顺序</p>
<p>调用 本类的基本方法，并且由 isAlarm（钩子函数）的返回直接确定run方法中的执行顺序的变更。</p>
</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>新手总是问老手： 父类怎么调用子类的方法。父类能调用子类的方法，但是强烈、极度不建议这么做。应该：</p>
<ul>
<li>把子类传递到父类的有参构造函数中，然后调用</li>
<li>使用反射的方式调用，</li>
<li>父类调用子类的静态方法</li>
</ul>
<p>以上三种都是父类直接调用子类的方法。不建议</p>
<p>父类建立框架，子类重写了父类的部分方法后，再调用从父类继承的方法，产生不同的结果（这就是Template Method Pattern）。</p>
<p>这是不是可以理解为父类调用了子类的方法。你修改了子类，影响了父类行为的结果，曲线救国的方式 实现了父类依赖子类的场景 。</p>
<p>模板方法模式就是这种效果</p>
<p>模板方法在一些开源框架中应用非常多，它提供了一个抽象类，然后开源框架写了一堆的子类。《** in action》中就说明了，</p>
<p>如果你需要扩展功能，可以继承这个抽象类，然后覆写 Protected 方法，然后就是 调用了一个类似 execute方法，就完成你的扩展开发，</p>
<p>非常容易扩展的一种模式</p>
<h3 id="todo-去找到这种开源框架的例子"><a href="#todo-去找到这种开源框架的例子" class="headerlink" title="todo 去找到这种开源框架的例子"></a>todo 去找到这种开源框架的例子</h3>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-07-建造者模式</title>
    <url>/2020/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-07-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>建造者模式（Builder Pattern）也叫 生成器模式</p>
<p>Separate the construction of a complex object  from its representation so that the same construction process can create different representations (将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 )</p>
<p>建造者模式的通用类图如下图所示：</p>
<p>聚合（导演类 ，builder ）</p>
<p>继承（builder，具体Builder）</p>
<p>依赖（具体Builder，产品类）</p>
<p><img src="/uploads/design_patterns/07builder/builder03.png"></p>
<ul>
<li><p>Product 产品类</p>
<p>通常是实现了模板模式，也就是由 模板方法和基本方法，就是ConcreteMOdle</p>
</li>
<li><p>Builder 抽象建造类</p>
<p>规范产品的组件，一般是由子类实现。如CarBuilder</p>
</li>
<li><p>ConcreteBuilder 具体的建造者</p>
<p>实现抽象类定义的所有方法，并且返回一个组件好的对象，</p>
</li>
<li><p>Director 导演类</p>
<p>负责安排已有模块的顺序，返回告诉Builder开始建造</p>
</li>
<li><p>ps: 导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。当然在建造者模式比较庞大时，导演雷可以有多个</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="/uploads/design_patterns/07builder/builder01.png"></p>
<p><img src="/uploads/design_patterns/07builder/builder02.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建造一个模型，你要给我一个顺序要求，就是组装顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(ArrayList&lt;String&gt; sequence)</span></span>;</span><br><span class="line">    <span class="comment">//设置完毕顺序后，就可以直接拿到这个车辆模型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> CarModel <span class="title">getCarModel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenzBuilder</span> <span class="keyword">extends</span> <span class="title">CarBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BenzModel benz = <span class="keyword">new</span> BenzModel();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CarModel <span class="title">getCarModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>.benz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequence</span><span class="params">(ArrayList&lt;String&gt; sequence)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.benz.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; sequence = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">private</span> BenzBuilder benzBuilder = <span class="keyword">new</span> BenzBuilder();</span><br><span class="line">    <span class="keyword">private</span> BMWBuilder bmwBuilder = <span class="keyword">new</span> BMWBuilder();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * A类型的奔驰车模型，先start，然后stop，其他什么引擎、喇叭一概没有</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BenzModel <span class="title">getABenzModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//清理场景，这里是一些初级程序员不注意的地方</span></span><br><span class="line">        <span class="keyword">this</span>.sequence.clear();</span><br><span class="line">        <span class="comment">//ABenzModel的执行顺序</span></span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        <span class="comment">//按照顺序返回一个奔驰车</span></span><br><span class="line">        <span class="keyword">this</span>.benzBuilder.setSequence(<span class="keyword">this</span>.sequence);</span><br><span class="line">        <span class="keyword">return</span> (BenzModel)<span class="keyword">this</span>.benzBuilder.getCarModel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * B型号的奔驰车模型，是先发动引擎，然后启动，然后停止，没有喇叭</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BenzModel <span class="title">getBBenzModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequence.clear();</span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;engine boom&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.benzBuilder.setSequence(<span class="keyword">this</span>.sequence);</span><br><span class="line">        <span class="keyword">return</span> (BenzModel)<span class="keyword">this</span>.benzBuilder.getCarModel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * C型号的宝马车是先按下喇叭（炫耀嘛），然后启动，然后停止</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BMWModel <span class="title">getCBMWModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequence.clear();</span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;alarm&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.bmwBuilder.setSequence(<span class="keyword">this</span>.sequence);</span><br><span class="line">        <span class="keyword">return</span> (BMWModel)<span class="keyword">this</span>.bmwBuilder.getCarModel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * D类型的宝马车只有一个功能，就是跑，启动起来就跑，永远不停止</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BMWModel <span class="title">getDBMWModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequence.clear();</span><br><span class="line">        <span class="keyword">this</span>.sequence.add(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.bmwBuilder.setSequence(<span class="keyword">this</span>.sequence);</span><br><span class="line">        <span class="keyword">return</span> (BMWModel)<span class="keyword">this</span>.benzBuilder.getCarModel();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这里还可以有很多方法，你可以先停止，然后再启动，或者一直停着不动，静态的嘛</span></span><br><span class="line"><span class="comment">* 导演类嘛，按照什么顺序是导演说了算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>封装性</p>
<p>使用建造者模式 可以使得 客户端不必知道产品内部组成得细节。</p>
</li>
<li><p>建造者独立，容易扩展</p>
<p>BenzBuilder 和 BMWBuilder 是互相独立的，对系统的扩展非常有利。</p>
</li>
<li><p>便于控制细节风险</p>
<p>由于具体的建造者都是独立的。因此可以对建造过程逐步细化，而不对其他的模块产生任何影响</p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式</p>
</li>
<li><p>多个部件或零件，都可以装配到同一个对象中，但是产生的运行结果又不相同的时候，则可以使用该模式</p>
</li>
<li><p>产品类非常复杂，或者产品类中的调用顺序不同 产生了不同的效能，这个时候使用建造者模式非常合适</p>
</li>
<li><p>在对象构建过程中，会使用到系统的一些其他对象，这些对象在产品对象的创建过程中不容易得到时，也可以采用建造者模式封装该对象的创建过程。     这种场景只能时一个补偿方案，因为一个对象不同意获得，而在设计阶段并发没发觉，而要通过 Builder模式 柔化创建过程，本身已经违反设计的最初目标 。</p>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>建造者模式关注的是 零件类型和装配工艺（顺序），这个是它和工厂模式最大的不同</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>建造者模式是零件的组装，组装顺序不同，对象的效能也不同，这才是建造者模式要表达的核心意义，</li>
<li>建造者模式最主要的功能是基本方法的调用顺序的安排，也就是这些基本方法已经实现了（通过模板方法模式）</li>
<li>工厂模式重点则是 创建，创建零件是它的主要职责，组装顺序则不是它的关注点</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>建造者模式</tag>
        <tag>Builder</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-09-原型模式</title>
    <url>/2020/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-09-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Specify the kinds of objects to create using a prototypical instance ,and create new object by copying this prototype( 用原型示例指定创建对象的种类，并且通过拷贝这些原型创建新的对象)</p>
<p><img src="/uploads/design_patterns/09prototype/prototype01.png"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ-02-RocketMQ快速入门</title>
    <url>/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="RocketMQ入门"><a href="#RocketMQ入门" class="headerlink" title="RocketMQ入门"></a>RocketMQ入门</h1><h2 id="核心概念说明"><a href="#核心概念说明" class="headerlink" title="核心概念说明"></a>核心概念说明</h2><p><img src="/uploads/RocketMQ/RocketMQ01.png" alt="image-20210106210340592"></p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ul>
<li>消息生产者，负责产生消息，一般由业务系统负责产生消息。</li>
</ul>
<h4 id="Producer-Group"><a href="#Producer-Group" class="headerlink" title="Producer Group"></a>Producer Group</h4><ul>
<li>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul>
<li>消息费者，负责消费消息，一般是后台系统负责异步消费。</li>
</ul>
<h4 id="Push-Consumer"><a href="#Push-Consumer" class="headerlink" title="Push Consumer"></a>Push Consumer</h4><ul>
<li>服务端向消费者端推送消息</li>
</ul>
<h4 id="Pull-Consumer"><a href="#Pull-Consumer" class="headerlink" title="Pull Consumer"></a>Pull Consumer</h4><ul>
<li>消费者端向服务定时拉取消息</li>
</ul>
<h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><ul>
<li> 一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</li>
</ul>
<h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><ul>
<li><p>集群架构中的组织协调员</p>
</li>
<li><p>收集broker的工作情况</p>
</li>
<li><p>不负责消息的处理</p>
</li>
</ul>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><ul>
<li>是RocketMQ的核心负责消息的发送、接收、高可用等（真正干活的）</li>
<li>需要定时发送自身情况到NameServer，默认10秒发送一次，超时2分钟会认为该broker失效。</li>
</ul>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><ul>
<li><p>不同类型的消息以不同的Topic名称进行区分，如User、Order等</p>
</li>
<li><p>是逻辑概念</p>
</li>
</ul>
<h3 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h3><ul>
<li>消息队列，用于存储消息</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;zlm-mqProducer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置nameserver的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建topic，参数分别是：broker的名称，topic的名称，queue的数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        producer.createTopic(<span class="string">&quot;broker-zhangliming&quot;</span>, <span class="string">&quot;zhangliming-test-topic&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;topic创建成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="发送消息（同步）"><a href="#发送消息（同步）" class="headerlink" title="发送消息（同步）"></a>发送消息（同步）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;我的第一个消息-add!&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;add&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消息id：C0A800693F5814DAD5DC1E4E22F20000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">3</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A800693F5814DAD5DC1E4E22F20000, offsetMsgId=C0A83E5A00002A9F00000000000000BA, messageQueue=MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">3</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Message数据结构"><a href="#Message数据结构" class="headerlink" title="Message数据结构"></a>Message数据结构</h3><table>
<thead>
<tr>
<th>字段名</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Topic</td>
<td>null</td>
<td>必填，线下环境不需要申请，线上环境需要申请后才能使用</td>
</tr>
<tr>
<td>Body</td>
<td>null</td>
<td>必填，二进制形式，序列化由应用决定，Producer 与 Consumer 要协商好序列化形式。</td>
</tr>
<tr>
<td>Tags</td>
<td>null</td>
<td>选填，类似于 Gmail 为每封邮件设置的标签，方便服务器过滤使用。<br/>目前只支持每个消息设置一个 tag，所以也可以类比为 Notify 的 MessageType 概念</td>
</tr>
<tr>
<td>Keys</td>
<td>null</td>
<td>选填，代表这条消息的业务关键词，服务器会根据 keys 创建哈希索引，<br>设置后，可以在 Console 系统根据 Topic、Keys 来查询消息，<br>由于是哈希索引，请尽可能保证 key 唯一，例如订单号，商品 Id 等。</td>
</tr>
<tr>
<td>Flag</td>
<td>0</td>
<td>选填，完全由应用来设置，RocketMQ 不做干预</td>
</tr>
<tr>
<td>DelayTimeLevel</td>
<td>0</td>
<td>选填，消息延时级别，0 表示不延时，大于 0 会延时特定的时间才会被消费</td>
</tr>
<tr>
<td>WaitStoreMsgOK</td>
<td>True</td>
<td>选填，表示消息是否在服务器落盘后才返回应答。</td>
</tr>
</tbody></table>
<h3 id="发送消息（异步）"><a href="#发送消息（异步）" class="headerlink" title="发送消息（异步）"></a>发送消息（异步）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;我的第一个异步发送消息!&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        producer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送成功了!&quot;</span> + sendResult);</span><br><span class="line">                System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送失败!&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">发送成功了!SendResult [sendStatus=SEND_OK, msgId=C0A8006943E014DAD5DC1E5694380000, offsetMsgId=C0A83E5A00002A9F0000000000000174, messageQueue=MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">1</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line">消息id：C0A8006943E014DAD5DC1E5694380000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">1</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;haoke-consumer&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅消息，接收的是所有消息</span></span><br><span class="line"><span class="comment">//        consumer.subscribe(&quot;my-topic&quot;, &quot;*&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;add || update&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;消息:&quot;</span> + <span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息 -&gt; &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消息:我的第一个消息-add!</span><br><span class="line">消息:我的第一个消息-add!</span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">186</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609938835416</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">8951</span>, storeTimestamp=<span class="number">1609938835430</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000000, commitLogOffset=<span class="number">0</span>, bodyCRC=<span class="number">2131316890</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, CONSUME_START_TIME=<span class="number">1609939507601</span>, UNIQ_KEY=C0A8006920E814DAD5DC1E4E1BD80000, WAIT=<span class="keyword">true</span>, TAGS=add&#125;, body=[-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">102</span>, -<span class="number">124</span>, -<span class="number">25</span>, -<span class="number">84</span>, -<span class="number">84</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">128</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">86</span>, -<span class="number">26</span>, -<span class="number">74</span>, -<span class="number">120</span>, -<span class="number">26</span>, -<span class="number">127</span>, -<span class="number">81</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">33</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">3</span>, storeSize=<span class="number">186</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609938837234</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">8964</span>, storeTimestamp=<span class="number">1609938837241</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F00000000000000BA, commitLogOffset=<span class="number">186</span>, bodyCRC=<span class="number">2131316890</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, CONSUME_START_TIME=<span class="number">1609939507601</span>, UNIQ_KEY=C0A800693F5814DAD5DC1E4E22F20000, WAIT=<span class="keyword">true</span>, TAGS=add&#125;, body=[-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">102</span>, -<span class="number">124</span>, -<span class="number">25</span>, -<span class="number">84</span>, -<span class="number">84</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">128</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">86</span>, -<span class="number">26</span>, -<span class="number">74</span>, -<span class="number">120</span>, -<span class="number">26</span>, -<span class="number">127</span>, -<span class="number">81</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">33</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="消息过滤器"><a href="#消息过滤器" class="headerlink" title="消息过滤器"></a>消息过滤器</h2><ul>
<li><p>RocketMQ支持根据用户自定义属性进行过滤，过滤表达式类似于SQL的where，如：a&gt; 5 AND b =’abc’</p>
</li>
<li><p>原因是默认配置下，不支持自定义属性，需要设置开启 broker.conf中配置,见第一章可以看见配置<br>enablePropertyFilter=true</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.MessageSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅消息，接收的是所有消息</span></span><br><span class="line"><span class="comment">//        consumer.subscribe(&quot;my-topic&quot;, &quot;*&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;my-topic-filter&quot;</span>, MessageSelector.bySql(<span class="string">&quot;sex=&#x27;女&#x27; AND age&gt;=18&quot;</span>));</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;消息:&quot;</span> + <span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息 -&gt; &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">2</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940231764</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9804</span>, storeTimestamp=<span class="number">1609940231769</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F00000000000003CE, commitLogOffset=<span class="number">974</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">3</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940231776</span>, UNIQ_KEY=C0A800692B3C14DAD5DC1E636A540000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">21</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">1</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940241237</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9818</span>, storeTimestamp=<span class="number">1609940241243</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000490, commitLogOffset=<span class="number">1168</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940241244</span>, UNIQ_KEY=C0A8006908F014DAD5DC1E638F550000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">22</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">3</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940251652</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9836</span>, storeTimestamp=<span class="number">1609940251657</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000552, commitLogOffset=<span class="number">1362</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">4</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940251658</span>, UNIQ_KEY=C0A8006934D414DAD5DC1E63B8030000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">23</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;这是一个用户的消息, id = 1003&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic-filter&quot;</span>, <span class="string">&quot;delete&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        message.putUserProperty(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        message.putUserProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    消息id：C0A80069251814DAD5DC1E63D08D0000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic-filter, brokerName=broker-zhangliming, queueId=<span class="number">0</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A80069251814DAD5DC1E63D08D0000, offsetMsgId=C0A83E5A00002A9F0000000000000614, messageQueue=MessageQueue [topic=my-topic-filter, brokerName=broker-zhangliming, queueId=<span class="number">0</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="producer详解"><a href="#producer详解" class="headerlink" title="producer详解"></a>producer详解</h2><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>在某些业务中，consumer在消费消息时，是需要按照生产者发送消息的顺序进行消费的，比如在电商系统中，订单的消息，会有创建订单、订单支付、订单完成，如果消息的顺序发生改变，那么这样的消息就没有意义了。</p>
<p><img src="/uploads/RocketMQ/RocketMQ02.png" alt="image-20210106210340592"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;HAOKE_ORDER_PRODUCER&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> orderId = i % <span class="number">10</span>; <span class="comment">// 模拟生成订单id</span></span><br><span class="line">            String msgStr = <span class="string">&quot;order --&gt; &quot;</span> + i +<span class="string">&quot;, id = &quot;</span>+ orderId;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;haoke_order_topic&quot;</span>, <span class="string">&quot;ORDER_MSG&quot;</span>,</span><br><span class="line">                    msgStr.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(message, (mqs, msg, arg) -&gt; &#123;</span><br><span class="line">                Integer id = (Integer) arg;</span><br><span class="line">                <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">            &#125;, orderId);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">                DefaultMQPushConsumer(<span class="string">&quot;HAOKE_ORDER_CONSUMER&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;haoke_order_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                                + msg.getQueueId() + <span class="string">&quot; &quot;</span></span><br><span class="line">                                + <span class="keyword">new</span> String(msg.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                System.out.println(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs);</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：相同订单id的消息会落到同一个queue中，一个消费者线程会顺序消费queue，从而实现顺序消费消<br>息。</p>
<h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><h3 id="回顾是什么事务"><a href="#回顾是什么事务" class="headerlink" title="回顾是什么事务"></a>回顾是什么事务</h3><p>聊什么是事务，最经典的例子就是转账操作，用户A转账给用户B1000元的过程如下：<br>用户A发起转账请求，用户A账户减去1000元<br>用户B的账户增加1000元<br>如果，用户A账户减去1000元后，出现了故障（如网络故障），那么需要将该操作回滚，用户A账户增加1000元。<br>这就是事务。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>随着项目越来越复杂，越来越服务化，就会导致系统间的事务问题，这个就是分布式事务问题。<br>分布式事务分类有这几种：</p>
<ul>
<li>基于单个JVM，数据库分库分表了（跨多个数据库）。</li>
<li>基于多JVM，服务拆分了（不跨数据库）。</li>
<li>基于多JVM，服务拆分了 并且数据库分库分表了。</li>
</ul>
<p>解决分布式事务问题的方案有很多，使用消息实现只是其中的一种。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Half-Prepare-Message"><a href="#Half-Prepare-Message" class="headerlink" title="Half(Prepare) Message"></a>Half(Prepare) Message</h4><p>指的是暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次<br>确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息。</p>
<h4 id="Message-Status-Check"><a href="#Message-Status-Check" class="headerlink" title="Message Status Check"></a>Message Status Check</h4><p>由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长<br>期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回<br>查。</p>
<p><img src="/uploads/RocketMQ/RocketMQ03.png" alt="image-20210106210340592"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/uploads/RocketMQ/RocketMQ04.png" alt="image-20210106210340592"></p>
<ol>
<li>发送方向 MQ 服务端发送消息。</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后MQ Server 将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, LocalTransactionState&gt; STATE_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行具体的业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 发送的消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户A账户减500元.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">//模拟调用服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             System.out.println(1/0);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户B账户加500元.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            STATE_MAP.put(msg.getTransactionId(), LocalTransactionState.COMMIT_MESSAGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二次提交确认</span></span><br><span class="line"><span class="comment">//            return LocalTransactionState.UNKNOW;</span></span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        STATE_MAP.put(msg.getTransactionId(), LocalTransactionState.ROLLBACK_MESSAGE);</span><br><span class="line">        <span class="comment">// 回滚</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息回查</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;状态回查 ---&gt; &quot;</span> + msg.getTransactionId() +<span class="string">&quot; &quot;</span> +STATE_MAP.get(msg.getTransactionId()) );</span><br><span class="line">        <span class="keyword">return</span> STATE_MAP.get(msg.getTransactionId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;transaction_producer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> TransactionListenerImpl());</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;pay_topic&quot;</span>, <span class="string">&quot;用户A给用户B转账500元&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        producer.sendMessageInTransaction(message, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">99999</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;HAOKE_CONSUMER&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅topic，接收此Topic下的所有消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;pay_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h4><p>返回commit状态时，消费者能够接收到消息，返回rollback状态时，消费者接受不到消息。</p>
<h2 id="consumer详解"><a href="#consumer详解" class="headerlink" title="consumer详解"></a>consumer详解</h2><h3 id="push和pull模式"><a href="#push和pull模式" class="headerlink" title="push和pull模式"></a>push和pull模式</h3><p>在RocketMQ中，消费者有两种模式，一种是push模式，另一种是pull模式。</p>
<ul>
<li>(常用)push模式：客户端与服务端建立连接后，当服务端有消息时，将消息推送到客户端。</li>
<li>pull模式：客户端不断的轮询请求服务端，来获取新的消息。<br>但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式，即consumer轮询从broker拉取消息。<br>区别：</li>
<li> Push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。</li>
<li>Pull方式里，取消息的过程需要用户自己写，首先通过打算消费的Topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取的开始offset，直到取完了，再换另一个MessageQueue。</li>
<li>疑问：既然是采用pull方式实现，RocketMQ如何保证消息的实时性呢？</li>
</ul>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的<br>数据，再返回，然后进入循环周期。<br>客户端像传统轮询一样从服务端请求数据，服务端会阻塞请求不会立刻返回，直到有数据或超时才返回给客<br>户端，然后关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p>
<p><img src="/uploads/RocketMQ/RocketMQ05.png" alt="image-20210106210340592"></p>
<h2 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h2><p>DefaultMQPushConsumer实现了自动保存offset值以及实现多个consumer的负载均衡。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置组名</span></span><br><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;HAOKE_IM&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过groupname将多个consumer组合在一起，那么就会存在一个问题，消息发送到这个组后，消息怎么分配呢？<br>这个时候，就需要指定消息模式，分别有集群和广播模式。</p>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>同一个 ConsumerGroup(GroupName相同) 里的每 个 Consumer 只消费所订阅消息的一部分内容， 同<br>一个 ConsumerGroup 里所有的 Consumer消费的内容合起来才是所订阅 Topic 内容的整体， 从而达到<br>负载均衡的目的 。</p>
<h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p>同一个 ConsumerGroup里的每个 Consumer都 能消费到所订阅 Topic 的全部消息，也就是一个消息会<br>被多次分发，被多个 Consumer消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集群模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"><span class="comment">// 广播模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure>

<h3 id="重复消息的解决方案"><a href="#重复消息的解决方案" class="headerlink" title="重复消息的解决方案"></a>重复消息的解决方案</h3><p>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办<br>法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<ol>
<li>消费端处理消息的业务逻辑保持幂等性</li>
<li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li>
</ol>
<ul>
<li>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</li>
<li>第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</li>
<li>第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。</li>
<li>第2条可以消息系统实现，也可以业务端实现。</li>
<li>正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以</li>
<li>最好还是**<em>由业务端自己处理消息重复的问题**</em>，这也是RocketMQ不解决消息重复的问题的原因。</li>
<li>  RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</li>
</ul>
<h2 id="RocketMQ存储"><a href="#RocketMQ存储" class="headerlink" title="RocketMQ存储"></a>RocketMQ存储</h2><p>RocketMQ中的消息数据存储，采用了零拷贝技术（使用 mmap + write 方式），文件系统采用 Linux Ext4 文件系<br>统进行存储。</p>
<h3 id="消息数据的存储"><a href="#消息数据的存储" class="headerlink" title="消息数据的存储"></a>消息数据的存储</h3><p>在RocketMQ中，消息数据是保存在磁盘文件中，为了保证写入的性能，RocketMQ尽可能保证顺序写入，顺序写<br>入的效率比随机写入的效率高很多。<br>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的，CommitLog是真正存储数据的文件，<br>ConsumeQueue是索引文件，存储数据指向到物理文件的配置。</p>
<p><img src="/uploads/RocketMQ/RocketMQ06.png" alt="image-20210106210340592"></p>
<p>如上图所示：</p>
<ul>
<li>消息主体以及元数据都存储在CommitLog当中</li>
<li>Consume Queue相当于kafka中的partition，是一个逻辑队列，存储了这个Queue在CommiLog中的起始<br>offset，log大小和MessageTag的hashCode。</li>
<li>每次读取消息队列先读取consumerQueue,然后再通过consumerQueue去commitLog中拿到消息主体。</li>
</ul>
<p>文件位置：</p>
<p><img src="/uploads/RocketMQ/RocketMQ07.png" alt="image-20210106210340592"></p>
<h2 id="同步刷盘与异步刷盘"><a href="#同步刷盘与异步刷盘" class="headerlink" title="同步刷盘与异步刷盘"></a>同步刷盘与异步刷盘</h2><p>RocketMQ 为了提高性能，会尽可能地保证 磁盘的顺序写。消息在通过 Producer 写入 RocketMQ 的时候，有两<br>种写磁盘方式，分别是同步刷盘与异步刷盘。</p>
<ul>
<li><p>同步刷盘</p>
<ul>
<li>在返回写成功状态时，消息已经被写入磁盘 。</li>
<li>具体流程是：消息写入内存的 PAGECACHE 后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程<br>执行完成后唤醒等待的线程，返回消息写成功的状态 。</li>
</ul>
</li>
<li><p>异步刷盘</p>
</li>
<li><p>在返回写成功状态时，消息可能只是被写入了内存的 PAGECACHE，写操作的返回快，吞吐量大</p>
<ul>
<li>当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</li>
</ul>
</li>
<li><p>broker配置文件中指定刷盘方式</p>
<ul>
<li>flushDiskType=ASYNC_FLUSH – 异步</li>
<li>flushDiskType=SYNC_FLUSH – 同步</li>
</ul>
</li>
</ul>
<p><img src="/uploads/RocketMQ/RocketMQ08.png" alt="image-20210106210340592"></p>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-09-Autowired实现原理</title>
    <url>/2021/04/17/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-09-Autowired%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Autowired使用"><a href="#Autowired使用" class="headerlink" title="@Autowired使用"></a>@Autowired使用</h1><h3 id="1-构造函数注入"><a href="#1-构造函数注入" class="headerlink" title="1.构造函数注入"></a>1.构造函数注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Outer &#123;</span><br><span class="line">	<span class="keyword">private</span> Inner inner;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(Inner inner)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.inner = inner;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-属性注入"><a href="#2-属性注入" class="headerlink" title="2.属性注入"></a>2.属性注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Outer &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> Inner inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-方法注入"><a href="#3-方法注入" class="headerlink" title="3.方法注入"></a>3.方法注入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Outer &#123;</span><br><span class="line">	<span class="keyword">private</span> Inner inner;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> inner;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInner</span><span class="params">(Inner inner)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.inner = inner;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>绝大部分的代码都使用第2、第3种。第1种在bean实例化时完成，而第2、第3种的实现原理都是一样的，在属性填充时完成。</p>
<p>在开始之前，如果我们自己设计<code>@Autowired</code>，我们应该怎么实现？我想做法还是比较简单的</p>
<ol>
<li>通过反射查找bean的class下所有注解了<code>@Autowired</code>的<code>字段</code>和<code>方法</code></li>
<li>获取到字段，通过<code>getBean(字段)</code>获取到对应bean，然后再通过反射调用<code>field</code>的<code>set</code>将bean注入</li>
</ol>
<h1 id="Autowired源码分析"><a href="#Autowired源码分析" class="headerlink" title="@Autowired源码分析"></a>@Autowired源码分析</h1><h2 id="AutowiredAnnotationBeanPostProcessor类"><a href="#AutowiredAnnotationBeanPostProcessor类" class="headerlink" title="AutowiredAnnotationBeanPostProcessor类"></a>AutowiredAnnotationBeanPostProcessor类</h2><ul>
<li><p>处理 （@Value，@Autowired，@Inject）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">		<span class="keyword">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;)</span><br><span class="line">					ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">			logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			<span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>该类是<code>@Autowired</code>的具体实现类，先预览一下类方法</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTkwOTU1LWU0YWE4ZjY1ZDM1OTViMWMucG5n?x-oss-process=image/format,png" alt="AutowiredAnnotationBeanPostProcessor预览.png"></p>
<p>发现实际有机会介入bean的创建操作只有可能是后置处理器，用于后置处理的有3个方法，其中一个过时不用，分别是<code>postProcessMergedBeanDefinition</code>、<code>postProcessProperties</code>后置处理，我们再看一下这2个方法的具体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">InstantiationAwareBeanPostProcessorAdapter</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">MergedBeanDefinitionPostProcessor</span>, <span class="title">PriorityOrdered</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 寻找bean中所有被@Autowired注释的属性，并将属性封装成InjectedElement类型</span></span><br><span class="line">		InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">		metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1. 寻找通过@Autowired注解的属性或者方法</span></span><br><span class="line">		InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 2. 注入</span></span><br><span class="line">			metadata.inject(bean, beanName, pvs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pvs;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>跟我们的猜想是一样的，首先先找出所有注解了@Autowired的属性或者方法，然后进行注入，当然postProcessMergedBeanDefinition后置处理器的调用肯定是在postProcessProperties之前的，这里我们回顾一下spring bean的创建过程。2个处理器我已用黄色标出</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTkwOTU1LTdmMDgyMjMxY2JhZTEyYzAuanBn?x-oss-process=image/format,png" alt="spring @Autowired注入时机.jpg"></p>
<h2 id="1-查找所有-Autowired"><a href="#1-查找所有-Autowired" class="headerlink" title="1. 查找所有@Autowired"></a>1. 查找所有@Autowired</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找bean中所有被@Autowired注释的属性，并将属性封装成InjectedElement类型</span></span><br><span class="line">InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">		<span class="comment">// 获取缓存的key值，一般以beanName做key</span></span><br><span class="line">		String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">		<span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">		<span class="comment">// 从缓存中获取metadata</span></span><br><span class="line">		InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">		<span class="comment">// 检测metadata是否需要更新</span></span><br><span class="line">		<span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">				metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">				<span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">						metadata.clear(pvs);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 通过clazz类，查找所有@Autowired的属性或者方法，并封装成InjectionMetadata类型</span></span><br><span class="line">					metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">					<span class="comment">// 将metadata加入缓存</span></span><br><span class="line">					<span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> metadata;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到spring依然在用缓存的方式提高性能，继续跟踪核心代码<code>buildAutowiringMetadata(clazz)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 查看clazz是否有Autowired注解</span></span><br><span class="line">	<span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, <span class="keyword">this</span>.autowiredAnnotationTypes)) &#123;</span><br><span class="line">		<span class="keyword">return</span> InjectionMetadata.EMPTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里需要注意AutowiredFieldElement，AutowiredMethodElement均继承了InjectionMetadata.InjectedElement</span></span><br><span class="line">	<span class="comment">// 因此这个列表是可以保存注解的属性和被注解的方法的</span></span><br><span class="line">	List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 通过do while循环，递归的往直接继承的父类寻找@Autowired</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 2. 通过反射，获取所有属性，doWithLocalFields则是循环的对每个属性应用以下匿名方法</span></span><br><span class="line">		ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">			<span class="comment">// 判断当前field属性是否含有@Autowired的注解</span></span><br><span class="line">			MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line">			<span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 返回该属性在类中的修饰符，如果等于static常量，则抛出异常，@Autowired不允许注解在静态属性上</span></span><br><span class="line">				<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">						logger.info(<span class="string">&quot;Autowired annotation is not supported on static fields: &quot;</span> + field);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// @Autowired有required属性，获取required的值，默认为true</span></span><br><span class="line">				<span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">				<span class="comment">// 3. 将field封装成InjectedElement，并添加到集合中，这里用的是AutowiredFieldElement</span></span><br><span class="line">				currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4. @Autowired可以注解在方法上</span></span><br><span class="line">		ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">			Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">			<span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">			<span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">						logger.info(<span class="string">&quot;Autowired annotation is not supported on static methods: &quot;</span> + method);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (method.getParameterCount() == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">						logger.info(<span class="string">&quot;Autowired annotation should only be used on methods with parameters: &quot;</span> +</span><br><span class="line">								method);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">				PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">				<span class="comment">// 5. 将方法封装成InjectedElement，并添加到集合中，这里用的是AutowiredMethodElement</span></span><br><span class="line">				currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">		<span class="comment">// 返回直接继承的父类</span></span><br><span class="line">		targetClass = targetClass.getSuperclass();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果父类不为空则需要把父类的@Autowired属性或方法也找出</span></span><br><span class="line">	<span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line">	<span class="comment">// 6. new InjectionMetadata(clazz, elements)，将找到的所有的待注入属性或方法生成metadata返回</span></span><br><span class="line">	<span class="keyword">return</span> InjectionMetadata.forElements(elements, clazz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>外层 do … while … 的循环被用于递归的查找父类的@Autowired属性或方法</p>
</li>
<li><p>通过反射的方式获取到所有属性并循环验证每一个属性是否被@Autowired注解</p>
</li>
<li><p>将查找到包含@Autowired注解的filed封装成AutowiredFieldElement，加入到列表中</p>
</li>
<li><p>循环查找在方法上的注解</p>
</li>
<li><p>将找到的方法封装成AutowiredMethodElement，并加入列表<br>这里需要特别强调一点，InjectedElement被AutowiredFieldElement、AutowiredMethodElement所继承，他们都有各自的inject函数，实现各自的注入。因此改ArrayList elements是拥有2种类型的属性</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MTkwOTU1LTcxZjNjZjNiMzk2YTBjOTAucG5n?x-oss-process=image/format,png" alt="InjectedElement.png"></p>
</li>
<li><p>将找到的所有元素列表和clazz作为参数生成metadata数据返回</p>
</li>
</ol>
<h2 id="2-注入"><a href="#2-注入" class="headerlink" title="2. 注入"></a>2. 注入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注入</span></span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// 获取所有需要被注入的元素</span></span><br><span class="line">		Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">		Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">				(checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line">		<span class="comment">// 迭代的元素不为空</span></span><br><span class="line">		<span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Processing injected element of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;: &quot;</span> + element);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 循环注入，这里有可能是AutowiredFieldElement也可能AutowiredMethodElement，因此调用的inject是2个不同的方法</span></span><br><span class="line">				element.inject(target, beanName, pvs);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用for循环，遍历刚刚我们查到到的elements列表，进行注入。在上面有特别提醒，这里的element有可能是AutowiredFieldElement类型、或AutowiredMethodElement类型。各自代表@Autowired注解在属性上、以及注解在方法上的2种不同元素。因此他们调用的element.inject(target, beanName, pvs);也是不一样的</p>
<h3 id="2-1-字段注入-AutowiredFieldElement"><a href="#2-1-字段注入-AutowiredFieldElement" class="headerlink" title="2.1 字段注入(AutowiredFieldElement)"></a>2.1 字段注入(AutowiredFieldElement)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredFieldElement</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span>.<span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">		Object value;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">			value = resolvedCachedArgument(beanName, <span class="keyword">this</span>.cachedFieldValue);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 专门用于注入的包装类，包装构造函数参数，方法参数或字段</span></span><br><span class="line">			DependencyDescriptor desc = <span class="keyword">new</span> DependencyDescriptor(field, <span class="keyword">this</span>.required);</span><br><span class="line">			<span class="comment">// 设置class</span></span><br><span class="line">			desc.setContainingClass(bean.getClass());</span><br><span class="line">			<span class="comment">// 需要被自动注入的beanNames，这里只有可能 = 1，方法注入时才有可能为多个</span></span><br><span class="line">			Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">			Assert.state(beanFactory != <span class="keyword">null</span>, <span class="string">&quot;No BeanFactory available&quot;</span>);</span><br><span class="line">			TypeConverter typeConverter = beanFactory.getTypeConverter();<span class="comment">// 获取类型转换器</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 通过beanFactory获取属性对应的值，比如需要调用getBean(&quot;b&quot;)获取依赖的属性单例，并且通过自动转型转为需要的类型</span></span><br><span class="line">				value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(<span class="keyword">null</span>, beanName, <span class="keyword">new</span> InjectionPoint(field), ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">					<span class="keyword">if</span> (value != <span class="keyword">null</span> || <span class="keyword">this</span>.required) &#123;</span><br><span class="line">						<span class="keyword">this</span>.cachedFieldValue = desc;</span><br><span class="line">						<span class="comment">// 注册依赖，</span></span><br><span class="line">						registerDependentBeans(beanName, autowiredBeanNames);</span><br><span class="line">						<span class="comment">// 因为是属性注入，因此这里只有可能等于1</span></span><br><span class="line">						<span class="keyword">if</span> (autowiredBeanNames.size() == <span class="number">1</span>) &#123;</span><br><span class="line">							String autowiredBeanName = autowiredBeanNames.iterator().next();</span><br><span class="line">							<span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class="line">									beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;</span><br><span class="line">								<span class="comment">// 缓存当前value</span></span><br><span class="line">								<span class="keyword">this</span>.cachedFieldValue = <span class="keyword">new</span> ShortcutDependencyDescriptor(</span><br><span class="line">										desc, autowiredBeanName, field.getType());</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">this</span>.cachedFieldValue = <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">this</span>.cached = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 通过反射，将value值设置到bean中</span></span><br><span class="line">			ReflectionUtils.makeAccessible(field);</span><br><span class="line">			field.set(bean, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>spring通过反射的方式，调用field的set进行属性的注入</li>
</ul>
<h3 id="2-2-方法注入-AutowiredMethodElement"><a href="#2-2-方法注入-AutowiredMethodElement" class="headerlink" title="2.2 方法注入(AutowiredMethodElement)"></a>2.2 方法注入(AutowiredMethodElement)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredMethodElement</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span>.<span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, <span class="meta">@Nullable</span> String beanName, <span class="meta">@Nullable</span> PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (checkPropertySkipping(pvs)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// @Autowired标注在方法上</span></span><br><span class="line">		Method method = (Method) <span class="keyword">this</span>.member;</span><br><span class="line">		Object[] arguments;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">			<span class="comment">// Shortcut for avoiding synchronization...</span></span><br><span class="line">			<span class="comment">// 有缓存</span></span><br><span class="line">			arguments = resolveCachedArguments(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 没缓存，直接获取方法上所有的参数</span></span><br><span class="line">			<span class="keyword">int</span> argumentCount = method.getParameterCount();</span><br><span class="line">			arguments = <span class="keyword">new</span> Object[argumentCount];</span><br><span class="line">			DependencyDescriptor[] descriptors = <span class="keyword">new</span> DependencyDescriptor[argumentCount];</span><br><span class="line">			Set&lt;String&gt; autowiredBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(argumentCount);</span><br><span class="line">			Assert.state(beanFactory != <span class="keyword">null</span>, <span class="string">&quot;No BeanFactory available&quot;</span>);</span><br><span class="line">			TypeConverter typeConverter = beanFactory.getTypeConverter();</span><br><span class="line">			<span class="comment">// 循环所有参数</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">				MethodParameter methodParam = <span class="keyword">new</span> MethodParameter(method, i);</span><br><span class="line">				DependencyDescriptor currDesc = <span class="keyword">new</span> DependencyDescriptor(methodParam, <span class="keyword">this</span>.required);</span><br><span class="line">				currDesc.setContainingClass(bean.getClass());</span><br><span class="line">				descriptors[i] = currDesc;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 通过beanFactory，获取代注入的bean，并进行类型转换</span></span><br><span class="line">					Object arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter);</span><br><span class="line">					<span class="keyword">if</span> (arg == <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.required) &#123;</span><br><span class="line">						arguments = <span class="keyword">null</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					arguments[i] = arg;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(<span class="keyword">null</span>, beanName, <span class="keyword">new</span> InjectionPoint(methodParam), ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="keyword">this</span>.cached) &#123;</span><br><span class="line">					<span class="keyword">if</span> (arguments != <span class="keyword">null</span>) &#123;</span><br><span class="line">						DependencyDescriptor[] cachedMethodArguments = Arrays.copyOf(descriptors, arguments.length);</span><br><span class="line">						<span class="comment">// 注册依赖</span></span><br><span class="line">						registerDependentBeans(beanName, autowiredBeans);</span><br><span class="line">						<span class="comment">// 如果自动注入的个数 = 参数个数，则缓存</span></span><br><span class="line">						<span class="keyword">if</span> (autowiredBeans.size() == argumentCount) &#123;</span><br><span class="line">							Iterator&lt;String&gt; it = autowiredBeans.iterator();</span><br><span class="line">							Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramTypes.length; i++) &#123;</span><br><span class="line">								String autowiredBeanName = it.next();</span><br><span class="line">								<span class="keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;</span><br><span class="line">										beanFactory.isTypeMatch(autowiredBeanName, paramTypes[i])) &#123;</span><br><span class="line">									<span class="comment">// 缓存</span></span><br><span class="line">									cachedMethodArguments[i] = <span class="keyword">new</span> ShortcutDependencyDescriptor(</span><br><span class="line">											descriptors[i], autowiredBeanName, paramTypes[i]);</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 缓存方法</span></span><br><span class="line">						<span class="keyword">this</span>.cachedMethodArguments = cachedMethodArguments;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">this</span>.cachedMethodArguments = <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">this</span>.cached = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (arguments != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 反射调用注入方法，将获取到的所有bean作为参数</span></span><br><span class="line">				ReflectionUtils.makeAccessible(method);</span><br><span class="line">				method.invoke(bean, arguments);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里与属性注入最大的区别在于，<code>@Autowired注解</code>在方法上，方法可以拥有多个参数，因此这里需要通过循环将一个个获取，而获取bean的方式于上面一样，本质都是通过<code>getBean</code>获取。而核心语句还是2句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射调用注入方法，将获取到的所有bean作为参数</span></span><br><span class="line">ReflectionUtils.makeAccessible(method);</span><br><span class="line">method.invoke(bean, arguments);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与属性注入不同的是，当<code>@Autowired注解</code>在方法上，例如我们注解在setter方法上，则只需要直接调用该setter方法将参数数组传入即可以，即使用invoke触发方法，具体属性赋值的过程在setter方法中由用户自行编写</p>
]]></content>
      <categories>
        <category>Spring源码</category>
      </categories>
      <tags>
        <tag>AutowiredAnnotationBeanPostProcessor接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+NexT(v7.0+) 搭建博客：主题美化</title>
    <url>/2019/05/17/hexo-theme-beautifed/</url>
    <content><![CDATA[<p>本文介绍了在 NexT(v7.0+) 主题的基础上整体布局美化的方案，主要包括:</p>
<ul>
<li>Font：字体、动态背景canvas_ribbon</li>
<li>Top：进度条、Follow me、菜单背景收缩</li>
<li>Footer：备案显示、运行时间、访客统计</li>
<li>Sidebar：近期文章、浏览进度、左边显示、目录展开</li>
</ul>
<p>大家可以选择喜欢的方案美化自己的博客，当然最好可以再加入点自己的想法改造。</p>
<a id="more"></a>

<h2 id="Font"><a href="#Font" class="headerlink" title="Font"></a>Font</h2><p>前端的美化，可以做的比较多，比如修改字体、修改背景等等。<br>首先在 <span id="inline-purple">主题配置文件</span> _config.yml 中修改配置<code>font</code>：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 开启前端设置</span></span><br></pre></td></tr></table></figure>

<h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p>默认的字体是微软雅黑，有点审美疲劳了 (lll￢ω￢)，在浏览其他人网站的时候看到了一种很有科技感的字体 『<strong>Monda</strong>』，感觉还是不错的。如何应用到自己的博客呢？<br>首先，可以从 <a href="https://www.fontyukle.net/cn/1,MONDA">frontyukle</a> 下载字体文件，在服务器上安装。<br>然后在 <span id="inline-purple">主题配置文件</span> _config.yml 中的修改全局字体配置：</p>
<figure class="highlight diff"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line"><span class="deletion">- family: Lato</span></span><br><span class="line"><span class="addition">+ family: Monda   # 设置Monda字体</span></span><br></pre></td></tr></table></figure>

<h3 id="设置三角丝带背景"><a href="#设置三角丝带背景" class="headerlink" title="设置三角丝带背景"></a>设置三角丝带背景</h3><div class="note info"><p>该功能由 Vue 作者 <a href="http://evanyou.me/">尤雨溪</a> 首创。注意：添加动态背景会极大增加页面内存占用及 CPU 消耗。</p>
</div>

<p>首先，在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-canvas-ribbon themes/next/<span class="built_in">source</span>/lib/canvas_ribbon</span><br></pre></td></tr></table></figure>

<p>然后，在 <span id="inline-purple">主题配置文件</span> _config.yml 中的修改配置<code>canvas_ribbon</code>：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>	<span class="comment"># 开启随机三角丝带背景</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">90</span>	<span class="comment"># 设置丝带宽度</span></span><br></pre></td></tr></table></figure>

<h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><p>顶部我们保持简洁为主，设置主要包括：进度条、Fork、菜单等等。</p>
<h3 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h3><p>当网络不好的时候会出现白屏等待，此时如果能有加载进度提示将会提高用户操作体验。<br>首先，在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace themes/next/<span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>

<p>然后，修改 <span id="inline-purple">主题配置文件</span> _config.yml 中的配置<code>pace</code> 改为 <code>true</code>，并从上面提供的样式中选择一种填入<code>pace_theme</code>中就可以了。</p>
<h3 id="右上角的Follow-Github"><a href="#右上角的Follow-Github" class="headerlink" title="右上角的Follow-Github"></a>右上角的Follow-Github</h3><p>如果你想大家在看博客的时候能快速链接到你的Github，不妨设置<strong>Github_banner</strong>，效果图如下：<br><img src="https://image.chingow.cn/images/23aaa7f0-a7e7-b170-deef-a8ffb649a473.png?500x" alt="github_banner" title="github_banner"></p>
<p>修改 <span id="inline-purple">主题配置文件</span> _config.yml 中的配置<code>github_banner</code>，在<code>permalink</code>里配置自己的github地址：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/yourname</span></span><br></pre></td></tr></table></figure>

<h3 id="菜单背景收缩"><a href="#菜单背景收缩" class="headerlink" title="菜单背景收缩"></a>菜单背景收缩</h3><p>在 Muse主题方案中 Header 和 Footer 是没有背景色的，的颜色与内容一致不易区分，而且网站标题的字体不够明显，我做了几个修改</p>
<ul>
<li>头部和底部颜色修改</li>
<li>网站标题加粗和颜色修改</li>
<li>菜单字体增大显示</li>
</ul>
<p>在主题自定义样式文件中添加以下样式：</p>
<figure class="highlight css"><figcaption><span>themes/next/sources/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//窗口效果相关样式</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为Header和Footer添加背景色</span><br><span class="line"><span class="selector-id">#header</span>, <span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">245</span>, <span class="number">245</span>, <span class="number">245</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//防止sidebar和footer同时开启动效时堆叠异常</span><br><span class="line"><span class="selector-id">#sidebar</span>, <span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//防止挡住页末文章的阅读全文按钮</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加宽菜单间距，放大菜单图标</span><br><span class="line"><span class="selector-id">#menu</span> <span class="selector-class">.menu-item</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">14px</span>;</span><br><span class="line"></span><br><span class="line">  .fa &#123;</span><br><span class="line">    <span class="selector-tag">font-size</span>: 16<span class="selector-tag">px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Muse主题下自定义样式</span><br><span class="line">if hexo-config(&#x27;scheme&#x27;) == &quot;Muse&quot; &#123;</span><br><span class="line">  <span class="selector-class">.site-meta</span> &#123;</span><br><span class="line">    .brand &#123;</span><br><span class="line">      <span class="selector-tag">color</span>: <span class="selector-tag">rgb</span>(34, 34, 34);</span><br><span class="line">      <span class="selector-tag">background</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.site-title</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">      <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改完才发现顶部菜单的空间太大了，于是调节菜单高度，在自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes/next/layout/_custom/custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;# 页面加载时header高度收缩动效 #&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.header-inner&quot;</span>).animate(&#123;<span class="attr">padding</span>: <span class="string">&quot;25px 0 25px&quot;</span>&#125;, <span class="number">1000</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">    ...</span><br><span class="line">  &#123;% include &#x27;_third-party/copy-code.swig&#x27; %&#125;</span><br><span class="line">  &#123;% include &#x27;_third-party/chatra.swig&#x27; %&#125;</span><br><span class="line">  &#123;% include &#x27;_third-party/tidio.swig&#x27; %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  &#123;% include &#x27;_custom/custom.swig&#x27; %&#125;</span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>调节移动端显示的高度</p>
<figure class="highlight diff"><figcaption><span>themes/next/source/css/_schemes/Muse/_menu.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">mobile() &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 0;</span><br><span class="line"><span class="deletion">-  top: 52px;</span></span><br><span class="line"><span class="addition">+  top: 95px;</span></span><br><span class="line">  margin: 0;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h2><p>底部设置的可完性就比较多了，建站信息、备案信息、以及访客和统计信息等信息都可以个性化定制。</p>
<h3 id="ICP备案和公安备案"><a href="#ICP备案和公安备案" class="headerlink" title="ICP备案和公安备案"></a>ICP备案和公安备案</h3><p>我们的网站已经有备案号了，但是应该如何添加备案号到博客最下面呢？<br>首先，在 <span id="inline-purple">主题配置文件</span> _config.yml 中的配置添加备案配置：</p>
<figure class="highlight diff"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"> # 这里打开备案信息，填写ICP备案号</span><br><span class="line">   beian:</span><br><span class="line">    enable: true</span><br><span class="line">    icp: 鄂ICP证18014719号</span><br><span class="line"></span><br><span class="line"> # 这里是新加的内容，填写公安备案信息</span><br><span class="line"><span class="addition">+  gongan:</span></span><br><span class="line"><span class="addition">+    enable: true</span></span><br><span class="line"><span class="addition">+    local: 鄂</span></span><br><span class="line"><span class="addition">+    num: 42011102003178</span></span><br></pre></td></tr></table></figure>

<p>然后，在语言配置文件里，添加表述文案<code>beian</code>：</p>
<figure class="highlight diff"><figcaption><span>themes/next/languages/zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line"><span class="addition">+   beian: </span></span><br><span class="line"><span class="addition">+    gongan: 公网安备%s号</span></span><br></pre></td></tr></table></figure>

<p>接下来，删除原有的布局文件中备案样式的代码：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_partials/footer.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  #&#125;&#123;% set current = date(Date.now(), &quot;YYYY&quot;) %&#125;&#123;#</span><br><span class="line"><span class="deletion">- #&#125;&#123;% if theme.footer.beian.enable %&#125;&#123;#</span></span><br><span class="line"><span class="deletion">- #&#125;  &#123;&#123; next_url(&#x27;http://www.beian.miit.gov.cn&#x27;, theme.footer.beian.icp + &#x27; &#x27;) &#125;&#125;&#123;#</span></span><br><span class="line"><span class="deletion">- #&#125;&#123;% endif %&#125;&#123;#</span></span><br><span class="line">  #&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;&#123;#</span><br><span class="line">  ...</span><br><span class="line">  &lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright || author &#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  &lt;span class=&quot;post-meta-divider footer-ages-icon&quot;&gt; | &lt;/span&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% if config.symbols_count_time.total_symbols %&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在主题布局文件中添加我们自定义的备案样式：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &lt;div class=&quot;footer-inner&quot;&gt;</span><br><span class="line">    &#123;&#123; partial(&#x27;_partials/footer.swig&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">    &#123;% include &#x27;_third-party/analytics/analytics-with-widget.swig&#x27; %&#125;</span><br><span class="line"><span class="addition">+        &lt;div class=&quot;footer-custom&quot;&gt;</span></span><br><span class="line"><span class="addition">+            &#123;% if theme.footer.beian.enable %&#125;&#123;#</span></span><br><span class="line"><span class="addition">+          #&#125;&#123;&#123; next_url(&#x27;http://www.beian.miit.gov.cn&#x27;, theme.footer.beian.icp + &#x27; &#x27;) &#125;&#125;&#123;#</span></span><br><span class="line"><span class="addition">+          #&#125;&#123;% endif %&#125;</span></span><br><span class="line"><span class="addition">+          &#123;% if theme.footer.beian.enable and theme.footer.gongan.enable %&#125;</span></span><br><span class="line"><span class="addition">+            &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span></span><br><span class="line"><span class="addition">+          &#123;% endif %&#125;</span></span><br><span class="line"><span class="addition">+          &#123;% if theme.footer.gongan.enable %&#125;&#123;#</span></span><br><span class="line"><span class="addition">+          #&#125; &lt;span style=&quot;padding-left:25px;background:url(/images/beian.png) no-repeat left center&quot; rel=&quot;nofollow&quot;&gt;&#123;#</span></span><br><span class="line"><span class="addition">+          #&#125; &#123;&#123; theme.footer.gongan.local&#125;&#125;&#123;&#123;__(&#x27;footer.beian.gongan&#x27;, next_url(&#x27;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=&#x27;+theme.footer.gongan.num, theme.footer.gongan.num )) &#125;&#125;&#123;#</span></span><br><span class="line"><span class="addition">+          #&#125;&#123;% endif %&#125;</span></span><br><span class="line"><span class="addition">+        &lt;/div&gt;</span></span><br><span class="line">    &#123;% block footer %&#125;&#123;% endblock %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="网站的建站时间"><a href="#网站的建站时间" class="headerlink" title="网站的建站时间"></a>网站的建站时间</h3><p>NexT主题已经内置了添加建站时间。在 <span id="inline-purple">主题配置文件</span> _config.yml 中修改配置<code>since</code> ：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>  <span class="comment"># 修改建站时间</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span>  <span class="comment"># 改成心型图标</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#ff0000&quot;</span> <span class="comment"># 改成红色图标</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="网站的运行时间"><a href="#网站的运行时间" class="headerlink" title="网站的运行时间"></a>网站的运行时间</h3><div class="note info"><p>本章节受 <a href="http://yearito.cn/posts/hexo-advanced-settings.html">Yearito’s Blog | 站点运行时间统计 </a> 的启发，自行重构了代码逻辑。</p>
</div>

<p>接下来我们显示网站的运行时间，在这里我做了一些个性化文案，可供大家参考：<br><img src="https://image.chingow.cn/images/00c3834a-cf72-22a3-cd7c-6486649fd648.png?550x" alt="网站建站运行时间" title="网站建站运行时间"></p>
<p>在 <span id="inline-purple">主题配置文件</span> _config.yml 中的添加 <code>ages</code>配置：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">ages:</span> <span class="comment"># site running time</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">birthday:</span> <span class="number">20190419</span>    <span class="comment"># 网站运行时间</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#1094e8&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>在语言配置文件里，添加表述文案<code>age</code>：</p>
<figure class="highlight diff"><figcaption><span>themes/next/languages/zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line"><span class="addition">+   age: 我已在此等候你</span></span><br></pre></td></tr></table></figure>

<p>在主题自定义布局文件中添加以下代码：</p>
<figure class="highlight html"><figcaption><span>themes/next/layout/_custom/custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 页脚站点运行时间统计 #&#125;</span><br><span class="line">  &#123;% if theme.footer.ages.enable %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        var ages = moment.preciseDiff(moment(),moment(</span><span class="template-variable">&#123;&#123; <span class="name">theme.footer.ages.birthday</span> &#125;&#125;</span><span class="xml">,&quot;YYYYMMDD&quot;));</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//去除时分秒信息</span></span></span><br><span class="line"><span class="javascript">        ages = ages.replace(<span class="regexp">/\s?\d&#123;0,2&#125;\s+hours?/</span>, <span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="javascript">        ages = ages.replace(<span class="regexp">/\s?\d&#123;0,2&#125;\s+minutes?/</span>, <span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="javascript">        ages = ages.replace(<span class="regexp">/\s?\d&#123;0,2&#125;\s+seconds?/</span>, <span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//将年月日转换为中文</span></span></span><br><span class="line"><span class="javascript">        ages = ages.replace(<span class="regexp">/years?/</span>, <span class="string">&quot;年&quot;</span>);</span></span><br><span class="line"><span class="javascript">        ages = ages.replace(<span class="regexp">/months?/</span>, <span class="string">&quot;月&quot;</span>);</span></span><br><span class="line"><span class="javascript">        ages = ages.replace(<span class="regexp">/days?/</span>, <span class="string">&quot;天&quot;</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml">        ages = ages.replace(/\d+/g, &#x27;<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:</span></span></span><span class="template-variable">&#123;&#123; <span class="name">theme.footer.ages.color</span> &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span>&gt;</span>$&amp;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#x27;);</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        span.innerHTML = `</span><span class="template-variable">&#123;&#123; <span class="name">__</span>(<span class="name">&#x27;footer.age&#x27;</span>)&#125;&#125;</span><span class="xml"> $&#123;ages&#125;`;</span></span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">&quot;span&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">//插入到agesicon之后</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> agesicon = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.footer-ages-icon&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.querySelector(<span class="string">&quot;.copyright&quot;</span>).insertBefore(span, agesicon.nextSibling);</span></span><br><span class="line">      timer();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加访客统计"><a href="#添加访客统计" class="headerlink" title="添加访客统计"></a>添加访客统计</h3><p>该功能由 <a href="http://ibruce.info/2015/04/04/busuanzi/">不蒜子</a> 提供。UV：独立访客数，PV：网站浏览量，访客数和浏览量的区别在于一个用户连续点击n篇文章，会记录n次浏览量，但只记录一次访客数，效果如图：<br><img src="https://image.chingow.cn/images/0298aada-faa2-1f09-f68a-e0382168a5ed.png?550x" alt="网站访客统计" title="网站访客统计"></p>
<div class="note info"><p>由于不蒜子是基于域名来进行统计计算的，所以通过 localhost:4000 端口访问的时候统计数据UV和PV都会异常的大，属于正常现象。</p>
</div>

<p>首先，在 <span id="inline-purple">主题配置文件</span> _config.yml 中打开不蒜子功能：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>   <span class="comment"># 访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>   <span class="comment"># 访问量</span></span><br></pre></td></tr></table></figure>

<p>然后，在语言配置文件里，修改个性化表述文案：</p>
<figure class="highlight diff"><figcaption><span>themes/next/languages/zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line"><span class="deletion">- total_views: 总访问量</span></span><br><span class="line"><span class="deletion">- total_visitors: 总访客量</span></span><br><span class="line"><span class="addition">+ total_views: &quot;历经 %s 次回眸才与你相遇&quot;</span></span><br><span class="line"><span class="addition">+ total_visitors: &quot;我的第 %s 位朋友，&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后，修改不蒜子模板文件：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_third-party/analytics/busuanzi-counter.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;busuanzi-count&quot;&gt;</span><br><span class="line">  &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="addition">+  &#123;% if theme.busuanzi_count.enable %&#125;</span></span><br><span class="line"><span class="addition">+  &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">    &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line"><span class="deletion">-    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span></span><br><span class="line"><span class="deletion">-      &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="deletion">-    &lt;/span&gt;</span></span><br><span class="line"><span class="deletion">-    &lt;span class=&quot;site-uv&quot; title=&quot;&#123;&#123; __(&#x27;footer.total_visitors&#x27;) &#125;&#125;&quot;&gt;</span></span><br><span class="line"><span class="deletion">-      &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="addition">+       &lt;span class=&quot;site-uv&quot;&gt;</span></span><br><span class="line"><span class="addition">+       &#123;&#123; __(&#x27;footer.total_visitors&#x27;, &#x27;&lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&#x27;) &#125;&#125;</span></span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   &#123;% if theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125;</span></span><br><span class="line"><span class="deletion">-     &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span></span><br><span class="line"><span class="deletion">-   &#123;% endif %&#125;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">    &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="deletion">-     &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span></span><br><span class="line"><span class="deletion">-       &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;/span&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;span class=&quot;site-pv&quot; title=&quot;&#123;&#123; __(&#x27;footer.total_views&#x27;) &#125;&#125;&quot;&gt;</span></span><br><span class="line"><span class="deletion">-       &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;</span></span><br><span class="line"><span class="addition">+     &lt;span class=&quot;site-pv&quot;&gt;</span></span><br><span class="line"><span class="addition">+       &#123;&#123; __(&#x27;footer.total_views&#x27;, &#x27;&lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;&#x27;) &#125;&#125;</span></span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="addition">+ &#123;% endif %&#125;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下样式：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">//修改不蒜子数据颜色</span><br><span class="line"><span class="selector-class">.busuanzi-value</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1890ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sidebar"><a href="#Sidebar" class="headerlink" title="Sidebar"></a>Sidebar</h2><p>侧边栏里的信息有很多，比如站点信息、RSS、链接信息、目录信息等等，我们要有选择性的显示。尽量保持Next主题的宗旨 – <span id="inline-green">简洁</span></p>
<h3 id="显示近期文章"><a href="#显示近期文章" class="headerlink" title="显示近期文章"></a>显示近期文章</h3><p>当你新写了一些好文章，想尽快告诉大家要怎么办呢？放在侧边栏里那是最合适不过了～(￣▽￣～)(～￣▽￣)～ 比如这样：<br><img src="https://image.chingow.cn/images/f2840b83-ff46-dd56-0aa1-1af57c5e5dad.png" alt="近期文章" title="近期文章"></p>
<p>首先配置开关和文案，便于随时修改。<br>在 <span id="inline-purple">主题配置文件</span> _config.yml 中添加近期文章<code>recent_posts</code>的配置：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 近期文章</span></span><br><span class="line"><span class="attr">recent_posts:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">recent_posts_layout:</span> <span class="string">block</span></span><br></pre></td></tr></table></figure>

<p>在语言配置文件里，添加表述文案<code>recent_posts</code>：</p>
<figure class="highlight diff"><figcaption><span>themes/next/languages/zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line"><span class="addition">+   recent_posts: 近期文章</span></span><br></pre></td></tr></table></figure>

<p>在侧边栏原有布局文件中的合适位置添加近期文章显示代码：</p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_macro/sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;% if theme.social %&#125;</span><br><span class="line">  ...</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ &lt;!-- 添加近期文章 --&gt;</span></span><br><span class="line"><span class="addition">+ &#123;% if theme.recent_posts %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts_layout  &#125;&#125;&quot;&gt;</span></span><br><span class="line"><span class="addition">+     &lt;div class=&quot;links-of-blogroll-title&quot;&gt;</span></span><br><span class="line"><span class="addition">+       &lt;!-- modify icon to fire by szw --&gt;</span></span><br><span class="line"><span class="addition">+       &lt;i class=&quot;fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+       &#123;&#123; __(&#x27;sidebar.recent_posts&#x27;) &#125;&#125;</span></span><br><span class="line"><span class="addition">+     &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+     &lt;ul class=&quot;links-of-blogroll-list&quot;&gt;</span></span><br><span class="line"><span class="addition">+       &#123;% set posts = site.posts.sort(&#x27;-date&#x27;) %&#125;</span></span><br><span class="line"><span class="addition">+       &#123;% for post in posts.slice(&#x27;0&#x27;, &#x27;5&#x27;) %&#125;</span></span><br><span class="line"><span class="addition">+         &lt;li&gt;</span></span><br><span class="line"><span class="addition">+           &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;</span></span><br><span class="line"><span class="addition">+         &lt;/li&gt;</span></span><br><span class="line"><span class="addition">+       &#123;% endfor %&#125;</span></span><br><span class="line"><span class="addition">+     &lt;/ul&gt;</span></span><br><span class="line"><span class="addition">+   &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+ &#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="显示当前浏览进度"><a href="#显示当前浏览进度" class="headerlink" title="显示当前浏览进度"></a>显示当前浏览进度</h3><p>在 <span id="inline-purple">主题配置文件</span> _config.yml 中修改<code>back2top</code>的<code>scrollpercent</code>：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span>  <span class="comment">#  浏览页面的时候显示当前浏览进度  </span></span><br></pre></td></tr></table></figure>

<p>配置完之后，发现这个按钮颜色有点单调，让它炫酷点的吧 &lt;(￣ˇ￣)/ ，每次刷新可以生成不同的颜色，在自定义样式文件中添加如下样式：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">// 回到顶部样式</span><br><span class="line"><span class="selector-class">.back-to-top</span> <span class="selector-class">.fa-arrow-up</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgb</span>(random-color(<span class="number">0</span>, <span class="number">255</span>) - <span class="number">50%</span>, <span class="built_in">random-color</span>(<span class="number">0</span>, <span class="number">255</span>) - <span class="number">50%</span>, <span class="built_in">random-color</span>(<span class="number">0</span>, <span class="number">255</span>) - <span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="侧边栏移到左边"><a href="#侧边栏移到左边" class="headerlink" title="侧边栏移到左边"></a>侧边栏移到左边</h3><p>用惯了<strong>Ofice</strong>的人习惯导航菜单在左边的格式，如何把侧边栏放在左侧呢？<br>NexT 主题中 Pisces 和 Gemini 支持通过主题配置文件来将侧边栏置于左侧或右侧。<br>在 <span id="inline-purple">主题配置文件</span> _config.yml 中修改配置<code>sidebar</code> ：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line"><span class="comment"># Sidebar Position, available values: left | right (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span>   <span class="comment"># 调整侧边栏显示位置，仅支持 Pisces 和 Gemini 主题</span></span><br></pre></td></tr></table></figure>

<p>而 Muse 和 Mist 则需要深度修改源码才能实现改变侧边栏位置：</p>
<figure class="highlight css"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar-toggle</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改动效脚本代码：</p>
<figure class="highlight diff"><figcaption><span>themes/next/source/js/src/motion.js</span></figcaption><table><tr><td class="code"><pre><span class="line">$(document)</span><br><span class="line">  .on(&#x27;sidebar.isShowing&#x27;, function() &#123;</span><br><span class="line">    NexT.utils.isDesktop() &amp;&amp; $(&#x27;body&#x27;).velocity(&#x27;stop&#x27;).velocity(</span><br><span class="line"><span class="deletion">-     &#123;paddingRight: SIDEBAR_WIDTH&#125;,</span></span><br><span class="line"><span class="addition">+     &#123;paddingLeft: SIDEBAR_WIDTH&#125;,</span></span><br><span class="line">      SIDEBAR_DISPLAY_DURATION</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">  hideSidebar: function() &#123;</span><br><span class="line"><span class="deletion">-   NexT.utils.isDesktop() &amp;&amp; $(&#x27;body&#x27;).velocity(&#x27;stop&#x27;).velocity(&#123;paddingRight: 0&#125;);</span></span><br><span class="line"><span class="addition">+   NexT.utils.isDesktop() &amp;&amp; $(&#x27;body&#x27;).velocity(&#x27;stop&#x27;).velocity(&#123;paddingLeft: 0&#125;);</span></span><br><span class="line">    this.sidebarEl.find(&#x27;.motion-element&#x27;).velocity(&#x27;stop&#x27;).css(&#x27;display&#x27;, &#x27;none&#x27;);</span><br><span class="line">    this.sidebarEl.velocity(&#x27;stop&#x27;).velocity(&#123;width: 0&#125;, &#123;display: &#x27;none&#x27;&#125;);</span><br><span class="line"></span><br><span class="line">    sidebarToggleLines.init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此以来就可以将侧边栏放置在左边了，但当窗口宽度缩小到991px之后会出现样式错误：侧边栏收缩消失但是页面左侧仍留有空白间距，此时修改如下代码即可：</p>
<figure class="highlight diff"><figcaption><span>themes/next/source/css/_common/scaffolding/base.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  position: relative; // Required by scrollspy</span><br><span class="line">  font-family: $font-family-base;</span><br><span class="line">  font-size: $font-size-base;</span><br><span class="line">  line-height: $line-height-base;</span><br><span class="line">  color: $text-color;</span><br><span class="line">  background: $body-bg-color;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- +mobile() &#123; padding-left: 0 !important; &#125;</span></span><br><span class="line"><span class="deletion">- +tablet() &#123; padding-left: 0 !important; &#125;  </span></span><br><span class="line"><span class="addition">+ +mobile() &#123; padding-right: 0 !important; &#125;</span></span><br><span class="line"><span class="addition">+ +tablet() &#123; padding-right: 0 !important; &#125;</span></span><br><span class="line">  +desktop-large() &#123; font-size: $font-size-large; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="侧边栏目录展开"><a href="#侧边栏目录展开" class="headerlink" title="侧边栏目录展开"></a>侧边栏目录展开</h3><p>侧边栏的TOC目录每次滑到哪儿，目录展开到哪。这样查看文章结构就很不方便，如何设置才能让文章目录默认全部都展开？<br>在 <span id="inline-purple">主题配置文件</span> _config.yml 中修改配置<code>toc</code> ：</p>
<figure class="highlight yaml"><figcaption><span>themes/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span>  <span class="comment">## 如果标题超长，是否换行</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span>  <span class="comment">## 侧边栏是否完全展开</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-03-ThreadAPI详解</title>
    <url>/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="线程sleep"><a href="#线程sleep" class="headerlink" title="线程sleep"></a>线程sleep</h2><p>sleep是一个静态方法，其中有两个重载方法，其中一个需要传入毫秒数，另外一个既需要毫秒数也需要纳秒数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">     * execution) for the specified number of milliseconds, subject to</span></span><br><span class="line"><span class="comment">     * the precision and accuracy of system timers and schedulers. The thread</span></span><br><span class="line"><span class="comment">     * does not lose ownership of any monitors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">     * execution) for the specified number of milliseconds plus the specified</span></span><br><span class="line"><span class="comment">     * number of nanoseconds, subject to the precision and accuracy of system</span></span><br><span class="line"><span class="comment">     * timers and schedulers. The thread does not lose ownership of any</span></span><br><span class="line"><span class="comment">     * monitors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  nanos</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> 0-999999&#125; additional nanoseconds to sleep</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative, or the value of</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@code</span> nanos&#125; is not in the range &#123;<span class="doctag">@code</span> 0-999999&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">            millis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(millis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>sleep方法会使得当前线程进入指定毫秒数的休眠，暂停执行，虽然给定一个休眠时间，但是最终要以系统的定时器和调度器的精度为准。</strong></p>
</li>
<li><p><strong>sleep 期间不会放弃 monitor 锁的所有权</strong> </p>
</li>
</ul>
<h3 id="使用TimeUnit-替代-Thread-sleep"><a href="#使用TimeUnit-替代-Thread-sleep" class="headerlink" title="使用TimeUnit 替代 Thread.sleep"></a>使用TimeUnit 替代 Thread.sleep</h3><ul>
<li>在JDK引入了一个枚举 TimeUnit，其对 sleep 方法提供了很好的封装。</li>
<li>强烈建议，使用TimeUnit代替 直接使用Thread.sleep()</li>
</ul>
<h2 id="线程yield"><a href="#线程yield" class="headerlink" title="线程yield"></a>线程yield</h2><ul>
<li>Thread.yeild 线程礼让，当前线程暂时不跑了，让其他线程先跑。类似于你去银行排队办事情，你跑到最后去重新拿个号重新排队。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A hint to the scheduler that the current thread is willing to yield</span></span><br><span class="line"><span class="comment">   * its current use of a processor. The scheduler is free to ignore this</span></span><br><span class="line"><span class="comment">   * hint.</span></span><br><span class="line"><span class="comment">   * // 意思是，给了调度器scheduler一个提示，我愿意让出当前的处理器processor给其他人，但是人家processor未必搭理你这个暗示。</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span></span><br><span class="line"><span class="comment">   * between threads that would otherwise over-utilise a CPU. Its use</span></span><br><span class="line"><span class="comment">   * should be combined with detailed profiling and benchmarking to</span></span><br><span class="line"><span class="comment">   * ensure that it actually has the desired effect.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   这个例子就是通过yield方法来实现两个线程的交替执行。</span></span><br><span class="line"><span class="comment"> 		不过请注意：这种交替并不一定能得到保证，源码中也对这个问题进行说明：</span></span><br><span class="line"><span class="comment"> 		主要说明了三个问题：</span></span><br><span class="line"><span class="comment"> 　　调度器可能会忽略该方法。</span></span><br><span class="line"><span class="comment"> 　　使用的时候要仔细分析和测试，确保能达到预期的效果。</span></span><br><span class="line"><span class="comment"> 　　很少有场景要用到该方法，主要使用的地方是调试和测试。　　</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span></span><br><span class="line"><span class="comment">   * for debugging or testing purposes, where it may help to reproduce</span></span><br><span class="line"><span class="comment">   * bugs due to race conditions. It may also be useful when designing</span></span><br><span class="line"><span class="comment">   * concurrency control constructs such as the ones in the</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> java.util.concurrent.locks&#125; package.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>yield方法属于一种<strong>启发式的方法</strong>，会提醒调度器 我愿意放弃当前CPU资源，如果CPU资源不紧张，则会忽略这种提醒</p>
</li>
<li><p>调用 yield 方法 会使当前线程从 ＲＵＮＮＩＮＧ　状态切换到　ＲＵＮＮＡＢＬＥ</p>
</li>
<li><p>yield 只是一个提示(hint),cpu 调度器并不会担保每次都能满足 yield提示.</p>
<h3 id="yield-和-sleep"><a href="#yield-和-sleep" class="headerlink" title="yield 和 sleep"></a>yield 和 sleep</h3><ul>
<li>sleep 会导致当前线程暂停指定的时间,没有CPU时间片的消耗</li>
<li>yield 只是对CPU调度器的一个提示,如果CPU调度器没有忽略这个提示, 他会导致线程上下文的切换.(因为当前线程愿意让出自己的资源)</li>
<li>sleep会使 线程短暂block ,会在给定的时间内释放 CPU资源 </li>
<li>yield 会使 RUNNING状态的Ｔｈｒｅａｄ　进入　ＲＵＮＮＡＢＬＥ状态(如果CPU调度器没有忽略这个提示的话)</li>
<li>sleep几乎百分百地完成了给定时间的休眠,而 yield 的提示并不能一定担保</li>
<li>一个线程sleep 另一个线程调用interrupt 会捕获到中断信号,而 yield 则不会</li>
<li><strong>yield 方法和同步没关系，也就是和ObjectMonitor没关系，你硬上锁就是在唱独角戏 ( _05_03_YieldTest）</strong></li>
</ul>
</li>
</ul>
<h2 id="设置线程的优先级"><a href="#设置线程的优先级" class="headerlink" title="设置线程的优先级"></a>设置线程的优先级</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Changes the priority of this thread.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called</span></span><br><span class="line"><span class="comment">  * with no arguments. This may result in throwing a</span></span><br><span class="line"><span class="comment">  * &lt;code&gt;SecurityException&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Otherwise, the priority of this thread is set to the smaller of</span></span><br><span class="line"><span class="comment">  * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted</span></span><br><span class="line"><span class="comment">  * priority of the thread&#x27;s thread group.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">     ThreadGroup g;</span><br><span class="line">     checkAccess();</span><br><span class="line">     <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">             newPriority = g.getMaxPriority();</span><br><span class="line">         &#125;</span><br><span class="line">         setPriority0(priority = newPriority);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns this thread&#x27;s priority.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  this thread&#x27;s priority.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #setPriority</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> priority;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>理论上优先级高的线程会优先获取到  被cpu调度的机会,但是<strong>这个优先级 和yield一样,同样只是一个  hint(提示)</strong></p>
</li>
<li><p>对于root用户,他会 hint  系统你想要设置的优先级别, 否则他会被忽略</p>
</li>
<li><p>如果CPU比较忙,设置优先级可能会获得更多的CPU时间片,但是 在闲时优先级的高低几乎不会有任何作用</p>
</li>
<li><p><strong>不要在程序设计当中企图使用线程优先级绑定某些特定的业务,或者让业务严重依赖线程优先级</strong></p>
</li>
<li><p>线程优先级 区间范围为 [1,10],如果不在该区间 则 抛出异常</p>
</li>
<li><p>如果set设置的优先级大于 ThreadGroup的优先级, 则以 ThreadGroup为准 .</p>
</li>
<li><p>线程默认的优先级与父类保持一致, 一般情况下是 5,因为main线程的优先级就是5,所以它派生出来的线程都是5.</p>
</li>
</ul>
<h2 id="获取线程唯一ID"><a href="#获取线程唯一ID" class="headerlink" title="获取线程唯一ID"></a>获取线程唯一ID</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the identifier of this Thread.  The thread ID is a positive</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;long&lt;/tt&gt; number generated when this thread was created.</span></span><br><span class="line"><span class="comment">   * The thread ID is unique and remains unchanged during its lifetime.</span></span><br><span class="line"><span class="comment">   * When a thread is terminated, this thread ID may be reused.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> this thread&#x27;s ID.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> tid;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程的ID在整个JVM进程中都会是唯一的,并且是从 0开始逐次递增.</li>
<li>如果在main方法(main线程)中创建了一个唯一的线程,并且调用getid方法 后发现返回结果并不等于0 ,不必惊讶,因为一个JVM启动时候,实际上已经开辟了很多个线程.自增序列已经有所增加了,所以我们创建的并非是第0号线程</li>
</ul>
<h2 id="获取当前线程"><a href="#获取当前线程" class="headerlink" title="获取当前线程"></a>获取当前线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a reference to the currently executing thread object.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  the currently executing thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>currentThread() 用于返回当前执行线程的引用,这个方法虽然很简单,但是使用非常广泛,</li>
</ul>
<h2 id="设置线程上下文类加载器"><a href="#设置线程上下文类加载器" class="headerlink" title="设置线程上下文类加载器"></a>设置线程上下文类加载器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/* The context ClassLoader for this thread */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader contextClassLoader;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        contextClassLoader = cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (contextClassLoader == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                                   Reflection.getCallerClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contextClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>getContextClassLoader ()<ul>
<li>获取线程上下文的类加载器, 简单来说就是这个线程是由哪个类加载器加载的.</li>
<li>如果在没有修改线程上下文类加载器的情况下,则保持与父类同样的类加载器</li>
</ul>
</li>
<li>setContextClassLoader(ClassLoader cl) 设置该线程的类加载器,<ul>
<li>该方法可以打破java类加载的双亲加载(父委托机制),有时候也称为 <strong>Java类加载器的后门</strong></li>
<li>后续会有专门的讲解</li>
</ul>
</li>
</ul>
<h2 id="线程interrupt"><a href="#线程interrupt" class="headerlink" title="线程interrupt"></a>线程interrupt</h2><p><strong>中断线程阻塞</strong></p>
<p><strong>这是一个 非常重要的API</strong>,也是经常使用的方法,与线程中断的API有如下几个,我们通过源码详解解析</p>
<ul>
<li>public void interrupt() </li>
<li>public static boolean interrupted()</li>
<li>public boolean isInterrupted()</li>
</ul>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Interrupts this thread.(打断这个线程)   </span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Unless the current thread is interrupting itself, which is</span></span><br><span class="line"><span class="comment">     * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     * of this thread is invoked, which may cause a &#123;@link</span></span><br><span class="line"><span class="comment">     * SecurityException&#125; to be thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link</span></span><br><span class="line"><span class="comment">     * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link</span></span><br><span class="line"><span class="comment">     * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;</span></span><br><span class="line"><span class="comment">     * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link</span></span><br><span class="line"><span class="comment">     * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,</span></span><br><span class="line"><span class="comment">     * methods of this class, then its interrupt status will be cleared and it</span></span><br><span class="line"><span class="comment">     * will receive an &#123;@link InterruptedException&#125;.</span></span><br><span class="line"><span class="comment">     // 如果当前线程被阻塞了由于调用下面这些什么Object的wait或者Thread的 sleep .join方法,</span></span><br><span class="line"><span class="comment">     然后它的中断状态将被清除 会收到&#123;@link InterruptedException&#125;。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span></span><br><span class="line"><span class="comment">     * then the channel will be closed, the thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">     * status will be set, and the thread will receive a &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.ClosedByInterruptException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125;</span></span><br><span class="line"><span class="comment">     * then the thread&#x27;s interrupt status will be set and it will return</span></span><br><span class="line"><span class="comment">     * immediately from the selection operation, possibly with a non-zero</span></span><br><span class="line"><span class="comment">     * value, just as if the selector&#x27;s &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">     * status will be set. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果 当前线程正处于 阻塞状态,调用 interrupt方法,则可以 <strong>中断打断这个阻塞</strong></p>
</li>
<li><p>是线程进入阻塞的方法有:</p>
<ul>
<li><p>Object的 wait 方法 以及变形的 重载的方法:wait (long)    和wait (long,int)</p>
</li>
<li><p>Thread 的sleep(long)方法,以及 重载的方法</p>
</li>
<li><p>Thread的join方法 以及重载的方法</p>
</li>
<li><p>InterruptibleChannel 的io操作</p>
</li>
<li><p>Selector 的wakeup方法</p>
</li>
<li><p>其他方法</p>
<ul>
<li>以上的方法都会使得当前线程进入阻塞状态.如果另外一个线程调用被阻塞线程的 interrupt 方法,则会打破这种阻塞 .</li>
<li>打断一个线程并不等于该线程的生命周期结束,仅仅是 打断了当前线程的阻塞状态</li>
<li>一个线程在阻塞的情况下被打断,会抛出一个 InterruptedException 的异常,这个异常就像一个 signal 一样通知当前线程被打断了 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="interrupt源码解析"><a href="#interrupt源码解析" class="headerlink" title="interrupt源码解析"></a>interrupt源码解析</h3><ul>
<li>一个线程内存存在着名为 interrupt flag的标识,如果一个 线程被interrupt ,那么它的 flag 将被设置</li>
<li>通过源码可以看到Thread中存在一个私有方法: <strong>interrupt0();           // Just to set the interrupt flag</strong>“,该方法作用是  修改interrupt flag</li>
<li>如果一个线程已经是 死亡Terminated 状态,那么尝试对其的interrupt 会直接被忽略\</li>
</ul>
<h3 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted"></a>isInterrupted</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">    * status&lt;/i&gt; of the thread is unaffected by this method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment">    * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment">    * returning false.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span></span><br><span class="line"><span class="comment">    *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #interrupted()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">    * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">    * passed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要判断当前线程是否被中断,该方法仅仅是对 interrupt flag 的一个判断,并不会影响改变 interrupt flag的值</li>
<li>可中断方法捕获到了中断信号(signal) 之后,也就是捕获了InterruptedException 异常之后,会擦除interrupt的标识.</li>
<li>可中断方法捕获到了中断信号后,为了不影响线程中的其他方法的执行,将线程的interrupt flag标识复位 ,很合理的 设计</li>
</ul>
<h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted"></a>interrupted</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests whether the current thread has been interrupted.  The</span></span><br><span class="line"><span class="comment">    * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In</span></span><br><span class="line"><span class="comment">    * other words, if this method were to be called twice in succession, the</span></span><br><span class="line"><span class="comment">    * second call would return false (unless the current thread were</span></span><br><span class="line"><span class="comment">    * interrupted again, after the first call had cleared its interrupted</span></span><br><span class="line"><span class="comment">    * status and before the second call had examined it).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    测试当前线程是否已被中断的 . 这个线程的 &lt;中断状态&gt;被这个方法清除。</span></span><br><span class="line"><span class="comment">*换句话说，如果这个方法被连续调用两次，则第二个调用将返回false(</span></span><br><span class="line"><span class="comment">   除非当前线程被再一次 interrupted,在第一次调用后 已经清除了它自身 的interrupted status后再次被中断状态和第二次调用之前检查它</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment">    * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment">    * returning false.</span></span><br><span class="line"><span class="comment">    线程中断被忽略，因为线程不是活的中断的时间会被这个方法反映出来*返回false。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span></span><br><span class="line"><span class="comment">    *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isInterrupted()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">    * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">    * passed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用该方法会直接擦除掉线程的interrupt flag,</p>
</li>
<li><p>需要注意的是: 第一次调用interrupted方法会返回true ,并且立即擦除了interrupt flag;</p>
</li>
<li><p>第二次包括以后的调用永远都是返回false,除非在此期间又一次地被打断了 .</p>
</li>
</ul>
<h3 id="interrupted源码分析"><a href="#interrupted源码分析" class="headerlink" title="interrupted源码分析"></a>interrupted源码分析</h3><ul>
<li>isInterrupted() 方法和   interrupted()方法都调用了同一个 native方法 :isInterrupted(boolean ClearInterrupted);,                                                                 ClearInterrupted用来控制是否擦除线程的 interrupt flag</li>
<li>isInterrupted()的 参数为 false,表示 不想擦除</li>
<li>interrupt 静态方法中该参数为 true,表示想擦除 </li>
</ul>
<p>如果一个线程在没有执行可中断方法之前就被打断了,那么其接下来执行可中断方法,比如sleep 会发生什么情况呢:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrupt</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//  1.判断当前线程是否被中断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread is interrupted? &quot;</span> + Thread.interrupted());</span><br><span class="line">        <span class="comment">// 2.中断当前线程</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="comment">//  3.判断当前线程是否被中断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread is interrupted? &quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//4. 当前线程执行可中断方法</span></span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 5.捕获中断信号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;I will be interrupted still.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果: </span><br><span class="line">Main thread is interrupted? <span class="keyword">false</span></span><br><span class="line">Main thread is interrupted? <span class="keyword">true</span></span><br><span class="line">I will be interrupted still.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明: 如果一个线程设置了 interrupt flag,那么接下来可中断方法 会立即中断,因此 注释5的信号捕获部分会被执行.</p>
<h2 id="线程Join"><a href="#线程Join" class="headerlink" title="线程Join"></a>线程Join</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment"> * way as the invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #join(long) join&#125;&#123;<span class="doctag">@code</span> (0)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment"> * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment"> * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment"> * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>join某个线程A(),会使当前线程B进入等待,直到线程A结束生命周期,或者到达给定的时间,</p>
<p>那么在此期间B线程是处于BLOCKED的,而不是A线程,</p>
<ul>
<li>join方法会使得当前线程永远的等待下去,知道期间被另外的线程中断,或者join的线程执行结束.</li>
<li>join的另外2个重载方法,指定毫秒数,在指定的时间到达之后,当前线程也会退出阻塞.</li>
</ul>
<h4 id="问题-如果一个线程已经结束了生命周期-那么调用它的join方法的当前线程会被阻塞吗"><a href="#问题-如果一个线程已经结束了生命周期-那么调用它的join方法的当前线程会被阻塞吗" class="headerlink" title="问题: 如果一个线程已经结束了生命周期,那么调用它的join方法的当前线程会被阻塞吗?"></a>问题: 如果一个线程已经结束了生命周期,那么调用它的join方法的当前线程会被阻塞吗?</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">不会被阻塞</span><br></pre></td></tr></table></figure>

<ul>
<li><p> join() 和 sleep() 一样，可以被中断（被中断时，会抛出 InterrupptedException 异常）；</p>
</li>
<li><p>不同的是，join() 内部调用了 wait()，会出让锁，</p>
</li>
<li><p>而 sleep() 会一直保持锁。</p>
</li>
</ul>
<h3 id="join-的示例和作用"><a href="#join-的示例和作用" class="headerlink" title="join() 的示例和作用"></a>join() 的示例和作用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建child对象，此时child表示的线程处于NEW状态</span></span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        <span class="comment">// child表示的线程转换为RUNNABLE状态</span></span><br><span class="line">        child.start();</span><br><span class="line">        <span class="comment">// 等待child线程运行完再继续运行</span></span><br><span class="line">        child.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码展示了两个类：Parent（父线程类），Child（子线程类）。</p>
<p>Parent.main()方法是程序的入口，通过 Child child = new Child(); 新建child子线程（此时 child子线程处于NEW状态）；</p>
<p>然后调用child.start()（child子线程状态转换为RUNNABLE）；</p>
<p>再调用child.join()，此时，Parent父线程会等待child子线程运行完再继续运行。</p>
<p>下图是我总结的 Java 线程状态转换图：</p>
<p><img src="/uploads/java-concurrency-master/thread-join.png"></p>
<h3 id="join-的作用"><a href="#join-的作用" class="headerlink" title="join() 的作用"></a>join() 的作用</h3><p>让父线程等待子线程结束之后才能继续运行</p>
<p>Waiting for the finalization of a thread</p>
<p>In some situations, we will have to wait for the finalization of a thread. For example, we may have a program that will begin initializing the resources it needs before proceeding with the rest of the execution. We can run the initialization tasks as threads and wait for its finalization before continuing with the rest of the program. For this purpose, we can use the join() method of the Thread class.   <strong><em>When we call this method using a thread object, it suspends the execution of the calling thread until the object called finishes its execution.</em></strong></p>
<p> 当我们调用某个线程的这个方法时，这个方法会挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。</p>
<h3 id="join源码分析"><a href="#join源码分析" class="headerlink" title="join源码分析:"></a>join源码分析:</h3><p>join() 一共有三个重载版本，分别是无参、一个参数、两个参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public final void join() throws InterruptedException;</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">public final synchronized void join(long millis, int nanos) throws InterruptedException;</span><br></pre></td></tr></table></figure>



<p>其中</p>
<p>(1) 三个方法都被final修饰，无法被子类重写。</p>
<p>(2) join(long), join(long, long) 是synchronized method，同步的对象是当前线程实例。</p>
<p>(2) 无参版本和两个参数版本最终都调用了一个参数的版本。</p>
<p>(3) join() 和 join(0) 是等价的，表示一直等下去；join(非0)表示等待一段时间。</p>
<p><strong>从源码可以看到 join(0) 调用了Object.wait(0)，其中Object.wait(0) 会一直等待，直到被notify/中断才返回。</strong></p>
<p><strong>while(isAlive())是为了防止子线程伪唤醒(spurious wakeup)，只要子线程没有TERMINATED的，父线程就需要继续等下去。</strong></p>
<p>(4) join() 和 sleep() 一样，可以被中断（被中断时，会抛出 InterrupptedException 异常）；不同的是，join() 内部调用了 wait()，会出让锁，而 sleep() 会一直保持锁。</p>
<p><strong>以本文开头的代码为例，我们分析一下代码逻辑：</strong></p>
<ul>
<li><p>调用链：Parent.main() -&gt; child.join() -&gt; child.join(0) -&gt; child.wait(0)（此时 Parent线程会获得 child 实例作为锁，其他线程可以进入 child.join() ，但不可以进入 child.join(0)， 因为child.join(0)是同步方法）。</p>
</li>
<li><p>如果 child 线程是 Active，则调用 child.wait(0)（为了防止子线程 spurious wakeup, 需要将 wait(0) 放入 while(isAlive()) 循环中。</p>
</li>
<li><p>一旦 child 线程不为 Active （状态为 TERMINATED）, child.notifyAll() 会被调用-&gt; child.wait(0)返回 -&gt; child.join(0)返回 -&gt; child.join()返回 -&gt; Parent.main()继续执行, 子线程会调用this.notify()，child.wait(0)会返回到child.join(0) ，child.join(0)会返回到 child.join(), child.join() 会返回到 Parent 父线程，Parent 父线程就可以继续运行下去了。</p>
</li>
</ul>
<ul>
<li>子线程结束后，子线程的this.notifyAll()会被调用，join()返回，父线程只要获取到锁和CPU，就可以继续运行下去了</li>
<li>在调用 join() 方法的程序中，原来的多个线程仍然多个线程，<strong>并没有发生“合并为一个单线程”</strong>。真正发生的是调用 join() 的线程进入 TIMED_WAITING 状态，等待 join() 所属线程运行结束后再继续运行。</li>
</ul>
<h2 id="如何关闭一个线程"><a href="#如何关闭一个线程" class="headerlink" title="如何关闭一个线程"></a>如何关闭一个线程</h2><h3 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h3><ol>
<li><p>线程结束生命周期,正常结束</p>
</li>
<li><p>捕获中断信号 关闭线程</p>
<ul>
<li><p>通过new Thread的方式创建线程,这种方式看似简单,但是其实 派生成本是比较高的,因此在一个线程中往往会循环地执行某个任务,比如心跳检查,不断接收网络消息报文,系统决定退出地时候,可以借助中断线程地方式使其退出,例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I will start work&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//working.</span></span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;I will be exiting.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;System will be shutdown.&quot;</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">线程中执行某个可中断方法,可以通过捕获中断信号来决定是否退出</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用volatile开关控制</p>
<p>由于线程的interrupt 标识 很有可能被擦除,或者逻辑单元不会调用任何可中断方法,</p>
<p>所以使用volatile修饰的开关 flag关闭线程也是一种常见做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlagThreadExit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I will start work&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!closed &amp;&amp; !isInterrupted())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;i am working.&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;I will be exiting.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.closed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyTask t = <span class="keyword">new</span> MyTask();</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;System will be shutdown.&quot;</span>);</span><br><span class="line">        t.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="异常退出"><a href="#异常退出" class="headerlink" title="异常退出"></a>异常退出</h3><p>在一个线程的执行单元中,是不允许抛出 checked异常的, 如果线程在运行过程中,需要捕获checked 异常并且判断是否继续运行,</p>
<p>那么此时可以将checked异常封装成unchecked异常(RuntimeException) 抛出,进而 结束线程的生命周期</p>
<h3 id="系统假死"><a href="#系统假死" class="headerlink" title="系统假死"></a>系统假死</h3><p>绝大部分原因是因为某个线程阻塞了,或者线程出现了死锁 .</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>学习了Thread 的大多数API,主要分为2类,</li>
<li>一类是 获取线程的信息,如 getID,getName,getPriority,currThread</li>
<li>一类是阻塞以及中断阻塞 方法, sleep,join,  interrupt </li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>ThreadAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-05-线程间通信</title>
    <url>/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<ul>
<li><p>线程间通信又称为 进程内通信，多个线程实现互斥访问共享资源时 会互相发送信号或等待信号</p>
</li>
<li><p>主要是 线程之间 wait，notify，notifyAll ，以及背后的原理内幕</p>
</li>
<li><p>wait 和 notify 方法必须拥有该对象的monitor ，也就是wait方法必须在同步方法中使用**</p>
</li>
</ul>
<h1 id="同步阻塞与异步非阻塞"><a href="#同步阻塞与异步非阻塞" class="headerlink" title="同步阻塞与异步非阻塞"></a>同步阻塞与异步非阻塞</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Event&gt; eventQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_EVENT = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_MAX_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventQueue.size() &gt;= max) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is full.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            console(<span class="string">&quot; the new event is submitted&quot;</span>);</span><br><span class="line">            eventQueue.addLast(event);</span><br><span class="line">            <span class="comment">// 只能唤醒一个 线程</span></span><br><span class="line">            eventQueue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is empty.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Event event = eventQueue.removeFirst();</span><br><span class="line">            <span class="keyword">this</span>.eventQueue.notify();</span><br><span class="line">            console(<span class="string">&quot; the event &quot;</span> + event + <span class="string">&quot; is handled.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">console</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s:%s\n&quot;</span>, currentThread().getName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="同步阻塞消息处理"><a href="#同步阻塞消息处理" class="headerlink" title="同步阻塞消息处理"></a>同步阻塞消息处理</h2><ul>
<li>同步Event 提交，客户端等待时间过长 会陷入阻塞，导致二次提交 Event耗时过长</li>
<li>由于客户端提交的Event数量不多，导致系统同时受理业务数量有限，也就是系统的整理的吞吐量不高</li>
<li>这种一个线程处理一个Event的方式，会导致出现频繁的创建开启和销毁，从而增加系统额外开销</li>
<li>在业务达到峰值的时候，大量的业务处理线程阻塞会导致频繁的CPU切换上下文，从而降低系统性能</li>
</ul>
<h2 id="异步非阻塞消息处理"><a href="#异步非阻塞消息处理" class="headerlink" title="异步非阻塞消息处理"></a>异步非阻塞消息处理</h2><ul>
<li>客户端不用等到结果处理结束之后才能返回，从而提高了系统的吞吐量和并发量</li>
<li>服务端的线程数量在一个可控的范围之内是不会导致太多的CPU上下文切换，从而带来额外的开销</li>
<li>服务端线程可以重复利用，这样可以减少不断创建线程带来的资源浪费</li>
</ul>
<h1 id="单线程间通信"><a href="#单线程间通信" class="headerlink" title="单线程间通信"></a>单线程间通信</h1><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><ul>
<li><p>wait 和 notify是 Object中的方法，也就是说 JDK中的每一个类都拥有这2个方法</p>
</li>
<li><p>下面是 wait的 3个重载方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2. </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>wait 方法的3个重载方法都将调用wait（long timeout）这个方法，</li>
<li>wait（）等价于 wait（0），其中0代表永不超时 </li>
<li>Object的wait（long timeout）方法会导致当前线程进入阻塞，直到 有其他线程调用了 Object的notify 或者 notifyAll方法才能将其唤醒，或者 阻塞时间到达了 timeout时间而自动唤醒</li>
<li><strong>wait方法必须拥有该对象的monitor ，也就是wait方法必须在同步方法中使用</strong></li>
<li><strong>当前线程执行了该对象的wait方法之后，将会放弃对该 monitor的所有权并且进入与该对象关联的waitset中，也就说一旦线程执行了某个object 的wait方法之后，他就会释放对该对象 monitor的所有权，</strong>其他线程也会有机会继续争抢该 monitor的所有权 </li>
<li>（这个就是 Thread:: join的背后的逻辑，thread.join就是调用了wait 方法，所以父线程会 等到子线程执行完毕，才继续执行）</li>
</ul>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Wakes up a single thread that is waiting on this object&#x27;s</span></span><br><span class="line"><span class="comment">    * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment">    * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment">    * the discretion of the implementation. A thread waits on an object&#x27;s</span></span><br><span class="line"><span class="comment">    * monitor by calling one of the &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The awakened thread will not be able to proceed until the current</span></span><br><span class="line"><span class="comment">    * thread relinquishes the lock on this object. The awakened thread will</span></span><br><span class="line"><span class="comment">    * compete in the usual manner with any other threads that might be</span></span><br><span class="line"><span class="comment">    * actively competing to synchronize on this object; for example, the</span></span><br><span class="line"><span class="comment">    * awakened thread enjoys no reliable privilege or disadvantage in being</span></span><br><span class="line"><span class="comment">    * the next thread to lock this object.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment">    * of this object&#x27;s monitor. A thread becomes the owner of the</span></span><br><span class="line"><span class="comment">    * object&#x27;s monitor in one of three ways:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;By executing a synchronized instance method of that object.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;By executing the body of a &#123;<span class="doctag">@code</span> synchronized&#125; statement</span></span><br><span class="line"><span class="comment">    *     that synchronizes on the object.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;For objects of type &#123;<span class="doctag">@code</span> Class,&#125; by executing a</span></span><br><span class="line"><span class="comment">    *     synchronized static method of that class.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Only one thread at a time can own an object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">    *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        java.lang.Object#notifyAll()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        java.lang.Object#wait()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>看一下方法说明注释-</p>
<ul>
<li><p>唤醒<strong>单个</strong>正在等待执行该对象wait 方法的线程</p>
</li>
<li><p>如果有很多线程都在等待，其中之一会被选中唤醒， 选择是任意的</p>
</li>
<li><p>被唤醒的线程需要重新获取对该对象所关联 monitor的lock 才能继续执行</p>
</li>
<li><p>被唤醒的线程将不能继续，直到当前线程放弃对该对象的锁。被唤醒的线程将以通常的方式与任何其他可能正在主动竞争同步这个对象的线程竞争;例如，被唤醒的线程在成为下一个锁定该对象的线程时没有任何可靠的特权或劣势</p>
</li>
</ul>
<h3 id="关于wait-和notify的注意事项"><a href="#关于wait-和notify的注意事项" class="headerlink" title="关于wait 和notify的注意事项"></a>关于wait 和notify的注意事项</h3><ul>
<li><p><strong>wait 是可中断方法</strong>，所以： 当前线程一旦调用了wait方法 进入阻塞状态，其他线程是可以使用 interrupt 方法将其打断的； 可中断方法被打断后，会收到 中断异常 InterruptedException ，同时 interrupt flag 也会被擦除 </p>
</li>
<li><p>线程执行了某个对象的wait 方法之后，会加入与之 对应的wait set中，<strong>每一个对象的 monitor 都有一个与之关联的 wait set</strong></p>
</li>
<li><p><strong>当线程进入wait set之后，notify 方法可以将其唤醒</strong>，也就是 从 wait set中弹出，<strong>同时中断 wait 中的线程也会将其唤醒</strong></p>
</li>
<li><p><strong>必须在同步方法中 使用 wait 和 notify 方法，</strong> 因为执行wait 和 notify 的前提条件是  必须持有同步方法的monitor 的所有权， 运行下面任何一个方法 都会抛出 非法的 monitor 状态异常  InllegalMonitorStateException: </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错，因为 **必须在同步方法中 使用 wait 和 notify 方法，**</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testwait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.wait();  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，**必须在同步方法中 使用 wait 和 notify 方法，**</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testwait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步代码的monitor 必须与执行  wait  notify方法的对象一致，简单来说就是 <strong>用哪个对象的 monitor 进行同步，就只能用哪个对象 进行wait 和 notify操作。</strong></li>
</ul>
<p>运行下面代码的任何一个方法会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object MUTEX = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错，如果非要用 MUTEx ，可以使用同步代码块的形式 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            MUTEX.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 报错，报错，如果非要用 MUTEx ，可以使用同步代码块的形式 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testNotify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MUTEX.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify();</span><br><span class="line">        waitNotify.testNotify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.lang.Object.notifyAll(Native Method)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.WaitNotify.testNotify(WaitNotify.java:<span class="number">21</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.WaitNotify.main(WaitNotify.java:<span class="number">27</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面同步方法中 monitor 引用的是 this，而wait notify 使用的确实  MUTEX，<strong>虽然是在 同步方法中执行 wait  notify方法，但是 wait 和 notify方法的执行并未 获取 MUTEX 的monitor 为前提</strong></p>
<h2 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait 和sleep"></a>wait 和sleep</h2><ul>
<li>都可以使线程进入 阻塞状态</li>
<li>都是可中断方法，被中断后会收到中断异常</li>
<li>wait 时 Object方法， sleep 是 THread  方法</li>
<li>wait 执行需要在 synchronized 方法中进行，而sleep 不需要</li>
<li><strong>线程在同步方法中执行sleep 方法时，不会释放 monitor锁 ， 而 wait 方法则会释放monitor 锁</strong></li>
<li>sleep 方法短暂休眠后会主动退出阻塞 ，而 wait方法（没有指定时间） 则需要被其他线程中断才能退出阻塞 </li>
</ul>
<h1 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h1><ul>
<li>前面之所以 把 notify划到  单线程通信，我觉得是 因为 notify 只能唤醒一个线程，所以叫单线程通信</li>
<li>而 notifyAll 可以唤醒所以 waitset中的线程，所以称为 多线程通信</li>
</ul>
<h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><h3 id="1-notifyAll-方法"><a href="#1-notifyAll-方法" class="headerlink" title="1.notifyAll 方法"></a>1.notifyAll 方法</h3><ul>
<li>多线程之间通信需要用到Object 的notifyAll 方法，该方法与notify类似，都可以唤醒 由于调用wait方法而阻塞的线程，</li>
<li>但是 notify方法只能唤醒其中的一个线程，而notifyALL方法则可以同时唤醒全部的阻塞线程，同样被唤醒的线程仍需要继续争抢monitor的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up all threads that are waiting on this object&#x27;s monitor. A</span></span><br><span class="line"><span class="comment"> * thread waits on an object&#x27;s monitor by calling one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The awakened threads will not be able to proceed until the current</span></span><br><span class="line"><span class="comment"> * thread relinquishes the lock on this object. The awakened threads</span></span><br><span class="line"><span class="comment"> * will compete in the usual manner with any other threads that might</span></span><br><span class="line"><span class="comment"> * be actively competing to synchronize on this object; for example,</span></span><br><span class="line"><span class="comment"> * the awakened threads enjoy no reliable privilege or disadvantage in</span></span><br><span class="line"><span class="comment"> * being the next thread to lock this object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment"> * of this object&#x27;s monitor. See the &#123;<span class="doctag">@code</span> notify&#125; method for a</span></span><br><span class="line"><span class="comment"> * description of the ways in which a thread can become the owner of</span></span><br><span class="line"><span class="comment"> * a monitor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment"> *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#notify()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#wait()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-生产者消费者"><a href="#2-生产者消费者" class="headerlink" title="2.生产者消费者"></a>2.生产者消费者</h3><p>前面的EventQueue 队列在多个线程同时并发的情况下会出现数据不一致的情况。当线程的数量增加的时候，会出现数据不一致的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EventQueue eventQueue = <span class="keyword">new</span> EventQueue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    eventQueue.offer(<span class="keyword">new</span> EventQueue.Event());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    eventQueue.take();</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer: the queue is empty.</span><br><span class="line">Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> java.util.NoSuchElementException</span><br><span class="line">	at java.util.LinkedList.removeFirst(LinkedList.java:<span class="number">270</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventQueue.take(EventQueue.java:<span class="number">48</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventClient.lambda$main$<span class="number">1</span>(EventClient.java:<span class="number">25</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventClient$$Lambda$<span class="number">2</span>/<span class="number">1324119927.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>

<p>数据不一致的情况大致分为2类，</p>
<ul>
<li>其一是 LinLinkedList 中没有元素的时候，依旧调用了 removeFirst方法，</li>
<li>其二是 当LinkedList中的元素超过了10个的时候 仍旧执行了addLast方法</li>
</ul>
<p>分析现象：</p>
<h4 id="LinLinkedList-为空时，执行removeFirst方法"><a href="#LinLinkedList-为空时，执行removeFirst方法" class="headerlink" title="LinLinkedList 为空时，执行removeFirst方法"></a>LinLinkedList 为空时，执行removeFirst方法</h4><p>假设EventQueue中元素为空，</p>
<ul>
<li>两个线程在执行take方法时分别调用wait 进入阻塞，另外一个offer线程执行addLast方法之后唤醒了其中一个阻塞的take线程，</li>
<li>该take线程顺利消费了一个元素之后，因为是 使用notify方法，只能唤醒一个线程，而此时恰巧再次唤醒了一个take线程，此时就会导致执行empty LinkedList的 removeFirst方法，过程如下：</li>
</ul>
<pre class="mermaid">sequenceDiagram
autonumber
note over take线程1,take线程2:queue size=0
take线程1 ->>take线程1: 执行wait,进入wait set中释放monitor lock
take线程2 ->>take线程2: 执行wait,进入wait set中释放monitor lock
offer线程1 ->>offer线程1: Offer线程addLast，queue size=1
offer线程1 ->>offer线程1: notify方法
offer线程1->>take线程2: 唤醒
take线程2 ->>take线程2: remove first,Queue size=0
take线程2 ->>take线程2: Notify
take线程2->>take线程1: 唤醒
take线程1 ->>take线程1: remove first,报错</pre>

<h4 id="LinLinkedList-元素为10时执行addLast方法"><a href="#LinLinkedList-元素为10时执行addLast方法" class="headerlink" title="LinLinkedList 元素为10时执行addLast方法"></a>LinLinkedList 元素为10时执行addLast方法</h4><pre class="mermaid">sequenceDiagram
autonumber
note over offer线程1,offer线程2:queue size=10
offer线程1 ->>offer线程1: 执行wait,进入wait set中释放monitor lock
offer线程2 ->>offer线程2: 执行wait,进入wait set中释放monitor lock
take线程1 ->>take线程1: Take线程removeFirst，queue size=9
take线程1 ->>take线程1: notify方法
take线程1->>offer线程2: 唤醒
offer线程2 ->>offer线程2: addLast,Queue size=10
offer线程2 ->>offer线程2: Notify
offer线程2->>offer线程1: 唤醒
offer线程1 ->>offer线程1: addLast,Queue size=10</pre>



<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p><strong>只需要将临界值的if判断更改为while ，将 notify更改为 notifyAll即可</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Event&gt; eventQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_EVENT = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_MAX_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (eventQueue.size() &gt;= max) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is full.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            console(<span class="string">&quot; the new event is submitted&quot;</span>);</span><br><span class="line">            eventQueue.addLast(event);</span><br><span class="line">            <span class="comment">// 唤醒所有线程，让他们再去争抢 monitor</span></span><br><span class="line">            eventQueue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is empty.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Event event = eventQueue.removeFirst();</span><br><span class="line">            <span class="comment">// 唤醒所有线程，让他们再去争抢 monitor</span></span><br><span class="line">            <span class="keyword">this</span>.eventQueue.notifyAll();</span><br><span class="line">            console(<span class="string">&quot; the event &quot;</span> + event + <span class="string">&quot; is handled.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">console</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s:%s\n&quot;</span>, currentThread().getName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程休息室wait-set"><a href="#线程休息室wait-set" class="headerlink" title="线程休息室wait set"></a>线程休息室wait set</h3><ul>
<li>在虚拟机规范中存在一个 wait set（线程休息室）的概念，至于 wait set时怎么样的数据结构，JDK官网并没有给出明确的定义，不同厂家的JDK有着不同的实现方式。</li>
<li>不管怎样，线程调用了某个对象的wait方法之后，都会加入与该对象monitor关联的wait set中，并且释放 monitor的所有权</li>
</ul>
<p>下图演示了 ： 若干个线程调用了 wait方法之后被加入与 monitor关联的wait set中，待 另外一个线程（当前monitor持有者）调用该monitor的 notify方法之后，其中一个线程会从 wait set中弹出 。至于时随机弹出 还是先进先出的方式弹出，虚拟机同样没有给出强制要求 </p>
<p><img src="/uploads/java-concurrency-master/notify-waitset.png"></p>
<p>而执行notifyAll 则不需要考虑哪个线程会被弹出，因为wait set中的所有wait线程都会被弹出，如下图5-6 所示</p>
<p><img src="/uploads/java-concurrency-master/notifyAll-waitset.png"></p>
<h2 id="自定义显示锁BooleanLock"><a href="#自定义显示锁BooleanLock" class="headerlink" title="自定义显示锁BooleanLock"></a>自定义显示锁BooleanLock</h2><h3 id="synchronized关键字的缺陷"><a href="#synchronized关键字的缺陷" class="headerlink" title="synchronized关键字的缺陷"></a>synchronized关键字的缺陷</h3><p>synchronized关键字 提供了一种排他式的数据同步机制，某个线程在获取 monitor lock的时候可能会被阻塞，而这种阻塞有2个很明显的缺陷：</p>
<ul>
<li>无法控制阻塞时长</li>
<li>阻塞不可被中断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDefect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronizedDefect defect = <span class="keyword">new</span> SynchronizedDefect();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(defect::syncMethod, <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        <span class="comment">//make sure the t1 started.</span></span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(defect::syncMethod, <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//make sure the t2 started.</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(t2.isInterrupted());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/T1_TIME_WAITTING.png"></p>
<p><img src="/uploads/java-concurrency-master/T2_BLOCKED.png"></p>
<ul>
<li>被 synchronized 同步的线程不可被中断</li>
</ul>
<h3 id="自定义显示锁BooleanLock-1"><a href="#自定义显示锁BooleanLock-1" class="headerlink" title="自定义显示锁BooleanLock"></a>自定义显示锁BooleanLock</h3><p>利用前面所学的知识，构造一个显示的BooleanLock，使其</p>
<ul>
<li>具备synchronized关键字所有功能的同时，</li>
<li>又具备<strong>可中断 和lock超时的功能</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 永远阻塞，除非获取到了锁，这一点与synchronized类似，</span></span><br><span class="line"><span class="comment">     * 但是该方法可以被中断，中断时会抛出 InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 除了被中断外，还增加了 对应的超时功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mills</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行锁的释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前有哪些线程被 阻塞，类是与 wait set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Thread&gt; <span class="title">getBlockedThreads</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true； 锁空闲</span></span><br><span class="line"><span class="comment">     * false：当前锁不可用，（锁被其他线程占领 &amp;&amp; 或者自己已经拥有锁（这次就不让锁重入了） ）</span></span><br><span class="line"><span class="comment">     * 该方式 只是去判断锁的状态，不会真正的去 lock 或者 unlock，也就是不会修改锁状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现BooleanLock"><a href="#实现BooleanLock" class="headerlink" title="实现BooleanLock"></a>实现BooleanLock</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前拥有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread currentThread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * false ：当前锁没有被任何线程 获得，或者已经释放</span></span><br><span class="line"><span class="comment">     * true： 该锁已经被某个线程获得，该线程就是 currThread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储因为获取锁 而阻塞的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thread&gt; blockedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (locked) &#123;</span><br><span class="line">                <span class="comment">//暂存当前线程</span></span><br><span class="line">                <span class="keyword">final</span> Thread tempThread = currentThread();</span><br><span class="line">                <span class="comment">// 装载 因获取锁而阻塞的 其他线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!blockedList.contains(currentThread()))</span><br><span class="line">                        blockedList.add(currentThread());</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前线程在wait时候被中断，则从blockedList中删除，避免内存泄漏</span></span><br><span class="line">                    blockedList.remove(tempThread);</span><br><span class="line">                    <span class="comment">//继续抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放自己</span></span><br><span class="line">            blockedList.remove(currentThread());</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            <span class="keyword">this</span>.locked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//更新当前拥有锁的对象</span></span><br><span class="line">            <span class="keyword">this</span>.currentThread = currentThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 如果 mills（超时时间）不合法，抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidParameterException(<span class="string">&quot;非法的mills参数&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mills == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> remainingMills = mills;</span><br><span class="line">                <span class="keyword">long</span> endMills = currentTimeMillis() + remainingMills;</span><br><span class="line">                <span class="keyword">while</span> (locked) &#123;</span><br><span class="line">                    <span class="comment">//2. 如果剩余等待时间（remainingMills），小于等于0，意味着已经超时了，应该抛出 超时的异常</span></span><br><span class="line">                    <span class="keyword">if</span> (remainingMills &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">&quot;can not get the lock during &quot;</span> + mills + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!blockedList.contains(currentThread()))</span><br><span class="line">                        blockedList.add(currentThread());</span><br><span class="line">                    <span class="comment">// 3. 多次wait的过程中，剩余等待时间（remainingMills）也会不断地更新</span></span><br><span class="line">                    <span class="keyword">this</span>.wait(remainingMills);</span><br><span class="line">                    <span class="comment">// 4. 刷新 remainingMills</span></span><br><span class="line">                    remainingMills = endMills - currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5. 获得 monitor lock，从blockList中删除当前线程，修改locked 标识，且更新当前线程为 锁地拥有者</span></span><br><span class="line">                blockedList.remove(currentThread());</span><br><span class="line">                <span class="keyword">this</span>.locked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.currentThread = currentThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//1.只有锁地拥有者，才有资格释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (currentThread == currentThread()) &#123;</span><br><span class="line">                <span class="comment">// 2. 更新lock 标识为 未锁定</span></span><br><span class="line">                <span class="keyword">this</span>.locked = <span class="keyword">false</span>;</span><br><span class="line">                Optional.of(currentThread().getName() + <span class="string">&quot; release the lock monitor.&quot;</span>).ifPresent(System.out::println);</span><br><span class="line">                <span class="comment">//3. 清空wait set,通知wait set中所有线程，可以尝试抢锁了</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Thread&gt; <span class="title">getBlockedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(blockedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">//            // 如果当前 lock 标识为已锁定 并且 自己不是锁的拥有者</span></span><br><span class="line"><span class="comment">//            if (locked &amp;&amp; !this.currentThread.equals(currentThread())) &#123;</span></span><br><span class="line"><span class="comment">//                //直接返回，也不 加入blockList</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;tryLock fail，当前Lock拥有者是:&quot; + this.currentThread.getName());</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //说明当前锁 空闲或者自己已经是锁的拥有者，</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;说明当前锁 空闲或者自己已经是锁的拥有者&quot;);</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line">            <span class="comment">//如果当前锁空闲，则返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">                <span class="comment">//直接返回false，也不 加入blockList</span></span><br><span class="line">                System.out.println(<span class="string">&quot;tryLock succ,当前锁空闲&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;tryLock fail，当前Lock拥有者是:&quot;</span> + <span class="keyword">this</span>.currentThread.getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试类：-tryLock是自己加上的，也可以去除"><a href="#测试类：-tryLock是自己加上的，也可以去除" class="headerlink" title="测试类：(tryLock是自己加上的，也可以去除)"></a>测试类：(tryLock是自己加上的，也可以去除)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLockTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> BooleanLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁失败，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(!lock.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程tryLock失败,退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(currentThread() + <span class="string">&quot; get the lock.&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> randomInt = current().nextInt(<span class="number">10</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(randomInt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethodTimeoutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁失败，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(!lock.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程tryLock失败,退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(currentThread() + <span class="string">&quot; get the lock.&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> randomInt = current().nextInt(<span class="number">10</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(randomInt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BooleanLockTest blt = <span class="keyword">new</span> BooleanLockTest();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(blt::syncMethod, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(blt::syncMethodTimeoutable, <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*(BooleanLockTest blt = new BooleanLockTest();</span></span><br><span class="line"><span class="comment">        IntStream.range(0, 2)</span></span><br><span class="line"><span class="comment">                .mapToObj(i -&gt; new Thread(blt::syncMethod,&quot;Thread&quot;+i))</span></span><br><span class="line"><span class="comment">                .forEach(Thread::start);*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li><p>介绍了wait 和notify方法的使用，以及注意事项，比如：</p>
<ul>
<li>wait 和notify方法必须在同步方法中使用，且当前线程必须拥有锁，才可以</li>
<li>同步代码的monitor 必须与执行  wait  notify方法的对象一致，简单来说就是 <strong>用哪个对象的 monitor 进行同步，就只能用哪个对象 进行wait 和 notify操作。</strong></li>
<li>不能使用空对象（null）作为 monitor</li>
</ul>
</li>
<li><p>生产者与消费者模型是多线程开发最常用的模型之一，也是多线程间 通信的最好范例</p>
</li>
<li><p>讲诉了wait set线程休息室的概念，以及调用notify 和 notifyAll 对wait set的影响</p>
</li>
<li><p>synchronized同步方法的缺点：</p>
<ul>
<li>不可以中断</li>
<li>无法超时</li>
</ul>
</li>
<li><p>通过synchronized的缺点，只定义开发了一个BooleanLock锁，其功能包括：</p>
<ul>
<li>synchronized关键字的互斥访问 共享资源</li>
<li>增加了可中断功能</li>
<li>增加了 可超时功能</li>
<li>增加了 tryLock功能</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>线程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-08-线程池原理以及自定义线程池</title>
    <url>/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<ul>
<li>线程池主要是为了重复利用线程，提高效率</li>
<li>因为线程是一个重量级的资源，创建、启动以及销毁都是比较耗费资源的，因此对线程重复利用是一种好的程序设计习惯</li>
<li>系统中可创建的线程数量是有限的，线程数量和系统性能是一种抛物线的关系</li>
<li>本章主要从原理入手，设计一个线程池，理解一个线程池应该具有哪些功能，需要注意哪些细节</li>
</ul>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p>一个完整的线程池应该具备如下要素</p>
<ul>
<li><p>任务队列： 用户缓存提交的任务</p>
</li>
<li><p>线程数量管理功能： 一个线程池必须能够很好的管理 和控制线程的数量，可以通过3个参数来实现：</p>
<ul>
<li>创建线程池时 初始的线程数量init</li>
<li>线程池自动扩充的最大线程数量max</li>
<li>在线程池空闲的时候需要释放线程，但是也要维护一定数量的活跃数量或者核心数量 core</li>
</ul>
<p>有了这3个参数，就能够很好的控制线程池中的线程数量，将其维护在一个合理的范围之内，三者关系是  init&lt;=core&lt;=max</p>
</li>
<li><p>任务拒绝策略： 如果线程数量已达到上限且任务队列已满，则需要有相应的拒绝策略来通知任务提交者。</p>
</li>
<li><p>线程工厂： 用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等</p>
</li>
<li><p>QueueSize： 任务队列主要存放 提交的Runnable，但是为了防止内存溢出，需要有limit 数量对其进行控制</p>
</li>
<li><p>KeepedAlive时间： 该时间主要决定线程各个重要参数自动维护的时间间隔</p>
</li>
</ul>
<p><img src="/uploads/java-concurrency-master/ThreadPoolPrinciple.png"></p>
<h1 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h1><p><img src="/uploads/java-concurrency-master/ThreadPoolImpl.png"></p>
<h2 id="线程池接口定义"><a href="#线程池接口定义" class="headerlink" title="线程池接口定义"></a>线程池接口定义</h2><ol>
<li><p>ThreadPool</p>
<p>ThreadPool主要顶一个了一个线程池应该具备的基本操作和方法，</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池大小,返回初始线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getInitSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池最大线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池的核心线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCoreSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中用户缓存任务队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中活跃线程的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//查看线程池是否已经被shutdown</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>RunnableQueue</p>
<p>RunnableQueue 用于存放提交的Runnable，该Runnable是一个BlockedQueue，并且有limit的限制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务队列，用户缓存提交到线程池中的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当有新任务进来时候，首先会offer 到队列中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程通过take方法 获取Runnable</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Runnable <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务队列中任务的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>ThreadFactory</p>
<p>THreadFactory 提供创建线程的接口，以便于个性化的定制 Thread，比如应该被加入到哪个 group中，优先级，线程名字以及是否为守护线程等</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">createThread</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>DenyPolicy</p>
<p>DenyPolicy主要用于 当Queue中的runnable 达到了limit上限的时候， 决定采用何种策略通知提交者。该接口中默认定义了3中实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现1： 直接将任务丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DiscardDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现2： 像任务提交者抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AbortDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RunnableDenyException(<span class="string">&quot;The runnable &quot;</span> + runnable + <span class="string">&quot; will be abort.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现3： 在提交者所在的线程中执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RunnerDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!threadPool.isShutdown()) &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>RunnableDenyException</p>
<p>RunnableDenyException 是RuntimeException的子类，主要用于通知 任务提交者，任务队列已无法再接受新的任务</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDenyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableDenyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>InternalTask</p>
<p>InternalTask 是 Runnable的一个实现，主要用于线程池内部，该类会使用到 RunnableQueue，然后不断地从queue中取出某个runnable ，并且运行runnable的 run方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RunnableQueue runnableQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalTask</span><span class="params">(RunnableQueue runnableQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runnableQueue = runnableQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前任务为 running ，并且没有被中断，</span></span><br><span class="line">        <span class="keyword">while</span> (running &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 则其将不断地 从queue中获取 runnable，然后执行run方法</span></span><br><span class="line">                Runnable task = runnableQueue.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                running = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止当前任务，主要会在 线程池的shutdown 方法中使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程池的详细实现"><a href="#线程池的详细实现" class="headerlink" title="线程池的详细实现"></a>线程池的详细实现</h2><ol>
<li><p>LinkedRunnableQueue (将runnableList 作为同步锁 对象)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedRunnableQueue</span> <span class="keyword">implements</span> <span class="title">RunnableQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务队列的最大容量，在构造时候传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="comment">// 假如任务队列中的任务满了，则需要执行拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DenyPolicy denyPolicy;</span><br><span class="line">    <span class="comment">// 用于存放任务的队列（双向循环列表）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; runnableList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPool threadPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedRunnableQueue</span><span class="params">(<span class="keyword">int</span> limit, DenyPolicy denyPolicy, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        <span class="keyword">this</span>.denyPolicy = denyPolicy;</span><br><span class="line">        <span class="keyword">this</span>.threadPool = threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runnableList.size() &gt;= limit) &#123;</span><br><span class="line">                <span class="comment">// 无法容纳新的任务时，执行拒绝策略</span></span><br><span class="line">                denyPolicy.reject(runnable, threadPool);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将任务假如到队尾，并且唤醒阻塞中的线程</span></span><br><span class="line">                runnableList.addLast(runnable);</span><br><span class="line">                runnableList.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="comment">// 如果任务队列中没有可执行的任务，则将当前线程挂起，进入 runnablelist 关联的wait set中等待唤醒</span></span><br><span class="line">            <span class="comment">// （有新任务假如时，会被唤醒）</span></span><br><span class="line">            <span class="keyword">while</span> (runnableList.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runnableList.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 被中断时，需要将该异常抛出，通知上游 InternalTask</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从任务队列头部移除一个任务</span></span><br><span class="line">            <span class="keyword">return</span> runnableList.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回当前任务队列中的任务数量</span></span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="keyword">return</span> runnableList.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>2.初始化线程池 (线程池本身也是一个线程)</p>
<p>线程池需要有数量控制属性（）、创建线程工厂（ThreadFactory）、任务队列策略（DenyPolicy） 等功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池本身自己也是一个线程，需要keepAlive，更新容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThreadPool</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initSize;</span><br><span class="line">    <span class="comment">//线程池最大线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//线程池核心线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 当前活跃的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> activeCount;</span><br><span class="line">    <span class="comment">// 创建线程工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RunnableQueue runnableQueue;</span><br><span class="line">    <span class="comment">// 线程池是否已经被shutdown</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isShutdown = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 工作线程队列（存放活跃线程）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;ThreadTask&gt; threadQueue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DenyPolicy DEFAULT_DENY_POLICY = <span class="keyword">new</span> DenyPolicy.DiscardDenyPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadFactory DEFAULT_THREAD_FACTORY = <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initSize  初始的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize   最大的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize  核心线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueSize 任务队列的最大数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicThreadPool</span><span class="params">(<span class="keyword">int</span> initSize, <span class="keyword">int</span> maxSize, <span class="keyword">int</span> coreSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> queueSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initSize, maxSize, coreSize, DEFAULT_THREAD_FACTORY,</span><br><span class="line">                queueSize, DEFAULT_DENY_POLICY, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造线程池需要传入的参数，更多</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initSize      初始的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize       最大的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize      核心线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 创建线程工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueSize     任务队列的最大数量（最大任务数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> denyPolicy    任务队列满后的拒绝策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicThreadPool</span><span class="params">(<span class="keyword">int</span> initSize, <span class="keyword">int</span> maxSize, <span class="keyword">int</span> coreSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory, <span class="keyword">int</span> queueSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           DenyPolicy denyPolicy, <span class="keyword">long</span> keepAliveTime, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initSize = initSize;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.runnableQueue = <span class="keyword">new</span> LinkedRunnableQueue(queueSize, denyPolicy, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时，先创建initSize 个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initSize; i++) &#123;</span><br><span class="line">            newThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务，只需要将 runnable插入任务队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">this</span>.runnableQueue.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的自动维护，具体逻辑看 InternalTask的run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalTask internalTask = <span class="keyword">new</span> InternalTask(runnableQueue);</span><br><span class="line">        Thread thread = <span class="keyword">this</span>.threadFactory.createThread(internalTask);</span><br><span class="line">        ThreadTask threadTask = <span class="keyword">new</span> ThreadTask(thread, internalTask);</span><br><span class="line">        threadQueue.offer(threadTask);</span><br><span class="line">        <span class="keyword">this</span>.activeCount++;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从线程池中 remove 某个线程</span></span><br><span class="line">        ThreadTask threadTask = threadQueue.remove();</span><br><span class="line">        threadTask.internalTask.stop();</span><br><span class="line">        <span class="keyword">this</span>.activeCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 主要用于维护线程数量，比如 扩容、回收等工作</span></span><br><span class="line">        <span class="keyword">while</span> (!isShutdown &amp;&amp; !isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                timeUnit.sleep(keepAliveTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                isShutdown = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShutdown)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(runnableQueue.size() + <span class="string">&quot;==&quot;</span> + activeCount);</span><br><span class="line">                <span class="comment">// 当前队列中 有任务尚未处理，并且 activeCount&lt; coreSize 则继续扩容</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() &gt; <span class="number">0</span> &amp;&amp; activeCount &lt; coreSize) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = initSize; i &lt; coreSize; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;--create&quot;</span>);</span><br><span class="line">                        newThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前队列中 有任务尚未处理，并且 activeCount&lt; maxSize 则继续扩容</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() &gt; <span class="number">0</span> &amp;&amp; activeCount &lt; maxSize) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = coreSize; i &lt; maxSize; i++) &#123;</span><br><span class="line">                        newThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果任务队列中 没有任务，则需要回收，回收至 coreSize 即可</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() == <span class="number">0</span> &amp;&amp; activeCount &gt; maxSize) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;remove...&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = coreSize; i &lt; maxSize; i++) &#123;</span><br><span class="line">                        removeThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShutdown) <span class="keyword">return</span>;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">            threadQueue.forEach(threadTask -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                threadTask.internalTask.stop();</span><br><span class="line">                threadTask.thread.interrupt();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">this</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInitSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.initSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCoreSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.coreSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> runnableQueue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.activeCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isShutdown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger GROUP_COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadGroup group = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;MyThreadPool-&quot;</span> + GROUP_COUNTER.getAndDecrement());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">createThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(group, runnable, <span class="string">&quot;thread-pool-&quot;</span> + COUNTER.getAndDecrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadTask 只是 InternalTask和Thread的一个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(Thread thread, InternalTask internalTask)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">            <span class="keyword">this</span>.internalTask = internalTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread;</span><br><span class="line"></span><br><span class="line">        InternalTask internalTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BasicThreadPool 同时也是Thread的子类，它在初始化的时候启动，在keepalive时间到了之后，再自动维护活动线程数量</li>
<li>TODO： BasicThreadPool 采用继承Thread的方式，不好的方式，会暴露Thread的方法，建议 改为组合关系，TODO 后面我这边会自行修改 </li>
</ul>
<h3 id="线程自动维护"><a href="#线程自动维护" class="headerlink" title="线程自动维护"></a>线程自动维护</h3><ul>
<li>自动维护线程的代码块（run方法） 是同步代码块，主要是为了阻止在线程维护过程中 线程池销毁引起的数据不一致的问题</li>
<li>任务队列中若存在积压任务，并且当前活动线程少于核心线程数，则新建 （CoreSize-initSize）数量的线程，并且将其假如到活动线程队列中，为了防止马上进行 （maxSize-coreSize）数量的扩充，建议使用 continue 终止本次循环</li>
<li>任务队列中有 积压任务，并且当前活动线程少于 最大线程数，则新建（maxSIze-coreSIze）数量的扩充，建议使用 continue 终止本次循环</li>
<li>当线程池不够繁忙时，则需要回收部分线程，回收到coreSize 数量即可，回收时调用removeThread（）方法，在该方法中需要考虑的一点是，如果被回收的线程恰巧从Runnable任务取出了某个任务，则会继续保持该线程的运行，知道完成了任务的运行为止 。详情见 InterTask 的run方法</li>
</ul>
<h3 id="线程池销毁shutdown"><a href="#线程池销毁shutdown" class="headerlink" title="线程池销毁shutdown"></a>线程池销毁shutdown</h3><ul>
<li>线程池的销毁同样需要同步机制的保护，主要是 为了防止与线程池本身的维护线程引起数据冲突</li>
</ul>
<h1 id="线程池的应用"><a href="#线程池的应用" class="headerlink" title="线程池的应用"></a>线程池的应用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadPool threadPool = <span class="keyword">new</span> BasicThreadPool(<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            threadPool.execute(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running and done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (; ; )</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getActiveCount:&quot; + threadPool.getActiveCount());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getQueueSize:&quot; + threadPool.getQueueSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getCoreSize:&quot; + threadPool.getCoreSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getMaxSize:&quot; + threadPool.getMaxSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;======================================&quot;);</span></span><br><span class="line"><span class="comment">//            TimeUnit.SECONDS.sleep(5);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">12</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>TODO： 看看 JDK 的 ExecutorService的原理和源码，据说是类似的</p>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-09-类的加载过程</title>
    <url>/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<ul>
<li>ClassLoader的主要职责是负责加载各种class文件到JVM中</li>
<li>ClassLoader是一个抽象的class ，给定一个class 的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存区域中</li>
</ul>
<h1 id="类的加载过程简介"><a href="#类的加载过程简介" class="headerlink" title="类的加载过程简介"></a>类的加载过程简介</h1><p>类的加载过程一般分为3个比较大的阶段，分别是 <strong>加载阶段、连接阶段、初始化阶段，</strong></p>
<p><img src="/uploads/java-concurrency-master/loadClassStep.png"></p>
<ul>
<li>加载阶段： 主要负责查找并加载类的二进制数据文件，其实就是class文件</li>
<li>连接阶段： 这个阶段所做的工作比较多，细分的话还可以分为以下3个阶段<ul>
<li>验证： 主要是确保类文件的正确性，比如class的版本，class文件的魔术因子是否正确</li>
<li>准备： 为类的静态变量分配内存，并且为其初始化默认值</li>
<li>解析： 把类中的符号引用转换为 直接引用</li>
</ul>
</li>
<li>初始化阶段： 为类的静态变量赋予正确的初始值 （代码编写阶段给定的值，也就是程序员的代码赋的值）</li>
</ul>
<p>当一个JVM在我们通过执行Java 命令启动后，其中可能包含的类非常多，并不是每个类都会被初始化。</p>
<ul>
<li>JVM对类的初始化时一个延迟的机制，即 ：使用的时 lazy的方式，当一个类在首次使用的时候才会被 初始化，同一个运行时包下，一个Class 只会被初始化一次 （运行时包和类的包是有区别的）</li>
</ul>
<h1 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h1><p>jvm虚拟机规范规定了，每个类或者接口被Java程序首次主动使用时，才会对其进行初始化。</p>
<h2 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h2><p>(下面的例子有问题，main方法应该写在别的类里面，因为main方法会导致类初始化)</p>
<p>jvm同时规范了以下6种主动使用类的场景，具体如下</p>
<ol>
<li><p>通过new 关键字会导致类的初始化： 这种是我们经常采用的初始化一个类的方式，它肯定会导致类的加载并且最终初始化。</p>
</li>
<li><p><strong>访问类的静态变量</strong>，包括读取和更新会导致类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    I will be initialized</span><br><span class="line">	<span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>访问类的静态方法</strong>，会导致类的初始化 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">       <span class="comment">// System.out.println(x);</span></span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    I will be initialized</span><br><span class="line">test execute</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>对某个类进行反射操作，会导致类的初始化 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">       <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//        test();</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">I will be initialized</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>初始化子类会导致父类的初始化 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The parent is initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The child will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line">        System.out.println(Child.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    ActiveLoadTest test</span><br><span class="line">The parent is initialized</span><br><span class="line">The child will be initialized</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在测试类中调用了Child的静态变量，会使得Child被初始化，Child又是 Parent的子类， 子类的初始化会导致父类的初始化</p>
</li>
<li><p>需要注意的一点是，如果<strong>通过子类使用父类的 静态变量（输出Child.y）只会导致父类的初始化，子类则不会被初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line">        System.out.println(Child.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    </span><br><span class="line">ActiveLoadTest test</span><br><span class="line">The parent is initialized</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>启动类： 也就是执行main函数所在的类会导致该类的初始化， 比如使用java命令运行上文中的ActiveLoadTest类</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h2><p>除了上面的6种情况，其余的都称为被动使用，不会导致类的加载和初始化</p>
<ol>
<li><p>构造某个类的数组时，并不会导致该类的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line"><span class="comment">//        System.out.println(Child.y);</span></span><br><span class="line"></span><br><span class="line">        Simple[] simples = <span class="keyword">new</span> Simple[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//        System.out.println(simples);</span></span><br><span class="line">        <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//            test();</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li> 引用<strong>类的静态常量</strong>不会导致类的初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The GlobalConstants will be initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在其他类中使用 MAX 不会导致 GlobalConstants的初始化，静态代码块不会输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 虽然 RANDOM 是静态常量，但是由于计算复杂，只有初始化之后才能得到记过，因此在其他类中使用 RANDOM 会导致 GlobalConstants的初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RANDOM = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(GlobalConstants.MAX);</span><br><span class="line">        System.out.println(GlobalConstants.RANDOM);</span><br><span class="line"><span class="comment">//        System.out.println(Child.y);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">//        System.out.println(simples);</span></span><br><span class="line">        <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//            test();</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    ActiveLoadTest test</span><br><span class="line"><span class="number">100</span></span><br><span class="line">The GlobalConstants will be initialized.</span><br><span class="line"><span class="number">1357034692</span></span><br></pre></td></tr></table></figure>



<h1 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h1><h2 id="类的加载阶段"><a href="#类的加载阶段" class="headerlink" title="类的加载阶段"></a>类的加载阶段</h2><p>类的加载就是将class文件中的二进制数据读取到内存之中，然后将该字节流所代表的静态存储结构转换为方法区中 运行的数据结构，并且在堆内存中生成一个该类的 java.lang.Class 对象，作为访问方法区数据结构的入口。</p>
<p><img src="/uploads/java-concurrency-master/afterCLassLoader.png"></p>
<ul>
<li>类加载的最终产物就是堆内存中的class对象，对同一个ClassLoader来讲，不管某个类被加载了多少次，对应到堆内存中的class对象始终是同一个。</li>
<li>虚拟机规范中指出了类的加载是通过一个<strong>全限定名（包名+类名）</strong>来获取二进制数据流，</li>
<li>但是并没有限定必须通过某种方式去获得，例如常见的是  <strong>class二进制文件的形式</strong><ul>
<li>运行时动态生成，比如通过动态代理 java.lang.Proxy也可以生成代理类的二进制字节流</li>
<li>通过网络获取</li>
<li>通过读取zip文件获得类的二进制字节流，比如jar 、war</li>
<li>将类的二进制数据存储在数据库的BLOB字段类型中</li>
<li>运行时生成class文件，并且动态加载</li>
</ul>
</li>
<li>在某个类完成加载阶段之后，虚拟机会<strong>将这些二进制字节流按照虚拟机所需的格式存储在<em>方法区</em>中</strong>，然后形成特定的数据结构，随之<strong>又在堆内存中实例化一个 java.lang.Class类对象，</strong>在类加载的整个生命周期中，加载过程还没有结束，连接阶段是可以交叉工作的，比如连接阶段验证字节流信息的合法性。</li>
</ul>
<h2 id="类的连接阶段"><a href="#类的连接阶段" class="headerlink" title="类的连接阶段"></a>类的连接阶段</h2><p>类的连接阶段可以细分为3个小的过程，分别是<strong>验证、准备和解析</strong></p>
<h3 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h3><p>验证在连接阶段的主要目的是：  <strong>确保class文件的字节流所包含的内存符合当前JVM的规范要求，并且不会危害JVM 自身安全的代码</strong>，当字节流信息不符合要求时，则会抛出 VerifyError 这样的异常或者时子异常。</p>
<ul>
<li>验证文件格式（例如魔术因子 0xCAFEBABE, 主次版本号）</li>
<li>元数据的验证<ul>
<li>元数据的验证其实是对class的字节流进行语义分析的过程，确保class字节流符合JVM规范的要求</li>
<li>检查当前类是否存在父类，是否继承了某个接口，这些父类和接口是否合法</li>
<li>检查该类是否继承了被final修饰的类，被final修饰的类是不允许被继承并且其中的方法是不允许被 override的</li>
<li>检查该类是否为抽象类，如果不是抽象类，是否实现了父类的抽象方法或者接口中的所有方法</li>
<li>检查方法重载的合法性，比如相同的方法名称、相同的参数，但是返回类型不同，这都是不被允许的</li>
</ul>
</li>
<li>字节码验证<ul>
<li>主要是验证程序的控制流程，比如循环、分支。比如： 类型转换是否合法 ，程序计数器的指令不会跳转到不合法的字节码指令中去</li>
</ul>
</li>
<li>符号引用的验证<ul>
<li>验证符号引用转换为直接引用时的合法性</li>
<li>通过符号引用描述的字符串全限定名称是否能够顺利的找到相关的类</li>
<li>符号引用的类、字段、方法，是否能对当前类可见，比如不能访问引用类的私有方法</li>
<li>符号引用验证的目的是： 为了保证解析动作的顺利进行，比如某个类的字段不存在，则会抛出NoSuchFieldError ，若方法不存在 则抛出 NoSuchMethodError等，我们在使用反射的时候，会遇到这样的异常信息</li>
</ul>
</li>
</ul>
<h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h3><p>当一个class字节流通过了所有的验证过程后，就开始为该对象的类变量（静态变量）分配内存并设置初始值了。 </p>
<p>注意： <strong>类变量的内存会被分配到方法区中，</strong> 不同于实例变量会被分配到对内存中 。</p>
<ul>
<li>所谓的设置初始值，其实就是为相应的类变量 给定一个相关类型在没有设置值时的默认值，不同的数据类型以及其 初始值为：</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>（byte）0</td>
</tr>
<tr>
<td>Char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>Short</td>
<td>(short)0</td>
</tr>
<tr>
<td>Int</td>
<td>0</td>
</tr>
<tr>
<td>Float</td>
<td>0.0F</td>
</tr>
<tr>
<td>Double</td>
<td>0.0D</td>
</tr>
<tr>
<td>Long</td>
<td>0L</td>
</tr>
<tr>
<td>Boolean</td>
<td>False</td>
</tr>
<tr>
<td>引用类型</td>
<td>null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedPrepate</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>static int a=10,在准备阶段值为 初始值0，</li>
<li>final static int b则为10 ，因为在类的编译阶段javac 会将其Value 生成一个 ConstantValue属性，直接赋予10.</li>
</ul>
<h3 id="3-解析（TODO）"><a href="#3-解析（TODO）" class="headerlink" title="3.解析（TODO）"></a>3.解析（TODO）</h3><p>在连接阶段中经历了验证、准备之后，就可以顺利进入到解析过程了，当然在解析的过程中照样会交叉一些验证的过程，</p>
<ul>
<li>比如符号引用的验证，</li>
</ul>
<p>所谓解析就是在常量池中寻找类、接口、字段和方法的符号引用，并且将这些符号引用替换为直接引用的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassResolve</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Simple simple=<span class="keyword">new</span> Simple();</span><br><span class="line">    <span class="function">pulbic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(simple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机规范规定了，在anewarray，checkcast、getfield、getstatic，instanceof，invokeinterface，invokespecial、invokevirtual，multianewarray、new、putfiled、putstatic 这13个 操作符号引用的字节码指令之前，必须要对所有的符号提前进行解析 。</p>
<p>解析过程主要是 针对类接口、字段、类方法和接口方法这4类进行的，分别对应到常量池中的CONSTANT_Class_info、 Constant_Filldref_info、Constant_Methodref_info 和 Constant_InterfaceMethodref_info 这4中类型常量 。</p>
<h4 id="类接口解析"><a href="#类接口解析" class="headerlink" title="类接口解析"></a>类接口解析</h4><ul>
<li>假设前文代码中的Simple ，不是一个数组类型，则在加载的过程中，需要先完成对SImple 类的加载，同样需要经历所有的类加载阶段</li>
<li>如果SImple是一个数组类型，则虚拟机不需要完成对 SImple 的加载，只需要在虚拟机中生成一个能够代表该类型的数组对象，并且在堆内存中开辟一片连续的地址空间即可</li>
<li>在类接口的解析完成之后，还需要进行符号引用的验证</li>
</ul>
<h4 id="字段的解析"><a href="#字段的解析" class="headerlink" title="字段的解析"></a>字段的解析</h4><p>所谓字段的解析，就是解析你所访问类或者接口中的字段，在解析类或者变量的时候，如果该字段不存在，或者出现错误，则会抛出异常，不再进行下面的解析。</p>
<ul>
<li>如果Simple类本身就包含某个字段，则直接返回这个字段的引用，当然也要对该字段所属的类提前进行类加载</li>
<li>如果Simple 类中不存在该字段，则会根据继承关系自下而上，查找父类或者接口的字段，找到即可返回，同样需要提前对找到的字段进行类的加载过程 。</li>
<li>如果SImple类中没有字段，一直找到了最上层的java.lang.Object 还是没有，则表示 查找失败，也就不再进行任何解析，直接抛出了NoSuchFieldError 异常</li>
</ul>
<h4 id="类方法的解析"><a href="#类方法的解析" class="headerlink" title="类方法的解析"></a>类方法的解析</h4><p>类方法和接口方法有所不同，类方法可以直接使用该类进行调用，而接口方法必须要有相应的实现类继承才能够进行调用 。</p>
<ul>
<li>若在类方法表中发现class_index 中索引的Simple 是一个接口而不是一个类，则 直接返回错误</li>
<li>在SImple类中查找是否有方法描述和目标方法完全一致的方法，如果有，则直接返回这个方法的引用，否则直接继续向上查找。</li>
<li>如果父类中仍然没有找到，则意味着查找失败，程序会抛出NoSuchMethodError 异常</li>
<li>如果在当前类或者父类中找到了和目标方法一致的方法，但是它是一个抽象类，则会抛出AbstractMethodError 这个异常</li>
</ul>
<h4 id="接口方法的解析"><a href="#接口方法的解析" class="headerlink" title="接口方法的解析"></a>接口方法的解析</h4><p>接口不仅可以定义方法，还可以继承其他接口</p>
<ul>
<li>在接口方法表中发现 class_index 中索引的Simple是一个类而不是一个接口，则会直接 返回错误，因为方法接口表 和类接口表 所容纳的类型应该是 不一样的，所以常量池 中有 Constant_Methodref_info 和 Constant_InterfaceMethodref_info 两个不同的类型 </li>
<li>接下来的查找 和类方法的解析就比较类似了，自下而上的查找，直到找到为止，或者没找到 抛出NoSuchMethodError 异常 。</li>
</ul>
<h3 id="类的初始化阶段"><a href="#类的初始化阶段" class="headerlink" title="类的初始化阶段"></a>类的初始化阶段</h3><p>类的初始化阶段是整个类加载过程的最后一个阶段</p>
<ul>
<li>在初始化阶段做的最主要的一件事情就是执行 <clinit> () 方法中所有的类变量都会被 赋予正确的值，也就是在程序编写的时候指定的值 </li>
<li> <clinit> () 方法 实在编译阶段生成的，也就是说它 已经包含在 class文件中了，<clinit>中包含了所有类变量的赋值动作和静态语句块的执行代码 ，</li>
<li>编译器收集的顺序是 由执行语句在源文件中的出现顺序所决定的 （<clinit> 是能够保证顺序性）</li>
<li>静态 语句块只能对后面的静态变量进行赋值，但是 不能对其进行访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">static</span>&#123;</span><br><span class="line">         <span class="comment">// 静态代码块 只能对后面的静态变量进行赋值，但是不能对其访问 </span></span><br><span class="line">        System.out.println(x);<span class="comment">// 报错，Illegal forward reference </span></span><br><span class="line">        <span class="comment">//  </span></span><br><span class="line">        x=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外<clinit> 方法与类的构造函数有所不同，它不需要显示的调用父类的 构造器，虚拟机会保证父类的 <clinit>方法最先执行，因此父类的静态变量总是能够得到优先赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            value = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类使用父类的静态变量为自己的静态变量赋值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出的是： <span class="number">20</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟机会保证父类的 <clinit>方法最先执行，因此父类的静态变量总是 能够得到优先赋值  </li>
<li><clinit>() 方法虽然是真实存在的，但是它 只能被虚拟机执行，在主动使用触发了类的初始化之后就会调用这个方法  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The ClassInit static code block will be invoke.&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">                .forEach(i -&gt; <span class="keyword">new</span> Thread(ClassInit::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在同一时间，只能有一个线程执行到静态代码块中的内容，并且静态代码块仅仅只会被执行一次，JVM保证了 <clinit> 方法在多线程的执行环境下的同步语义，因此在单例设计模式下，采用 Holder的方式是一种最佳的设计方法 </li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li>类的加载过程 还是会围绕 二进制文件的加载，二进制数据的连接以及类的初始化这样的过程区进行 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">   <span class="comment">//1. </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton(); <span class="comment">// 2.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y+;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton singleton=Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton.x);</span><br><span class="line">        System.out.println(singleton.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    com.wangwenjun.concurrent.chapter09.Singleton@<span class="number">4554617</span>c</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先在连接阶段的准备过程中，每一个类变量都被赋予了相应的初始值  x=0，y=0， instance=null</p>
</li>
<li><p>类的初始化阶段，初始化阶段会为每一个类变量赋予正确的值，也就是执行 <clinit> 方法的过程 </p>
<p>x=0, y=0, instance =new Singleton()</p>
</li>
<li><p>然后在 new SIngleton 的时候，会执行类的构造函数，而在构造函数中 分别对 x和y 进行自增，结果为：</p>
<p>x=1，  y=1</p>
</li>
</ol>
<p>再看调换 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 调换Singleton顺序之后， </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton);</span><br><span class="line">        System.out.println(singleton.x);</span><br><span class="line">        System.out.println(singleton.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    </span><br><span class="line">    com.wangwenjun.concurrent.chapter09.Singleton@<span class="number">4554617</span>c</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>类的加载过程</tag>
      </tags>
  </entry>
  <entry>
    <title>java高并发详解-10-JVM类加载器</title>
    <url>/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h1><ul>
<li>类加载器就是负责类的加载的职责，对于任意一个class，都需要由加载它的类加载器和这个类本身确立其在JVM中的唯一性，这也就是 运行时包</li>
<li>任何一个对象的class 在JVM中只存在唯一的一份，比如 String.class 、Object.class 在堆内存以及方法区中肯定是唯一的 。</li>
<li>但是绝不可以理解为我们自定义的类 在JVM中同样也是这样。</li>
</ul>
<h2 id="JVM内置三大类加载器"><a href="#JVM内置三大类加载器" class="headerlink" title="JVM内置三大类加载器"></a>JVM内置三大类加载器</h2><ul>
<li>JVM为我们提供了 三大内置的类加载器，不同的类加载器负责 将不同的类加载到JVM 内存之中，并且他们之间严格遵守着父委托的机制 </li>
</ul>
<p><img src="/uploads/java-concurrency-master/CLassLoader-father.png"></p>
<h2 id="根类加载器介绍"><a href="#根类加载器介绍" class="headerlink" title="根类加载器介绍"></a>根类加载器介绍</h2><p>根加载器又称为 Bootstrap类加载器，该类加载器是最为顶层的加载器，其没有任何父加载器，它是由 根加载器 所加载的，可以通过 -Xbootclasspath 来指定根加载器 的路径，也 可以通过系统属性来得知当前JVM 的根加载器都加载了哪些资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrapClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bootstrap:&quot;</span> + String.class.getClassLoader());</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">Bootstrap:<span class="keyword">null</span></span><br><span class="line">D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\resources.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\rt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\sunrsasign.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jsse.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jce.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\charsets.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfr.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\classes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="扩展类加载器介绍"><a href="#扩展类加载器介绍" class="headerlink" title="扩展类加载器介绍"></a>扩展类加载器介绍</h2><p>扩展类加载器的父加载器是根加载器，它主要用于加载 JAVA_HOME下的 jre\lib\ext 子目录里面的类库。扩展类加载器是由纯java语言实现的，它是 java.lang.URLClassLoader的子类，它的完整类名 是 sun.misc.Launcher$ExtClassLoader。扩展类加载器所加载的类库 可以通过系统属性 java.ext.dirs获得</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        Class&lt;?&gt; helloClass = Class.forName(&quot;Hello&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(helloClass.getClassLoader());</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果： D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>

<h2 id="系统类加载器介绍"><a href="#系统类加载器介绍" class="headerlink" title="系统类加载器介绍"></a>系统类加载器介绍</h2><p>系统类加载器是一种常见的类加载器，其负责加载 classpath下的类库资源。我们在进行项目开发的时候引入的第三方jar包，<strong>系统类加载器的父类加载器 是扩展类加载器，同时它也是自定义类加载器的默认父加载器，</strong>  系统类加载器的加载路径一般通过 -classpath 或者 -cp指定，同样的也可以通过系统属性 java.class.path进行获取，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">        System.out.println(ApplicationClassLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line">    D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\charsets.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\deploy.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\cldrdata.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\dnsns.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\jaccess.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\jfxrt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\localedata.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\nashorn.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunec.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunjce_provider.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunmscapi.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunpkcs11.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\zipfs.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\javaws.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jce.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfr.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfxswt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jsse.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\management-agent.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\plugin.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\resources.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\rt.jar;H:\pdf\java-concurrency-master\java-concurrency-master\book\target\classes;C:\Users\yinshi\.m2\repository\mysql\mysql-connector-java\<span class="number">6.0</span>.<span class="number">6</span>\mysql-connector-java-<span class="number">6.0</span>.<span class="number">6.</span>jar;D:\Program Files\JetBrains\IntelliJ IDEA <span class="number">2020.1</span>.<span class="number">3</span>\lib\idea_rt.jar</span><br><span class="line"></span><br><span class="line">        sun.misc.Launcher$AppClassLoader@<span class="number">14d</span>ad5dc</span><br></pre></td></tr></table></figure>

<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>用程序实现自定义的类加载器，所有的自定义类加载都是ClassLoader的直接子类或者间接子类，java.lang.ClassLoader是一个抽象类，它里面并没有抽象方法，但是又findClass 方法，务必实现该方法，否则将会抛出 Class找不到的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类加载器必须是ClassLoader 的直接或者间接子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义默认的class 存放路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Path DEFAULT_CLASS_DIR = Paths.get(<span class="string">&quot;H:\\pdf\\java-concurrency-master\\java-concurrency-master\\book\\target\\classes\\com\\wangwenjun\\concurrent\\chapter10&quot;</span></span><br><span class="line">            , <span class="string">&quot;classloader1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path classDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认的class路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = DEFAULT_CLASS_DIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许传入指定的class路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定class路径的同时，指定父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写父类的findClass 方法，这个是至关重要的step</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 读取class 的二进制数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">this</span>.readClassBytes(name);</span><br><span class="line">        <span class="comment">//如果数据为null，或者没有读到任何信息，则抛出 ClassNotFoundException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Can not load the class &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用defineClass 方法定义class（）</span></span><br><span class="line">        <span class="comment">//name 定义类的名字</span></span><br><span class="line">        <span class="comment">// classBytes class文件的二进制字节数组</span></span><br><span class="line">        <span class="comment">// 字节数组的偏移量</span></span><br><span class="line">        <span class="comment">// 从偏移量开始读取多长的byte数据</span></span><br><span class="line">        <span class="comment">// 问题： 第一个 阶段的加载主要是获取class的字节流信息，那么我们将整个字节流信息交给defineClass不就行 了吗，为什么还要指定偏移量和读取长度呢：</span></span><br><span class="line">        <span class="comment">// 因为class字节数组不一定是从一个class文件中获得的，有可能是来自网络的，也有可能是来自网络或者其他途径。</span></span><br><span class="line">        <span class="comment">//由此可见一个字节数组中很有可能存储多个class的字节信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将class文件读入内存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClassBytes(String name)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 将包名分隔符 转换为分拣路径分隔符</span></span><br><span class="line">        String classPath = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Path classFullPath = classDir.resolve(Paths.get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!classFullPath.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Files.copy(classFullPath, baos);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;load the class &quot;</span> + name + <span class="string">&quot; occur error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My ClassLoader&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个构造函数使用默认的文件路径</li>
<li>第二个构造函数允许外部指定一个特定的磁盘目录</li>
<li>第三个构造函数除了可以指定磁盘目录外，还可以指定该类加载的父加载器</li>
</ul>
<p>全路径格式有以下几种情况：</p>
<ul>
<li>java.lang.String:     包名.类名</li>
<li>javax.swing.JSpinner $DefaultEditor: 包名.类名 $内部类</li>
<li>java.security.KeyStor$Builder$FileBuilder$1 :包名.类名 $内部类 $内部类$匿名内部类</li>
<li>java.net.URLClassLoader$3$1: 包名.类名 $内部类$匿名内部类</li>
</ul>
<p>强调defineClass 方法，该方法的完整方法描述是  defineClass(String name, byte[] b, int off, int len) </p>
<ul>
<li>其中第一个是要定义类的名字，一般与findClass 方法中的类名保持一致即可</li>
<li>第二个是 class文件的二进制字节数组，</li>
<li>第三个是字节数组的偏移量</li>
<li>第4个是从偏移量开始读取多长的byte数据</li>
</ul>
<h2 id="双亲委托机制详细介绍"><a href="#双亲委托机制详细介绍" class="headerlink" title="双亲委托机制详细介绍"></a>双亲委托机制详细介绍</h2><ul>
<li>当一个类加载器被调用了loadClass之后，它并不会直接将其加载，而是先交给当前类加载器的 父加载器尝试加载直到最顶层的父加载器，然后一次向下进行加载。</li>
</ul>
<p><img src="/uploads/java-concurrency-master/classLoaderOfFather.png"></p>
<p>在解析loadClass 源码之前，思考一个问题，由于担心HelloWorld.class 被系统类加载器加载，所以删除了HelloWorld 的相关文件，那么有什么办法可以不用删除又可以使用 MyClassLoader对HelloWorld 进行加载的吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">     <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码片段是 java.lang.ClassLoader 的loadClass（name）和 loadClass（name，resolve）方法，由于loadClass （name）调用的是 loadClass（name，false），因此我们重点解释  loadClass（name，false）即可</p>
<ul>
<li>从当前类加载器的已加载类缓存中根据类的全路径名查询是否存在该类， 如果存在则直接返回 </li>
<li>如果当前类存在父类加载器，则 调用父类加载器的loadClass （name,false） 方法对其 进行加载</li>
<li>如果当前类加载不存在父类加载器，则直接调用根类加载器 对该类进行加载</li>
<li>如果 当前类的所有父类加载器都没有成功加载class ，则尝试 调用当前类加载器的 findClass 方法对其进行加载，该方法就是我们自定义加载器需要重写的方法</li>
<li>最后如果类被成功加载，则做一些性能数据的统计 </li>
<li>由于loadClass 指定了revolve 为false，所以不会 进行连接阶段的继续执行 ，这也就解释了  为什么通过类加载器 加载类并不会导致类的初始化</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何在不删除HelloWorld.class 文件的情况下 使用MyClassLoader 而不是系统类加载器进行HelloWorld 的加载，有如下两种方法可以做到。</p>
<ol>
<li>第一种方式 是绕过系统类加载器，直接将扩展类加载器 作为MyClassLoader 的父加载器，示例 代码如下： </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader extClassloader = MyClassLoaderTest.class.getClassLoader().getParent();</span><br><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classLoader1&quot;</span>,extClassloader);</span><br><span class="line">Class&lt;?&gt; aclass=classLoader.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.HelloWorld&quot;</span>);</span><br><span class="line">System.out.println(aClass);</span><br><span class="line">System.out.println(aClass.getClassLoader());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>首先我们通过MyClassLoaderTest.class 获取系统类加载器，然后再获取系统类加载器的父类加载器 扩展类加载器，使其成为MyClassLoader的父类加载器，这样一来，根加载器和扩展类加载器都无法对 G:\ classloader 类文件进行加载，自然而然就交给了MyClassLoader 对 HelloWorld 进行加载了，这种方式充分利用了类加载器 父类委托机制的特性</li>
</ul>
<ol start="2">
<li> 第二种方式实在构造 MyClassLoader 的时候指定其父类加载器为null ，示例代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClassLoader classLoader=<span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; aclass=classLoader.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.HelloWorld&quot;</span>);</span><br><span class="line">System.out.println(aClass);</span><br><span class="line">System.out.println(aClass.getClassLoader());</span><br><span class="line"></span><br><span class="line">根据对 loadClass方法的源码分析，当前类在没有父类加载器的情况下，会直接使用根加载器对该类进行加载 ，很显然，HelloWorld 在根加载器的加载路径下 是无法找到的，那么它 自然而然地就交给当前类加载器进行加载了</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="破坏双亲委托机制"><a href="#破坏双亲委托机制" class="headerlink" title="破坏双亲委托机制"></a>破坏双亲委托机制</h2><ul>
<li>我们发现类加载器的父委托机制的逻辑 主要是由loadClass来控制的，有些时候我们需要打破这种双亲委托的机制，比如 HelloWorld 这个类就是不希望通过系统类加载器对其进行加载。</li>
<li>JDk 提供的双亲委托机制并非一个强制性的模型，程序开发人员是可以对其进行 灵活发挥破坏这种委托机制的 </li>
</ul>
<p>比如： 如果我们想要在程序运行时进行某个模块功能的升级，甚至是 在不停止服务的前提下增加新的功能，这就是我们常说的热部署。</p>
<ul>
<li>热部署首先要卸载掉加载该模块所有Class的类加载器，卸载类加载器会导致所有类的卸载，</li>
<li>很显然我们无法对JVM 三大内置加载器进行卸载，我们只有通过控制 自定义类加载器才能做到这一点 </li>
</ul>
<p>我们可以通过破坏父委托机制的方式 来实现对HelloWorld类的加载，而不需要在工程中删除该文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerDelegateClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Path DEFAULT_CLASS_DIR = Paths.get(<span class="string">&quot;G:&quot;</span>, <span class="string">&quot;classloader1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path classDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = DEFAULT_CLASS_DIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">(String classDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">(String classDir, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">this</span>.readClassBytes(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Can not load the class &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1. 根据类的全路径名称进行加锁，确保每一个类在多线程 的情况下制备加载一次 </span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">//2. 到已加载类的缓存中查看该类是否已经被加载，如果已加载则直接返回</span></span><br><span class="line">            Class&lt;?&gt; klass = findLoadedClass(name);</span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">if</span> (klass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4. 假如缓存中没有被加载的类，则需要对其进行首次加载，如果类的全路径以java和javax开头，则直接委托给 系统类加载器对其进行加载 </span></span><br><span class="line">                <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;java.&quot;</span>) || name.startsWith(<span class="string">&quot;javax&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        klass = getSystemClassLoader().loadClass(name);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 5. 如果类不是以java 和javax 开头，则尝试用我们自定义的类加载进行加载 </span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        klass = <span class="keyword">this</span>.findClass(name);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 6. 如果 自定义类加载仍旧 没有完成对类的加载，则委托 给其父类加载器进行加载或者系统类加载器进行加载 </span></span><br><span class="line">                    <span class="keyword">if</span> (klass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            klass = getParent().loadClass(name);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            klass = getSystemClassLoader().loadClass(name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 经过诺干次的尝试后，如果还是无法对类进行加载，则抛出无法找到类的异常 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == klass) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(klass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> klass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClassBytes(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String classPath = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Path classFullPath = classDir.resolve(Paths.get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!classFullPath.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Files.copy(classFullPath, baos);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;load the class &quot;</span> + name + <span class="string">&quot; occur error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Broker Delegate ClassLoader&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类加载器命名空间、运行时包、类的卸载等"><a href="#类加载器命名空间、运行时包、类的卸载等" class="headerlink" title="类加载器命名空间、运行时包、类的卸载等"></a>类加载器命名空间、运行时包、类的卸载等</h2><h3 id="1-类的命名空间"><a href="#1-类的命名空间" class="headerlink" title="1.类的命名空间"></a>1.类的命名空间</h3><p>每一个类加载器都有各自的命名空间，命名空间时由该加载器及其所有父加载器所构成的，因此在每一个类加载器中同一个class 都是独一无二的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">       MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">       MyClassLoader classLoader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">       Class&lt;?&gt; aClass = classLoader1.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.Test&quot;</span>);</span><br><span class="line">       Class&lt;?&gt; bClass = classLoader2.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.Test&quot;</span>);</span><br><span class="line">       System.out.println(aClass.getClassLoader());</span><br><span class="line">       System.out.println(bClass.getClassLoader());</span><br><span class="line">       System.out.println(aClass.hashCode());</span><br><span class="line">       System.out.println(bClass.hashCode());</span><br><span class="line">       System.out.println(aClass == bClass);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，不论load多少次Test，都会发现他们始终时同一份class对象，这也完全符合我们在本书9.1节中的描述。 类被加载后的内存情况如图所示：</p>
<p><img src="/uploads/java-concurrency-master/classAfterLoader.png"></p>
<ul>
<li>但是，使用不同的类加载器，或者同一个类加载器的不同示例，去加载同一个class，则会在堆内存和方法区产生多个class对象 </li>
</ul>
<p>（1） 不同类加载器加载同一个class，输出的结果显示aclass 和 bclass不是同一个class示例 </p>
<p>（2）相同类加载器加载同一个class,输出的结果显示aclass 和 bclass不是同一个class示例 </p>
<p>分析JDK 中关于ClassLoader 的相关源代码，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            。。。</span><br><span class="line">                </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在类加载器进行类加载的时候，首先会到  加载记录表也就是缓存中，查看该类是否已经被加载过了，如果已经被加载过了，就不会重复加载，否则就会认为其是 首次加载， 下图就是同一个class 被不同类加载器加载之后的内存i情况 。</p>
<p><img src="/uploads/java-concurrency-master/differentClassLoaderLoadClass.png"></p>
<p>同一个class示例在同一个类加载器命名空间之下是唯一的。</p>
<h3 id="2-运行时包"><a href="#2-运行时包" class="headerlink" title="2. 运行时包"></a>2. 运行时包</h3><ul>
<li>我们在编写代码的时候，通常会给一个类指定一个包名，包的作用是为了组织类，防止不同包下同样名称的class 引起冲突，还能起到封装的作用，包名和类名构成了类的全限定名称。</li>
<li>在JVM运行时，class会由一个运行时包，<strong>运行时的包是类加载器的命名空间和类的全限定名称共同组成的</strong>。 例如:BootstrapClassLoader.ExtClassLoader.AppClassLoader.MyClassLoader.com.wangwenjun.concurrent.chapter10.Test</li>
<li>这样做的好处同样是 处于安全和封装的考虑，在java.lang.String中存在仅包可见的方法 void getChars（char[] var1,int var2），java.lang包以外的class 是无法直接对其访问的。  假设用户想自己定义一个类 java.lang.HackString。并且由自定义的类加载器进行加载，尝试访问getChars方法，由于 java.lang.HackString 和 java.lang.String是由不同的类加载器进行加载的，它们拥有各自不同的运行时包，因此 HackString 是无法访问java.lang.String 的包可见方法以及成员变量的 </li>
</ul>
<h3 id="3-初始化类加载器"><a href="#3-初始化类加载器" class="headerlink" title="3.初始化类加载器"></a>3.初始化类加载器</h3><p>由于运行时包的存在，JVM 规定了不同的运行时包下的类 彼此之间是不可以进行访问的。那么问题来了，为什么我们在开发的程序中可以访问java.lang包下的类呢。 我们直到java.lang包 是由根加载器进行加载的，而我们开发的程序或者第三方类库一般是 由系统类加载器进行加载的。</p>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>每一个类在经过ClassLoader 的加载之后，在虚拟机中都会 有对应的Class 实例，如果某个类C 被类加载器CL 加载，那么CL 就被成为C的初始类加载器。 </p>
<p>JVM 为每一个类加载器维护了一个列表，该列表中记录了 将该类加载器作为初始类加载器的所有class ，在加载一个类时，JVM 使用这些列表来判断该类是否已经被加载过了，是否需要首次加载 。</p>
<ul>
<li>根据JVM规范的规定，在类的加载过程中，所有 参与的类加载器，即使没有亲自记载过该类，也会被标识为该类的初始类加载器，比如 java.lang.String首先经过了 BrokerDelegateClassLoader类加载器，一次又经过了 系统类加载器、扩展类加载器、根类加载器，这些类加载器都是java.lang.String 的初始类加载器，JVM会在每一个类加载器维护的列表中添加该 class 类型，如下图所示。</li>
</ul>
<p><img src="/uploads/java-concurrency-master/InitClassLoaderWithClassList.png"></p>
<p>虽然SimpleClass 和 java.lang.String 由不同的类加载器加载，但是 在BrokerDelegate-Class Loader的class列表中维护了 SimpleClass.class  和String.class ，因此在SimpleClass中 是可以正常访问 rt.jar 中的class 的</p>
<h3 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4.类的卸载"></a>4.类的卸载</h3><ul>
<li>在jvm启动的过程中，jvm会加载很多的类，在运行期间同样会加载很多的类，比如用自定义的类加载器进行类的加载，或者像Apache Drools框架一样会在每一个DSL 文件解析成功之后生成相应的类文件。</li>
<li>关于JVM在运行期间到底加载了多少class，可以在启动JVM时 指定 -verbose：class 参数观察到，我们直到某个对象在堆内存中如果没有其他地方引用则会在垃圾回收器 线程进程GC的时候被回收掉，那么该对象在堆内存中的Class 对象以及Class 在方法区中的数据结构何时被回收呢?</li>
<li>JVM规定一个Class只有在满足下面三个条件的时候才会被GC回收，也就是类被卸载<ol>
<li>该类所有的实例都已经被GC ，比如SImple.class 的所有Simple实例都被回收掉</li>
<li>加载该类的ClassLoader实例被回收</li>
<li>该类的class实例 没有在其他地方被引用</li>
</ol>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>唉，为情所困，脑子都要炸了，这篇记录拖得太久了，<ol>
<li>介绍了JVM 内置的3大类加载器（根类加载器，扩展类加载器，系统类加载器）</li>
<li>通过继承ClassLoader重写findClass方法自定义了MyClassLoader，</li>
<li>通过堆loadClass方法的源码剖析详细分析了双亲委托机制的原理，双亲委托机制时一种包含关系，而并非继承关系。</li>
<li> 自定义一个与java.lang.String 同名的String类 ，但是JVM不允许这样做，会在JVM 的defineClass的时候做安全性检查。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>高并发详解</category>
      </categories>
      <tags>
        <tag>JVM类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-02-OOM异常</title>
    <url>/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-02-OOM%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="OOM实战"><a href="#OOM实战" class="headerlink" title="OOM实战"></a>OOM实战</h1><p>《java虚拟机规范》的规定中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM 异常的可能</p>
<h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><ul>
<li>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证 <strong><em>GC Roots到对象之间有可达路径</em></strong> 来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。代码清单2-3中限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOf-MemoryError可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid14844.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">29587006</span> bytes in <span class="number">0.082</span> secs]</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.base/java.util.Arrays.copyOf(Arrays.java:<span class="number">3720</span>)</span><br><span class="line">	at java.base/java.util.Arrays.copyOf(Arrays.java:<span class="number">3689</span>)</span><br><span class="line">	at java.base/java.util.ArrayList.grow(ArrayList.java:<span class="number">237</span>)</span><br><span class="line">	at java.base/java.util.ArrayList.grow(ArrayList.java:<span class="number">242</span>)</span><br><span class="line">	at java.base/java.util.ArrayList.add(ArrayList.java:<span class="number">485</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>第一步首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（MemoryOverflow）</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集无法回收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。</li>
<li>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</li>
</ul>
<h2 id="虚拟机栈-和本地方法栈溢出"><a href="#虚拟机栈-和本地方法栈溢出" class="headerlink" title="虚拟机栈 和本地方法栈溢出"></a>虚拟机栈 和本地方法栈溢出</h2><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常：</p>
<p>1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟机栈和本地方法栈测试</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackSOF_1 oom = <span class="keyword">new</span> JavaVMStackSOF_1();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length:&quot;</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    stack length:<span class="number">982</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">13</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">14</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">14</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">14</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机栈和本地方法栈测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.jvm.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM: JDK 1.0.2, Sun Classic VM</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF_3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line"></span><br><span class="line">        stackLength ++;</span><br><span class="line">        test();</span><br><span class="line"></span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">                unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">                        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">                                unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">                                        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">                                                unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">                                                        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">                                                                unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">                                                                        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">                                                                                unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">                                                                                        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">                                                                                                unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">                                                                                                        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">                                                                                                                unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">                                                                                                                        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">                                                                                                                                unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">                                                                                                                                        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">                                                                                                                                                unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">                                                                                                                                                        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">                                                                                                                                                                unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length:&quot;</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果： stack length:<span class="number">7550</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_3.test(JavaVMStackSOF_3.java:<span class="number">34</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_3.test(JavaVMStackSOF_3.java:<span class="number">34</span>)</span><br></pre></td></tr></table></figure>



<p>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常。</p>
<p>可见相同的代码在Classic虚拟机中成功产生了OutOfMemoryError而不是StackOver-flowError异常。如果测试时不限于单线程，通过不断建立线程的方式，HotSpot上也是可以产生内存溢出异常的，具体如代码清单2-6所示。但是这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系，主要取决于操作系统本身的内存使用状态。甚至可以说，在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p>
<p>操作系统分配给每个进程的内存是有限制的，譬如32位Windows的单个进程最大内存限制为2GB。HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值，那剩余的内存即为2GB（操作系统限制）减去最大堆容量，再减去最大方法区容量，由于程序计数器消耗内存很小，可以忽略掉，如果把直接内存和虚拟机进程本身耗费的内存也去掉的话，剩下的内存就由虚拟机栈和本地方法栈来分配了。因此为每个线程分配到的栈内存越大，可以建立的线程数量自<br>然就越少，建立线程时就越容易把剩下的内存耗尽，代码清单2-6演示了这种情况。</p>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。</p>
<p>前面曾经提到HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代的背景故事，在此我们就以测试代码来观察一下，使用“永久代”还是“元空间”来实现方法区，</p>
<p>String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过-XX：PermSize和-XX：MaxPermSize限制永久代的大小，即可间接限制其中常量池的容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行时常量池导致的内存溢出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">at java.lang.String.intern(Native Method)</span><br><span class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>从运行结果中可以看到，运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是“PermGen space”，说明运行时常量池的确是属于方法区（即JDK 6的HotSpot虚拟机中的永久代）的一部分。</p>
<p>而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使用-XX：MaxPermSize参数或者在JDK 8及以上版本使用-XX：MaxMeta-spaceSize参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将一直进行下去，永不停歇[1]。出现这种变化，是因为自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中，所以在JDK 7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。这时候使用-Xmx参数限制最大堆到6MB就能够看到以下两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OOM异常一：</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.base/java.lang.Integer.toString(Integer.java:<span class="number">440</span>)</span><br><span class="line">at java.base/java.lang.String.valueOf(String.java:<span class="number">3058</span>)</span><br><span class="line">at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:<span class="number">12</span>)</span><br><span class="line"><span class="comment">// OOM异常二：</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.base/java.util.HashMap.resize(HashMap.java:<span class="number">699</span>)</span><br><span class="line">at java.base/java.util.HashMap.putVal(HashMap.java:<span class="number">658</span>)</span><br><span class="line">at java.base/java.util.HashMap.put(HashMap.java:<span class="number">607</span>)</span><br><span class="line">at java.base/java.util.HashSet.add(HashSet.java:<span class="number">220</span>)</span><br><span class="line">at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java from InputFile-Object:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>而JDK 7（以及部分其他虚拟机，例如JRockit）的intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可，因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。</p>
<p>而对str2比较返回false，这是因为“java”[2]这个字符串在执行String-Builder.toString()之前就已经出现过了，字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“计算机软件”这个字符串则是首次出现的，因此结果返回true。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。<br>-XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。<br>·-XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可<br>减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最<br>大的元空间剩余容量的百分比</p>
<h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致，代码清单越过了DirectByteBuffer类直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例，体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能，在JDK 10时才将Unsafe的部分功能通过VarHandle开放给外部使用），因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常，真正申请分配内存的方法是Unsafe::allocateMemory()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError</span><br><span class="line">	at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.DirectMemoryOOM.main(DirectMemoryOOM.java:<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>OOM异常</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-05-调优案例分析与实战</title>
    <url>/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><h2 id="大内存硬件上的程序部署策略"><a href="#大内存硬件上的程序部署策略" class="headerlink" title="大内存硬件上的程序部署策略"></a>大内存硬件上的程序部署策略</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>服务器的硬件为四路志强处理器、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的文档网站使用。软件版本选用的是64位的JDK 5，管理员启用了一个虚拟机实例，使用-Xmx和-Xms参数将Java堆大小固定在12GB。使用一段时间后发现服务器的运行效果十分不理想，网站经常不定期出现长时间失去响应。</p>
<p>监控服务器运行状况后发现网站失去响应是由垃圾收集停顿所导致的，在该系统软硬件条件下，HotSpot虚拟机是以服务端模式运行，默认使用的是吞吐量优先收集器，回收12GB的Java堆，一次FullGC的停顿时间就高达14秒。由于程序设计的原因，访问文档时会把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象大多在分配时就直接进入了老年代，没有在Minor GC中被清理掉。这种情况下即使有12GB的堆，内存也很快会被消耗殆尽，由此导致每隔几分钟出现十几秒的停顿，令网站开发、管理员都对使用Java技术开发网站感到很失望</p>
<ul>
<li><strong><em>回收大块堆内存而导致的长时间停顿</em></strong></li>
</ul>
<h3 id="解决方案（单体）："><a href="#解决方案（单体）：" class="headerlink" title="解决方案（单体）："></a>解决方案（单体）：</h3><p><strong><em>程序部署上的主要问题显然是过大的堆内存进行回收时带来的长时间的停顿</em></strong></p>
<ul>
<li><p>将Java堆分配的内存重新缩小到1.5GB或者2GB ，在深夜执行定时任务的方式触发Full GC甚至是自动重启应用服务器来保持内存可用空间在一个稳定的水平。</p>
</li>
<li><p>这样的确可以避免长时间停顿，</p>
</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>在硬件上的投资就显得非常浪费。</li>
</ul>
<h3 id="解决方案（集群）："><a href="#解决方案（集群）：" class="headerlink" title="解决方案（集群）："></a>解决方案（集群）：</h3><ul>
<li>建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了10GB内存。</li>
<li>另外建立一个Apache服务作为前端均衡代理作为访问门户。</li>
<li>考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问，处理器资源敏感度较低，</li>
<li>因此改为CMS收集器进行垃圾回收。</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致I/O异常。</li>
<li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点的连接池已经满了，而另外一些节点仍有较多空余</li>
</ul>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><p><strong><em>控制Full GC频率的关键是老年代的相对稳定</em></strong></p>
<p>这主要取决于应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。</p>
<p>目前单体应用在较大内存的硬件上主要的部署方式有两种：</p>
<ul>
<li>通过一个单独的Java虚拟机实例来管理大量的Java堆内存。</li>
<li>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源。</li>
</ul>
<h2 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h2><h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><p>这是一个学校的小型项目：基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据，系统使用了逆向AJAX技术（也称为Comet或者Server Side Push），选用CometD 1.1.1作为服务端推送框架，服务器是Jetty 7.1.4，硬件为一台很普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统。</p>
<ul>
<li><p>测试期间发现服务端不定时抛出内存溢出异常，服务不一定每次都出现异常</p>
</li>
<li><p>尝试过把堆内存调到最大，32位系统最多到1.6GB基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁</p>
</li>
<li><p>加入-XX：+HeapDumpOnOutOfMemoryError参数，居然也没有任何反应，抛出内存溢出异常时什么文件都没有产生</p>
</li>
<li><p>无奈之下只好挂着jstat紧盯屏幕，发现垃圾收集并不频繁，Eden区、Survivor区、老年代以及方法区的内存全部都很稳定，压力并不大，但就是照样不停抛出内存溢出异常</p>
</li>
<li><p>在内存溢出后从系统日志中找到异常堆栈如代码清单5-1所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 异常堆栈</span><br><span class="line"></span><br><span class="line">[org.eclipse.jetty.util.log] handle failed java.lang.OutOfMemoryError: null</span><br><span class="line">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:99)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)</span><br><span class="line">at org.eclipse.jetty.io.nio.DirectNIOBuffer.&lt;init&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul>
<li>操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位Windows平台的限制是2GB，其中划了1.6GB给Java堆，</li>
<li>而Direct Memory耗用的内存并不算入这1.6GB的堆之内，因此它最大也只能在剩余的0.4GB空间中再分出一部分而已</li>
<li> 直接内存（Direct Memory）空间不足之后，不会主动触发GC ，只能等待老年代满了之后Full GC，顺便帮忙清理 直接内存的废弃对象 </li>
<li>否则就不得不一直等到抛出内存溢出异常时，先捕获到异常，再在Catch块里面通过System.gc()命令来触发垃圾收集</li>
<li>如果Java虚拟机再打开了-XX：+DisableExplicitGC开关，禁止了人工触发垃圾收集的话，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常</li>
</ul>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul>
<li>直接内存：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出OutOf-MemoryError或者OutOfMemoryError：Direct buffer memory。</li>
<li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（如果线程请求的栈深度大于虚拟机所允许的深度）或者OutOfMemoryError</li>
<li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，可能会抛出IOException：Too many open files异常。</li>
<li>JNI代码：如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中，而是占用Java虚拟机的本地方法栈和本地内存的。</li>
<li>虚拟机和垃圾收集器：虚拟机、垃圾收集器的工作也是要消耗一定数量的内存的。</li>
</ul>
<h2 id="外部命令导致系统缓慢："><a href="#外部命令导致系统缓慢：" class="headerlink" title="外部命令导致系统缓慢："></a>外部命令导致系统缓慢：</h2><h3 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h3><p>一个数字校园应用系统，运行在一台四路处理器的Solaris 10操作系统上，中间件为GlassFish服务器。系统在做大并发压力测试的时候，发现请求响应时间比较慢，通过操作系统的mpstat工具发现处理器使用率很高，但是系统中占用绝大多数处理器资源的程序并不是该应用本身。这是个不正常的现象，通常情况下用户应用的处理器占用率应该占主要地位，才能说明系统是在正常工作。</p>
<p>通过Solaris 10的dtrace脚本可以查看当前情况下哪些系统调用花费了最多的处理器资源，dtrace运行后发现最消耗处理器资源的竟然是“fork”系统调用。众所周知，“fork”系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生，这又是个相当不正常的现象。</p>
<p><strong><em>最终找到了答案：</em></strong> </p>
<ul>
<li>每个用户请求的处理都需要执行一个外部Shell脚本来获得系统的一些信息。</li>
<li>执行这个Shell脚本是通过 <strong><em>Java的Runtime.getRuntime().exec()</em></strong> 方法来调用的。</li>
<li>这种调用方式可以达到执行Shell脚本的目的，但是它在Java虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。</li>
<li>Java虚拟机执行这个命令的过程是首先**<em>复制一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程**</em>。</li>
<li>如果频繁执行这个操作，系统的消耗必然会很大，而且不仅是处理器消耗，内存负担也很重。</li>
</ul>
<h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>建议去掉这个Shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快恢复了正常。</p>
<h2 id="服务器虚拟机进程崩溃"><a href="#服务器虚拟机进程崩溃" class="headerlink" title="服务器虚拟机进程崩溃"></a>服务器虚拟机进程崩溃</h2><h3 id="问题：-3"><a href="#问题：-3" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>一个基于B/S的MIS系统，硬件为两台双路处理器、8GB内存的HP系统，服务器是WebLogic9.2</p>
</li>
<li><p>正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid###.log文件后，虚拟机进程就消失了</p>
</li>
<li><p>两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日志中注意到，每个节点的虚拟机进程在崩溃之前，都发生过大量相同的异常，</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//异常堆栈2</span><br><span class="line"></span><br><span class="line">java.net.SocketException: Connection reset</span><br><span class="line">at java.net.SocketInputStream.read(SocketInputStream.java:168)</span><br><span class="line">at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)</span><br><span class="line">at java.io.BufferedInputStream.read(BufferedInputStream.java:235)</span><br><span class="line">at org.apache.axis.transport.http.HTTPSender.readHeadersFromSocket(HTTPSender.java:583)</span><br><span class="line">at org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:143)</span><br><span class="line">... 99 more</span><br></pre></td></tr></table></figure>

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li>这是一个远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的待办事项变化时，要通过Web服务通知OA门户系统，把待办事项的变化同步到OA门户之中。</li>
<li>通过SoapUI测试了一下同步待办事项的几个Web服务，发现调用后竟然需要长达3分钟才能返回，并且返回结果都是超时导致的连接中断。</li>
<li>由于MIS系统的用户多，待办事项变化很快，为了不被OA系统速度拖累，使用了异步的方式调用Web服务</li>
<li>但由于**<em>两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃**</em></li>
</ul>
<h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><p>通知OA门户方修复无法使用的集成接口，并**<em>将异步调用改为生产者/消费者模式的消息队列实现**</em>后，系统恢复正常。</p>
<h2 id="不恰当数据结构导致内存占用过大"><a href="#不恰当数据结构导致内存占用过大" class="headerlink" title="不恰当数据结构导致内存占用过大"></a>不恰当数据结构导致内存占用过大</h2><h3 id="问题：-4"><a href="#问题：-4" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>一个后台RPC服务器，使用64位Java虚拟机，内存配置为-Xms4g-Xmx8g-Xmn1g，使用ParNew加CMS的收集器组合。</p>
</li>
<li><p>平时对外服务的Minor GC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap&lt;Long，Long&gt;Entry，</p>
</li>
<li><p>在这段时间里面Minor GC就会造成超过500毫秒的停顿</p>
</li>
<li><p>，对于这种长度的停顿时间就接受不了了，具体情况如下面的收集器日志所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;Heap before GC invocations=95 (full 4):</span><br><span class="line">par new generation total 903168K, used 803142K [0x00002aaaae770000, 0x00002aaaebb70000, 0x00002aaaebb70000)</span><br><span class="line">eden space 802816K, 100% used [0x00002aaaae770000, 0x00002aaadf770000, 0x00002aaadf770000)</span><br><span class="line">from space 100352K, 0% used [0x00002aaae5970000, 0x00002aaae59c1910, 0x00002aaaebb70000)</span><br><span class="line">to space 100352K, 0% used [0x00002aaadf770000, 0x00002aaadf770000, 0x00002aaae5970000)</span><br><span class="line">concurrent mark-sweep generation total 5845540K, used 3898978K [0x00002aaaebb70000, 0x00002aac507f9000, 0x00002aacae770000)</span><br><span class="line">concurrent-mark-sweep perm gen total 65536K, used 40333K [0x00002aacae770000, 0x00002aacb2770000, 0x00002aacb2770000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2011-10-28T11:40:45.162+0800: 226.504: [GC 226.504: [ParNew: 803142K-&gt; 100352K(903168K), 0.5995670 secs] 4702120K-&gt;Heap after GC invocations=96 (full 4):</span><br><span class="line">par new generation total 903168K, used 100352K [0x00002aaaae770000, 0x00002-aaaebb70000, 0x00002aaaebb70000)</span><br><span class="line">eden space 802816K, 0% used [0x00002aaaae770000, 0x00002aaaae770000, 0x00002aaadf770000)</span><br><span class="line">from space 100352K, 100% used [0x00002aaadf770000, 0x00002aaae5970000, 0x00002aaae5970000)</span><br><span class="line">to space 100352K, 0% used [0x00002aaae5970000, 0x00002aaae5970000, 0x00002aaaebb70000)</span><br><span class="line">concurrent mark-sweep generation total 5845540K, used 3955980K [0x00002aaaebb70000, 0x00002aac507f9000, 0x00002aacae770000)</span><br><span class="line">concurrent-mark-sweep perm gen total 65536K, used 40333K [0x00002aacae770000, 0x00002aacb2770000, 0x00002aacb2770000)</span><br><span class="line">&#125;T</span><br><span class="line">otal time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 0.6070570 seconds</span><br></pre></td></tr></table></figure>



<h3 id="分析-："><a href="#分析-：" class="headerlink" title="分析 ："></a>分析 ：</h3><ul>
<li>观察这个案例的日志，平时Minor GC时间很短，原因是新生代的绝大部分对象都是可清除的，在Minor GC之后Eden和Survivor基本上处于完全空闲的状态。</li>
<li>但是在分析数据文件期间，800MB的Eden空间很快被填满引发垃圾收集</li>
<li>但Minor GC之后，新生代中绝大部分对象依然是存活的</li>
<li>ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，</li>
<li>如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确性就成为一个沉重的负担，因此导致垃圾收集的暂停时间明显变长。</li>
</ul>
<h3 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h3><p>如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑直接将Survivor空间去掉（加入参数-XX：SurvivorRatio=65536、</p>
<p>-XX ：MaxTenuringThreshold=0或者-XX：+Always-Tenure），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再去清理它们。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>这种措施可以治标，但也有很大副作用</p>
<h3 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h3><p>治本的方案必须要修改程序，因为这里产生问题的根本原因是用HashMap&lt;Long，Long&gt;结构来存储数据文件空间效率太低了。</p>
<ul>
<li>我们具体分析一下HashMap空间效率，在HashMap&lt;Long，Long&gt;结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16字节（2×8字节）。</li>
<li>这两个长整型数据包装成java.lang.Long对象之后，就分别具有8字节的Mark Word、8字节的Klass指针，再加8字节存储数据的long值。</li>
<li>然后这2个Long对象组成Map.Entry之后，又多了16字节的对象头，然后一个8字节的next字段和4字节的int型的hash字段，为了对齐，还必须添加4字节的空白填充，</li>
<li>最后还有HashMap中对这个Entry的8字节的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24byte)×2)+Entry(32byte)+HashMapRef(8byte)=88byte，空间效率为有效数据除以全部内存空间，即16字节/88字节=18%，这确实太低了。</li>
</ul>
<ul>
<li>如果是写入数据库，是否可以采用 ，边读边写，200条commit 一次</li>
</ul>
<h2 id="由安全点导致长时间停顿"><a href="#由安全点导致长时间停顿" class="headerlink" title="　由安全点导致长时间停顿"></a>　由安全点导致长时间停顿</h2><h3 id="问题：-5"><a href="#问题：-5" class="headerlink" title="问题："></a>问题：</h3><p>有一个比较大的承担公共计算任务的离线HBase集群，运行在JDK 8上，使用G1收集器。每天都有大量的MapReduce或Spark离线分析任务对其进行访问，同时有很多其他在线集群Replication过来的数据写入，因为集群读写压力较大，而离线分析任务对延迟又不会特别敏感，所以将-XX：MaxGCPauseMillis参数设置到了500毫秒。</p>
<ul>
<li><p>不过运行一段时间后发现垃圾收集的停顿经常达到3秒以上，</p>
</li>
<li><p>而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒，现象如以下日志所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Times: user=1.51 sys=0.67, real=0.14 secs]</span><br><span class="line">2019-06-25T 12:12:43.376+0800: 3448319.277: Total time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 2.2645818</span><br></pre></td></tr></table></figure>



<h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>在垃圾收集调优时，我们主要依据real时间为目标来优化程序，因为最终用户只关心发出请求到得到响应所花费的时间，也就是响应速度，而不太关心程序到底使用了多少个线程或者处理器来完成任务。</p>
<p>日志显示这次垃圾收集一共花费了0.14秒，但其中用户线程却足足停顿了有2.26秒，两者差距已经远远超出了正常的TTSP（Time To Safepoint）耗时的范畴。</p>
<ul>
<li>所以先加入参数-XX：+PrintSafepointStatistics和-XX：PrintSafepointStatisticsCount=1去查看安全点日志，具体如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmop [threads: total initially_running wait_to_block]</span><br><span class="line">65968.203: ForceAsyncSafepoint [931 1 2]</span><br><span class="line">[time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line">[2255 0 2255 11 0] 1</span><br></pre></td></tr></table></figure>

<ul>
<li>日志显示当前虚拟机的操作（VM Operation，VMOP）是等待所有用户线程进入到安全点，</li>
<li>但是有两个线程特别慢，导致发生了很长时间的自旋等待。</li>
<li>日志中的2255毫秒自旋（Spin）时间就是指由于部分线程已经走到了安全点，但还有一些特别慢的线程并没有到，</li>
<li>所以垃圾收集线程无法开始工作，只能空转（自旋）等待。</li>
</ul>
<ul>
<li>解决问题的第一步是把这两个特别慢的线程给找出来，这个倒不困难，添加-XX：+SafepointTimeout和-XX：SafepointTimeoutDelay=2000两个参数，</li>
<li>让虚拟机在等到线程进入安全点的时间超过2000毫秒时就认定为超时，这样就会输出导致问题的线程名称，得到的日志如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SafepointSynchronize::begin: Timeout detected:</span></span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: Timed out while spinning to reach a safepoint.</span></span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: Threads which did not reach the safepoint:</span></span><br><span class="line"><span class="comment"># &quot;RpcServer.listener,port=24600&quot; #32 daemon prio=5 os_prio=0 tid=0x00007f4c14b22840</span></span><br><span class="line">nid=0xa621 runnable [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: (End of list)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从错误日志中顺利得到了导致问题的线程名称为“RpcServer.listener，port=24600”</li>
<li>有什么因素可以阻止线程进入安全点？</li>
<li>安全点是以“是否具有让程序长时间执行的特征”为原则进行选定的，</li>
<li>所以方法调用、循环跳转、异常跳转这些位置都可能会设置有安全点，</li>
<li>但是HotSpot虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用int类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环（CountedLoop），相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为不可数循环（Uncounted Loop），将会被放置安全点。</li>
<li>通常情况下这个优化措施是可行的，但循环执行的时间不单单是由其次数决定，如果循环体单次执行就特别慢，那即使是可数循环也可能会耗费很多的时间。</li>
</ul>
<h3 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h3><p>最终查明导致这个问题是HBase中一个连接超时清理的函数，由于集群会有多个MapReduce或Spark任务进行访问，而每个任务又会同时起多个Mapper/Reducer/Executer，其每一个都会作为一个HBase的客户端，这就导致了同时连接的数量会非常多。更为关键的是，清理连接的索引值就是int类型，所以这是一个可数循环，HotSpot不会在循环中插入安全点。当垃圾收集发生时，如果RpcServer的Listener线程刚好执行到该函数里的可数循环时，则必须等待循环全部跑完才能进入安全点，此时其他线程也必须一起等着，所以从现象上看就是长时间的停顿。找到了问题，解决起来就非常简单了，</p>
<p><strong><em>把循环索引的数据类型从int改为long即可，</em></strong></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>调优案例分析与实战</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-07-字节码指令简介</title>
    <url>/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h1><ul>
<li>Java虚拟机的指令 由一个字节长度的，代表着某种特定操作含义的数字（称为操作码，<strong>Opcode</strong>） 以及零至多个代表操作所需参数（称为操作数，<strong>Operand</strong>）构成。</li>
<li>由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码Opcode，指令参数Operand都存放在操作数栈中</li>
<li>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构</li>
<li>由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条</li>
<li>又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构</li>
<li>这种操作在某种程度上会导致解释执行字节码时将损失一些性能，但这样做的优势也同样明显：</li>
<li><ul>
<li>放弃了操作数长度对齐[1]，就意味着可以省略掉大量的填充和间隔符号；</li>
<li>用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">JVM解释器 最基本执行模型伪代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	自动计算PC寄存器的值+1；</span><br><span class="line">	根据PC寄存器指示的位置，从字节码流中取出操作码；</span><br><span class="line">	<span class="keyword">if</span>(字节码存在操作数)&#123;</span><br><span class="line">		从字节码流中取出操作数；</span><br><span class="line">	&#125;</span><br><span class="line">	执行操作码所定义的操作；</span><br><span class="line">&#125;<span class="keyword">while</span>（字节码流长度&gt;0）</span><br></pre></td></tr></table></figure>



<h2 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h2><h3 id="字节码指令："><a href="#字节码指令：" class="headerlink" title="字节码指令："></a>字节码指令：</h3><ul>
<li>在Java虚拟机的指令集中，<strong>大多数</strong>指令都包含<strong>其操作所对应的数据类型信息</strong>。举个例子，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据</li>
<li>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference</li>
<li>也有一些指令的助记符中<strong>没有明确指明操作类型的字母</strong>，例如arraylength指令，它没有代表数据类型的特殊字符</li>
<li>还有另外一些指令，例如无条件跳转指令goto则是<strong>与数据类型无关的指令</strong></li>
<li>因为Java虚拟机的<strong>操作码长度只有一字节</strong>，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力</li>
<li>如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么指令的数量恐怕就会超出一字节所能表示的数量范围了</li>
<li>因此，Java虚拟机的指令集<strong>对于特定的操作只提供了有限的类型相关指令去支持它</strong></li>
<li>换句话说，指令集将会被故意设计成非完全独立的（<strong>Not Orthogonal</strong>）</li>
</ul>
<ul>
<li>表6-40列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。</li>
<li>如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。</li>
<li>例如load指令有操作int类型的iload，但是没有操作byte类型的同类指令。</li>
</ul>
<p><img src="/uploads/jvm/07ByteOpCond/01-opcode-01.png"></p>
<p><img src="/uploads/jvm/07ByteOpCond/02-opcode-02.png"></p>
<h3 id="总结上图指令集："><a href="#总结上图指令集：" class="headerlink" title="总结上图指令集："></a>总结上图指令集：</h3><p>从表6-40中看来，</p>
<ul>
<li><p>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。</p>
</li>
<li><p>编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，</p>
</li>
<li><p>将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。</p>
</li>
<li><p>与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p>
</li>
<li><p>因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</p>
</li>
<li><p>阅读字节码作为了解Java虚拟机的基础技能，是一项应当熟练掌握的能力。</p>
</li>
</ul>
<h3 id="字节码操作按用途分类："><a href="#字节码操作按用途分类：" class="headerlink" title="字节码操作按用途分类："></a>字节码操作按用途分类：</h3><p>笔者将字节码操作按用途大致分为9类，下面按照分类来为读者概略介绍这些指令的用法。</p>
<h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之间来回传输，这类指令包括：</p>
<ul>
<li>将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n></li>
<li>将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n></li>
<li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></li>
<li>扩充局部变量表的访问索引的指令：wide</li>
</ul>
<p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>），这些指令助记符实际上代表了一组指令（例如iload_<n>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。</p>
<p>这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p>
<p>除了这点不同以外，它们的语义与原生的通用指令是完全一致的（例如iload_0的语义与操作数为0时的iload指令语义完全一致</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// Java源码</span><br><span class="line">public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">    int x;</span><br><span class="line">    try &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">    	<span class="built_in">return</span> x;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    	x = 2;</span><br><span class="line">   	 	<span class="built_in">return</span> x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	x = 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后的ByteCode字节码及异常表</span><br><span class="line">public int inc();</span><br><span class="line">    Code:</span><br><span class="line">        Stack=1, Locals=5, Args_size=1</span><br><span class="line">            0: iconst_1 // try块中的x=1  (将常量1加载到操作数栈)</span><br><span class="line">            1: istore_1  //（将1 从操作数栈存储到局部变量表）</span><br><span class="line">            2: iload_1 // 保存x到returnValue中，此时x=1  （将局部变量 加载到操作数栈）</span><br><span class="line">            3: istore   4  将操作数栈 存储到局部变量表</span><br><span class="line">            5: iconst_3 // finaly块中的x=3</span><br><span class="line">            6: istore_1</span><br><span class="line">            7: iload     4 // 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            9: ireturn</span><br><span class="line">            10: astore_2 // 给catch中定义的Exception e赋值，存储在变量槽 2中</span><br><span class="line">            11: iconst_2 // catch块中的x=2</span><br><span class="line">            12: istore_1</span><br><span class="line">            13: iload_1 // 保存x到returnValue中，此时x=2</span><br><span class="line">            14: istore    4</span><br><span class="line">            16: iconst_3 // finaly块中的x=3</span><br><span class="line">            17: istore_1</span><br><span class="line">            18: iload      4 // 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            20: ireturn</span><br><span class="line">            21: astore_3 // 如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</span><br><span class="line">            22: iconst_3 // finaly块中的x=3</span><br><span class="line">            23: istore_1</span><br><span class="line">            24: aload_3 // 将异常放置到栈顶，并抛出</span><br><span class="line">            25: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">    from to target <span class="built_in">type</span></span><br><span class="line">        0 5 10 Class java/lang/Exception</span><br><span class="line">        0 5 21 any</span><br><span class="line">        10 16 21 any</span><br></pre></td></tr></table></figure>



<h4 id="运算指令："><a href="#运算指令：" class="headerlink" title="运算指令："></a>运算指令：</h4><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<p>大体上运算指令可以分为两种：</p>
<ul>
<li>对整型数据进行运算的指令</li>
<li>对浮点型数据进行运算的指令</li>
</ul>
<ol>
<li>整数与浮点数的算术指令在<strong>溢出</strong> 和<strong>被零除</strong>的时候也有各自不同的行为表现 </li>
<li>无论是哪种算术指令，均是使用Java虚拟机的算术类型来进行计算的，</li>
<li>换句话说是不存在直接支持byte、short、char和boolean类型的算术指令，</li>
</ol>
<h5 id="int-指令："><a href="#int-指令：" class="headerlink" title="int 指令："></a>int 指令：</h5><p>对于上述几种数据的运算，应使用操作int类型的指令代替。所有的算术指令包括：</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem</li>
<li>取反指令：ineg、lneg、fneg、dneg</li>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
<li>局部变量自增指令：iinc</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li>
</ul>
<h5 id="运算溢出问题："><a href="#运算溢出问题：" class="headerlink" title="运算溢出问题："></a>运算溢出问题：</h5><ul>
<li>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象，对于程序员来说是很容易理解的，</li>
<li>但其实《Java虚拟机规范》中并没有明确定义过整型数据溢出具体会得到什么计算结果，仅规定了在处理整型数据时，</li>
<li>只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，</li>
<li>其余任何整型数运算场景都不应该抛出运行时异常</li>
</ul>
<h5 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题:"></a>浮点数精度问题:</h5><ul>
<li>《Java虚拟机规范》要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754规范中所规定行为和限制，也就是说Java虚拟机必须完全支持IEEE 754中定义的“非正规浮点数值”（DenormalizedFloating-Point Number）和“逐级下溢”（Gradual Underflow）的运算规则。这些规则将会使某些数值算法处理起来变得明确，不会出现模棱两可的困境</li>
<li>以上规则要求Java虚拟机在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值；</li>
<li>如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的</li>
<li>这种舍入模式也是IEEE 754规范中的默认舍入模式，称为向最接近数舍入模式</li>
<li>而在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近，但是不大于原值的数字来作为最精确的舍入结果。</li>
<li>Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一种运算信号），</li>
<li>当一个操作产生溢出时，将会使用有符号的无穷大来表示；</li>
<li>如果某个操作结果没有明确的数学定义的话，将会使用NaN（Not a Number）值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</li>
</ul>
<h5 id="long类型与浮点数值比较原则："><a href="#long类型与浮点数值比较原则：" class="headerlink" title="long类型与浮点数值比较原则："></a>long类型与浮点数值比较原则：</h5><ul>
<li><p>在对long类型数值进行比较时，Java虚拟机采用带符号的比较方式，</p>
</li>
<li><p>而对浮点数值进行比较时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（NonsignalingComparison）方式进行。</p>
</li>
</ul>
<h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<h5 id="宽化类型转换（WideningNumeric-Conversion）"><a href="#宽化类型转换（WideningNumeric-Conversion）" class="headerlink" title="宽化类型转换（WideningNumeric Conversion）"></a>宽化类型转换（WideningNumeric Conversion）</h5><p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（WideningNumeric Conversion，即小范围类型向大范围类型的安全转换）：</p>
<ul>
<li>int类型到long、float或者double类型</li>
<li>long类型到float、double类型</li>
<li>float类型到double类型</li>
</ul>
<h5 id="窄化类型转换（Narrowing-Numeric-Conversion）"><a href="#窄化类型转换（Narrowing-Numeric-Conversion）" class="headerlink" title="窄化类型转换（Narrowing Numeric Conversion）"></a>窄化类型转换（Narrowing Numeric Conversion）</h5><p>处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。</p>
<p>窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p>
<ul>
<li>在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。对于了解计算机数值存储和表示的程序员来说这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N字节的首位了。</li>
</ul>
<h6 id="浮点型转整形（int、long）"><a href="#浮点型转整形（int、long）" class="headerlink" title="浮点型转整形（int、long）"></a>浮点型转整形（int、long）</h6><p>Java虚拟机将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，必须遵循以下转换规则：</p>
<ul>
<li>如果浮点值是NaN，那转换结果就是int或long类型的0。</li>
<li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在目标类型T（int或long）的表示范围之类，那转换结果就是v；</li>
<li>否则，将根据v的符号，转换为T所能表示的最大或者最小正数。</li>
</ul>
<h6 id="Double转float"><a href="#Double转float" class="headerlink" title="Double转float"></a>Double转float</h6><ul>
<li>从double类型到float类型做窄化转换的过程与IEEE 754中定义的一致，通过IEEE 754向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。</li>
<li>如果转换结果的绝对值太小、无法使用float来表示的话，将返回float类型的正负零；</li>
<li>如果转换结果的绝对值太大、无法使用float来表示的话，将返回float类型的正负无穷大。</li>
<li>对于double类型的NaN值将按规定转换为float类型的NaN值。</li>
</ul>
<h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。</p>
<p>对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p>
<ul>
<li>创建类实例的指令：new</li>
<li>创建数组的指令：newarray、anewarray、multianewarray</li>
<li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore</li>
<li>取数组长度的指令：arraylength</li>
<li>检查类实例类型的指令：instanceof、checkcast</li>
</ul>
<h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li>
<li>将栈最顶端的两个数值互换：swap</li>
</ul>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，</p>
<p>从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。</p>
<p>控制转移指令包括：</p>
<ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li>
<li>复合条件分支：tableswitch、lookupswitch</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li>
</ul>
<p>在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否null，也有专门的指令用来检测null值。</p>
<ul>
<li>对于boolean类型、byte类型、char类型和short类型的条件分支比较操作，都使用int类型的比较指令来完成</li>
<li>对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，），运算<br>指令会**<em>返回一个整型值**</em>到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。</li>
<li>由于**<em>各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便、完善就显得尤为重要，而Java虚拟机提供的**</em>int类型的条件分支指令是最为丰富、强大的。</li>
</ul>
<h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4><p>方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下五条指令用于方法调用：</p>
<ul>
<li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li>
<li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li>
<li>invokestatic指令：用于调用类静态方法（static方法）。</li>
<li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法</li>
</ul>
<p>前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</p>
<ul>
<li>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的</li>
<li>包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。</li>
</ul>
<h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，</p>
<p>《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成。</p>
<h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p>
<h5 id="方法级同步："><a href="#方法级同步：" class="headerlink" title="方法级同步："></a>方法级同步：</h5><ul>
<li>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。</li>
<li>虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。</li>
<li>当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，<ul>
<li>如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。</li>
</ul>
</li>
<li>在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。<ul>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</li>
</ul>
</li>
</ul>
<h5 id="方法内指令级同步："><a href="#方法内指令级同步：" class="headerlink" title="方法内指令级同步："></a>方法内指令级同步：</h5><ul>
<li>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，</li>
<li>Java虚拟机的指令集中有 <strong><em>monitorenter</em></strong> 和 <strong><em>monitorexit</em></strong> 两条指令来支持synchronized关键字的语义，</li>
<li>正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，</li>
<li>譬如有代码清单6-6所示的代码。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 代码清单6-6　代码同步演示</span><br><span class="line"></span><br><span class="line">void onlyMe(Foo f) &#123;</span><br><span class="line">    synchronized(f) &#123;</span><br><span class="line">    	doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译后，这段代码生成的字节码序列如下：</span><br><span class="line">Method void onlyMe(Foo)</span><br><span class="line">0 aload_1          // 将对象f入栈</span><br><span class="line">1 dup 　　          // 复制栈顶元素（即f的引用）</span><br><span class="line">2 astore_2         // 将栈顶元素存储到局部变量表变量槽 2中</span><br><span class="line">3 monitorenter     // 以栈定元素（即f）作为锁，开始同步</span><br><span class="line">4 aload_0          // 将局部变量槽 0（即this指针）的元素入栈</span><br><span class="line">5 invokevirtual <span class="comment">#5 // 调用doSomething()方法</span></span><br><span class="line">8 aload_2           // 将局部变量Slow 2的元素（即f）入栈</span><br><span class="line">9 monitorexit       // 退出同步</span><br><span class="line">10 goto 18          // 方法正常结束，跳转到18返回</span><br><span class="line">13 astore_3         // 从这步开始是异常路径，见下面异常表的Taget 13</span><br><span class="line">14 aload_2          // 将局部变量Slow 2的元素（即f）入栈</span><br><span class="line">15 monitorexit      // 退出同步</span><br><span class="line">16 aload_3          // 将局部变量Slow 3的元素（即异常对象）入栈</span><br><span class="line">17 athrow 			// 把异常对象重新抛出给onlyMe()方法的调用者</span><br><span class="line">18 <span class="built_in">return</span> 			// 方法正常返回</span><br><span class="line">Exception table:</span><br><span class="line">FromTo Target Type</span><br><span class="line">4 10 13 any</span><br><span class="line">13 16 13 any</span><br></pre></td></tr></table></figure>



<ul>
<li>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</li>
<li>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</li>
</ul>
<h3 id="公有设计，私有实现"><a href="#公有设计，私有实现" class="headerlink" title="公有设计，私有实现"></a>公有设计，私有实现</h3><p>《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：<strong>Class文件格式</strong>以及 <strong>字节码指令集</strong></p>
<p>任何一款Java虚拟机实现都必须能够**<em>读取Class文件并精确实现**</em>包含在其中的Java虚拟机代码的语义。拿着《Java虚拟机规范》一成不变地逐字实现其中要求的内容当然是一种可行的途径，</p>
<p>但一个优秀的虚拟机实现，在满足《Java虚拟机规范》的约束下对具体实现做出修改和优化也是完全可行的，</p>
<p>并且《Java虚拟机规范》中明确鼓励实现者这样去做。只要优化以后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整保持，那实现者就可以选择以任何方式去实现这些语义，</p>
<p>虚拟机在后台如何处理Class文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可[1]。</p>
<p>虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么，虚拟机实现的方式主要有以下两种：</p>
<ul>
<li>将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集；</li>
<li>将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即即时编译器代码生成技术）。</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>字节码指令简介</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-09-类加载器</title>
    <url>/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>Java虚拟机设计团队 有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流” 这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 “<strong>类加载器</strong>”（Class Loader）。</p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><ul>
<li>类加载器虽然只用于实现类的加载，但它在Java程序中起到的作用却<strong>远超类加载阶段</strong>。</li>
<li>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的<strong>唯一性</strong>，<strong>每一个类加载器都拥有一个独立的类名称空间</strong>。</li>
<li>比较2个类是否“<strong>相等</strong>”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这2个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这2个类就必定不相等。</li>
<li>这里所说的“相等”，包括了类的Class对象的 equals() 、isAssignableFrom()、 isInstance()方法的返回结果，也包括了使用instanceof 关键字做对象所属关系判断等 各种情况。</li>
<li>下面代码演示了不同的类加载器对instanceof关键字运算的结果的影响</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;org.fenixsoft.jvm.chapter7.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.jvm.chapter7.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter7</span>.<span class="title">ClassLoaderTest</span></span></span><br><span class="line"><span class="class">	<span class="title">false</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码构造了一个简单的类加载器，它可以加载与自己在同意路径下的Class 文件，我们使用这个类加载器去加载了一个名为 “ class org.fenixsoft.jvm.chapter7.ClassLoaderTest” 的类，并实例化了这个类的对象。</li>
<li>todo： 看一下类加载器的源码，如：loadClass（）、defineClass（）等</li>
<li>两行输出结果中，从第一行可以看到这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化出来的，但在第二行的输出中却发现这个对象与类org.fenixsoft.classloading.ClassLoaderTest做所属类型检查的时候返回了false。 </li>
<li> 因为Java虚拟机中同时存在两个 ClassLoaderTest 类，一个是由虚拟机的应用程序类加载器所加载的， 另一个是我们自定义的类加载器加载的，虽然他们都来自于同一个Class文件，但在JVM中仍然是两个互相独立的类，做对象所属类型检查时的结果自然为false。</li>
</ul>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>站在Java 虚拟机的角度来看，只存在2种不同的类加载器：</p>
<ul>
<li> 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器由C++ 语言实现，是虚拟机自身的一部分</li>
<li>另一种就是其他所有的类加载器，这些类加载器都有Java语言实现，独立存在虚拟机外部，全部继承自抽象类 java.lang.ClassLoader</li>
</ul>
<p>站在Java开发人员的角度来看，类加载器应当划分的更细致一些，从JDK1.2以来，Java一直保持 3层类加载器、双亲委派的 类加载架构。</p>
<p>3层类加载器：</p>
<h3 id="启动类加载器（Bootstrap-ClassLoader）："><a href="#启动类加载器（Bootstrap-ClassLoader）：" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）："></a>启动类加载器（Bootstrap ClassLoader）：</h3><ul>
<li>负责加载存放在%JAVA_HOME%\lib 目录，或者被 -Xbootclasspath 参数所指定的路径存放的，而且是Java虚拟机能够识别的（PS：java虚拟机识别是按照文件名识别的，如rt.jar,  tool.jar ，名字不符合类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li>
<li>启动类加载器无法被java程序直接引用，用户在编写自定义的ClassLoader 时，如果需要把加载请求委派给  启动类加载器 去处理，直接使用<strong>null</strong> 代替即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the class loader for the class.  Some implementations may use </span></span><br><span class="line"><span class="comment">    * null to represent the bootstrap class loader. This method will return</span></span><br><span class="line"><span class="comment">    * null in such implementations if this class was loaded by the bootstrap</span></span><br><span class="line"><span class="comment">    * class loader.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; If a security manager is present, and the caller&#x27;s class loader is</span></span><br><span class="line"><span class="comment">    * not null and the caller&#x27;s class loader is not the same as or an ancestor of</span></span><br><span class="line"><span class="comment">    * the class loader for the class whose class loader is requested, then</span></span><br><span class="line"><span class="comment">    * this method calls the security manager&#x27;s &#123;<span class="doctag">@code</span> checkPermission&#125;</span></span><br><span class="line"><span class="comment">    * method with a &#123;<span class="doctag">@code</span> RuntimePermission(&quot;getClassLoader&quot;)&#125;</span></span><br><span class="line"><span class="comment">    * permission to ensure it&#x27;s ok to access the class loader for the class.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this object</span></span><br><span class="line"><span class="comment">    * represents a primitive type or void, null is returned.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the class loader that loaded the class or interface</span></span><br><span class="line"><span class="comment">    *          represented by this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">    *    if a security manager exists and its</span></span><br><span class="line"><span class="comment">    *    &#123;<span class="doctag">@code</span> checkPermission&#125; method denies</span></span><br><span class="line"><span class="comment">    *    access to the class loader for the class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.ClassLoader</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ClassLoader cl = getClassLoader0();</span><br><span class="line">       <span class="keyword">if</span> (cl == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Returns the class loader for the class.  Some implementations may use     <strong>null to represent the bootstrap class loader.</strong> </p>
<p>This method will <strong>return  null in</strong> such implementations if this class was <strong>loaded by the bootstrap  class loader</strong>.</p>
<h3 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h3><ul>
<li><p>这个类加载器时在类 sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。</p>
</li>
<li><p>它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
</li>
<li><p>根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代</p>
</li>
<li><p>由于扩展类加载器是由 Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载 Class文件</p>
</li>
</ul>
<h3 id="应用程序类加载器（Application-Class-Loader）"><a href="#应用程序类加载器（Application-Class-Loader）" class="headerlink" title="应用程序类加载器（Application Class Loader）"></a>应用程序类加载器（Application Class Loader）</h3><ul>
<li>这个类加载器由sun.misc.Launcher$AppClassLoader来实现</li>
<li>由于应用程序类加载器是ClassLoader类中的getSystem- ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。</li>
<li>它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li>
<li>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h3 id="类加载器双亲委派模型"><a href="#类加载器双亲委派模型" class="headerlink" title="类加载器双亲委派模型"></a>类加载器双亲委派模型</h3><p><strong>图7-2　类加载器双亲委派模型</strong></p>
<pre class="mermaid">classDiagram
BootstrapClassLoader <-- ExtensionClassLoader : 父亲
ExtensionClassLoader <-- ApplicationClassLoader : 父亲
ApplicationClassLoader <-- Custom_ClassLoader1 : 父亲
ApplicationClassLoader <-- Custom_ClassLoader2 : 父亲</pre>

<ul>
<li><p>图7-2中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents DelegationModel）”。</p>
</li>
<li><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
</li>
<li><p>不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
</li>
<li><p>类加载器的双亲委派模型在JDK 1.2时期被引入，并被广泛应用于此后几乎所有的Java程序中，但它并不是一个具有强制性约束力的模型，而是Java设计者们推荐给开发者的一种类加载器实现的最佳实践。</p>
</li>
</ul>
<h4 id="双亲委派工作过程"><a href="#双亲委派工作过程" class="headerlink" title="双亲委派工作过程"></a>双亲委派工作过程</h4><ul>
<li>如果一个ClassLoader 收到了 类加载的请求，</li>
<li>它首先不会自己去尝试加载这个类，而是把这个请求委派给 <strong>父类加载器</strong> 去完成，每一个层次的类加载器都是如此，</li>
<li>因此所有的加载请求最终都应该送到最顶层的启动类加载器中，</li>
<li>只有当 父类加载器 反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去完成加载。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li>Java中类随着它的类加载器一起具有了一种带有优先级的层次关系。</li>
<li>例如：类java.lang.Object ，它存放在rt.jar 中，无论哪一个类加载要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器 环境中都能保证时同一个类。</li>
<li>反之 如果没有使用双亲委派模型，都有各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现 多个不同的Object类，Java类型体系中最基础的行为也就无从保证。</li>
</ul>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">	<span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 在父类加载器无法加载时</span></span><br><span class="line">	<span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑清晰易懂：</p>
<ul>
<li><p>先检查请求加载的类型是否已经被加载过，</p>
<ul>
<li><p>若没有则调用父加载器的loadClass()方法，</p>
</li>
<li><p>若父加载器为空则默认使用启动类加载器作为父加载器。</p>
</li>
</ul>
</li>
<li><p>假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
</li>
</ul>
<h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<h3 id="第一次破坏双亲委派"><a href="#第一次破坏双亲委派" class="headerlink" title="第一次破坏双亲委派"></a>第一次破坏双亲委派</h3><ul>
<li>第一次 “被破坏”其实发生在<strong>双亲委派模型出现之前</strong>——即JDK 1.2面世以前的“远古”时代。</li>
<li>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了<strong>兼容这些已有代码</strong>，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个<strong>新的protected方法findClass()**，并</strong>引导用户编写的类加载逻辑时尽可能去重写这个方法**，而不是在loadClass()中编写代码。</li>
<li>我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</li>
</ul>
<h3 id="第二次破坏双亲委派"><a href="#第二次破坏双亲委派" class="headerlink" title="第二次破坏双亲委派"></a>第二次破坏双亲委派</h3><ul>
<li>第二次“被破坏”是由这个模型自身的缺陷导致的，</li>
<li>双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，</li>
<li>但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</li>
<li>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</li>
<li>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内<br>都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>
<li>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种<strong>父类加载器去请求子类加载器完成类加载</strong>的行为，这种行为实际上是打通了双亲委派模型的层次结构来<strong>逆向使用类加载器</strong>，已经<strong>违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了<strong>java.util.ServiceLoader类</strong>，以<strong>META-INF/services</strong>中的配置信息，<strong>辅以责任链模式</strong>，这才算是给SPI的加载提供了一种相对合理的解决方案。</li>
</ul>
<h3 id="第三次破坏双亲委派"><a href="#第三次破坏双亲委派" class="headerlink" title="第三次破坏双亲委派"></a>第三次破坏双亲委派</h3><ul>
<li>第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：<strong>代码热替换</strong>（<strong>Hot Swap</strong>）、<strong>模块热部署</strong>（<strong>Hot Deployment</strong>）等。</li>
<li>说白了就是希望Java应用程序能像我们的电脑外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用关机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是大型系统或企业级软件开发者具有很大的吸引力。</li>
</ul>
<h3 id="OSGi实现热部署原理"><a href="#OSGi实现热部署原理" class="headerlink" title="OSGi实现热部署原理"></a>OSGi实现热部署原理</h3><p>OSGi实现模块化热部署的关键是它<strong>自定义的类加载器机制</strong>的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把<strong>Bundle连同类加载器一起换掉</strong>以实现代码的热替换。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以java.*开头的类，委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>上面的查找顺序中只有<strong>开头两点仍然符合双亲委派模型</strong>的原则，其余的类查找都是在<strong>平级的类加载器</strong>中进行的。</p>
<p>虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。</p>
<p><strong>只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新</strong>。</p>
<p>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之禅-08-代理模式</title>
    <url>/2020/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-08-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Provide a surrogate or placeholder for another object to control access to it (为其他对象提供一种代理以控制对这个对象的访问)</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="/uploads/design_patterns/08proxy/proxy01.png"></p>
<ul>
<li><p>代理模式也叫委托模式，他是一项基本设计技巧。 其他的很多模式都是在更特殊的场合下采用 委托模式</p>
</li>
<li><p>Subject 抽象主题角色</p>
<p>抽象主题类可以是抽象类，也可以是接口，是一个最普通的业务类型定义，没有特殊要求</p>
</li>
<li><p>RealSubject 具体主题角色</p>
<p>也叫 ： 被委托角色、被代理角色。是 业务逻辑的具体执行者</p>
</li>
<li><p>Proxy 代理主题角色</p>
<p>也叫做 委托类、代理类。它负责对真是角色的应用，把所有抽象主题类定义的方法限制委托给 真实主题角色卡实现， </p>
<p>并且在真实主题角色处理完毕 前后做预处理 以及善后处理 工作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码清单12-6 抽象主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码清单12-7 真实主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务逻辑处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码清单12-8 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要代理哪个实现类</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//默认被代理者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	 <span class="keyword">this</span>.subject = <span class="keyword">new</span> Proxy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过构造函数传递代理者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Object...objects )</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现接口中定义的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.before();</span><br><span class="line">        <span class="keyword">this</span>.subject.request();</span><br><span class="line">        <span class="keyword">this</span>.after();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	 <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//善后处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>一个代理类可以代理多个 被委托者，因此 一个代理类具体代理 哪个真实主题角色，是由场景类决定的。 </li>
<li>当然最简单的情况就是 一个主题类和一个代理类。  </li>
<li> 一个接口只需要一个代理类即可，具体代理哪个实现类 ，则由高层模块来决定，也就是在代理类的构造函数中 传递被代理者。</li>
</ul>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>职责清晰</p>
<p>真实的角色 只是去实现实际的业务逻辑，不用去关心其非本职责的事务， 通过后期的代理 完成一件事务，附带的结果就是code 简洁清晰</p>
</li>
<li><p>高扩展性</p>
<p>具体主题角色是随时都会发生变化的，只要它实现了接口 。而代理类不需要修改，因为真正的实现是 具体实现类做的。代理类只是增强 </p>
</li>
<li><p>智能化</p>
</li>
</ul>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>Spring Aop 动态代理</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="普通扩展"><a href="#普通扩展" class="headerlink" title="普通扩展"></a>普通扩展</h5><p><img src="/uploads/design_patterns/08proxy/normalProxy.png"></p>
<p>GamePlayer 的构造函数增加了 _gamePlayer参数，而代理角色只需要传入代理者 名字即可，而不需要说是替代哪个对象做代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码清单12-10 普通代理的游戏者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//构造函数限制谁能创建对象，并同时传递姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(IGamePlayer _gamePlayer,String _name)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_gamePlayer == <span class="keyword">null</span> )&#123;</span><br><span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;不能创建真实角色！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   	 	<span class="keyword">this</span>.name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打怪，最期望的就是杀老怪</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;在打怪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进游戏之前你肯定要登录吧，这是一个必要条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;登录名为&quot;</span>+user + <span class="string">&quot;的用户&quot;</span> + <span class="keyword">this</span>.name + <span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//升级，升级有很多方法，花钱买是一种，做任务也是一种</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; 又升了一级！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码清单12-11 普通代理的代理者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过构造函数传递要对谁进行代练</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	gamePlayer = <span class="keyword">new</span> GamePlayer(<span class="keyword">this</span>,name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// TODO 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练杀怪</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.gamePlayer.killBoss();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练登录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">   	 	<span class="keyword">this</span>.gamePlayer.login(user, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练升级</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.gamePlayer.upgrade();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在该模式下，调用者只知道代理 而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色可以任意修改，对高层模块没有任何影响。</p>
<p>该模式非常适合对扩展性要求较高的场合。  </p>
<p>在真实项目中，一般都是通过约定来 禁止new 一个真实的角色。这里GamePlayer的构造函数要求，必须传入一个 GamePlayerProxy</p>
<h5 id="强制代理"><a href="#强制代理" class="headerlink" title="强制代理"></a>强制代理</h5><p>必须通过真实角色查找代理角色，否则不能访问 ，只有通过真实角色指定的代理类才可以访问 ，也就是是说 真实角色管理代理角色。</p>
<p>高层模块new 了一个真实角色的对象，返回的确实代理角色。</p>
<p>比喻ps： 你和一个明星很熟，互相认识，有事情需要找他，于是你直接给他打电话。但是 明星却让你去找经纪人。</p>
<p>你想直接绕过明星的代理，但是返回的还是 明星的代理。这就是强制代理</p>
<p><img src="/uploads/design_patterns/08proxy/forceProxy.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码清单12-13 强制代理的接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGamePlayer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//登录游戏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user,String password)</span></span>;</span><br><span class="line">    <span class="comment">//杀怪，这是网络游戏的主要特色</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//升级</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//每个人都可以找一下自己的代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//我的代理是谁</span></span><br><span class="line">    <span class="keyword">private</span> IGamePlayer proxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayer</span><span class="params">(String _name)</span></span>&#123;</span><br><span class="line">   	 	<span class="keyword">this</span>.name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到自己的代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxy = <span class="keyword">new</span> GamePlayerProxy(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打怪，最期望的就是杀老怪</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isProxy())&#123;</span><br><span class="line">        	System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot;在打怪！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请使用指定的代理访问&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进游戏之前你肯定要登录吧，这是一个必要条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isProxy())&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;登录名为&quot;</span>+user+<span class="string">&quot;的用户&quot;</span>+<span class="keyword">this</span>.name+<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;请使用指定的代理访问&quot;</span>);;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//升级，升级有很多方法，花钱买是一种，做任务也是一种</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isProxy())&#123;</span><br><span class="line">        	System.out.println(<span class="keyword">this</span>.name + <span class="string">&quot; 又升了一级！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;请使用指定的代理访问&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验是否是代理访问</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.proxy == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码清单12-15 强制代理的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造函数传递用户名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.gamePlayer = _gamePlayer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练杀怪</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.gamePlayer.killBoss();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练登录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.gamePlayer.login(user, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练升级</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gamePlayer.upgrade();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理的代理暂时还没有，就是自己</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IGamePlayer <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps: 强制代理的概念  是 从真实角色找到代理角色，不需要直接访问真实角色。 高层模块 只要调用getProxy 就可以访问真实角色的所有方法，他根本不需要产生一个代理出来，代理的管理已经由真实角色自己完成 。</p>
<h5 id="代理是有个性的"><a href="#代理是有个性的" class="headerlink" title="代理是有个性的"></a>代理是有个性的</h5><p>一个类可以实现多个接口，完成不同任务的整合。也就是说代理类不仅仅可以实现主题接口，也可以实现其他接口完成不同的任务 ，而且</p>
<p>ps: 代理的目的 是在目标对象方法的基础上 作增强，这种增强的本质是对目标对象的方法进行拦截和过滤 。</p>
<p><img src="/uploads/design_patterns/08proxy/wavedProxy.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算费用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayerProxy</span> <span class="keyword">implements</span> <span class="title">IGamePlayer</span>,<span class="title">IProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IGamePlayer gamePlayer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过构造函数传递要对谁进行代练</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayerProxy</span><span class="params">(IGamePlayer _gamePlayer)</span></span>&#123;</span><br><span class="line">   	 	<span class="keyword">this</span>.gamePlayer = _gamePlayer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练杀怪</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">killBoss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.gamePlayer.killBoss();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练登录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String user, String password)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.gamePlayer.login(user, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代练升级</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.gamePlayer.upgrade();</span><br><span class="line">    <span class="keyword">this</span>.count();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算费用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;升级总费用是：150元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>动态代理是 在实现阶段不需要关心代理谁 ，而在运行阶段才指定代理哪一个对象 。 相对来说，自己写代理类的方式就是静态代理。</p>
<p>AOP（Aspect Oriented Programming），其核心就是动态代理机制 </p>
<p><img src="/uploads/design_patterns/08proxy/aopProxy.png"></p>
<ul>
<li><p>在类图中增加了一个 InvocationHandler 接口 和GamePlayIH 类，作用就是产生一个对象的代理对象。</p>
</li>
<li><p>其中 InvocationHandler 就是JDK 提供的动态代理接口，对被代理类的方法进行代理 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码清单12-21 动态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayIH</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理者</span></span><br><span class="line">    Class cls =<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//被代理的实例</span></span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//我要代理谁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GamePlayIH</span><span class="params">(Object _obj)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.obj = _obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用被代理的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = method.invoke(<span class="keyword">this</span>.obj, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>其中invoke 方法是 接口InvocationHandler 定义必须实现的 。他完成对真实方法的调用 </p>
</li>
<li><p>动态代理是 更具被代理的接口 （ here:   Class cls =null; ）生成所有的方法 ,  也就是说给定一个接口，动态代理会宣称： 我已经实现了该接口下的所有方法</p>
</li>
<li><p>动态代理如何实现被代理接口中的方法：</p>
<ul>
<li> 默认情况下所有方法的返回值  都是空的，代理已经实现了它，但是没有任何的逻辑含义 </li>
<li>都是通过 InvocationHandler 接口，所有方法都由该 Handler 来进行处理，即 所有被代理的方法都由 InvocationHandler接管实际的处理任务 </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码清单<span class="number">12</span>-<span class="number">22</span> 动态代理的场景类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个痴迷的玩家</span></span><br><span class="line">		IGamePlayer player = <span class="keyword">new</span> GamePlayer(<span class="string">&quot;张三&quot;</span>);		</span><br><span class="line">		<span class="comment">//定义一个hanlder</span></span><br><span class="line">		InvocationHandler handler = <span class="keyword">new</span> GamePlayIH(player);		</span><br><span class="line">		<span class="comment">//开始打游戏，记下时间戳</span></span><br><span class="line">		System.out.println(<span class="string">&quot;开始时间是：2009-8-25 10:45&quot;</span>);		</span><br><span class="line">		<span class="comment">//获得类的class loader</span></span><br><span class="line">		ClassLoader cl = player.getClass().getClassLoader();		</span><br><span class="line">		<span class="comment">//动态产生一个代理者</span></span><br><span class="line">		IGamePlayer proxy = (IGamePlayer)Proxy.newProxyInstance(cl,<span class="keyword">new</span> Class[]&#123;IGamePlayer.class&#125;,handler);		</span><br><span class="line">		<span class="comment">//登录</span></span><br><span class="line">		proxy.login(<span class="string">&quot;zhangSan&quot;</span>, <span class="string">&quot;password&quot;</span>);		</span><br><span class="line">		<span class="comment">//开始杀怪</span></span><br><span class="line">		proxy.killBoss();</span><br><span class="line">		<span class="comment">//升级</span></span><br><span class="line">		proxy.upgrade();</span><br><span class="line">		<span class="comment">//记录结束游戏时间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;结束时间是：2009-8-26 03:40&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们既没有创建代理类，也没有实现IGamePlayer 接口，却实现了 代练的功能 。这就是动态代理 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码清单12-23 修正后的动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GamePlayIH</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">//被代理者</span></span><br><span class="line">	Class cls =<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//被代理的实例</span></span><br><span class="line">	Object obj = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//我要代理谁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyIvocationHandler</span><span class="params">(Object _obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.obj = _obj;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用被代理的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		Object result = method.invoke(<span class="keyword">this</span>.obj, args);</span><br><span class="line">		<span class="comment">//如果是登录方法，则发送信息</span></span><br><span class="line">		<span class="keyword">if</span>(method.getName().equalsIgnoreCase(<span class="string">&quot;login&quot;</span>))&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;有人在用我的账号登陆！&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="动态代理模型"><a href="#动态代理模型" class="headerlink" title="动态代理模型"></a>动态代理模型</h5><p><img src="/uploads/design_patterns/08proxy/aopCommonClassDiagram.png"></p>
<p>两条独立发展线路</p>
<ul>
<li>动态代理实现代理的职责</li>
<li>业务逻辑Subject 实现相关的逻辑功能。二者没有必然的相互耦合的关系</li>
<li>通知Advice 从另一个切面切入，最终在高层模块 也就是client进行耦合 ，完成逻辑的封装</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码清单12-24 抽象主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码清单12-25 真实主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;do something!----&gt;&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点是我们的MyInvocationHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过构造函数传递一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object _obj)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.target = _obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//执行被代理的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码清单12-27 动态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span>&#123;</span><br><span class="line">    <span class="comment">//寻找JoinPoint连接点，AOP框架使用元数据定义</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//执行一个前置通知</span></span><br><span class="line">        (<span class="keyword">new</span> BeforeAdvice()).exec();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行目标，并返回结果</span></span><br><span class="line">    <span class="keyword">return</span> (T)Proxy.newProxyInstance(loader,interfaces, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通知只有一个方法，执行即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdvice</span> <span class="keyword">implements</span> <span class="title">IAdvice</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;我是前置通知，我被执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码清单12-29 动态代理的场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个主题</span></span><br><span class="line">        Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        <span class="comment">//定义一个Handler</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</span><br><span class="line">        <span class="comment">//定义主题的代理</span></span><br><span class="line">        Subject proxy = DynamicProxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(),handler);</span><br><span class="line">        <span class="comment">//代理的行为</span></span><br><span class="line">        proxy.doSomething(<span class="string">&quot;Finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO</span></span><br></pre></td></tr></table></figure>

<p>通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.obj=Proxy.newProxyInstance(c.getClassLoader(),c.getInterfaces(),<span class="keyword">new</span> MyInvocationHandler(_obj));</span><br></pre></td></tr></table></figure>

<p>重新生成了一个代理对象 。c.getInterfaces()的作用是查找该类的所有接口，然后实现接口的所有方法。虽然方法内都是空的。 </p>
<p> handler=new MyInvocationHandler(_obj) ，handler 对象 接管了这些方法。这个就是动态代理类</p>
<p>也就是由 InvocationHandler 的实现类实现所有的方法，由其 invoke 方法接管所有方法的实现。其动态调用的过程就是 </p>
<p><img src="/uploads/design_patterns/08proxy/dynamicProxyProcess.png"></p>
<p>client –doSomethind–&gt; DynamicProxy –invoke–&gt;MyInvocationHandler –”invoke()”–&gt;Subject对象</p>
<p>ps: 因为 DynamicProxy  是一个通用类，没有业务含义，我们可以新建一个实现类实现它，赋予业务含义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码清单12-30 具体业务的动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectDynamicProxy</span> <span class="keyword">extends</span> <span class="title">DynamicProxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newProxyInstance</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获得ClassLoader</span></span><br><span class="line">    ClassLoader loader = subject.getClass().getClassLoader();</span><br><span class="line">    <span class="comment">//获得接口数组</span></span><br><span class="line">    Class&lt;?&gt;[] classes = subject.getClass().getInterfaces();</span><br><span class="line">    <span class="comment">//获得handler</span></span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(subject);</span><br><span class="line">    	<span class="keyword">return</span> newProxyInstance(loader, classes, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码清单12-31 场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个主题</span></span><br><span class="line">    Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    <span class="comment">//定义主题的代理</span></span><br><span class="line">    Subject proxy = SubjectDynamicProxy.newProxyInstance(subject);</span><br><span class="line">    <span class="comment">//代理的行为</span></span><br><span class="line">    proxy.doSomething(<span class="string">&quot;Finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>动态代理的主要意图就是： 横切面编程（AOP），在不改变已有代码结构的情况下 增强或者控制 对象的行为</li>
<li>实现动态代理的首要条件就是： 被代理类（realSubject）必须实现一个接口 。当然cglib 可以实现不需要接口也可以实现动态代理的方式</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>代理模式 应用非常广泛， 事务处理，日志管理 都用到了代理模式。应该是 接触最多的模式，有了AOP 后写代理就更加简单了 。可以使用 springAOP 和 ASpectJ工具 。调试时候看到 $Proxy0 这种结构，就可以知道这个是 动态代理了。</p>
<p>学习AOP框架时候，弄清楚这几个名词： 切面（Aspect）、切入点（JoinPoint）、通知（Advice）、织入（Weave）</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
        <tag>委托模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码解析-01-02-bean的加载</title>
    <url>/2021/03/11/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01-2-bean%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<ul>
<li>其实这一章，描述了很多次关于循环依赖的问题，后面需要专门去看看 。</li>
</ul>
<h1 id="Bean的加载"><a href="#Bean的加载" class="headerlink" title="Bean的加载"></a>Bean的加载</h1><p>对于加载Bean的功能，在Spring中的调用方式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext applicationContext1 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line"><span class="comment">// MyTestBean bean = applicationContext1.getBean(MyTestBean.class);</span></span><br><span class="line">MyTestBean bean = applicationContext1.getBean(<span class="string">&quot;myTestBean&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在阅读源码看看Spring代码是如何实现的</p>
<ul>
<li>BeanFactory</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean containsBean(String name);</span><br></pre></td></tr></table></figure>

<ul>
<li>AbstractBeanFactory</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="comment">// 提取对应的beanName</span></span><br><span class="line">		String beanName = transformedBeanName(name);</span><br><span class="line">		System.out.println(<span class="string">&quot;doGetBean beanName=&quot;</span>+beanName);</span><br><span class="line">		Object bean;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">		<span class="comment">// 急切地检查手动注册的单例缓存。</span></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 检查缓存中或者实例工厂中是否有对应的实例</span></span><br><span class="line"><span class="comment">		 * 为什么首先会 使用这段代码呢，因为在创建单例Bean 的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，</span></span><br><span class="line"><span class="comment">		 * spring 创建bean的原则是不等 bean创建完成就会将bean 的ObjectFactory 提早曝光</span></span><br><span class="line"><span class="comment">		 * 也就是将 ObjectFactory 加入到缓存中 ，一旦下个bean 创建时候需要依赖上个bean ，则直接使用ObjectFactory</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 直接尝试从缓存获取 或者 singletonFactories中的ObjectFactory 中获取</span></span><br><span class="line">		Object sharedInstance = getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">							<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 返回对应的实例，有时候存在诸如 BeanFactory的情况，并不是直接返回实例本身，而是返回指定方法返回的实例</span></span><br><span class="line">			bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//只有在单例情况才会尝试解决循环依赖，原型模式情况下，如果存在A中有B的属性，B中有Ade属性，</span></span><br><span class="line">			<span class="comment">// 那么当依赖注入的时候，就会产生当A还未创建完的时候，因为对于B的创建再次返回创建A，造成循环依赖，也就是下面的情况</span></span><br><span class="line">			<span class="comment">// isPrototypeCurrentlyInCreation(beanName)为 true</span></span><br><span class="line">			<span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">			<span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">			<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">			BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">			<span class="comment">// 如果beanDefinitionMap中 也就是所有已经加载的类中 不包括beanName，则尝试从parentBeanFactory中检查</span></span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">				String nameToLookup = originalBeanName(name);</span><br><span class="line">				<span class="comment">// 递归 到BeanFactory 中寻找</span></span><br><span class="line">				<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">					<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">							nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">					<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">					<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 如果 不是仅仅做类型检查 则是创建Bean，这里要进行记录</span></span><br><span class="line">			<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">				markBeanAsCreated(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 将存储XML配置文件的 GernericBeanDefinition 转换为 RootBeanDefinition，</span></span><br><span class="line">			<span class="comment">// 如果指定beanName 是子Bean 的话，同时会合并父类的相关属性</span></span><br><span class="line">				RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">				checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">				String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">				<span class="comment">// 如果存在依赖，则需要递归实例化的bean</span></span><br><span class="line">				<span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">						<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 缓存依赖调用</span></span><br><span class="line">						registerDependentBean(dep, beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							getBean(dep);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">									<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 实例化 依赖的bean后便可以实例化 mbd本身了</span></span><br><span class="line">				<span class="comment">// singleton 模式的创建</span></span><br><span class="line">				<span class="comment">// Create bean instance.</span></span><br><span class="line">				<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">					sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">							<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">							<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">							<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">							destroySingleton(beanName);</span><br><span class="line">							<span class="keyword">throw</span> ex;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">					bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">					<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">					<span class="comment">// prototype 模式的创建 （new）</span></span><br><span class="line">					Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">finally</span> &#123;</span><br><span class="line">						afterPrototypeCreation(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">					bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					String scopeName = mbd.getScope();</span><br><span class="line">					<span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">					<span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">							beforePrototypeCreation(beanName);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								afterPrototypeCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">						bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">								<span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">								<span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">								ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">		<span class="comment">// 检查需要的类型是否 符合bean的实际类型</span></span><br><span class="line">		<span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">				<span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> convertedBean;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">							ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (T) bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出bean的加载经历 了一个相当复杂的过程，其中涉及各种各样的考虑。</p>
<p>对于加载的过程涉及的步骤大致如下：</p>
<ol>
<li><p>转换对应的beanName</p>
<ul>
<li>传入的参数name 可能是别名，也可以是FactoryBean,所以需要进行一系列的解析，解析的内容包括一下内容：<ul>
<li>去除Factory的修饰符， 比如 如果name是 “&amp;aa”,name首先会去除 &amp;，使得name=“aa”</li>
<li>去指定alias所表示的最终beanName，例如 别名A指向名称为B的bean，则返回B； 如果别名A指向别名B，别名B指向 名称为C的bean，则返回C</li>
</ul>
</li>
</ul>
</li>
<li><p>尝试从缓存中加载单例</p>
<ul>
<li><p>单例在Spring的同一个容器中 只会被创建一次，后续在获取Bean，就直接从单例缓存中获取了。</p>
</li>
<li><p>当然这里也是尝试加载，首先尝试从缓存中加载，如果加载不成功则尝试从singletonFactories 中加载。</p>
</li>
<li><p>因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖，在Spring中创建bean的原则是 <strong>不等bean创建完成就会创建bean的 ObjectFactory 提早曝光加入到缓存中 ，一旦下一个bean创建时候需要依赖上一个 bean则直接使用ObjectFactory</strong> </p>
</li>
</ul>
</li>
<li><p>bean的实例化</p>
<ul>
<li>如果从缓存中得到了bean 的原始状态，则需要 对bean进行实例化</li>
<li>强调一下： 缓存中记录的只是最原始的bean 状态，并不一定是 我们最终想要的bean 。举个例子，假如 我们需要对工厂bean进行处理，那么这里得到的其实是 工厂bean的 初始状态， 但是我们真正需要的是工厂bean 中定义的factory-method方法中返回的bean ，而 getObjectForBeanInstance 就是完成这个工作的，</li>
</ul>
</li>
<li><p>原型模式的依赖检查</p>
<ul>
<li>只有在单例的情况下，才会尝试解决循环依赖 ，如果存在A 中有B的属性，B中有A的属性 ，那么当依赖注入的时候，就会产生当A 还未创建完成的时候因为对于B的创建再次返回创建A，造成循环依赖 ，也就是情况：if (isPrototypeCurrentlyInCreation(beanName)) =true</li>
</ul>
</li>
<li><p>检测parentBeanFactory</p>
<ul>
<li>从代码上看，如果缓存没有数据的话，就直接转到父类工厂上去加载了，为啥呢</li>
<li>if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) <ul>
<li>parentBeanFactory != null ，parentBeanFactory如果为空，则其他一切都是浮云，这个无fuck可说</li>
<li> !containsBeanDefinition(beanName)这个判断比较重要， 她是在检测如果当前加载的XML配置文件 中不包含beanName 所对应的配置，就只能到parentBeanFactory 去尝试下了，然后再去 递归的调用getBean 方法</li>
</ul>
</li>
</ul>
</li>
<li><p>将存储XML配置文件的GernericBeanDefinition 转换为 RootBeanDefinition</p>
<ul>
<li>因为从XML配置文件中读取到的Bean信息是存储在GernericBeanDefinition 中的，但是所有的Bean后续处理都是针对RootBeanDefinition的，所以这里需要进行一个转换，转换的同时 如果父类bean不为空的话，则会一并合并父类的属性</li>
</ul>
</li>
<li><p>寻找依赖</p>
<ul>
<li>因为bean的初始化过程中 可能会用到某些属性，而这些属性很可能是动态配置的，并且配置成依赖其他的bean，那么这个时候就有必要先加载依赖的bean，</li>
<li>所以在Spring的加载顺寻中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖 </li>
</ul>
</li>
<li><p><strong>针对不同的scope 进行bean的创建</strong></p>
<ul>
<li>在Spring中存在不同的scope，其中默认的是Singleton，但是还有些其他的配置 诸如 prototype、request之类的。这个步骤中，Spring会根据 不同的配置进行不同的初始化策略</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li>程序到这里返回bean后已经基本结束了，通常对该方法的调用参数requiredType 是为空的 ，</li>
<li>但是可能会存在这种情况： 返回的bean 其实是个String ，但是requiredType却传入 Integer类型，那么这个时候本步骤就会起作用了，他的功能是将返回的bean转换为requiredType. </li>
<li>在Spring 中提供了各种各样的转换器，用户也可以自己扩展转换器来满足需求 。</li>
</ul>
</li>
</ol>
<h2 id="1-1-FactoryBean的使用"><a href="#1-1-FactoryBean的使用" class="headerlink" title="1.1 FactoryBean的使用"></a>1.1 FactoryBean的使用</h2><ul>
<li>一般情况下，Spring通过反射机制利用bean的class 属性指定实现类 来实例化bean。在某些情况下，实例化bean的过程比较复杂，如果按照传统的方式，则需要在<bean> 中提供大量的配置信息，配置方式的灵活性受限，这是采用编码的方式可能会得到一个简单的方案 。  </li>
<li>spring为此通过了一个  org.springframework.beans.factory.FactoryBean 的工厂类接口 ，用户可以通过实现该接口定制实例化bean的 逻辑 </li>
<li>org.springframework.beans.factory.FactoryBean 接口对于Spring框架非常重要，Spring本身就提供了70多个 FactoryBean的实现。他们隐藏了实例化一些复杂bean的细节 ，为上层应用带来了便利 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The name of an attribute that can be</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.core.AttributeAccessor#setAttribute set&#125; on a</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanDefinition&#125; so that</span></span><br><span class="line"><span class="comment">	 * factory beans can signal their object type when it can&#x27;t be deduced from</span></span><br><span class="line"><span class="comment">	 * the factory bean class.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.2</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String OBJECT_TYPE_ATTRIBUTE = <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">// 返回 由FactoryBean 创建的bean的实例，如果 isSingleton()返回 true，则该实例会放到Spring容器中单实例缓存池 中</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">// 返回 FactoryBean 创建的bean类型</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 由FactoryBean 创建的bean实例的作用域 是singleton 还是 prototype</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当配置文件中<bean>的class 属性配置的实现类是 FactoryBean是，通过getBean（）方法返回的不是FactoryBean本身 ，而是 FactoryBean#getObject()方法所返回的对象 ，相当于 Factory#getObject() 代理了getBean() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;</span><br><span class="line">	<span class="keyword">private</span> String brand;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> maxSpeed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> brand;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// factoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String carInfo;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Car car = <span class="keyword">new</span> Car();</span><br><span class="line">		String[] infos = carInfo.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		car.setBrand(infos[<span class="number">0</span>]);</span><br><span class="line">		car.setMaxSpeed(Integer.valueOf(infos[<span class="number">1</span>]));</span><br><span class="line">		car.setPrice(Double.valueOf(infos[<span class="number">1</span>]));</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		<span class="keyword">return</span> Car.class;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getCarInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> carInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarInfo</span><span class="params">(String carInfo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.carInfo = carInfo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件</span></span><br><span class="line">	&lt;bean id=<span class="string">&quot;car&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mazhichu.spring.factory.CarFactoryBean&quot;</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;carInfo&quot;</span> value=<span class="string">&quot;BMW,200,200000&quot;</span>/&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyTestBeanTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		ApplicationContext applicationContext1 = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line">		MyTestBean bean = applicationContext1.getBean(MyTestBean.class);</span><br><span class="line">		Car car = (Car)applicationContext1.getBean(<span class="string">&quot;car&quot;</span>);</span><br><span class="line">		System.out.println(car.toString());</span><br><span class="line">        <span class="comment">// factoryBean 需要加 &amp;</span></span><br><span class="line">		CarFactoryBean carFactoryBean = (CarFactoryBean)applicationContext1.getBean(<span class="string">&quot;&amp;car&quot;</span>);</span><br><span class="line">		System.out.println(car.toString());</span><br><span class="line">		System.out.println(carFactoryBean.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行 结果</span></span><br><span class="line">Car&#123;maxSpeed=<span class="number">200</span>, brand=<span class="string">&#x27;BMW&#x27;</span>, price=<span class="number">200.0</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当调用getBean(“car”)时，Spring通过反射机制发现 CarFactoryBean 实现了FactoryBean接口， 这时候 Spring 容器就调用 接口方法getObject 方法返回 Car对象</li>
<li>如果希望 FactoryBean对象，则需要在使用getBean（beanName）方法时 ，在beanName 前面显示的加上”&amp;”前缀，例如getBean（“&amp;car”），CarFactoryBean carFactoryBean = (CarFactoryBean)applicationContext1.getBean(“&amp;car”);</li>
</ul>
<h2 id="1-2-缓存中获取单例Bean"><a href="#1-2-缓存中获取单例Bean" class="headerlink" title="1.2 缓存中获取单例Bean"></a>1.2 缓存中获取单例Bean</h2><ul>
<li>前面知道FactoryBean的用法后，我们就可以了解 bean加载的过程了，</li>
<li>单例在Spring的同一个容器内只会被创建一次 ，后续在获取bean 就直接从单例缓存中获取， 当然这里也只是尝试加载，</li>
<li>首先尝试从缓存中加载，然后再尝试从singletonFactories 中加载 。</li>
<li>因为在创建单例bean 的时候，会出现依赖注入的情况，而在创建依赖的时候，为了避免循环依赖 ，Spring 创建bean 的原则是 不等bean创建完成就会将创建bean的ObjectFactory提早曝光加入到缓存中，一旦下一个bean创建的时候需要依赖上个bean，则直接使用 ObjectFactory</li>
</ul>
<h3 id="getSingleton逻辑"><a href="#getSingleton逻辑" class="headerlink" title="getSingleton逻辑"></a>getSingleton逻辑</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数 true，设置标识 允许早期依赖</span></span><br><span class="line">		<span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment">	 * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">		<span class="comment">//1. 检查缓存中是否存在单例，首先从 singletonObjects 中获取</span></span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 2. 再尝试从 earlySingletonObjects 中获取</span></span><br><span class="line">			singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="comment">// 3.如果为空 ，则锁定全局变量 并进行处理</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">					<span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">					singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">//如果此bean正在加载，则不处理</span></span><br><span class="line">						singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">						<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 4. 获取 ObjectFactory ，通过ObjectFactory.getObject 获取bean</span></span><br><span class="line">							<span class="comment">// 当某些 方法需要提前初始化的时候，</span></span><br><span class="line">							<span class="comment">// 则会调用 addSingletonFactory 方法将对应的ObjectFactory初始化策略存储在SingletonFactoryes</span></span><br><span class="line">							ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">							<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">								<span class="comment">// 调用预先设定的getObject方法</span></span><br><span class="line">								singletonObject = singletonFactory.getObject();</span><br><span class="line">								<span class="comment">// 记录在缓存中，earlySingletonObjects 与 singletonFactories互斥</span></span><br><span class="line">								<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">								<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法因为设计循环依赖的检测，以及涉及很多变量的记录存取，所以让人 困惑</p>
<ol>
<li>首先尝试 从 singletonObjects 里面获取实例，</li>
<li>如果获取不到再从 earlySIngletontonObjects里面获取，</li>
<li>如果还获取不到，再尝试 从singletonFactories 里面获取beanName 对应的ObjectFactory ，然后调用这个 ObjectFactory 的getObject方法来创建bean ，并放到 earlySingletonObjects中去，并且从 singletonFactories 里面remove掉这个 ObjectFactory，</li>
<li>而对于后续的所有内存操作都只为了循环依赖检测时候使用，也就是在allowEarlyReference 为 true 的情况下才会使用</li>
</ol>
<h3 id="各类Map缓存的介绍"><a href="#各类Map缓存的介绍" class="headerlink" title="各类Map缓存的介绍"></a>各类Map缓存的介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Set of registered singletons, containing the bean names in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>singletonObjects :用于保存beanName 和创建bean实例之间的关系， beanName-&gt; bean instance</li>
<li>singletonFactories :用于保存beanName 和创建Bean的工厂之间的关系 ，beanName-&gt;objectFactory</li>
<li>earlySingletonObjects： 也是保存BeanName 和创建bean 实例之间额关系，与 singletonObjects 的不同之处在于：当一个单例bean被放在这里之后，那么当bean还在创建过程中，就可以通过getBean方法获取到了， 其目的是用来检测循环引用 </li>
<li>registeredSingletons ：用来保存所有已经注册的bean</li>
</ul>
<h2 id="1-3-从bean的实例中获取对象"><a href="#1-3-从bean的实例中获取对象" class="headerlink" title="1.3 从bean的实例中获取对象"></a>1.3 从bean的实例中获取对象</h2><p>在getBean方法中 getObjectForBeanInstance 是个高频率使用的方法，无论从缓存中获得bean 还是根据 不同的scope 策略加载bean 。</p>
<p>总之 我们得到bean的实例后要做第一步就是调用这个方法来检测一下正确性，其实 就是用于检测当前bean 是否是 FactoryBean类型的bean ，如果是，那么需要调用该bean对应的FactoryBean 实例中的getObject作为返回值 。</p>
<ul>
<li>无论从缓存中获取到的bean还是通过不同的scope 策略加载的bean 都只是最原始的bean状态，并不一定是我们最想要的bean。 </li>
<li>举个例子，加入我们需要对工厂bean进行处理，那么这里得到的其实是工厂bean的初始状态，但是我们真正需要的是工厂bean 中定义的 factory-method 方法中返回的bean ，而 getObjectForBeanInstance 方法就是完成这个工作的 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果指定的name 是工厂相关（以 &amp;为前缀）且 beanInstance 又不是FactoryBean类型，则 验证不通过</span></span><br><span class="line">		<span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">		<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				<span class="keyword">return</span> beanInstance;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">				<span class="comment">// beanInstance 又不是FactoryBean类型，则 验证不通过</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">		<span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">		<span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">		<span class="comment">// 现在我们有了个Bean的实例，这个实例可能会是正常的bean 或者 factoryBean</span></span><br><span class="line">		<span class="comment">// 如果是FactoryBean 我们使用它创建实例，但是如果 用户想要直接获取工厂实例 而不是工厂的getObject 方法对应的实例，</span></span><br><span class="line">		<span class="comment">// 那么传入的name 应该加入前缀 &amp;</span></span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加载FactoryBean</span></span><br><span class="line">		Object object = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 尝试从缓存中加载bean</span></span><br><span class="line">			object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 到这里已经明确知道  beanInstance 一定是 FactoryBean类型</span></span><br><span class="line">			<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">			<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// containsBeanDefinition 检测 beanDefinitionMap中 也就是在所有已经加载的类中检查是否定义beanName</span></span><br><span class="line">			<span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">				<span class="comment">// 将存储XML配置文件的 GernericBeanDefinition 转换为RootBeanDefinition，</span></span><br><span class="line">				<span class="comment">// 如果指定beanName 是子bean的话，会合并父类的相关属性</span></span><br><span class="line">				mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 是否是用户定义的而不是应用程序本身定义的</span></span><br><span class="line">			<span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">// !!!!!!重点方法</span></span><br><span class="line">			object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从上面代码来看，其实这个方法并没有上面重要的信息，大多是 写辅助代码以及一些功能性的判断，</li>
<li>而真正的核心代码却委托给了  getObjectFromFactoryBean（）</li>
</ul>
<h3 id="getObjectFromFactoryBean（）"><a href="#getObjectFromFactoryBean（）" class="headerlink" title="getObjectFromFactoryBean（）"></a>getObjectFromFactoryBean（）</h3><ul>
<li>对FactoryBean正确性的验证 </li>
<li>对非 FactoryBean 不做任何处理</li>
<li>对bean进行转换</li>
<li>将从 Factory中解析bean 的工作委托给 getObjectFromFactoryBean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1.如果是单例模式</span></span><br><span class="line">		<span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">				Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">					 <span class="comment">// 1.1 就是 ObjectFactory.getObject 方法</span></span><br><span class="line">					object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">					<span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">					<span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">					Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">						object = alreadyThere;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">							<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">								<span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">								<span class="keyword">return</span> object;</span><br><span class="line">							&#125;</span><br><span class="line">							beforeSingletonCreation(beanName);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="comment">// 调用ObjectFactory 的后处理器</span></span><br><span class="line">								object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">								<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">										<span class="string">&quot;Post-processing of FactoryBean&#x27;s singleton object failed&quot;</span>, ex);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								afterSingletonCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">							<span class="comment">// 1.3. 再放入缓存中</span></span><br><span class="line">							<span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> object;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 2.不是单例，就可以重复创建了</span></span><br><span class="line">			<span class="comment">// 2.1 就是 ObjectFactory.getObject 方法</span></span><br><span class="line">			Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">			<span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 调用ObjectFactory 的后处理器</span></span><br><span class="line">					object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Post-processing of FactoryBean&#x27;s object failed&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> object;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个方法只做了一件事情，就是返回的bean 如果是单例的 ，那就必须保证全局唯一， 同时，也因为是单例的，所以不必重复创建 ，可以使用缓存来提高性能 。也就是说已经加载过就要记录下来以便于下次复用 ，否则就直接获取了 </li>
<li>在 doGetObjectFromFactoryBean 方法中，我们终于看到想要看到的方法，也就是 Object=factory.getObject();</li>
</ul>
<h3 id="postProcessObjectFromFactoryBean-object-beanName-后处理器"><a href="#postProcessObjectFromFactoryBean-object-beanName-后处理器" class="headerlink" title="postProcessObjectFromFactoryBean(object, beanName)后处理器"></a>postProcessObjectFromFactoryBean(object, beanName)后处理器</h3><ul>
<li>AbstractAutowireCapableBeanFactory#postProcessObjectFromFactoryBean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Applies the &#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; callback of all</span></span><br><span class="line"><span class="comment">	 * registered BeanPostProcessors, giving them a chance to post-process the</span></span><br><span class="line"><span class="comment">	 * object obtained from FactoryBeans (for example, to auto-proxy them).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #applyBeanPostProcessorsAfterInitialization</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">postProcessObjectFromFactoryBean</span><span class="params">(Object object, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> applyBeanPostProcessorsAfterInitialization(object, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以后应用非常广泛的  XXBeanPostProcessor</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">			Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">			result = current;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在Spring 获取Bean的规则中有这样一条：  尽可能保证所有bean初始化后都会调用注册的BeanPostProcessor 的 postProcessAfterInitialization 方法进行处理</li>
</ul>
<h2 id="1-4-获取单例"><a href="#1-4-获取单例" class="headerlink" title="1.4 获取单例"></a>1.4 获取单例</h2><p>之前我们知道了如何从缓存中获取单例的过程， 如果缓存中不存在已经加载的单例bean，就需要 从头开始bean的加载过程。 而spring中使用getSIngleton 的重载方法实现bean的加载过程</p>
<p>org/springframework/beans/factory/support/AbstractBeanFactory.java:342</p>
<ul>
<li>DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">		<span class="comment">// 全局变量需要同步</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="comment">// 首先检查对应的bean 是否已经加载过，因为singleton模式 其实就是复用以创建的bean，所以 这一步是必须的</span></span><br><span class="line">			Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">			<span class="comment">// 如果为空才可以进行 singleton 的bean 的初始化</span></span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">							<span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">							<span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">                <span class="comment">// 通过 this.singletonsCurrentlyInCreation.add(beanName) 将当前正在创建的bean 记录在缓存中。</span></span><br><span class="line">				<span class="comment">// 这样便可以对循环依赖进行检测</span></span><br><span class="line">				beforeSingletonCreation(beanName);</span><br><span class="line">				<span class="comment">//</span></span><br><span class="line">				<span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 初始化 bean</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					newSingleton = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">					<span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">					singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">					<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">						<span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">							ex.addRelatedCause(suppressedException);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">						<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">                    <span class="comment">// this.singletonsCurrentlyInCreation.remove(beanName)，</span></span><br><span class="line">					<span class="comment">// 移除 缓存中对该bean的正在加载的状态 的记录</span></span><br><span class="line">					afterSingletonCreation(beanName);</span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">					<span class="comment">// 加入缓存 ，并删除 各类辅助状态</span></span><br><span class="line">					addSingleton(beanName, singletonObject);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> singletonObject;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">			<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">			<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">			<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码其实是使用 了回调方法，使得 程序可以在 单例创建的前后做一些准备 以及处理操作， 而真正的获取单例bean的方法其实并不是在 此方法中实现的。其实 现在逻辑是在 ObjectFactory 类型的实例singletonFactory 中实现的。而这些 准备及处理操作包括如下内容：</p>
<ol>
<li><p>检查缓存是否已经加载过</p>
</li>
<li><p>若没有加载，则记录 beanName 的正在加载状态</p>
</li>
<li><p>加载单例前，记录加载状态 ，</p>
<p>beforeSingletonCreation(beanName)：通过 this.singletonsCurrentlyInCreation.add(beanName) 将当前正在创建的bean 记录在缓存中。这样便可以对循环依赖进行检测</p>
</li>
</ol>
<ol start="4">
<li><p>通过调用参数 传入的ObjectFactory 的个体Object 方法实例化bean </p>
</li>
<li><p>加载单例后的处理方法调用 </p>
</li>
<li><p>将结果记录至缓存 并删除 加载bean过程中所记录的各种辅助状态 </p>
</li>
<li><p>返回处理结果</p>
</li>
</ol>
<h2 id="1-5-准备创建bean"><a href="#1-5-准备创建bean" class="headerlink" title="1.5 准备创建bean"></a>1.5 准备创建bean</h2><p>跟踪了这么多Spring源码，经历了这么多函数，或多或少发现了一些规律 ：</p>
<ul>
<li>一个真正干活的函数其实是以 do开头的，比如 doGetObjectFromFactoryBean； 而 给我们错觉的函数，比如 getObjectFromFactoryBean ，其实只是从全局角度去做些 统筹的工作 。</li>
</ul>
<p>这个规律对于createBean 也不例外，可以看看createBean做了哪些准备工作 </p>
<ul>
<li>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean<ul>
<li>org.springframework.beans.factory.support.AbstractBeanFactory#createBean<ul>
<li>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">	 * Central method of this class: creates a bean instance,</span><br><span class="line">	 * populates the bean instance, applies post-processors, etc.</span><br><span class="line">	 * @see #doCreateBean</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span><br><span class="line">			throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		RootBeanDefinition mbdToUse &#x3D; mbd;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Make sure bean class is actually resolved at this point, and</span><br><span class="line">		&#x2F;&#x2F; clone the bean definition in case of a dynamically resolved Class</span><br><span class="line">		&#x2F;&#x2F; which cannot be stored in the shared merged bean definition.</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 1. 锁定class ，根据设置的class 属性或者根据className 来解析class</span><br><span class="line">		Class&lt;?&gt; resolvedClass &#x3D; resolveBeanClass(mbd, beanName);</span><br><span class="line">		if (resolvedClass !&#x3D; null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() !&#x3D; null) &#123;</span><br><span class="line">			mbdToUse &#x3D; new RootBeanDefinition(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Prepare method overrides.</span><br><span class="line">		&#x2F;&#x2F; 2. 验证以及准备覆盖的方法</span><br><span class="line">		try &#123;</span><br><span class="line">			mbdToUse.prepareMethodOverrides();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">					beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; 3. 给BeanPostProcessor 一个机会来返回代理，来替代真正的实例</span><br><span class="line">			&#x2F;&#x2F; Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br><span class="line">			Object bean &#x3D; resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			if (bean !&#x3D; null) &#123;</span><br><span class="line">				return bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">					&quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; 4. doXXXX 才是真正做符合方法名称事情的方法</span><br><span class="line">			Object beanInstance &#x3D; doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">			&#x2F;&#x2F; A previously detected exception with proper bean creation context already,</span><br><span class="line">			&#x2F;&#x2F; or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>根据设置的class 属性或者根据className 来解析 Class</p>
</li>
<li><p>对override 属性进行标记及验证 </p>
</li>
<li><p>应用初始化前的后处理器，解析指定bean 是否存在 初始化前的短路操作 </p>
</li>
<li><p>创建bean</p>
</li>
</ol>
<h3 id="实例化的前置处理"><a href="#实例化的前置处理" class="headerlink" title="实例化的前置处理"></a>实例化的前置处理</h3><p>在真正调用docreate方法创建bean的实力前，使用resolveBeforeInstantiation 对 BeanDefinition 中的属性做些前置处理 。</p>
<p>无论其中是否有相应的逻辑实现我们都可以理解，因为真正逻辑实现前后 留有处理函数也是 可扩展的一种体现， 但是这并不是最重要的 ，在函数 中 还提供了一个 短路判断，这才是最为关键的部分 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 3. 给BeanPostProcessor 一个机会来返回代理，来替代真正的实例</span></span><br><span class="line">			<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">			<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> bean;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>当经过前置处理后，返回的结果如果不为空，那么会直接略过后续的Bean的创建 而直接返回结果。    </p>
<p>这一特性虽然很容易被忽略，但是却起着至关重要的作用，我们熟知的AOP功能 就是基于这里的判断 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">		Object bean = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 如果尚未被解析</span></span><br><span class="line">		<span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">			<span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">			<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">				Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">				<span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">					bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">					<span class="comment">//</span></span><br><span class="line">					<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>此方法最吸引我们的无疑 是两个方法 applyBeanPostProcessorsBeforeInstantiation  以及 applyBeanPostProcessorsAfterInitialization 。两个方法的实现非常的简单 ，无非是 对后处理器中的所有 InstantiationAwareBeanPostProcessor 类型的后处理器 进行 postProcessBeforeInstantiation 方法 和 BeanPostProcesso</p>
]]></content>
      <categories>
        <category>Sprig源码解析</category>
      </categories>
      <tags>
        <tag>bean的加载</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-08-虚拟机类加载机制</title>
    <url>/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机的类加载机制：</p>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<p>在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载稍微增加一些性能开销，</p>
<p>但是却为了Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接的特点实现的。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期都将会经历 加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。 这7个阶段的发生顺序为:</p>
<p><img src="/uploads/jvm/08ClassLoading/01ClassLoadingLifecircle.png"></p>
<ul>
<li>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，</li>
<li>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</li>
<li>请注意，是按部就班地<strong>“开始”</strong>，而不是按部就班地“进行”或按部就班地<strong>“完成”</strong>，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</li>
</ul>
<h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，</p>
<p>这六种场景中的行为称为对一个类型进行主动引用。</p>
<p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p>
<p>下面举三个例子来说明何为被动引用，分别见代码清单7-1、代码清单7-2和代码清单7-3。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><h4 id="通过子类引用父类的静态字段，不会导致子类初始化"><a href="#通过子类引用父类的静态字段，不会导致子类初始化" class="headerlink" title="通过子类引用父类的静态字段，不会导致子类初始化"></a>通过子类引用父类的静态字段，不会导致子类初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示一：</span></span><br><span class="line"><span class="comment">* 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">SuperClass init!</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。</p>
</li>
<li><p>对于静态字段，只有<strong>直接定义这个字段的类</strong>才会被初始化，因此<strong>通过其子类来引用父类中定义的静态字段</strong>，只会<strong>触发</strong><br><strong>父类的初始化</strong>而不会触发子类的初始化。</p>
</li>
<li><p>至于是否要触发子类的加载和验证阶段，在《Java虚拟机规范》中并未明确规定，所以这点取决于虚拟机的具体实现。对于HotSpot虚拟机来说，可通过-XX：+TraceClassLoading参数观察到此操作是会导致子类加载的。</p>
</li>
</ul>
<h4 id="通过数组定义来引用类，不会触发此类的初始化"><a href="#通过数组定义来引用类，不会触发此类的初始化" class="headerlink" title="通过数组定义来引用类，不会触发此类的初始化"></a>通过数组定义来引用类，不会触发此类的初始化</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被动使用类字段演示二：</span><br><span class="line"> * 通过数组定义来引用类，不会触发此类的初始化</span><br><span class="line"> **/</span><br><span class="line">public class NotInitialization_2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SuperClass[] sca = new SuperClass[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 javap -verbose NotInitialization_2.class</span><br><span class="line">&#123;</span><br><span class="line">  public org.fenixsoft.jvm.chapter7.NotInitialization_2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lorg/fenixsoft/jvm/chapter7/NotInitialization_2;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: anewarray     <span class="comment">#2                  // class org/fenixsoft/jvm/chapter7/SuperClass</span></span><br><span class="line">         5: astore_1</span><br><span class="line">         6: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 6</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  args   [Ljava/lang/String;</span><br><span class="line">            6       1     1   sca   [Lorg/fenixsoft/jvm/chapter7/SuperClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行之后发现没有输出“SuperClassinit！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。</p>
</li>
<li><p>但是这段代码里面触发了另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是<br>一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</p>
</li>
<li><p>这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里</p>
</li>
</ul>
<h4 id="常量在编译阶段会存入调用类的常量池中"><a href="#常量在编译阶段会存入调用类的常量池中" class="headerlink" title="常量在编译阶段会存入调用类的常量池中"></a>常量在编译阶段会存入调用类的常量池中</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示三：</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行之后，也没有输出“ConstClass init！”，、</p>
</li>
<li><p>这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在编译阶段通过*<strong>常量传播优化**<em>，已经将此常量的值“helloworld”直接存储在NotInitialization类的</em></strong>常量池*<strong>中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类</strong>对自身常量池的引用**了</p>
</li>
<li><p>也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class文件后就已不存在任何联系了。</p>
</li>
</ul>
<h2 id="接口的加载过程"><a href="#接口的加载过程" class="headerlink" title="接口的加载过程"></a>接口的加载过程</h2><ul>
<li>接口的加载过程与类加载过程稍有不同，</li>
<li>针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，</li>
<li>而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[2]，用于初始化接口中所定义的成员变量。</li>
<li>接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：<br>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><ul>
<li><p>“<strong>加载</strong>”（Loading）阶段是整个“<strong>类加载</strong>”（Class Loading）过程中的一个阶段，</p>
</li>
<li><p>希望没有混淆这两个看起来很相似的名词。在加载阶段，Java虚拟机需要完成以下三件事情：</p>
</li>
</ul>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<ul>
<li><p>《Java虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与Java应用的灵活度都是相当大的。</p>
</li>
<li><p>例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。仅仅这一点空隙，Java虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台。例如：</p>
<ol>
<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是Web Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</li>
<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
<li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li>
</ol>
</li>
<li><p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p>
</li>
<li><p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的</p>
</li>
<li><p>但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p>
<ol>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>
</ol>
</li>
</ul>
<ul>
<li><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在**<em>方法区**</em>之中了（<strong>平安面试遇到过，编译后的数据放在哪个内存区域</strong>（<strong>方法区</strong>））</p>
</li>
<li><p>类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
</li>
<li><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><ul>
<li><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
</li>
<li><p>因为使用纯粹的java语言是可以拦截一些异常的，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果尝试这样去做了，编译器会毫不留情地抛出异常、拒绝编译。</p>
</li>
<li><p>但是 Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。上述Java代码无法做到的事情在字节码层面上都是可以实现的，至少语义上是可以表达出来的</p>
</li>
<li><p>所以 Java虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是Java虚拟机保护自身的一项必要措施。</p>
</li>
<li><p>验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重</p>
</li>
</ul>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
<li>and so on …</li>
</ul>
<p>验证阶段的主要目的是保证输入的<strong>字节流</strong>能<strong>正确地解析并存储于方法区</strong>之内，格式上符合描述一个Java类型信息的要求。</p>
<p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，</p>
<p>所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方<br>法重载，例如方法参数都一致，但返回值类型却不同等）</li>
<li>and so on … </li>
</ul>
<p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，</p>
<p>主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p>在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的</li>
<li> and so on …</li>
</ul>
<p>如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再严密的检查，也依然不能保证这一点。</p>
<p>这里涉及了离散数学中一个很著名的问题——“停机问题”（Halting Problem）[2]，即不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p>
<p>在我们讨论字节码校验的上下文语境里，通俗一点的解释是通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在Bug。</p>
<h5 id="Ps"><a href="#Ps" class="headerlink" title="Ps:"></a>Ps:</h5><ul>
<li>由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行</li>
<li>具体做法是给方法体Code属性的属性表中新增加了一项名为“<strong>StackMapTable</strong>”的新属性，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，</li>
<li>在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。这样就将字节码验证的<strong>类型推导</strong>转变为<strong>类型检查</strong>，从而节省了大量校验时间</li>
</ul>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，</p>
<p>这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，</p>
<p>通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>本阶段通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当前类访问。</li>
<li>and so on …</li>
</ul>
<p>符号引用验证的主要目的是确保解析行为能正常执行，</p>
<p>如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：<br>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<h5 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h5><p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><ul>
<li><p>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）<strong>分配内存并设置类变量初始值</strong>的阶段，</p>
</li>
<li><p>从概念上讲，这些变量所使用的内存都应当在<strong>方法区</strong>中进行分配，但必须注意到方法区本身是一个逻辑上的区域，</p>
</li>
<li><p>在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；</p>
</li>
<li><p>而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了，</p>
</li>
</ul>
<p>关于准备阶段，还有两个容易产生混淆的概念需要着重强调，</p>
<ul>
<li><p>首先是这时候进行内存分配的仅包括<strong>类变量</strong>，而不包括实例变量，</p>
</li>
<li><p>实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li><p>其次是这里所说的<strong>初始值</strong>“<strong>通常情况</strong>”下是<strong>数据类型的零值</strong>，</p>
</li>
<li><p>假设一个类变量的定义为：public static int value = 123;</p>
</li>
<li><p>那变量value在准备阶段过后的<strong>初始值为0</strong>而不是123，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于<strong>类构造器</strong><clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</p>
</li>
</ul>
<p><strong>基本数据类型的零值</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“<strong>特殊情况</strong>”：如果类字段的字段属性表中存在<strong>ConstantValue</strong>属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，假设上面类变量value的定义修改为：</p>
<p>public static final int value = 123;</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据Con-stantValue的设置<br>将value赋值为123。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p>在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p>
<h4 id="符号引用-Symbolic-References"><a href="#符号引用-Symbolic-References" class="headerlink" title="符号引用(Symbolic References):"></a>符号引用(Symbolic References):</h4><ul>
<li><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
</li>
<li><p>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，</p>
</li>
<li><p>但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p>
</li>
</ul>
<h4 id="直接引用（Direct-References）："><a href="#直接引用（Direct-References）：" class="headerlink" title="直接引用（Direct References）："></a>直接引用（Direct References）：</h4><ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
<li>直接引用是和虚拟机实现的内存布局直接相关的，</li>
<li>同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li>
<li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p>
<p>所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引<br>用将要被使用前才去解析它。</p>
<p>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>这7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CON-STANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、<br>CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型</p>
<p>后4种(CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info)，它们都和动态语言支持密切相关</p>
<h4 id="4-1-类或接口的解析"><a href="#4-1-类或接口的解析" class="headerlink" title="4.1 类或接口的解析"></a>4.1 类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个<strong>从未解析过的符号引用N</strong>解析为一个<strong>类或接口C的直接引用</strong>，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<ol>
<li><p>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</p>
</li>
<li><p>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</p>
</li>
<li><p>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，<br>但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p>
</li>
</ol>
<p>针对上面第3点访问权限验证，在JDK 9引入了模块化以后，一个public类型也不再意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。</p>
<p>如果我们说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p>
<ul>
<li>被访问类C是public的，并且与访问类D处于同一个模块。</li>
<li>被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问</li>
<li>被访问类C不是public的，但是它与访问类D处于同一个包中</li>
</ul>
<h4 id="4-2-字段解析"><a href="#4-2-字段解析" class="headerlink" title="4.2 字段解析"></a>4.2 字段解析</h4><p>要解析一个未被解析过的字段符号引用，</p>
<ul>
<li><p>首先将会对字段表内class_index[3]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。</p>
<ul>
<li><p>如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。</p>
</li>
<li><p>如果解析成功完成，那把这个字段所属的类或接口用C表示，</p>
</li>
</ul>
</li>
</ul>
<p>《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：</p>
<ol>
<li><p>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</p>
</li>
</ol>
<p> 如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<p>如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac编译器就可能直接拒绝其编译为Class文件。</p>
<p>在代码清单7-4中演示了这种情况，如果注释了Sub类中的“public static int A=4；”，接口与父类同时存在字段A，那Oracle公司实现的Javac编译器将提示“<strong>The field Sub.A is ambiguous</strong>”，并且会拒绝编译这段代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class FieldResolution &#123;</span><br><span class="line"></span><br><span class="line">    interface Interface0 &#123;</span><br><span class="line">        int A = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Interface1 extends Interface0 &#123;</span><br><span class="line">        int A = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Interface2 &#123;</span><br><span class="line">        int A = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Parent implements Interface1 &#123;</span><br><span class="line">        public static int A = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Sub extends Parent implements Interface2 &#123;</span><br><span class="line">        public static int A = 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/uploads/jvm/08ClassLoading/02-analysisError.png"></p>
<h4 id="4-3-方法解析"><a href="#4-3-方法解析" class="headerlink" title="4.3 方法解析"></a>4.3 方法解析</h4><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index[4]项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，</p>
<p>接下来虚拟机将会按照如下步骤进行后续的方法搜索：(TODO 不是很理解，回头看 <strong>字节码结构</strong>)</p>
<p>ps :简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</p>
<ol>
<li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li>
</ol>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此<br>方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h4 id="4-4-接口方法解析"><a href="#4-4-接口方法解析" class="headerlink" title="4.4 接口方法解析"></a>4.4 接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，</p>
<p>如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<ol>
<li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法,但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<p>在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。</p>
<p>但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常。</p>
<p>[1] invokedynamic指令是在JDK 7时加入到字节码中的，当时确实只为了做动态语言（如JRuby、<br>Scala）支持，Java语言本身并不会用到它。而到了JDK 8时代，Java有了Lambda表达式和接口的默认方<br>法，它们在底层调用时就会用到invokedynamic指令，这时再提动态语言支持其实已不完全切合，我们<br>就只把它当个代称吧。笔者将会在第8章中介绍这部分内容。<br>[2] 严格来说，CONSTANT_String_info这种类型的常量也有解析过程，但是很简单而且直观，不再做<br>独立介绍。<br>[3] 参见第6章中关于CONSTANT_Fieldref_info常量的相关内容。<br>[4] 参见第6章关于CONSTANT_Methodref_info常量的相关内容。<br>[5] 参见第6章中关于CONSTANT_InterfaceMethodref_info常量的相关内容。</p>
<h3 id="5-初始化-应用程序发挥作用-clinit"><a href="#5-初始化-应用程序发挥作用-clinit" class="headerlink" title="5.初始化(应用程序发挥作用 clinit)"></a>5.初始化(应用程序发挥作用 clinit)</h3><p>类的初始化阶段是类加载过程的最后一个步骤，</p>
<p>之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全<strong>由Java虚拟机来主导控制</strong>。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将<strong>主导权移交给应用程序</strong>。</p>
<p>进行<strong>准备阶段</strong>时，变量已经赋过一次系统要求的<strong>初始零值</strong>，而在<strong>初始化阶段</strong>，则会根据程序员通过<strong>程序编码</strong>制定的主观计划去初始化类变量和其他资源。</p>
<p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及<clinit>()方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作[1]。</p>
<p><clinit>()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块</strong>（static{}块）中的语句合并产生的，</p>
<p><strong>编译器收集的顺序</strong>是由语句在源文件中<strong>出现的顺序</strong>决定的，静态语句块中只能访问到<strong>定义在静态语句块之前</strong>的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如代码清单7-5所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">        System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值<br>操作，如代码清单7-6中，字段B的值将会是2而不是1。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Test01 &#123;</span><br><span class="line">    static class Parent &#123;</span><br><span class="line">        public static int A = 1;  //step1</span><br><span class="line">        static &#123;</span><br><span class="line">            A = 2; //step2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Sub extends Parent &#123;</span><br><span class="line">        public static int B = A; //step3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： 2</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</p>
</li>
<li><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，</p>
<ul>
<li>如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等<br>待，直到活动线程执行完毕<clinit>()方法。</li>
</ul>
</li>
<li><p>如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞[2]，在实际应用中这种阻塞往往是很隐蔽的。</p>
<p>  代码清单7-7演示了这种场景。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不加上这个if语句，编译器将提示“Initializer does not complete normally”并拒绝编译</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;init DeadLoopClass&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下，一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待：</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]init DeadLoopClass</span><br></pre></td></tr></table></figure>

<p>[2] 需要注意，其他线程虽然会被阻塞，但如果执行＜clinit＞()方法的那条线程退出＜clinit＞()方法后，其他线程唤醒后则不会再次进入＜clinit＞()方法。同一个类加载器下，一个类型只会被初始化一次。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>虚拟机类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-12-动态类型语言支持</title>
    <url>/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h1 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h1><p>在介绍Java虚拟机的动态类型语言支持之前，</p>
<ul>
<li>我们要先弄明白动态类型语言是什么？</li>
<li>它与Java语言、Java虚拟机有什么关系？</li>
</ul>
<p>了解Java虚拟机提供动态类型语言支持的技术背景，对理解这个语言特性是非常有必要的。</p>
<h2 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h2><ul>
<li><p>定义： 动态类型语言的关键特征是 它的<strong>类型检查的主体是在运行期而不是 编译期进行的</strong>，</p>
</li>
<li><p>满足这个特征的语言有很多，常用的包括： APL、Clojure、Erlang、Groovy、JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl，等等</p>
</li>
<li><p>那相对地，<strong>在编译期就进行类型检查过程的语言</strong>，譬如 C++ 和Java等就是最常用的<strong>静态类型语言</strong> </p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	int[][][] array = new int[1][0][-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这段Java代码能够正常编译，但运行的时候会出现NegativeArraySizeException异常。在《Java虚拟机规范》中明确规定了NegativeArraySizeException是一个运行时异常（Runtime Exception），通俗一点说，<strong>运行时异常就是指只要代码不执行到这一行就不会出现问题</strong>。</li>
<li>与运行时异常相对应的概念是<strong>连接时</strong>（<strong>类加载阶段的验证、准备和解析 称为连接阶</strong>段）<strong>异常</strong>，例如很常见的NoClassDefFoundError便属于连接时异常，即使导致连接时异常的代码放在一条根本无法被执行到的路径分支上，类加载时（第7章解释过Java的连接过程不在编译阶段，而在类加载阶段）也照样会抛出异常。</li>
</ul>
<p>不过在C语言中，语义相同的代码就会在编译期就直接出错，而不是等到运行时才出现异常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">	int i[1][0][-1]; // GCC拒绝编译，报“size of array is negative”</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此看来，一门语言的哪一种检查行为 要在运行期进行，哪一种检查要在编译期进行并没有什么必然的因果逻辑关系，关键在于语言规范中人为设立的约定。</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">obj.println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>虽然正在阅读本书的每一位读者都能看懂这行代码要做什么，但对于计算机来讲，这一行“没头没尾”的代码是无法执行的，它需要一个具体的上下文中（譬如程序语言是什么、obj是什么类型）才有讨论的意义。</p>
<ul>
<li>现在先假设这行代码是在<strong>Java语言中</strong>，并且变量obj的静态类型为java.io.PrintStream，那变量obj的实际类型就必须是PrintStream的子类（实现了PrintStream接口的类）才是合法的。否则，哪怕obj属于一个确实包含有println(String)方法相同签名方法的类型，但只要它与PrintStream接口没有继承关系，代码依然不可能运行——因为**<em>类型检查不合法**</em></li>
<li>但是相同的代码在<strong>ECMAScript（JavaScript</strong>）中情况则不一样，无论obj具体是何种类型，无论其继承关系如何，只要这种类型的方法定义中确实包含有println(String)方法，能够找到相同签名的方法，调用便可成功。</li>
<li>产生这种差别产生的根本原因是Java语言在编译期间却已将println(String)方法完整的符号引用（本例中为一项CONSTANT_InterfaceMethodref_info常量）生成出来，并作为方法调用指令的参数存储到Class文件中，</li>
<li>例如下面这个样子：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">invokevirtual <span class="comment">#4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br></pre></td></tr></table></figure>

<ol>
<li>这个符号引用包含了该方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，Java虚拟机就可以翻译出该方法的直接引用。</li>
<li>而ECMAScript等动态类型语言与Java有一个核心的差异就是变量obj本身并没有类型，<strong>变量obj的值才具有类型</strong>，</li>
<li>所以编译器在编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型（即<strong>方法接收者不固定</strong>）。</li>
<li><strong><em>“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个核心特征。</em></strong></li>
</ol>
<h3 id="动态类型对比静态类型语言的优缺点："><a href="#动态类型对比静态类型语言的优缺点：" class="headerlink" title="动态类型对比静态类型语言的优缺点："></a>动态类型对比静态类型语言的优缺点：</h3><p>了解了动态类型和静态类型语言的区别后，也许读者的下一个问题就是动态、静态类型语言两者谁更好，或者谁更加先进呢？这种比较不会有确切答案，它们都有自己的优点，选择哪种语言是需要权衡的事情。</p>
<ul>
<li><p>静态类型语言能够<strong>在编译期确定变量类型</strong>，最显著的好处是<strong>编译器可以提供全面严谨的类型检查</strong>，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于<strong>稳定性</strong>及让项目容易达到更大的规模。</p>
</li>
<li><p>而动态类型语言在运行期才确定类型，这可以为开发人员提供极大的<strong>灵活性</strong>，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很<strong>清晰简洁</strong>，清晰简洁通常也就意味着<strong>开发效率的提升</strong>。</p>
</li>
<li><p>ps： <strong>动态类型语言与动态语言、弱类型语言并不是一个概念，需要区别对待。</strong></p>
</li>
</ul>
<h2 id="Java与动态类型"><a href="#Java与动态类型" class="headerlink" title="Java与动态类型"></a>Java与动态类型</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ol>
<li>Java语言、Java虚拟机与 动态类型语言之间有什么关系。</li>
</ol>
<ul>
<li><p>Java虚拟机毫无疑问是Java语言的运行平台，但它的使命并不限于此。</p>
</li>
<li><p>目前确实已经有许多动态类型语言运行于Java虚拟机之上了，如Clojure、Groovy、Jython和JRuby等，能够在同一个虚拟机之上可以实现静态类型语言的严谨与动态类型语言的灵活，这的确是一件很美妙的事情。</p>
</li>
<li><p>但遗憾的是Java虚拟机层面对动态类型语言的支持一直都还有所欠缺，主要表现在方法调用方面：</p>
<ul>
<li>JDK 7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是<strong>被调用的方法的符号引用</strong>（CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量）</li>
<li>前面已经提到过，方法的符号引用在编译时产生，而<strong>动态类型语言只有在运行期才能确定方法的接收者</strong>。这样，在Java虚拟机上实现的动态类型语言就不得不使用“曲线救国”的方式（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现</li>
<li>但这样势必会<strong>让动态类型语言实现的复杂度增加</strong>，也会带来额外的性能和内存开销。</li>
<li>内存开销是很显而易见的，方法调用产生的那一大堆的动态类就摆在那里。</li>
<li>而其中最严重的性能瓶颈是在于动态类型方法调用时，由于<strong>无法确定调用对象的静态类型</strong>，而导致的<strong>方法内联无法有效进行</strong>。</li>
<li>尽管也可以想一些办法（譬如调用点缓存）尽量缓解支持动态语言而导致的性能下降，但这种改善毕竟不是本质的</li>
</ul>
</li>
</ul>
<p>譬如有类似一下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var arrays = &#123;<span class="string">&quot;abc&quot;</span>, new ObjectX(), 123, Dog, Cat, Car..&#125;</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> arrays)&#123;</span><br><span class="line">	item.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JVM动态字节码指令背景"><a href="#JVM动态字节码指令背景" class="headerlink" title="JVM动态字节码指令背景"></a>JVM动态字节码指令背景</h3><ul>
<li>在动态类型语言下这样的代码是没有问题，但由于在运行时arrays中的元素可以是任意类型，即使它们的类型中都有sayHello()方法，也肯定无法在编译优化的时候就确定具体sayHello()的代码在哪里，编译器只能不停编译它所遇见的每一个sayHello()方法，并缓存起来供执行时选择、调用和<strong>内联，</strong></li>
<li>如果arrays数组中不同类型的对象很多，就势必会对内联缓存产生很大的压力，缓存的大小总是有限的，类型信息的不确定性导致了缓存内容不断被失效和更新，先前优化过的方法也可能被不断替换而无法重复使用。</li>
<li>所以这种<strong>动态类型方法调用的底层问题</strong>终归是<strong>应当在Java虚拟机层次上去解决才最合适</strong>。</li>
<li>因此，在Java虚拟机层面上提供动态类型的直接支持就成为Java平台发展必须解决的问题，</li>
<li>这便是JDK 7时JSR-292提案中<strong>invokedynamic指令</strong>以及 <strong>java.lang.invoke</strong> 包出现的技术背景。</li>
</ul>
<h2 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h2><h3 id="方法句柄："><a href="#方法句柄：" class="headerlink" title="方法句柄："></a>方法句柄：</h3><p>JDK 7时新加入的java.lang.invoke包[1]是JSR 292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。</p>
<p>不妨把方法句柄与C/C++ 中的函数指针（Function Pointer），或者C# 里面的委派（Delegate）互相类比一下来理解。举个例子，，如果我们实现一个带谓词（谓词就是外部传入的排序时比较大小的动作）的排序函数，在C/C++ 中的常用做法时把谓词定义为函数，用函数指针来把谓词传递到排序方法，像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void sort(int list[], const int size, int (*compare)(int, int))</span><br></pre></td></tr></table></figure>

<p>但在Java语言中做不到这一点，没有办法单独把一个函数作为参数进行传递，普遍的做法是  涉及一个带有compare（）方法的Comparetor 接口，以实现这个接口的对象作为参数，例如 Java类库中的Collections：： sort 方法就是这样定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list,Comparator c)</span></span></span><br></pre></td></tr></table></figure>

<p>不过，在拥有方法句柄之后，Java 语言也可以拥有类似于 函数指针或者委托的方法别名这样的工具了，</p>
<p>以下代码演示了方法句柄的基本用法，无论obj 是何种类型（临时定义的ClassA 或者是实现PrintStream接口的实现类 System.out），都可以正确的调用到println（）方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">&quot;icyfenix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即是this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">&quot;println&quot;</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法getPrintlnMH()中实际上是模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。</p>
<p>而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。以此为基础，有了MethodHandle就可以写出类似于C/C++那样的函数声明了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, MethodHandle compare)</span></span></span><br></pre></td></tr></table></figure>

<p>从上面的例子看来，使用MethodHandle并没有多少困难，不过看完它的用法之后，读者大概就会产生疑问，相同的事情，用反射不是早就可以实现了吗？</p>
<p>确实，仅站在Java语言的角度看，MethodHandle在使用方法和效果上与Reflection有众多相似之处。不过，它们也有以下这些区别：</p>
<ol>
<li>Reflection和MethodHandle机制本质上都是在模拟方法调用，但是<strong>Reflection是在模拟Java代码层次的方法调用</strong>，而<strong>MethodHandle是在模拟字节码层次的方法调用</strong>。在MethodHandles.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual（以及<br>invokeinterface）和invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。</li>
<li>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是<strong>方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息</strong>。而后者仅包含<strong>执行该方法的相关信息</strong>。用开发人员通俗的话来讲，<strong>Reflection是重量级，而MethodHandle是轻量级。</strong></li>
<li>由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还在继续完善中），而通过<strong>反射去调用方法则几乎不可能直接去实施各类调用点优化措施</strong>。</li>
<li>MethodHandle与Reflection除了上面列举的区别外，最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度看”之后：<strong>Reflection API的设计目标是只为Java语言服务的</strong>，而<strong>MethodHandle则设计为可服务于所有Java虚拟机之上的语言，其中也包括了Java语言而已</strong>，而且Java在这里并不是主角。</li>
</ol>
<h2 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h2><p>了JDK 7为了更好地支持动态类型语言，引入了第五条方法调用的字节码指令invokedynamic，</p>
<ul>
<li>某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke<em>”指令方法（**</em>invokevirtual<strong>、</strong>invokespecial<strong>、**<em>invokestatic</em></strong>、**<em>invokeinterface**</em>））分派规则完全固化在虚拟机之中的问题，把<strong>如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中</strong>，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。</li>
<li>而且，它们两者的思路也是可类比的，都是为了达成同一个目的，只是一个用上层代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。因此，如果前面MethodHandle的例子看懂了，相信理解invokedynamic指令并不困难。</li>
</ul>
<ul>
<li>每一处含有invokedynamic指令的位置都被称作“<strong>动态调用点（Dynamically-Computed Call Site）</strong>”，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是<strong>变为JDK 7时新加入的CONSTANT_InvokeDynamic_info常量</strong>，从这个新常量中可以得到3项信息：<strong>引导方法</strong><br><strong>（Bootstrap Method，该方法存放在新增的BootstrapMethods属性中）、方法类型（MethodType）和名称。</strong></li>
<li>引导方法是有固定的参数，并且返回值规定是java.lang.invoke.CallSite对象，这个对象代表了真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用到要执行的目标方法上</li>
</ul>
<p>代码清单8-13所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeDynamicTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        INDY_BootstrapMethod().invokeExact(<span class="string">&quot;icyfenix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello String:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">BootstrapMethod</span><span class="params">(MethodHandles.Lookup lookup, String name, MethodType mt)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(lookup.findStatic(InvokeDynamicTest.class, name, mt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodType <span class="title">MT_BootstrapMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MethodType</span><br><span class="line">                .fromMethodDescriptorString(</span><br><span class="line">                        <span class="string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>,</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">MH_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookup().findStatic(InvokeDynamicTest.class, <span class="string">&quot;BootstrapMethod&quot;</span>, MT_BootstrapMethod());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">INDY_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        CallSite cs = (CallSite) MH_BootstrapMethod().invokeWithArguments(lookup(), <span class="string">&quot;testMethod&quot;</span>,</span><br><span class="line">                MethodType.fromMethodDescriptorString(<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> cs.dynamicInvoker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>前文提到过，由于**<em>invokedynamic**</em>指令面向的主要服务对象并非Java语言，而是<strong>其他Java虚拟机之上的其他动态类型语言</strong>，因此，光靠Java语言的<br>编译器Javac的话，在JDK 7时甚至还完全没有办法生成带有invokedynamic指令的字节码（曾经有一个java.dyn.InvokeDynamic的语法糖可以实现，但后来被取消了），</p>
</li>
<li><p>而到JDK 8引入了Lambda表达式和接口默认方法后，Java语言才算享受到了一点invokedynamic指令的好处，但用Lambda来解释invokedynamic指令运作就比较别扭，也无法与前面MethodHandle的例子对应类比，</p>
</li>
<li><p>所以笔者采用一些变通的办法：John Rose（JSR 292的负责人，以前Da Vinci Machine Project的Leader）编写过一个把程序的字节码转换为使用invokedynamic的简单工具<strong>INDY</strong>[1]来完成这件事，我们要使用这个工具来产生最终需要的字节码，</p>
</li>
<li><p>因此代码清单8-13中的方法名称不能随意改动，更不能把几个方法合并到一起写，因为它们是要被INDY工具读取的</p>
</li>
<li><p>把上面的代码编译，再使用INDY转换后重新生成的字节码如代码清单8-14所示,使用javap输出</p>
</li>
</ul>
<p>代码清单8-14　InvokeDynamic指令演示（2）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    #121 = NameAndType #33:#30 // testMethod:(Ljava/lang/String;)V</span><br><span class="line">    #123 = InvokeDynamic #0:#121 // #0:testMethod:(Ljava/lang/String;)V</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span> <span class="keyword">throws</span> java.lang.Throwable</span>;</span><br><span class="line">	Code:</span><br><span class="line">		stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">            0: ldc #23 // String abc</span><br><span class="line">            2: invokedynamic #123, 0 // InvokeDynamic #0:testMethod: (Ljava/lang/String;)V   </span><br><span class="line">            <span class="number">7</span>: nop</span><br><span class="line">            <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.invoke.<span class="function">CallSite <span class="title">BootstrapMethod</span><span class="params">(java.lang.invoke.Method Handles$Lookup, java.lang.String, </span></span></span><br><span class="line"><span class="function"><span class="params">	Code:</span></span></span><br><span class="line"><span class="function"><span class="params">		stack=<span class="number">6</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">0</span>: new #<span class="number">63</span> // class java/lang/invoke/ConstantCallSite</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">3</span>: dup</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">4</span>: aload_0</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">5</span>: ldc #<span class="number">1</span> // class org/fenixsoft/InvokeDynamicTest</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">7</span>: aload_1</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">8</span>: aload_2</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">9</span>: invokevirtual #<span class="number">65</span> // Method java/lang/invoke/MethodHandles$ Lookup.findStatic:(Ljava/lang/Class;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">12</span>: invokespecial #<span class="number">71</span> // Method java/lang/invoke/ConstantCallSite. <span class="string">&quot;&lt;init&gt;&quot;</span>:(Ljava/lang/invoke/MethodHandle;)</span></span></span><br><span class="line"><span class="function">            15: areturn</span></span><br></pre></td></tr></table></figure>

<p>从main()方法的字节码中可见，原本的方法调用指令已经被替换为invokedynamic了，它的参数为第123项常量（第二个值为0的参数在虚拟机中不会直接用到，这与invokeinterface指令那个的值为0的参数一样是占位用的，目的都是为了给常量池缓存留出足够的空间）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">2: invokedynamic #123, 0 // InvokeDynamic #0:testMethod:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>

<p>从常量池中可见，第123项常量显示“#123=InvokeDynamic#0：</p>
<ul>
<li>#121”说明它是一项CONSTANT_InvokeDynamic_info类型常量，常量值中前面“#0”代表引导方法取Bootstrap Methods属性表的第0项（javap没有列出属性表的具体内容，不过示例中仅有一个引导方法，即BootstrapMethod()），</li>
<li>而后面的“#121”代表引用第121项类型为CONSTANT_NameAndType_info的常量，从这个常量中可以获取到方法名称和描述符，即后面输出的“testMethod：<br>(Ljava/lang/String；)V”。</li>
</ul>
<p>再看BootstrapMethod()，这个方法在Java源码中并不存在，是由INDY产生的，但是它的字节码很容易读懂，</p>
<ul>
<li>所有逻辑都是调用MethodHandles$Lookup的findStatic()方法，产生testMethod()方法的MethodHandle，</li>
<li>然后用它创建一个ConstantCallSite对象。</li>
<li>最后，这个对象返回给invokedynamic指令实现对testMethod()方法的调用，invokedynamic指令的调用过程到此就宣告完成了。</li>
</ul>
<h2 id="实战：掌控方法分派规则"><a href="#实战：掌控方法分派规则" class="headerlink" title="实战：掌控方法分派规则"></a>实战：掌控方法分派规则</h2><p><strong>invokedynamic</strong>指令与此前4条传统的“invoke*”指令的最大区别就是它的<strong>分派逻辑不是由虚拟机决定的</strong>，而是<strong>由程序员决定</strong>。</p>
<p>在介绍Java虚拟机动态语言支持的最后一节中，笔者希望通过一个简单例子（如代码清单8-15所示），帮助读者理解程序员可以掌控方法分派规则之后，我们能做什么以前无法做到的事情。</p>
<p>代码清单8-15　方法调用问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 请读者在这里填入适当的代码（不能修改其他地方的代码）</span></span><br><span class="line">			<span class="comment">// 实现调用祖父类的thinking()方法，打印&quot;i am grandfather&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_1().<span class="function">new <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java程序中，可以通过“super”关键字很方便地调用到父类中的方法，但如果要访问祖类的方法呢？不妨自己思考一下，在JDK 7之前有没有办法解决这<br>个问题。</p>
<p>在拥有invokedynamic和java.lang.invoke包之前，使用纯粹的Java语言很难处理这个问题（使用ASM等字节码工具直接生成字节码当然还是可以处理的，但这已经是在字节码而不是Java语言层面来解决问题了），原因是在Son类的thinking()方法中根本无法获取到一个实际类型是GrandFather的对象引用，而invokevirtual指令的分派逻辑是固定的，只能按照方法接收者的实际类型进行分派，这个逻辑完全固化在虚拟机中，程序员无法改变。</p>
<p>如果是JDK 7 Update 9之前，使用代码清单8-16中的程序就可以直接解决该问题。</p>
<p>代码清单8-16　使用MethodHandle来解决问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">                MethodHandle mh = lookup().findSpecial(GrandFather.class,<span class="string">&quot;thinking&quot;</span>, mt, getClass());</span><br><span class="line">                mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_1().n<span class="function">ew <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<strong>JDK 7 Update 9之前</strong>的HotSpot虚拟机运行，会得到如下运行结果： i am grandfather</p>
<p>ps:  <strong>我试了一下用jdk 9</strong>，运行结果是： i am father，因为: </p>
<ul>
<li>这个逻辑在JDK 7 Update 9之后被视作一个潜在的安全性缺陷修正了，</li>
<li>原因是<strong>必须保证findSpecial()查找方法版本时受到的访问约束</strong>（譬如对访问控制的限制、对参数类型的限制）<strong>应与使用invokespecial指令一样</strong>，两者必须保持精确对等，包括在上面的场景中它只能访问到其直接父类中的方法版本。</li>
<li>所以在JDK 7 Update 10修正之后，运行以上代码只能得到如下结果 : i am father</li>
</ul>
<p>那在新版本的JDK中，上面的问题是否能够得到解决呢？</p>
<ul>
<li>答案是可以的，如果读者去查看MethodHandles.Lookup类的代码，将会发现需要进行哪些访问保护，在该API实现时是预留了后门的。</li>
<li>访问保护是通过一个<strong>allowedModes</strong>的参数来控制，而且这个参数可以被设置成“TRUSTED”来绕开所有的保护措施。尽管这个参数只是在Java类库本身使用，没有开放给外部设置，但我们<strong>通过反射可以轻易打破这种限制</strong>。</li>
<li>由此，我们可以把代码清单8-16中子类的thinking()方法修改为如下所示的代码来解决问题：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFatherTestCase_2</span>.<span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">GrandFatherTestCase_2</span>.<span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">                Field lookupImpl = MethodHandles.Lookup.class.getDeclaredField(<span class="string">&quot;IMPL_LOOKUP&quot;</span>);</span><br><span class="line">                lookupImpl.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                MethodHandle mh = ((MethodHandles.Lookup) lookupImpl.get(<span class="keyword">null</span>)).findSpecial(GrandFather.class,<span class="string">&quot;thinking&quot;</span>, mt, GrandFather.class);</span><br><span class="line">                mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_2().<span class="function">new <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码，在目前所有JDK版本中均可获得如下结果:   i am grandfather</p>
<h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><p>我们来探讨虚拟机是如何执行方法里面的字节码指令的。许多Java虚拟机的执行引擎在执行Java代码的时候都有<strong>解释执行（通过解释器执行）</strong>和 <strong>编译执行（通过即时编译器产生本地代码执行）</strong>两种选择，在本节中，我们将会分析在概念模型下的Java虚拟机解释执行字节码时，其执行引擎是如何工作的。</p>
<p>笔者在本章多次强调了“概念模型”，是因为实际的虚拟机实现，譬如HotSpot的模板解释器工作的时候，并不是按照下文中的动作一板一眼地进行机械式计算，而是动态产生每条字节码对应的汇编代码来运行，这与概念模型中执行过程的差异很大，但是结果却能保证是一致的。</p>
<h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><ul>
<li>Java语言经常被人们定位为“解释执行”的语言，在Java初生的JDK 1.0时代，这种定义还算是比较准确的，</li>
<li>但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事。</li>
<li>再后来，Java也发展出可以直接生成本地代码的编译器（如Jaotc、GCJ[1]，Excelsior JET），而C/C++语言也出现了通过解释器执行的版本（如<br>CINT[2]），</li>
<li>这时候再笼统地说“解释执行”，对于整个Java语言来说就成了几乎是没有意义的概念，</li>
<li>只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较合理确切。</li>
</ul>
<ul>
<li>无论是解释还是编译，也无论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅读、理解，然后获得执行能力。</li>
<li>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过图8-4中的各个步骤。</li>
<li>如果读者对大学编译原理的相关课程还有印象的话，很容易就会发现图8-4中下面的那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程；而中间的那条分支，自然就是解释执行的过程。</li>
</ul>
<p><img src="/uploads/jvm/11diapatch/compile.png"></p>
<p>如今，基于物理机、Java虚拟机，或者是非Java的其他高级语言虚拟机（HLLVM）的代码执行过程，大体上都会遵循这种符合现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树（Abstract Syntax Tree，AST）。</p>
<ul>
<li>对于一门具体语言的实现来说，词法、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。</li>
<li>也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的JavaScript执行引擎。</li>
</ul>
<p>在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p>
<h2 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h2><ul>
<li><p>Javac编译器输出的字节码指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作</p>
</li>
<li><p>与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，如果说得更通俗一些就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作</p>
</li>
</ul>
<h3 id="基于栈的指令集与基于寄存器的指令集区别："><a href="#基于栈的指令集与基于寄存器的指令集区别：" class="headerlink" title="基于栈的指令集与基于寄存器的指令集区别："></a>基于栈的指令集与基于寄存器的指令集区别：</h3><p>举个最简单的例子，分别使用这两种指令集去计算“1+1”的结果</p>
<h4 id="基于栈的指令集："><a href="#基于栈的指令集：" class="headerlink" title="基于栈的指令集："></a>基于栈的指令集：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>

<p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中。这种指令流中的指令通常都是不带参数的，使用操作数栈中的数据作为指令的运算输入，指令的运算结果也存储在操作数栈之中。</p>
<h4 id="基于寄存器的指令集"><a href="#基于寄存器的指令集" class="headerlink" title="基于寄存器的指令集:"></a>基于寄存器的指令集:</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">add eax, 1</span><br></pre></td></tr></table></figure>

<p>mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。这种二地址指令是x86指令集中的主流，每个指令都包含两个单独的输入参数，依赖于寄存器来访问和存储数据。</p>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul>
<li><p>基于栈的指令集主要优点是可移植，</p>
</li>
<li><p>因为寄存器由硬件直接提供[2]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束，</p>
</li>
<li><p>栈架构的指令集还有一些其他的优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编<br>译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）等。</p>
</li>
<li><p>栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些，所有主流物理机的指令集都是寄存器架构[3]也从侧面印证了这点</p>
</li>
<li><p>在解释执行时，栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。因此由于指令数量和内存访问的原因，导致了栈架构指令集的执行速度会相对慢上一点。</p>
</li>
</ul>
<h2 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="　基于栈的解释器执行过程"></a>　基于栈的解释器执行过程</h2><p>代码清单8-17　一段简单的算术代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>;</span><br><span class="line">	Code:</span><br><span class="line">        Stack=<span class="number">2</span>, Locals=<span class="number">4</span>, Args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: bipush <span class="number">100</span></span><br><span class="line">        <span class="number">2</span>: istore_1</span><br><span class="line">        <span class="number">3</span>: sipush <span class="number">200</span></span><br><span class="line">        <span class="number">6</span>: istore_2</span><br><span class="line">        <span class="number">7</span>: sipush <span class="number">300</span></span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: iload_1</span><br><span class="line">        <span class="number">12</span>: iload_2</span><br><span class="line">        <span class="number">13</span>: iadd</span><br><span class="line">        <span class="number">14</span>: iload_3</span><br><span class="line">        <span class="number">15</span>: imul</span><br><span class="line">        <span class="number">16</span>: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javap提示这段代码需要<strong>深度为2的操作数栈</strong>和<strong>4个变量槽</strong>的局部变量空间，笔者就根据这些信息画了图8-5至图8-11共7张图片，来描述代码清单8-13执行过程中的代码、操作数栈和局部变量表的变化情况。</p>
<p><img src="/uploads/jvm/12bytecodeEngineer/01bipush.png"></p>
<ol>
<li>首先，执行偏移地址为0的指令，Bipush指令的作用是将单字节的整型常量值（-128～127）推入操作数栈顶，跟随有一个参数，指明推送的常量值，这里是100。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/02istore.png"></p>
<ol start="2">
<li>执行偏移地址为2的指令，<strong>istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量槽中</strong>。后续4条指令（直到偏移为11的指令为止）都是做一样的事情，也就是在对应代码中把变量a、b、c赋值为100、200、300。这4条指令的图示略过。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/03iload.png"></p>
<ol start="3">
<li>执行偏移地址为11的指令，<strong>iload_1指令的作用是将局部变量表第1个变量槽中的整型值复制到操作数栈顶</strong>。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/04iload2.png"></p>
<ol start="4">
<li>执行偏移地址为12的指令，iload_2指令的执行过程与iload_1类似，<strong>把第2个变量槽的整型值入栈</strong>。<br>画出这个指令的图示主要是为了显示下一条iadd指令执行前的堆栈状况。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/05iadd.png"></p>
<ol start="5">
<li>执行偏移地址为13的指令，<strong>iadd指令的作用是将操作数栈中头两个栈顶元素出栈，做整型加法，</strong><br><strong>然后把结果重新入栈。</strong>在iadd指令执行完毕后，栈中原有的100和200被出栈，<strong>它们的和300被重新入栈</strong>。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/06iload3.png"></p>
<ol start="6">
<li>执行偏移地址为14的指令，iload_3指令<strong>把存放在第3个局部变量槽中的300入栈到操作数栈中</strong>。这时操作数栈为两个整数300。下一条指令imul是将操作数栈中头两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，与iadd完全类似，所以笔者省略图示。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/07ireturn.png"></p>
<ol start="7">
<li>执行偏移地址为16的指令，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶<br>的整型值返回给该方法的调用者。到此为止，这段方法执行结束。</li>
</ol>
<p>再次强调上面的执行过程仅仅是一种<strong>概念模型</strong>，虚拟机最终会对执行过程做出<strong>一系列优化</strong>来提高性能，实际的运作过程并不会完全符合概念模型的描述。</p>
<p>更确切地说，实际情况会和上面描述的概念模型差距非常大，差距产生的根本原因是<strong>虚拟机中解析器和即时编译器都会对输入的字节码进行优化</strong>，即使解释器中也不是按照字节码指令去逐条执行的。例如在HotSpot虚拟机中，就有很多以“fast_”开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，即时编译器的优化手段则更是花样繁多</p>
<p>我们从这段程序的执行中也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径，符合我们在前面分析的特点。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>动态类型语言支持</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-13-类加载及执行子系统的案例与实战</title>
    <url>/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="类加载及执行子系统的案例与实战"><a href="#类加载及执行子系统的案例与实战" class="headerlink" title="类加载及执行子系统的案例与实战"></a>类加载及执行子系统的案例与实战</h1><p>在Class文件格式与执行引擎这部分里，用户的程序能直接参与的内容并不太多，Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变.</p>
<p>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路，这些思路后来成为许多常用功能和程序实现的基础。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="Tomcat：正统的类加载器架构"><a href="#Tomcat：正统的类加载器架构" class="headerlink" title="Tomcat：正统的类加载器架构"></a>Tomcat：正统的类加载器架构</h3><p>主流的Java Web服务器，如Tomcat、Jetty、WebLogic、WebSphere或其他笔者没有列举的服务器，都实现了自己定义的类加载器，而且一般还都不止一个。因为一个功能健全的Web服务器，都要解决如下的这些问题：</p>
<ol>
<li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现<strong>相互隔离</strong>。这是最基本的需求，两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求每个类库在一个服务器中只能有一份，服务器应当能够<strong>保证两个独立应用程序的类库可以互相独立使用。</strong></li>
<li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。这个需求与前面一点正好相反，但是也很常见，例如用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费——这主要倒不是浪费磁盘空间的问题，而是指类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方 法区就会很容易出现过度膨胀的风险。</li>
<li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。目前，有许多主流的JavaWeb服务器自身也是使用Java语言来实现的。因此服务器本身也有类库依赖的问题，一般来说，基于安全考虑，服务器所使用的类库应该与应用程序的类库互相独立。</li>
<li>支持JSP应用的Web服务器，十有八九都需要支持HotSwap功能。我们知道JSP文件最终要被编译成Java的Class文件才能被虚拟机执行，但JSP文件由于其纯文本存储的特性，被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的“优势”来看待，因此“主流”的Web服务器都会支持JSP生成类的热替换，当然也有“非主流”的，如运行在生产模式（Production Mode）下的WebLogic服务器默认就不会处理JSP文件的变化。</li>
</ol>
<p>由于存在上述问题，在部署Web应用时，单独的一个ClassPath就不能满足需求了，所以各种Web服务器都不约而同地<strong>提供了好几个有着不同含义的ClassPath路径</strong>供用户存放第三方类库，这些路径一般会以“lib”或“classes”命名。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。现在就以Tomcat服务器[1]为例，与读者一同分析Tomcat具体是如何规划用户类库结构和类加载器的。</p>
<p>在Tomcat目录结构中，可以设置3组目录（/<strong>common</strong>/<em>、/<strong>server</strong>/<em>和/</em></em>shared**/<em>，但默认不一定是开放的，可能只有/lib/<em>目录存在）用于存放Java类库，另外还应该加上Web应用程序自身的“/</em></em>WEBINF**/*”目录，一共4组。把Java类库放置在这4组目录中，每一组都有独立的含义，分别是：</p>
<ul>
<li>放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</li>
<li>放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</li>
<li>放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li>
<li>放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li>
</ul>
<p>为了支持这套目录结构，并对目录里面的类库进行加载和隔离，<strong>Tomcat自定义了多个类加载器</strong>，这些类加载器按照经典的双亲委派模型来实现，其关系如图9-1所示。</p>
<p><img src="/uploads/jvm/23-tomcatClassLoader.png"></p>
<ul>
<li>灰色背景的3个类加载器是JDK（以JDK 9之前经典的三层类加载器为例）默认提供的类加载器，这3个加载器的作用在第7章中已经介绍过了。</li>
<li>而Common类加载器、Catalina类加载器（也称为Server类加载器）、Shared类加载器和Webapp类加载器则是Tomcat自己定义的类加载器，它们分别加<br>载/common/*、/server/*、/shared/*和/WebApp/WEB-INF/*中的Java类库。</li>
<li>其中WebApp类加载器和JSP类加载器通常还会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个JasperLoader类加载器。</li>
</ul>
<p>从图9-1的委派关系中可以看出，</p>
<ul>
<li>Common类加载器能加载的类都可以被Catalina类加载器和Shared类加载器使用，</li>
<li>而Catalina类加载器和Shared类加载器自己能加载的类则与对方相互隔离。</li>
<li>WebApp类加载器可以使用Shared类加载器加载到的类，但各个WebApp类加载器实例之间相互隔离。</li>
<li>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class文件，它存在的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的JSP类加载器来实现JSP文件的HotSwap功能。</li>
</ul>
<p>本例中的类加载结构在<strong>Tomcat 6以前</strong>是它默认的类加载器结构，在Tomcat 6及之后的版本简化了默认的目录结构，只有指定了<strong>tomcat/conf/catalina.properties</strong>配置文件的<strong>server.loader和share.loader</strong>项后才会真正建立Catalina类加载器和Shared类加载器的实例，否则会用到这两个类加载器的地方都会用Common类加载器的实例代替，</p>
<p>而默认的配置文件中并没有设置这两个loader项，所以Tomcat 6之后也顺理成章地把/common、/server和/shared这3个目录默认合并到一起变成1个/lib目录，这个目录里的类库相当于以前/common目录中类库的作用，是Tomcat的开发团队为了简化大多数的部署场景所做的一项易用性改进。</p>
<p>如果默认设置不能满足需要，用户可以通过修改配置文件指定server.loader和share.loader的方式重新启用原来完整的加载器架构。</p>
<h4 id="Tomcat类加载过程"><a href="#Tomcat类加载过程" class="headerlink" title="Tomcat类加载过程"></a>Tomcat类加载过程</h4><p>（1）在Tomcat启动时，会创建一系列的类加载器，在其主类Bootstrap的初始化过程中，会先初始化classloader，然后将其绑定到Thread中。 </p>
<p>（2）其中initClassLoaders方法，会根据catalina.properties的配置，创建相应的classloader。由于默认只配置了common.loader属性，所以其中只会创建一个出来</p>
<p>（3）然后，当一个应用启动的时候，会为其创建对应的WebappClassLoader。此时会将commonClassLoader设置为其parent</p>
<p>（4）在加载时，与java双亲委托机制不同，默认是子优先，也就是先用子加载器加载但是保证Java的基础类不允许其重新加载，以及servlet-api也不允许重新加载。</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>那么笔者不妨再提一个问题让各位读者思考一下：前面曾经提到过一个场景，如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring<br>放到Common或Shared目录下让这些程序共享。Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中的。那么被Common类加载器或Shared类加载器加载的Spring如何访问并不在其加载范围内的用户程序呢？</p>
<h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p><strong>当然就是前片所说的使用线程上下文类加载器，当我们在spring的配置文件中通过类来创建对象，spring都是使用线程上下文类加载器来加载了，默认设置为WebAppClassLoader，所以当在web应用程序内，spring通过线程上下文类加载器使用WebAppClassLoader来加载bean</strong></p>
<p>答案明显是使用线程上下文类加载器来实现的啊！仔细看源码你会发现，spring加载类所用的classloader都是通过Thread.currentThread().getContextClassLoader()来获取的，而当线程创建时会默认 setContextClassLoader(AppClassLoader)，即spring中始终可以获取到这个AppClassLoader(在tomcat里就是WebAppClassLoader)子类加载器来加载bean，以后任何一个线程都可以通过getContextClassLoader()获取到WebAppClassLoader来getbean了</p>
<h3 id="OSGi：灵活的类加载器架构"><a href="#OSGi：灵活的类加载器架构" class="headerlink" title="　OSGi：灵活的类加载器架构"></a>　OSGi：灵活的类加载器架构</h3><p>曾经在Java程序社区中流传着这么一个观点：“学习Java EE规范，推荐去看JBoss源码；学习类加载器的知识，就推荐去看OSGi源码。</p>
<ul>
<li><p>OSGi的Bundle类加载器之间只有规则，没有固定的委派关系。例如，某个Bundle声明了一个它依赖的Package，如果有其他Bundle声明了发布这个Package后，那么所有对这个Package的类加载动作都会委派给发布它的Bundle类加载器去完成。不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个Package和Class的时候，才会根据Package导入导出定义来构造Bundle间的委派和依赖。</p>
</li>
<li><p>另外，一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控制访问范围。如果一个类存在于Bundle的类库中但是没有被Export，那么这个Bundle的类加载器能找到这个类，但不会提供给其他Bundle使用，而且OSGi框架也不会把其他Bundle的类加载请求分配给这个Bundle来<br>处理。</p>
</li>
</ul>
<p>我们可以举一个更具体些的简单例子来解释上面的规则：</p>
<p>假设存在Bundle A、Bundle B、BundleC3个模块，并且这3个Bundle定义的依赖关系如下所示。</p>
<ul>
<li><p>Bundle A：声明发布了packageA，依赖了java.<em>的包；</em></p>
</li>
<li><p>*Bundle B：声明依赖了packageA和packageC，同时也依赖了java.*的包；</p>
</li>
<li><p>Bundle C：声明发布了packageC，依赖了packageA。</p>
</li>
</ul>
<p>那么，这3个Bundle之间的类加载器及父类加载器之间的关系如图9-2所示。</p>
<p><img src="/uploads/jvm/24-OSGiClassLoader.png"></p>
<p>由于没有涉及具体的OSGi实现，图9-2中的类加载器都没有指明具体的加载器实现，它只是一个<br>体现了加载器之间关系的概念模型，并且只是体现了OSGi中最简单的加载器委派关系。一般来说，在<br>OSGi里，加载一个类可能发生的查找行为和委派关系会远远比图9-2中显示的复杂，类加载时可能进<br>行的查找规则如下：</p>
<ul>
<li>以java.*开头的类，委派给父类加载器加载。</li>
<li>否则，委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的Classpath，使用自己的类加载器加载。</li>
<li>否则，查找是否在自己的Fragment Bundle中，如果是则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
<p>从图9-2中还可以看出，在OSGi中，加载器之间的关系不再是双亲委派模型的树形结构，而是已经进一步发展成一种更为复杂的、运行时才能确定的网状结构。这种网状的类加载器架构在带来更优秀的灵活性的同时，也可能会产生许多新的隐患</p>
<p>代码模块之间的依赖关系错综复杂，勉强分离出各个模块的Bundle后，发现在高并发环境下经常出现死锁。我们很容易就找到了死锁的原因：如果出现了Bundle A依赖Bundle B的Package B，而Bundle B又依赖了Bundle A的Package A，这两个Bundle进行类加载时就有很高的概率发生死锁。具体情况是当Bundle A加载Package B的类时，首先需要锁定当前类加载器的实例对象（java.lang.ClassLoader.loadClass()是一个同步方法），然后把请求委派给Bundle B的加载器处理，但如果这时Bundle B也正好想加载Package A的类，它会先锁定自己的加载器再去请求Bundle A的加载器处理，这样两个加载器都在等待对方处理自己的请求，而对方处理完之前自己又一直处于同步锁定的状态，因此它们就互相死锁，永远无法完成加载请求了。</p>
<p>在JDK 7时才终于出现了JDK层面的解决方案，类加载器架构进行了一次专门的升级，在ClassLoader中增加了registerAsParallelCapable方法对可并行的类加载进行注册声明，把锁的级别从ClassLoader对象本身，降低为要加载的类名这个级别，目的是从底层避免以上这类死锁出现的可能。</p>
<p>总体来说，OSGi描绘了一个很美好的模块化开发的目标，而且定义了实现这个目标所需的各种服务，同时也有成熟框架对其提供实现支持。对于单个虚拟机下的应用，从开发初期就建立在OSGi上是一个很不错的选择，这样便于约束依赖。但并非所有的应用都适合采用OSGi作为基础架构，OSGi在提供强大功能的同时，也引入了额外而且非常高的复杂度，带来了额外的风险。</p>
<h3 id="字节码生成技术与动态代理的实现"><a href="#字节码生成技术与动态代理的实现" class="headerlink" title="字节码生成技术与动态代理的实现"></a>字节码生成技术与动态代理的实现</h3><p>在Java世界里面除了Javac和字节码类库外，使用到字节码生成的例子比比皆是，如Web服务器中的JSP编译器，编译时织入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度。我们选择其中相对简单的动态代理技术来讲解字节码生成技术是如何影响程序运作的。</p>
<p>相信许多Java开发人员都使用过动态代理，即使没有直接使用过java.lang.reflect.Proxy或实现过java.lang.reflect.InvocationHandler接口，应该也用过Spring来做过Bean的组织管理。如果使用过Spring，那大多数情况应该已经不知不觉地用到动态代理了，因为如果Bean是面向接口编程，那么在Spring内部都是通过动态代理的方式来对Bean进行增强的。动态代理中所说的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的，它的优势不在于省去了编写代理类那一点编码工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。</p>
<p>代码清单9-1演示了一个最简单的动态代理的用法，原始的代码逻辑是打印一句“hello world”，代理类的逻辑是在原始类方法执行前打印一句“welcome”。我们先看一下代码，然后再分析JDK是如何做到的。</p>
<p>代码清单9-1　动态代理的简单示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">        System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">welcome</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>



<p>在上述代码里，唯一的“黑匣子”就是Proxy::newProxyInstance()方法，除此之外再没有任何特殊之处。这个方法返回一个实现了IHello的接口，并且代理了new Hello()实例行为的对象。跟踪这个方法的源码，可以看到程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作，前面的步骤并不是我们关注的重点，这里只分析它最后调用sun.misc.ProxyGenerator::generateProxyClass()方法来完成生成字节码的动作，这个方法会在运行时产生一个描述代理类的字节码byte[]数组.磁盘中将会产生一个名为“$Proxy0.class”的代理类Class文件，反编译后可以发现</p>
<p>这个代理类的实现代码也很简单，它为传入接口中的每一个方法，以及从java.lang.Object中继承来的equals()、hashCode()、toString()方法都生成了对应的实现，并且统一调用了InvocationHandler对象的invoke()方法（代码中的“this.h”就是父类Proxy中保存的InvocationHandler实例变量）来实现这些方法的内容，各个方法的区别不过是传入的参数和Method对象有所不同而已，所以无论调用动态代理的哪一个方法，实际上都是在执行InvocationHandler::invoke()中的代理逻辑。</p>
<h3 id="Backport工具：Java的时光机器"><a href="#Backport工具：Java的时光机器" class="headerlink" title="Backport工具：Java的时光机器"></a>Backport工具：Java的时光机器</h3><p>在Java世界里，每一次JDK大版本的发布，都会伴随着规模不等或大或小的技术革新，而对Java程序编写习惯改变最大的，肯定是那些对Java语法做出重大改变的版本，譬如JDK 5时加入的自动装箱、泛型、动态注解、枚举、变长参数、遍历循环（foreach循环）；譬如JDK 8时加入的Lambda表达式、Stream API、接口默认方法等。事实上在没有这些语法特性的年代，Java程序也照样能写，但是现在回头看来，上述每一种语法的改进几乎都是“必不可少”的，如同用惯了32寸液晶、4K分辨率显示器的程序员，就很难再在19寸显示器、1080P分辨率的显示器上编写代码了。</p>
<p>但假如公司“不幸”因为要保护现有投资、维持程序结构稳定等，必须使用JDK 5或者JDK 8以前的版本呢？幸好，我们没有办法把19寸显示器变成32寸的，但却可以跨越JDK版本之间的沟壑，把高版本JDK中编写的代码放到低版本JDK环境中去部署使用。为了解决这个问题，一种名为“Java逆向移植”的工具（Java Backporting Tools）应运而生，Retrotranslator[1]和Retrolambda是这类工具中的杰出代表。</p>
<p><strong>Retrotranslator</strong>的作用是将JDK 5编译出来的Class文件转变为可以在JDK 1.4或1.3上部署的版本，它能很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK 5中新增的集合改进、并发包及对泛型、注解等的反射操作。</p>
<p><strong>Retrolambda</strong>的作用与Retrotranslator是类似的，目标是将JDK 8的Lambda表达式和try-resources语法转变为可以在JDK5、JDK 6、JDK 7中使用的形式，同时也对接口默认方法提供了有限度的支持。</p>
<p>要想知道Backporting工具如何在旧版本JDK中模拟新版本JDK的功能，首先要搞清楚JDK升级中会提供哪些新的功能。JDK的每次升级新增的功能大致可以分为以下五类：</p>
<ol>
<li><p>对Java类库API的代码增强。譬如JDK 1.2时代引入的java.util.Collections等一系列集合类，在JDK 5时代引入的java.util.concurrent并发包、在JDK 7时引入的java.lang.invoke包，等等。</p>
</li>
<li><p>在前端编译器层面做的改进。这种改进被称作语法糖，如自动装箱拆箱，实际上就是Javac编译器在程序中使用到包装对象的地方自动插入了很Integer.valueOf()、Float.valueOf()之类的代码；变长参数在编译之后就被自动转化成了一个数组来完成参数传递；泛型的信息则在编译阶段就已经被擦<br>除掉了（但是在元数据中还保留着），相应的地方被编译器自动插入了类型转换代码。</p>
</li>
<li><p>需要在字节码中进行支持的改动。如JDK 7里面新加入的语法特性——动态语言支持，就需要在虚拟机中新增一条invokedynamic字节码指令来实现相关的调用功能。不过字节码指令集一直处于相对稳定的状态，这种要在字节码层面直接进行的改动是比较少见的。</p>
</li>
<li><p>需要在JDK整体结构层面进行支持的改进，典型的如JDK 9时引入的Java模块化系统，它就涉及了JDK结构、Java语法、类加载和连接过程、Java虚拟机等多个层面。</p>
</li>
<li><p>集中在虚拟机内部的改进。如JDK 5中实现的JSR-133[4]规范重新定义的Java内存模型（JavaMemory Model，JMM），以及在JDK 7、JDK 11、JDK 12中新增的G1、ZGC和Shenandoah收集器之类的改动，这种改动对于程序员编写代码基本是透明的，只会在程序运行时产生影响。</p>
</li>
</ol>
<p>上述的5类新功能中，逆向移植工具能比较完美地模拟了前两类，从第3类开始就逐步深入地涉及了直接在虚拟机内部实现的改进了，这些功能一般要么是逆向移植工具完全无能为力，要么是不能完整地或者在比较良好的运行效率上完成全部模拟。想想这也挺合理的，如果在语法糖和类库层面可以完美解决的问题，Java虚拟机设计团队也没有必要舍近求远地改动处于JDK底层的虚拟机嘛。</p>
<ul>
<li>在能够较好模拟的前两类功能中，第一类模拟相对更容易实现一些，如JDK 5引入的java.util.concurrent包，实际是由多线程编程的大师Doug Lea开发的一套并发包，在JDK 5出现之前就已经存在（那时候名字叫作dl.util.concurrent，引入JDK时由作者和JDK开发团队共同进行了一些改进），所以要在旧的JDK中支持这部分功能，以独立类库的方式便可实现。Retrotranslator中就附带了一个名叫“backport-util-concurrent.jar”的类库（由另一个名为“Backport to JSR166”的项目所提供）来代替JDK 5的并发包。</li>
<li>至于第二类JDK在编译阶段进行处理的那些改进，Retrotranslator则是使用ASM框架直接对字节码进行处理。由于组成Class文件的字节码指令数量并没有改变，所以无论是JDK 1.3、JDK 1.4还是JDK5，能用字节码表达的语义范围应该是一致的。当然，肯定不会是简单地把Class的文件版本号从49.0改回48.0就能解决问题了，虽然字节码指令的数量没有变化，但是元数据信息和一些语法支持的内容还是要做相应的修改。</li>
</ul>
<p>以枚举为例，尽管在JDK 5中增加了enum关键字，但是Class文件常量池的CONSTANT_Class_info类型常量并没有发生任何语义变化，仍然是代表一个类或接口的符号引用，没有加入枚举，也没有增加过“CONSTANT_Enum_info”之类的“枚举符号引用”常量。所以使用enum关键字定义常量，尽管从Java语法上看起来与使用class关键字定义类、使用interface关键字定义接口是同一层次的，但实际上这是由Javac编译器做出来的假象，从字节码的角度来看，枚举仅仅是一个继承于java.lang.Enum、自动生成了values()和valueOf()方法的普通Java类而已。</p>
<p>Retrotranslator对枚举所做的主要处理就是把枚举类的父类从“java.lang.Enum”替换为它运行时类库中包含的“net.sf.retrotranslator.runtime.java.lang.Enum_”，然后再在类和字段的访问标志中抹去ACC_ENUM标志位。当然，这只是处理的总体思路，具体的实现要比上面说的复杂得多。可以想象既然两个父类实现都不一样，values()和valueOf()的方法自然需要重写，常量池需要引入大量新的来自父类的符号引用，这些都是实现细节。</p>
<p>用Retrolambda模拟JDK 8的Lambda表达式属于涉及字节码改动的第三类情况，Java为支持Lambda会用到新的invokedynamic字节码指令，但幸好这并不是必须的，只是基于效率的考量。在JDK 8之前，Lambda表达式就已经被其他运行在Java虚拟机的编程语言（如Scala）广泛使用了，那时候是怎么生成字节码的现在照着做就是，不使用invokedynamic，除了牺牲一点效率外，可行性方面并没有太大的障碍。</p>
<p>Retrolambda的Backport过程实质上就是生成一组匿名内部类来代替Lambda，里面会做一些优化措施，譬如采用单例来保证无状态的Lambda表达式不会重复创建匿名类的对象。有一些Java IDE工具，如IntelliJ IDEA和Eclipse里会包含将此过程反过来使用的功能特性，在低版本Java里<strong>把匿名内部类显示成Lambda语法</strong>的样子，<strong>实际存在磁盘上的源码还是匿名内部类形式的</strong>，只是在IDE里可以把它显示为Lambda表达式的语法，让人阅读起来比较简洁而已。</p>
<h2 id="实战自己动手实现远程执行功能"><a href="#实战自己动手实现远程执行功能" class="headerlink" title="实战自己动手实现远程执行功能"></a>实战自己动手实现远程执行功能</h2><h3 id="痛点："><a href="#痛点：" class="headerlink" title="痛点："></a>痛点：</h3><p>在做程序维护的时候是否遇到过这类情形：排查问题的过程中，想查看内存中的一些参数值，却苦于没有方法把这些值输出到界面或日志中。又或者定位到某个缓存数据有问题，由于缺少缓存的统一管理界面，不得不重启服务才能清理掉这个缓存。类似的需求有一个共同的特点，那就是只要在服务中执行一小段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行临时代码的途径，让人恨不得在服务器上装个后门。这是项目运维中的常见问题，通常解决类问题有<br>以下几种途径：</p>
<h3 id="现存方案："><a href="#现存方案：" class="headerlink" title="现存方案："></a>现存方案：</h3><ol>
<li>可以使用BTrace[1]这类JVMTI工具去动态修改程序中某一部分的运行代码，这部分在第4章有简要的介绍，类似的JVMTI工具还有阿里巴巴的Arthas[2]等。</li>
<li>使用JDK 6之后提供了Compiler API，可以动态地编译Java程序，这样虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求是可以得到解决的。</li>
<li>也可以通过“曲线救国”的方式来做到，譬如写一个JSP文件上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个BeanShell Script、JavaScript等的执行引擎（如Mozilla Rhino[3]）去执行动态脚本。</li>
<li>在应用程序中内置动态执行的功能。</li>
</ol>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>首先，在实现“在服务端执行临时代码”这个需求之前，先来明确一下本次实战的具体目标，我们希望最终的产品是这样的：</p>
<ul>
<li>不依赖某个JDK版本才加入的特性（包括JVMTI），能在目前还被普遍使用的JDK中部署，只要是使用JDK 1.4以上的JDK都可以运行。</li>
<li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li>
<li>不侵入原有程序，即无须改动原程序的任何代码。也不会对原有程序的运行带来任何影响。</li>
<li>考虑到BeanShell Script或JavaScript等脚本与Java对象交互起来不太方便，“临时代码”应该直接支<br>持Java语言。</li>
<li>“临时代码”应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。这里写的是“不需要”而不是“不可以”，当“临时代码”需要引用其他类库时也没有限制，只要服务端程序能使用的类型和接口，临时代码都应当能直接引用。</li>
<li>“临时代码”的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在程序实现的过程中，我们需要解决以下3个问题：</p>
<ul>
<li>如何编译提交到服务器的Java代码？</li>
<li>如何执行编译之后的Java代码？</li>
<li>如何收集Java代码的执行结果？</li>
</ul>
<p>对于第一个问题，我们有两种方案可以选择。</p>
<ol>
<li><p>一种在服务器上编译，在JDK 6以后可以使用Compiler API，在JDK 6以前可以使用tools.jar包（在JAVA_HOME/lib目录下）中的com.sun.tools.Javac.Main类来编译Java文件，它们其实和直接使用Javac命令来编译是一样的。这种思路的缺点是引入了额外的依赖，而且把程序绑死在特定的JDK上了，要部署到其他公司的JDK中还得把tools.jar带上（虽然JRockit和J9虚拟机也有这个JAR包，但它总不是标准所规定必须存在的）。</p>
</li>
<li><p>另外一种思路是直接在客户端编译好，把字节码而不是Java代码传到服务端，这听起来好像有点投机取巧，一般来说确实不应该假定客户端一定具有编译代码的能力，也不能假定客户端就有编译出产品所需的依赖项。但是既然程序员会写Java代码去给服务端排查问题，那么很难想象他的机器上会连编译Java程序的环境都没有。</p>
</li>
</ol>
<p>对于第二个问题：</p>
<p>要执行编译后的Java代码，让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法就可以了（因为不实现任何接口，我们可以借用一下Java中约定俗成的“main()”方法）。但我们还应该考虑得更周全些：一段程序往往不是编写、运行一次就能达到效果，同一个类可能要被反复地修改、提交、执行。另外，提交上去的类要能访问到服务端的其他类库才行。还有就是既然提交的是临时代码，那提交的Java类在执行完后就应当能被卸载和回收掉。</p>
<p>最后一个问题，</p>
<p>我们想把程序往标准输出（System.out）和标准错误输出（System.err）中打印的信息收集起来。但标准输出设备是整个虚拟机进程全局共享的资源，如果使用<br>System.setOut()/System.setErr()方法把输出流重定向到自己定义的PrintStream对象上固然可以收集到输出信息，但也会对原有程序产生影响：会把其他线程向标准输出中打印的信息也收集了。虽然这些并不是不能解决的问题，不过为了达到完全不影响原程序的目的，我们可以采用另外一种办法：直接在执行的类中把对System.out的符号引用替换为我们准备的PrintStream的符号引用，依赖前面学习到的知识，做到这一点并不困难。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="HotSwapClassLoader"><a href="#HotSwapClassLoader" class="headerlink" title="HotSwapClassLoader"></a>HotSwapClassLoader</h4><p>第一个类用于实现“同一个类的代码可以被多次加载”这个需求，即用于解决9.2节列举的第二个问题的HotSwapClassLoader，具体程序如代码清单9-3所示。</p>
<p>HotSwapClassLoader所做的事情仅仅是公开父类（即java.lang.ClassLoader）中的protected方法defineClass()，我们将会使用这个方法把提交执行的Java类的byte[]数组转变为Class对象。HotSwapClassLoader中并没有重写loadClass()或findClass()方法，因此如果不算外部手工调用loadByte()方法的话，这个类加载器的类查找范围与它的父类加载器是完全一致的，在被虚拟机调用时，它会按照双亲委派模型交给父类加载。构造函数中指定为加载HotSwapClassLoader类的类加载器作为父类加载器，<strong>这一步是实现提交的执行代码可以访问服务端引用类库的关键</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 为了多次载入执行类而加入的加载器</span><br><span class="line"> * 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法</span><br><span class="line"> * 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载</span><br><span class="line"> *</span><br><span class="line"> * @author zzm</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HotSwapClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public HotSwapClassLoader() &#123;</span><br><span class="line">        super(HotSwapClassLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class loadByte(byte[] classByte) &#123;</span><br><span class="line">        return defineClass(null, classByte, 0, classByte.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClassModifier-、ByteUtils"><a href="#ClassModifier-、ByteUtils" class="headerlink" title="ClassModifier 、ByteUtils"></a>ClassModifier 、ByteUtils</h4><p>第二个类是实现将java.lang.System替换为我们自己定义的HackSystem类的过程，它直接修改符合Class文件格式的byte[]数组中的常量池部分，将常量池中指定内容的CONSTANT_Utf8_info常量替换为新的字符串，具体代码如下面的代码清单9-4所示。ClassModifier中涉及对byte[]数组操作的部分，主要是将byte[]与int和String互相转换，以及把对byte[]数据的替换操作封装在代码清单9-5所示的ByteUtils中。</p>
<p>经过ClassModifier处理后的byte[]数组才会传给HotSwapClassLoader.loadByte()方法进行类加载，byte[]数组在这里替换符号引用之后，与客户端直接在Java代码中引用HackSystem类再编译生成的Class是完全一样的。这样的实现既避免了客户端编写临时执行代码时要依赖特定的类（不然无法引入HackSystem），又避免了服务端修改标准输出后影响到其他程序的输出。下面我们来看看代码清单9-4和代码清单9-5。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改Class文件，暂时只提供修改常量池常量的功能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassModifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_Utf8_info = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] CONSTANT_ITEM_LENGTH = &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] classByte;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassModifier</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStr 修改前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStr 修改后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] modifyUTF8Constant(String oldStr, String newStr) &#123;</span><br><span class="line">        <span class="keyword">int</span> cpc = getConstantPoolCount();</span><br><span class="line">        <span class="keyword">int</span> offset = CONSTANT_POOL_COUNT_INDEX + u2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpc; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = ByteUtils.bytes2Int(classByte, offset, u1);</span><br><span class="line">            <span class="keyword">if</span> (tag == CONSTANT_Utf8_info) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = ByteUtils.bytes2Int(classByte, offset + u1, u2);</span><br><span class="line">                offset += (u1 + u2);</span><br><span class="line">                String str = ByteUtils.bytes2String(classByte, offset, len);</span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(oldStr)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);</span><br><span class="line">                    <span class="keyword">return</span> classByte;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offset += len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offset += CONSTANT_ITEM_LENGTH[tag];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 常量池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstantPoolCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bytes数组处理工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start + len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>) b[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            n &lt;&lt;= (--len) * <span class="number">8</span>;</span><br><span class="line">            sum = n + sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2Bytes(<span class="keyword">int</span> value, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((value &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b, start, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] string2Bytes(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bytesReplace(<span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)];</span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset);</span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes, offset, replaceBytes.length);</span><br><span class="line">        System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);</span><br><span class="line">        <span class="keyword">return</span> newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="HackSystem"><a href="#HackSystem" class="headerlink" title="HackSystem"></a>HackSystem</h4><p>最后一个类就是前面提到过的用来代替java.lang.System的HackSystem，这个类中的方法看起来不少，但其实除了把out和err两个静态变量改成使用ByteArrayOutputStream作为打印目标的同一个PrintStream对象，以及增加了读取、清理ByteArrayOutputStream中内容的getBufferString()和clearBuffer()方法外，就再没有其他新鲜的内容了。其余的方法全部都来自于System类的public方法，方法名字、参数、返回值都完全一样，并且实现也是直接转调了System类的对应方法而已。保留这些方法的目的，是为了在Sytem被替换成HackSystem之后，保证执行代码中调用的System的其余方法仍然可以继续使用，HackSystem的实现如代码清单9-6所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 为Javaclass劫持java.lang.System提供支持</span><br><span class="line"> * 除了out和err外，其余的都直接转发给System处理</span><br><span class="line"> *</span><br><span class="line"> * @author zzm</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HackSystem &#123;</span><br><span class="line"></span><br><span class="line">    public final static InputStream in &#x3D; System.in;</span><br><span class="line"></span><br><span class="line">    private static ByteArrayOutputStream buffer &#x3D; new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    public final static PrintStream out &#x3D; new PrintStream(buffer);</span><br><span class="line"></span><br><span class="line">    public final static PrintStream err &#x3D; out;</span><br><span class="line"></span><br><span class="line">    public static String getBufferString() &#123;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void clearBuffer() &#123;</span><br><span class="line">        buffer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setSecurityManager(final SecurityManager s) &#123;</span><br><span class="line">        System.setSecurityManager(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SecurityManager getSecurityManager() &#123;</span><br><span class="line">        return System.getSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static long currentTimeMillis() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) &#123;</span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int identityHashCode(Object x) &#123;</span><br><span class="line">        return System.identityHashCode(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面所有的方法都与java.lang.System的名称一样</span><br><span class="line">    &#x2F;&#x2F; 实现都是字节转调System的对应方法</span><br><span class="line">    &#x2F;&#x2F; 因版面原因，省略了其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JavaclassExecuter"><a href="#JavaclassExecuter" class="headerlink" title="JavaclassExecuter"></a>JavaclassExecuter</h4><p>我们来看看最后一个类JavaclassExecuter，它是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。JavaclassExecuter只有一个execute()方法，用输入的符合Class文件格式的byte[]数组替换掉java.lang.System的符号引用后，使用HotSwapClassLoader加载生成一个Class对象，由于每次执行execute()方法都会生成一个新的类加载器实例，因此同一个类可以实现重复加载。然后反射调用这个Class对象的main()方法，如果期间出现任何异常，将异常信息打印到HackSystem.out中，最后把缓冲区中的信息作为方法的结果来返回。JavaclassExecuter的实现代码<br>如代码清单9-7所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Javaclass执行工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaclassExecuter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类</span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classByte 代表一个Java类的Byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> ClassModifier(classByte);</span><br><span class="line">        <span class="keyword">byte</span>[] modiBytes = cm.modifyUTF8Constant(<span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;org/fenixsoft/classloading/execute/HackSystem&quot;</span>);</span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> HotSwapClassLoader();</span><br><span class="line">        Class clazz = loader.loadByte(modiBytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;);</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123;<span class="keyword">null</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证（TODO）"><a href="#验证（TODO）" class="headerlink" title="验证（TODO）"></a>验证（TODO）</h3>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>类加载及执行子系统的案例与实战</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-14-前端编译与优化</title>
    <url>/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h1><p>在Java技术下谈“编译期”而没有具体上下文语境的话，其实是一句很含糊的表述，</p>
<ul>
<li><p>因为它可能是指一个前端编译器（叫“编译器的前端”更准确一些）把*.java文件转变成*.class文件的过程；</p>
</li>
<li><p>也可能是指Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程；</p>
</li>
<li><p>还可能是指使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程序编译成与目标机器指令集相关的二进制代码的过程</p>
</li>
</ul>
<p>列举了这3类编译过程里一些比较有代表性的编译器产品：</p>
<ul>
<li>前端编译器：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li>
<li>即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器。</li>
<li>提前编译器：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET</li>
</ul>
<p>因为Java虚拟机设计团队选择把<strong>对性能的优化全部集中到运行期的即时编译器中</strong>，这样可以让那些不是由Javac产生的Class文件（如JRuby、Groovy等语言的Class<br>文件）也同样能享受到编译器优化措施所带来的性能红利。</p>
<ul>
<li>前端编译器，开发优化程序员的编码过程，降低了编码复杂度，提高了编码效率，提高了程序员的幸福感，很多”<strong>语法糖</strong>（枚举、泛型、装箱拆箱）“就是依赖前端编译期实现的。</li>
<li>即时编译器 在运行期的优化过程，支撑了程序的执行效率不断的提升，</li>
</ul>
<h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><p>分析源码是了解一项技术的实现内幕最彻底的手段，Javac编译器不像HotSpot虚拟机那样使用C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序，这为纯Java的程序员了解它的编译过程带来了很大的便利。</p>
<h4 id="Javac编译过程"><a href="#Javac编译过程" class="headerlink" title="Javac编译过程"></a>Javac编译过程</h4><ol>
<li>准备过程： 初始化插入式注解处理器</li>
<li>解析与填充符号表过程，包括：<ul>
<li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树</li>
<li>填充符号表。产生符号地址和符号信息</li>
</ul>
</li>
<li>插入式注解处理器的注解处理过程：  插入式注解处理器的执行阶段</li>
<li>分析与字节码生成过程，包括：<ul>
<li>标注检查。对语法的静态信息进行检查。</li>
<li>数据流及控制流分析。对程序动态运行过程进行检查</li>
<li>解语法糖。将简化代码编写的语法糖还原为原有的形式</li>
<li>字节码生成。将前面各个步骤所生成的信息转换为字节码</li>
</ul>
</li>
</ol>
<p>上述3个处理过程，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中 重新处理这些新符号。从总体上来看，三者之间的关系与交互顺序如下图所示</p>
<p><img src="/uploads/jvm/13Compile/javac-compile.png"></p>
<ul>
<li>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法里</li>
</ul>
<p><img src="/uploads/jvm/13Compile/javac-compile2.png"></p>
<h4 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h4><p>解析过程由图10-5中的parseFiles()方法（图10-5中的过程1.1）来完成，解析过程包括了经典程序编译原理中的词法分析和语法分析两个步骤。</p>
<h5 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h5><p><strong>词法分析</strong>是将源代码的字符流转变为标记（Token）集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记，如“int a=b+2”这句代码中就包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个独立的标记，不可以再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p>
<p><strong>语法分析</strong>是根据标记序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</p>
<p>在Javac的源码中，<strong>语法分析过程由com.sun.tools.javac.parser.Parser</strong>类实现，这个阶段产出的<strong>抽象语法树是以com.sun.tools.javac.tree.JCTree类表示</strong>的。</p>
<h5 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h5><p>完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程，也就是图10-5中 enterTrees()方法（图10-5中注释的过程1.2）要做的事情</p>
<p>符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构，读者可以把它类比想象成哈希表中键值对的存储形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等各种形式）。符号表中所登记的信息在编译的不同阶段都要被用到。譬如在语义分析的过程中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的声明是否一致）和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</p>
<p>在Javac源代码中，<strong>填充符号表</strong>的过程由<strong>com.sun.tools.javac.comp.Enter类实现</strong>，该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p>
<h5 id="注解处理器（Lombok的实现原理）"><a href="#注解处理器（Lombok的实现原理）" class="headerlink" title="注解处理器（Lombok的实现原理）"></a>注解处理器（Lombok的实现原理）</h5><p>在JDK 6中又提出并通过了JSR-269提案[1]，该提案设计了一组被称为“<strong>插入式注解处理器</strong>”的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次（Round），这也就对应着图10-4的那个回环过程。</p>
<p>有了编译器注解处理的标准API后，<strong>程序员的代码才有可能干涉编译器的行为</strong>，<strong>由于语法树中的任意元素，甚至包括代码注释都可以在插件中被访问到</strong>，所以<strong>通过插入式注解处理器实现的插件在功能上有很大的发挥空间</strong>。只要有足够的创意，程序员能使用插入式注解处理器来实现许多原本只能在编码中由人工完成的事情。譬如Java著名的编码效率工具<strong>Lombok</strong>[2]，它可以通过注解来实现自动产生getter/setter方法、进行空置检查、生成受查异常表、产生equals()和hashCode()方法，等等，帮助开发人员消除Java的冗长代码，<strong>这些都是依赖插入式注解处理器</strong>来实现的，</p>
<p>在Javac源码中，插入式注解处理器的初始化过程是在<strong>initPorcessAnnotations</strong>()方法中完成的，而它的执行过程则是在<strong>processAnnotations</strong>()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</p>
<h5 id="语义分析与字节码生成（IDE工具提示报错原理）"><a href="#语义分析与字节码生成（IDE工具提示报错原理）" class="headerlink" title="语义分析与字节码生成（IDE工具提示报错原理）"></a>语义分析与字节码生成（IDE工具提示报错原理）</h5><p>经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的</p>
<p>而<strong>语义分析</strong>的主要任务则是对结构上正确的源程序<strong>进行上下文相关性质的检查</strong>，譬如进行<strong>类型检查、控制流检查、数据流检查</strong>。</p>
<p>我们编码时经常能在IDE中看到由红线标注的错误提示，其中绝大部分都是来源于语义分析阶段的检查结果。</p>
<h6 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h6><p>Javac在编译过程中，语义分析过程可分为标注检查和数据及控制流分析两个步骤，分别由图10-5的attribute()和flow()方法（分别对应图10-5中的过程3.1和过程3.2）完成。</p>
<p>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等</p>
<p>在标注检查中，还会顺便进行一个称为常量折叠（Constant Folding）的代码优化，这是Javac编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）</p>
<p>标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类。</p>
<h6 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h6><p>数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的，但校验范围会有所区别，有一些校验项只有在编译期或运行期才能进行。</p>
<p>下面举一个关于final修饰符的数据及控制流分析的例子，见代码清单10-1所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一带有final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二没有final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两个foo()方法中，一个方法的参数和局部变量定义使用了final修饰符，另外一个则没有，<strong>在代码编写时程序肯定会受到final修饰符的影响</strong>，<strong>不能再改变arg和var变量的值</strong>，</p>
<p>但是如果观察这<strong>两段代码编译出来的字节码</strong>，会发现<strong>它们是没有任何一点区别的</strong>，每条指令，甚至每个字节都一模一样。</p>
<p>通过第6章对Class文件结构的讲解我们已经知道，局部变量与类的字段（实例变量、类变量）的存储是有显著差别的，<strong>局部变量在常量池中并没有CONSTANT_Fieldref_info的符号引用</strong>，<strong>自然就不可能存储有访问标志（access_flags）的信息</strong>，甚至可能连变量名称都不一定会被保留下来（这取决于编译时的<br>编译器的参数选项），自然<strong>在Class文件中就不可能知道一个局部变量是不是被声明为final了</strong>。</p>
<p>因此，可以肯定地推断出把局部变量声明为final，对运行期是完全没有影响的，<strong>变量的不变性仅仅由Javac编译器在编译期间来保障</strong>，这就是一个只能在编译期而不能在运行期中检查的例子。</p>
<p>在Javac的源码中，数据及控制流分析的入口是图10-5中的flow()方法（图10-5中的过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p>
<h6 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h6><p>语法糖（Syntactic Sugar），也称糖衣语法，，是由英国计算机科学家Peter J.Landin发明的一种编程术语，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言。通常来说使用语法糖能够减少代码量、增加程序的可读性，从而减少程序代码出错的机会。</p>
<p>Java中最常见的语法糖包括了前面提到过的泛型（其他语言中泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱拆箱，等等，Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为解语法糖.</p>
<p>在Javac的源码中，解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类<br>和com.sun.tools.javac.comp.Lower类中完成。</p>
<h6 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h6><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作.</p>
<ul>
<li>前文多次登场的实例构造器<init>()方法和类构造器<clinit>()方法就是在这个阶段被添加到语法树之中的</li>
<li>请注意<strong>这里的实例构造器并不等同于默认构造函数</strong>，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性（public、protected、private或<package>）与当前类型一致的默认构造函数，<strong>这个工作在填充符号表阶段中就已经完成</strong></li>
<li><init>()和<clinit>()这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器，<clinit>()方法中无须调用父类的<clinit>()方法，Java虚拟机会自动保证父类构造器的正确执行，但在<clinit>()方法中经常会生成调用java.lang.Object的<init>()方法的代码）等操作收敛到<init>()和<br><clinit>()方法之中，并且<strong>保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行</strong>，上面所述的动作由**Gen::normalizeDefs()**方法来实现</li>
<li>还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式，如把字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK 5）的append()操作，等等。</li>
</ul>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到<strong>com.sun.tools.javac.jvm.ClassWriter</strong>类手上，由这个类的writeClass()方法输出字节码，<strong>生成最终的Class文件</strong>，到此，整个编译过程宣告结束。</p>
<h3 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h3><p>语法糖可以看作是前端编译器实现的一些“小把戏”，这些“小把戏”可能会使效率得到“大提升”，但我们也应该去了解这些“小把戏”背后的真实面貌，那样才能利用好它们，而不是被它们所迷惑。</p>
<p><strong>ps:  其实只需要在 反编译class文件后，就可以知道 使用了语法糖的java文件最后去语法糖后，变成了什么样子</strong></p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型的本质是 参数化类型（Parameterized Type）或者参数化多态（Parameteric Polymorphism）的应用， 即可以<strong>将操作的数据类型指定为方法签名中的一种参数</strong>，这种参数类型能够用在 类、接口和方法的创建中，分别构成 泛型类、泛型接口和泛型方法。 泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大的增强了编程语言的类型系统以及抽象能力。</p>
<p>Java的泛型直到今天依然作为Java语言不如C#语言好用的“铁证”被众人嘲讽</p>
<h5 id="Java与C-的泛型"><a href="#Java与C-的泛型" class="headerlink" title="Java与C#的泛型"></a>Java与C#的泛型</h5><ul>
<li><p>Java选择的泛型实现方式叫作“类型擦除式泛型”（Type Erasure Generics），</p>
</li>
<li><p>而C#选择的泛型实现方式是“具现化式泛型”（Reified Generics）。具现化和特化、偏特化这些名词最初都是源于C++模版语法中的概念</p>
</li>
<li><p>C#里面泛型无论在程序源码里面、编译后的中间语言表示（Intermediate Language，这时候泛型是一个占位符）里面，抑或是运行期的CLR里面都是切实存在的，List<int>与 List<string>就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。</p>
</li>
<li><p>而Java语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type),并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>其实是同一个类型，由此读者可以想象“类型擦除”这个名字的含义和来源</p>
</li>
</ul>
<p>代码清单10-2　Java中不支持的泛型用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeErasureGenerics</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123; <span class="comment">// 不合法，无法对泛型进行实例判断</span></span><br><span class="line">        	...</span><br><span class="line">        &#125;</span><br><span class="line">        E newItem = <span class="keyword">new</span> E(); <span class="comment">// 不合法，无法使用泛型创建对象</span></span><br><span class="line">        E[] itemArray = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 不合法，无法使用泛型创建数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>C#2.0引入了泛型之后，带来的显著优势之一便是对比起Java在执行性能上的提高，因为在<strong>使用平台提供的容器类型</strong>（如List<T>，Dictionary&lt;TKey，TValue&gt;）时，<strong>无须像Java里那样不厌其烦地拆箱和装箱</strong>[1]，如果在Java中要避免这种损失，就必须构造一个与数据类型相关的容器类（譬如IntFloatHashMap这样的容器）。显然，这除了引入更多代码造成复杂度提高、复用性降低之外，更是丧失了泛型本身的存在价值。</p>
</li>
<li><p>Java的类型擦除式泛型无论在使用效果上还是运行效率上，几乎是全面落后于C#的具现化式泛型，而它的<strong>唯一优势是在于实现这种泛型的影响范围上</strong>：擦除式泛型的<strong>实现几乎只需要在Javac编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机</strong>，也<strong>保证了以前没有使用泛型的库可以直接运行在Java 5.0之上</strong>。但这种听起来节省工作量甚至可以说是有偷工减料嫌疑的优势就显得非常短视</p>
</li>
</ul>
<p>在没有泛型的时代，由于Java中的数组是支持协变（Covariant）的[6]，对应的集合类也可以存入不同类型的元素，类似于代码清单10-3这样的代码尽管不提倡，但是完全可以正常编译成Class文件。</p>
<p>代码清单10-3　以下代码可正常编译为Class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 编译期不会有问题，运行时会报错</span></span><br><span class="line">ArrayList things = <span class="keyword">new</span> ArrayList();</span><br><span class="line">things.add(Integer.valueOf(<span class="number">10</span>)); <span class="comment">//编译、运行时都不会报错</span></span><br><span class="line">things.add(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>为了保证这些编译出来的Class文件可以在Java 5.0引入泛型之后继续运行，设计者面前大体上有两条路可以选择：<br>1）需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型。<br>2）直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</p>
<p>C# 选择了第一种方式，平行的加了一套泛型化版本的新类型 </p>
<p>Java选择了，第一要考虑到 保证“二进制向后兼容性”（Binary Backwards Compatibility）。二进制向后兼容性是明确写入《Java语言<br>规范》中的对Java使用者的严肃承诺，譬如一个在JDK 1.2中编译出来的Class文件，必须保证能够在JDK 12乃至以后的版本中也能够正常运行。</p>
<p>然后Java当时已经流行了10来年，存量老代码太多。</p>
<p>但<strong>第二条路也并不意味着一定只能使用类型擦除来实现</strong>，如果当时有足够的时间好好设计和实现，是完全有可能做出更好的泛型系统的，否则也不会有今天的<strong>Valhalla</strong>项目来<strong>还以前泛型偷懒留下的技术债</strong>了</p>
<h5 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h5><p>由于Java选择了第二条路，直接把已有的类型泛型化。要让所有需要泛型化的已有类型，譬如 ArrayList，原地泛型化后变成 ArrayList<T>,而且保证以前直接使用ArrayList的代码在泛型新版本里必须还能继续用这同一容器，这就必须让所有泛型化的实例，譬如 ArrayList<Integer>、ArrayList<String>这些全部自动成为<br>ArrayList的子类型才能可以，否则类型转换就是不安全的。由此 就引出了 <strong>“裸类型”（Raw Type）</strong>的概念，裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type），</p>
<p>代码清单10-4　裸类型赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ilist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; slist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list; <span class="comment">// 裸类型</span></span><br><span class="line">list = ilist;</span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure>

<p>接下来的问题是该如何实现裸类型。这里又有了两种选择：</p>
<ul>
<li>一种是在运行期由Java虚拟机来自动地、真实地构造出ArrayList<Integer>这样的类型，并且自动实现从ArrayList<Integer>派生自ArrayList的继承关系来满足裸类型的定义；</li>
<li>（<strong>被选择</strong>）另外一种是<strong>索性简单粗暴地直接在编译时把ArrayList<Integer>还原回ArrayList</strong>，只在<strong>元素访问、修改时自动插入一些强制类型转换和检查指令</strong>，这样看起来也是能满足需要，这两个选择的最终结果大家已经都知道了。</li>
</ul>
<p>代码清单10-5是一段简单的Java泛型例子，我们可以看一下它编译后的实际样子是怎样的。</p>
<p>代码清单10-5　泛型擦除前的例子</p>
<p>代码清单10-5　泛型擦除前的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;how are you?&quot;</span>, <span class="string">&quot;吃了没？&quot;</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;how are you?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，<strong>泛型类型都变回了裸类型</strong>，只在<strong>元素访问时插入了从Object到String的强制转型代码</strong>，如代码清单10-6所示。</p>
<p>代码清单10-6　泛型擦除后的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;how are you?&quot;</span>, <span class="string">&quot;吃了没？&quot;</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println((String) map.get(<span class="string">&quot;how are you?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，使用擦除法实现泛型直接导致了对原始类型（Primitive Types）数据的支持又成了新的麻烦，譬如将代码清单10-2稍微修改一下，变成代码清单10-7这个样子</li>
</ul>
<p>代码清单10-7　原始类型的泛型（目前的Java不支持）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; ilist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">long</span>&gt; llist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ilist;</span><br><span class="line">list = llist;</span><br></pre></td></tr></table></figure>

<p>这种情况下，一旦把泛型信息擦除后，到要插入强制转型的地方就没办法往下做了，因为 不支持 int、long 与 Object之间的强制类型转换。 当时Java给出的解决方案一如既往的简单粗暴：  既然没法转换，<strong>索性就不支持原生类型的泛型</strong>。都用ArrayList<Integer>、ArrayList<Long>，反正都做了<strong>自动的强制类型转换</strong>，遇到<strong>原生类型时把装箱、拆箱也自动做了</strong>.。这个决定也导致了无数构造包装类的装箱、拆箱的开销， 称为Java泛型慢的重要原因。</p>
<ul>
<li>第二，运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦，譬如代码清单10-2中罗列的几种Java不支持的泛型用法，都是由于运行期Java虚拟机无法取得泛型类型而导致的。像代码清单10-8这样，我们去写一个泛型版本的从List到数组的转换方法，由于不能从List中取得参数化类型T，所以不得不从一个额外参数中再传入一个数组的组件类型进去，实属无奈。</li>
</ul>
<p>代码清单10-8　不得不加入的类型参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123;</span><br><span class="line">    T[] array = (T[])Array.newInstance(componentType, list.size());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后，通过擦除法来实现泛型，还丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况，例如代码清单10-9的例子</li>
</ul>
<p>代码清单10-9　当泛型遇见重载1 (<strong>这段代码无法编译通过</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">   	 	System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是不能被编译的，因为参数List<Integer>和List<String>编译之后都被擦除了，变成了同一种的裸类型List，<br>类型擦除导致这两个方法的特征签名变得一模一样。（<strong>特征签名最重要的任务就是作为方法独一无二不可重复的ID，在Java代码中的方法特征签名只包括了方法名称、参数顺序及参数类型，而在字节码中的特征签名还包括方法返回值及受查异常表</strong>）</p>
<ul>
<li>由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响并带来新的需求，如在泛型类中如何获取传入的参数化类型等。</li>
<li>所以JCP组织对《Java虚拟机规范》做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，</li>
<li>Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[8]，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范[9]要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</li>
<li>另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</li>
</ul>
<h5 id="值类型与未来的泛型"><a href="#值类型与未来的泛型" class="headerlink" title="值类型与未来的泛型"></a>值类型与未来的泛型</h5><p>值类型，这点也是C#用户攻讦Java语言的常用武器之一，C#并没有Java意义上的原生数据类型，在C#中使用的int、bool、double关键字其实是对应了一系列在.NET框架中预定义好的结构体（Struct），如Int32、Boolean、Double等。在C#中开发人员也可以定义自己值类型，只要继承于ValueType类型即可，而ValueType也是统一基类Object的子类，所以并不会遇到Java那样int不自动装箱就无法转型为Object的尴尬。</p>
<p>值类型可以与引用类型一样，具有构造函数、方法或是属性字段，等等，而它与引用类型的区别在于它在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的。更为关键的是，值类型的实例很容易实现分配在方法的调用栈上的，这意味着值类型会随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</p>
<h5 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h5><p>代码清单10-11　自动装箱、拆箱与遍历循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">    	sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单10-12　自动装箱、拆箱与遍历循环编译之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = Arrays.asList( <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">    Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单10-11中一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖，代码<br>清单10-12则展示了它们在编译前后发生的变化。泛型就不必说了，</p>
<ul>
<li>自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法，如本例中的Integer.valueOf()与Integer.intValue()方法，</li>
<li>而遍历循环则是把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因。</li>
<li>最后再看看变长参数，它在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员的确也就是使用数组来完成类似功能的。</li>
</ul>
<p>这些语法糖虽然看起来很简单，但也不见得就没有任何值得我们特别关注的地方，代码清单10-13演示了自动装箱的一些错误用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoBoxing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">        System.out.println(c+<span class="string">&quot; &quot;</span>+d+<span class="string">&quot; &quot;</span>+System.identityHashCode(c)+<span class="string">&quot; &quot;</span>+System.identityHashCode(d));</span><br><span class="line">        System.out.println(e == f);</span><br><span class="line">        System.out.println(e+<span class="string">&quot; &quot;</span>+f+<span class="string">&quot; &quot;</span>+System.identityHashCode(e)+<span class="string">&quot; &quot;</span>+System.identityHashCode(f));</span><br><span class="line">        System.out.println(c == (a + b));</span><br><span class="line">        System.out.println(c.equals(a + b));</span><br><span class="line">        System.out.println(g == (a + b));</span><br><span class="line">        System.out.println(g.equals(a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Integer 源码（解释为什么  System.out.println(e == f);  //返回false）</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>鉴于<strong>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</strong>，以及<strong>它们equals()方法不处理数据转型的关系</strong>，</p>
<p>Integer::valueOf(int i),  当i的值 处于[-128,127]时，从缓存Cache中取， 否则 new Integer(i)，包装类==比较hash地址，所以  返回false</p>
<h5 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h5><p>在Java语言之中并没有使用预处理器，因为Java语言天然的编译方式（编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）就无须使用到预处理器。</p>
<p>Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。如代码清单10-14所示，该代码中的if语句不同于其他Java代码，它在编译阶段就会被“运行”，生成的字节码之中只包括“System.out.println(“block 1”)；”一条语句，并不会包含if语句及另外一个分子中的“System.out.println(“block 2”)；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;block 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后的反编译结果：</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能力的语句搭配，则可能在控制流分析中提示错误，被拒绝编译，如代码清单10-15所示的代码就会被编译器拒绝编译。</p>
<p>代码清单10-15　不能使用其他条件语句来完成条件编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器将会提示“Unreachable code”</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">   	 System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了本节中介绍的泛型、自动装箱、自动拆箱、遍历循环、变长参数和条件编译之外，Java语言还有不少其他的语法糖，如<strong>内部类、枚举类、断言语句、数值字面量、对枚举和字符串的switch支持、try语句中定义和关闭资源（这3个从JDK 7开始支持）、Lambda表达式（</strong>从JDK 8开始支持，Lambda不能算是单纯的语法糖，但在前端编译器中做了大量的转换工作），等等，读者<strong>可以通过跟踪Javac源码、反编译Class文件等方式了解它们的本质实现</strong></p>
<h3 id="实战：插入式注解处理器-TODO"><a href="#实战：插入式注解处理器-TODO" class="headerlink" title="实战：插入式注解处理器(TODO)"></a>实战：插入式注解处理器(TODO)</h3><p>NameCheckProcessor的实战例子只演示了JSR-269嵌入式注解处理API其中的一部分功能，基于这组API支持的比较有名的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator AnnotationProcessor[1]（本质上与NameCheckProcessor所做的事情差不多）、自动为字段生成getter和setter方法等辅助内容的Lombok[2]（根据已有元素生成新的语法树元素）等，读者有兴趣的话可以参考它们官方站点的相关内容</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在本章中，我们从Javac编译器源码实现的层次上学习了Java源代码编译为字节码的过程，分析了Java语言中泛型、主动装箱拆箱、条件编译等多种语法糖的前因后果，并实战练习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。</p>
<p>如本章概述中所说的，在<strong>前端编译器中，“优化”手段主要用于提升程序的编码效率</strong>，之所以把Javac这类将Java代码转变为字节码的编译器称作“前端编译器”，是因为<strong>它只完成了从程序到抽象语法树或中间字节码的生成</strong>，而在此之后，还有一组<strong>内置于Java虚拟机内部的“后端编译器”来完成代码优化以及从字节码生成本地机器码的过程</strong>，即前面多次提到的即时编译器或提前编译器，这个<strong>后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标</strong></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>前端编译与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-15-后端编译与优化</title>
    <url>/2021/01/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-15-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h1><p>后端编译器<strong>编译性能的好坏</strong>、<strong>代码优化质量的高低</strong>确实衡量一款商用虚拟机优秀与否的关键指标之一，他们也是商业java虚拟机中的核心，是最能体现技术水平的价值的功能。</p>
<h2 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过<strong>解释器（Interpreter）</strong>进行解释执行的，当虚拟机发现<strong>某个方法或代码块</strong>的<strong>运行特别频繁</strong>，就会把这些代码认定为<strong>“热点代码”（Hot Spot Code）</strong>，为了提高热点代码的执行效率，在运行时，<strong>虚拟机将会把这些代码编译成本地机器码</strong>，并以各种手段尽可能地进行代码优化，运行时完成这个任务的<strong>后端编译器被称为即时编译器</strong>。本节我们将会了解HotSpot虚拟机内的即时编译器的运作过程，此外，我们还将解决以下几个问题：</p>
<ul>
<li>为何HotSpot虚拟机要使用解释器与即时编译器并存的架构？</li>
<li>为何HotSpot虚拟机要实现两个（或三个）不同的即时编译器？</li>
<li>程序何时使用解释器执行？何时使用编译器执行？</li>
<li>哪些程序代码会被编译为本地代码？如何编译本地代码？</li>
<li>如何从外部观察到即时编译器的编译过程和编译结果？</li>
</ul>
<h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>解释器与编译器两者各有优势：</p>
<ul>
<li>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。</li>
<li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。</li>
<li>当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），反之可以使用编<br>译执行来提升效率。</li>
<li>同时，解释器还可以作为编译器激进优化时后备的“逃生门”（如果情况允许，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行，</li>
<li>因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作，其交互关系如图11-1所示。</li>
</ul>
<p><img src="/uploads/jvm/13Compile/Interpreter01.png"></p>
<p>HotSpot虚拟机中内置了两个（或三个）即时编译器，其中有两个编译器存在已久，分别被称为“客户端编译器”（Client Compiler）和“服务端编译器”（Server Compiler），或者简称为C1编译器和C2编译器（部分资料和JDK源码中C2也叫Opto编译器），第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。Graal编译器目前还处于实验状态</p>
<p>无论采用的编译器是客户端编译器还是服务端编译器，解释器与编译器搭配使用的方式在虚拟机中被称为<strong>“混合模式”（Mixed Mode）</strong>，</p>
<p>用户也可以使用参数<strong>“-Xint”</strong>强制虚拟机运行于<strong>“解释模式”（Interpreted Mode</strong>），这时候编译器完全不介入工作，全部代码都使用解释方式执行。</p>
<p>另外，也可以使用参数<strong>“-Xcomp”</strong>强制虚拟机运行于<strong>“编译模式”（Compiled Mode）</strong>，这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。可以通过虚拟机的“-version”命令的输出结果显示出这三种模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$java</span> -version</span><br><span class="line">java version <span class="string">&quot;11.0.3&quot;</span> 2019-04-16 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, mixed mode)</span><br><span class="line"></span><br><span class="line"><span class="variable">$java</span> -Xint -version</span><br><span class="line">java version <span class="string">&quot;11.0.3&quot;</span> 2019-04-16 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, interpreted mode)</span><br><span class="line"></span><br><span class="line"><span class="variable">$java</span> -Xcomp -version</span><br><span class="line">java version <span class="string">&quot;11.0.3&quot;</span> 2019-04-16 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, compiled mode)</span><br></pre></td></tr></table></figure>

<h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>由于即时编译器编译本地代码需要占用程序运行时间，通常要<strong>编译出优化程度越高的代码，所花费的时间便会越长</strong>；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。</p>
<p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能。</p>
<p>分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ul>
<li>第0层。程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li>
<li>第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。</li>
<li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li>
<li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li>
<li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。<br>以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。各层次编译之间的交互、转换关系如图11-2所示。</li>
</ul>
<p>实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，</p>
<p>用客户端编译器获取更高的编译速度，</p>
<p>用服务端编译器来获取更好的编译质量，</p>
<p>在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间。</p>
<p><img src="/uploads/jvm/13Compile/layerCompile.png"></p>
<h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>在运行过程中会被即时编译器编译的目标是“热点代码”，这里所指的热点代码主要有两类，包括：</p>
<ul>
<li><p><strong>被多次调用的方法。</strong>（一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为“热点代码”是理所当然的）</p>
</li>
<li><p><strong>被多次执行的循环体</strong> （为了解决当一个方法只被调用过一次或少量的几次，但是方法体内部存在循环次数较多的循环体，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”）</p>
<p>对于这两种情况，<strong>编译的目标对象都是整个方法体</strong>，而不会是单独的循环体</p>
<ul>
<li>第一种情况，由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式。</li>
<li>对于后一种情况，尽管编译动作是由循环体所触发的，热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）。这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为<strong>“栈上替换”（On Stack Replacement，OSR）</strong>，即方法的栈帧还在栈上，方法就被替换了。</li>
</ul>
</li>
</ul>
<p><strong>即时编译被触发的条件</strong> 要知道方法执行多少次才算多次，代码块执行多少次 才算多次，要有一个定量。</p>
<h4 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h4><p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“<strong>热点探测”（HotSpot Code Detection）</strong>，其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主流的热点探测判定方式有两种[2]，分别是：</p>
<ul>
<li><strong>基于采样的热点探测（Sample Based Hot Spot Code Detection</strong>）。采用这种方法的虚拟机会<strong>周期性地检查各个线程的调用栈顶</strong>，如果发现某个（或某些）方法<strong>经常出现在栈顶，那这个方法就是“热点方法”</strong>。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，<strong>容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测</strong>。</li>
<li><strong>基于计数器的热点探测（Counter Based Hot Spot Code Detection</strong>）。采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li>
</ul>
<p>在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：<strong>方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter，“回边”的意思就是指在循环边界往回跳转）</strong>。当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈<br>值，计数器阈值一旦溢出，就会触发即时编译。</p>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>顾名思义，这个计数器就是用于统计方法被调用的次数，它的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数-XX：CompileThreshold来人为设定。</p>
<p>当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。</p>
<p>如果没有做过任何设置，<strong>执行引擎默认不会同步等待编译请求完成</strong>，而是<strong>继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成</strong>。当编译工作完成后，这个方法的<strong>调用入口地址就会被系统自动改写成新值</strong>，下一次调用该方法时就会使用已编译的版本了，整个即时编译的交互过程如图11-3所示。</p>
<p>在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为<strong>方法调用计数器热度的衰减（Counter Decay），</strong></p>
<p>而这段时间就称为此<strong>方法统计的半衰周期（Counter Half Life Time</strong>），进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。</p>
<p>另外还可以使用-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
<p><img src="/uploads/jvm/13Compile/methodIvokeCounter.png"></p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>回边计数器，它的作用是<strong>统计一个方法中循环体代码执行的次数</strong>，在字节码中遇到<strong>控制流向后跳转的指令就称为“回边（Back Edge</strong>）”，很显然建立回边计数<br>器统计的目的是为了<strong>触发栈上的替换编译</strong></p>
<ul>
<li>虚拟机运行在客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以OSR比率（-XX：OnStackReplacePercentage）除以100。其中-XX：OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为13995。</li>
<li>虚拟机运行在服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以（OSR比率（-XX：OnStackReplacePercentage）减去解释器监控比率（-XX：InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，-XX：InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为10700。</li>
</ul>
<p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果，整个执行过程如图11-4所示。</p>
<p><img src="/uploads/jvm/13Compile/BackEdgeCounter.png"></p>
<p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行。用户可以通过参数-XX：-BackgroundCompilation来禁止后台编译，后台编译被禁止后，当达到触发即时编译的条件时，执行线程向虚拟机提交编译请求以后将会一直阻塞等待，直到编译过程完成再开始执行编译器输出的本地代码。</p>
<h4 id="客户端编译器"><a href="#客户端编译器" class="headerlink" title="客户端编译器"></a>客户端编译器</h4><p>服务端编译器和客户端编译器的编译过程是有所差别的。对于客户端编译器来说，它是一个相对简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p>
<ul>
<li>在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-LevelIntermediate Representation，HIR，即与目标机器指令集无关的中间表示）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</li>
<li>在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</li>
<li>最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。客户端编译器大致的执行过程如图11-5所示。</li>
</ul>
<p><img src="/uploads/jvm/13Compile/ClientCompile.png"></p>
<h2 id="提前编译器（TODO）"><a href="#提前编译器（TODO）" class="headerlink" title="提前编译器（TODO）"></a>提前编译器（TODO）</h2><h2 id="编译器优化技术"><a href="#编译器优化技术" class="headerlink" title="编译器优化技术"></a>编译器优化技术</h2><p>编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但其实难点并不在于能不能成功翻译出机器码，输出代码优化质量的高低才是决定编译器优秀与否的关键。</p>
<h4 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a>优化技术概览</h4><p><img src="/uploads/jvm/13Compile/OptimizeTech.png"></p>
<p><img src="/uploads/jvm/13Compile/OptimizeTech02.png"></p>
<p>简单挑选几个代表性的优化技术：</p>
<ul>
<li>最重要的优化技术之一：方法内联。</li>
<li>最前沿的优化技术之一：逃逸分析。</li>
<li>语言无关的经典优化技术之一：公共子表达式消除。</li>
<li>语言相关的经典优化技术之一：数组边界检查消除。</li>
</ul>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联，说它是编译器最重要的优化手段，甚至都可以不加上“之一”。内联被业内戏称为优化之母，因为除了消除方法调用的成本之外，它更重要的意义<strong>是为其</strong><br><strong>他优化手段建立良好的基础</strong>，代码清单11-11所示的简单例子就揭示了内联对其他优化手段的巨大价值：没有内联，多数其他优化都无法有效进行。</p>
<p>例子里testInline()方法的内部全部是无用的代码，但如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何“Dead Code”的存在。如果分开来看，foo()和testInline()两个方法里面的操作都有可能是有意义的。</p>
<p>代码清单11-11　未作任何优化的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInline</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    foo(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内联的优化行为理解起来是没有任何困难的，不过就是<strong>把目标方法的代码原封不动地“复制”到发起调用的方法之中</strong>，避免发生真实的方法调用而已。</p>
<p>但实际上Java虚拟机中的内联过程却远没有想象中容易，甚至如果不是即时编译器做了一些特殊的努力，按照经典编译原理的优化理论，大多数的Java方法都无法进行内联。</p>
<p><strong>无法内联的原因</strong>其实在第8章中讲解Java<strong>方法解析和分派调用</strong>的时候就已经解释过：只有使用<strong>invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析</strong>。除了上述四种方法之外（<strong>最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法</strong>，《Java语言规范》中明确说明了这点），<strong>其他的Java方法调用都必须在运行时进行方法接收者的多态选择</strong>，<strong>它们都有可能存在多于一个版本的方法接收者，简而言之，Java语言中默认的实例方法是虚方法</strong>。</p>
<p>ps:  因为Java默认是虚方法，一个方法就可能被重写（动态分派），方法可能存在多个版本，复制方法内容就 不确定复制哪个版本的了。</p>
<p>对于一个虚方法，<strong>编译器静态地去做内联的时候很难确定应该使用哪个方法版本</strong>，以将代码清单11-7中所示b.get()直接内联为b.value为例，如果不依赖上下文，是无法确定b的实际类型是什么的。假如有ParentB和SubB是两个具有继承关系的父子类型，并且子类重写了父类的get()方法，那么b.get()是执行父类的get()方法还是子类的get()方法，这应该是根据实际类型动态分派的，而<strong>实际类型必须在实际运行到这一行代码时才能确定，编译器很难在编译时得出绝对准确的结论</strong>。</p>
<p>更糟糕的情况是，由于Java提倡使用面向对象的方式进行编程，而Java对象的方法默认就是虚方法，可以说Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑。根据上面的分析可知，<strong>内联与虚方法之间会产生“矛盾”</strong>，那是不是为了提高执行性能，就应该默认给每个方法都使用final关键字去修饰呢？C和C++语言的确是这样做的，默认的方法是非虚方法，如果需要用到多态，就用virtual关键字来修饰，但<strong>Java选择了在虚拟机中解决这个问题</strong>。</p>
<h4 id="类型继承关系分析（激进优化）"><a href="#类型继承关系分析（激进优化）" class="headerlink" title="类型继承关系分析（激进优化）"></a>类型继承关系分析（激进优化）</h4><p>为了解决虚方法的内联问题，Java虚拟机首先引入了一种名为<strong>类型继承关系分析（Class HierarchyAnalysis，CHA）</strong>的技术，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。这样，编译器在进行内联时就会分不同情况采取不同的处理：</p>
<ul>
<li>如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的；</li>
<li>如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为<strong>守护内联（Guarded Inlining</strong>）。</li>
<li>不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。</li>
<li>假如在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</li>
</ul>
<p>假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用<strong>内联缓存（Inline Cache）</strong>的方式来缩减方法调用的开销。这种状态下方法调用是真正发生了的，但是比起直接查虚方法表还是要快一些。内联缓存是一个建立在目标方法正常入口之前的缓存，它的工作原理大致为：</p>
<ul>
<li>在未发生方法调用之前，内联缓存状态为空，</li>
<li>当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。</li>
<li>如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种<strong>单态内联缓存（Monomorphic InlineCache</strong>）。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。</li>
<li>但如果真的出现方法接收者不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成<strong>超多态内联缓存（Megamorphic Inline Cache）</strong>，其开销相当于真正查找虚方法表来进行方法分派。</li>
</ul>
<p>所以说，在多数情况下Java虚拟机进行的方法内联都是一种<strong>激进优化</strong>。事实上，激进优化的应用在高性能的Java虚拟机中比比皆是，极为常见。除了方法内联之外，对于出现概率很小（通过经验数据或解释器收集到的性能监控信息确定概率大小）的隐式异常、使用概率很小的分支等都可以被激进优化“移除”，如果真的出现了小概率事件，这时才会从“逃生门”回到解释状态重新执行。</p>
<h3 id="逃逸分析（前沿技术）"><a href="#逃逸分析（前沿技术）" class="headerlink" title="逃逸分析（前沿技术）"></a>逃逸分析（前沿技术）</h3><p>逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它<strong>与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术</strong></p>
<p>逃逸分析的基本原理是：<strong>分析对象动态作用域</strong>，当一个对象在方法里面被定义后，它可能被外部方法所引用，</p>
<ul>
<li>例如<strong>作为调用参数传递到其他方法中，这种称为方法逃逸</strong>；</li>
<li>甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为<strong>线程逃逸；</strong></li>
<li>从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</li>
</ul>
<p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，如：</p>
<h4 id="栈上分配（Stack-Allocations）"><a href="#栈上分配（Stack-Allocations）" class="headerlink" title="栈上分配（Stack Allocations）"></a>栈上分配（Stack Allocations）</h4><p>在Java虚拟机中，Java堆上分配创建对象的内存空间几乎是Java程序员都知道的常识，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引<br>用，就可以访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。</p>
<p>如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，<strong>对象所占用的内存空间就可以随栈帧出栈而销毁</strong>。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多</p>
<p><strong>栈上分配可以支持方法逃逸，但不能支持线程逃逸</strong>。</p>
<h4 id="标量替换（Scalar-Replacement）"><a href="#标量替换（Scalar-Replacement）" class="headerlink" title="标量替换（Scalar Replacement）"></a>标量替换（Scalar Replacement）</h4><p>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为<strong>标量</strong>。</p>
<p>相对的，如果一个数据可以继续分解，那它就被称为<strong>聚合量（Aggregate）</strong>，Java中的对象就是典型的聚合量。</p>
<p>如果把一个Java对象拆散，根据程序访问的情况，<strong>将其用到的成员变量恢复为原始类型来访问</strong>，这个过程就称为标量替换。</p>
<p>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。</p>
<p>标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，<strong>它不允许对象逃逸出方法范围内</strong></p>
<h4 id="同步消除（Synchronization-Elimination）"><a href="#同步消除（Synchronization-Elimination）" class="headerlink" title="同步消除（Synchronization Elimination）"></a>同步消除（Synchronization Elimination）</h4><p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够<strong>确定一个变量不会逃逸出线程，无法被其他线程访问</strong>，那么这个变量的读写肯定就不会有竞争，<br>对这个变量实施的同步措施也就可以安全地消除掉。</p>
<h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是：</p>
<ul>
<li><p>如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为<strong>公共子表达式</strong>。</p>
</li>
<li><p>对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。</p>
</li>
<li><p>如果这种优化仅限于程序基本块内，便可称为<strong>局部公共子表达式消除（Local Common Subexpression Elimination）</strong>，</p>
</li>
<li><p>如果这种优化的范围涵盖了多个基本块，那就称为<strong>全局公共子表达式消除（Global Common Subexpression Elimination）</strong>。</p>
<p>下面举个简单的例子来说明它的优化过程，假设存在如下代码：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int d = (c * b) * 12 + a + (a + b * c);</span><br></pre></td></tr></table></figure>

<p>当这段代码进入虚拟机即时编译器后，它将进行如下优化：编译器检测到c<em>b与b</em>c是一样的表达式，而且在计算期间b与c的值是不变的。</p>
<p>因此这条表达式就可能被视为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">12</span> + a + (a + E);</span><br></pre></td></tr></table></figure>

<p>这时候，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化——<strong>代数化简（Algebraic Simplification）</strong>，在E本来就有乘法运算的前提下，把表达式变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">13</span> + a + a;</span><br></pre></td></tr></table></figure>

<p>表达式进行变换之后，再计算起来就可以节省一些时间了</p>
<h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术</p>
<p>我们知道Java语言是一门<strong>动态安全的语言</strong>，对数组的读写访问也不像C、C++那样实质上就是裸指针操作。</p>
<ul>
<li>如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即i必须满足“i&gt;=0&amp;&amp;i&lt;foo.length”的访问条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。</li>
<li>这对软件开发者来说是一件很友好的事情，即使程序员没有专门编写防御代码，也能够避免大多数的溢出攻击。</li>
<li>但是对于虚拟机的执行子系统来说，<strong>每次数组元素的读写都带有一次隐含的条件判定操作</strong>，对于拥有大量数组访问的程序代码，这必定是一种<strong>性能负担</strong>。</li>
</ul>
<p>为了安全，<strong>数组边界检查肯定是要做的</strong>，但数组边界检查<strong>是不是必须在运行期间一次不漏地进行</strong>则是可以“商量”的事情。</p>
<p>例如下面这个简单的情况：数组下标是一个常量，如foo[3]，只要<strong>在编译期根据数据流分析来确定foo.length的值</strong>，并判断下标“3”没有越界，执行的时候就无须判断了。</p>
<p>更加常见的情况是，数组访问发生在循环之中，并且使用循环变量来进行数组的访问。如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length)之内，那么在循环中就可以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。</p>
<p>把这个数组边界检查的例子放在更高的视角来看，<strong>大量的安全检查使编写Java程序比编写C和C++程序容易了很多</strong>，比如：数组越界会得到ArrayIndexOutOfBoundsException异常；空指针访问会得到NullPointException异常；除数为零会得到ArithmeticException异常……在C和C++程序中出现类似的问题，一个不小心就会出现Segment Fault信号或者Windows编程中常见的“XXX内存不能为Read/Write”之类的提示，处理不好程序就直接崩溃退出了。但这些安全检查也导致出现相同的程序，从而使Java比C和C++要做更多的事情（各种检查判断），这些事情就会导致一些隐式开销，如果不处理好它们，就很可能成为一项“Java语言天生就比较慢”的原罪。</p>
<ul>
<li><p>为了消除这些隐式开销，除了如<strong>数组边界检查优化这种尽可能把运行期检查提前到编译期完成的思路之外</strong>，</p>
</li>
<li><p>还有一种避开的处理思路——隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这种方案。举个例子，程序中访问一个对象（假设对象叫foo）的某个属性（假设属性叫value），那以Java伪代码来表示虚拟机访问foo.value的过程为：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> foo.value;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用隐式异常优化之后，虚拟机会把上面的伪代码所表示的访问过程变为如下伪代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除了 一次判断foo是否为空的操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> foo.value;</span><br><span class="line">&#125; <span class="keyword">catch</span> (segment_fault) &#123;</span><br><span class="line">	uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机会注册一个Segment Fault信号的异常处理器（伪代码中的uncommon_trap()，务必注意这里是指进程层面的异常处理器，并非真的Java的try-catch语句的异常处理器），</p>
<ul>
<li>这样当foo不为空的时候，对value的访问是不会有任何额外对foo判空的开销的，</li>
<li>而代价就是当foo真的为空时，必须转到异常处理器中恢复中断并抛出NullPointException异常。进入异常处理器的过程涉及进程从用户态转到内核态中处理的过程，结束后会再回到用户态，速度远比一次判空检查要慢得多。</li>
<li>当foo极少为空的时候，隐式异常优化是值得的，但假如foo经常为空，这样的优化反而会让程序更慢。</li>
<li>幸好HotSpot虚拟机足够聪明，它会根据运行期收集到的性能监控信息自动选择最合适的方案</li>
</ul>
<p>与语言相关的其他消除操作还有不少，如<strong>自动装箱消除（Autobox Elimination）、安全点消除（Safepoint Elimination）、消除反射（Dereflection）</strong>等，这里就不再一一介绍了。</p>
<h2 id="深入理解Graal编译器（TODO）"><a href="#深入理解Graal编译器（TODO）" class="headerlink" title="深入理解Graal编译器（TODO）"></a>深入理解Graal编译器（TODO）</h2><h3 id="代码中间表示"><a href="#代码中间表示" class="headerlink" title="代码中间表示"></a>代码中间表示</h3><p>Graal编译器在设计之初就刻意采用了与HotSpot服务端编译器一致（略有差异但已经非常接近）的中间表示形式，也即是被称为<strong>Sea-of-Nodes的中间表示</strong>，或者与其等价的被称为<strong>理想图（IdealGraph，在代码中称为Structured Graph）的程序依赖图（Program Dependence Graph，PDG）形式</strong>。</p>
<p>在11.2节即时编译器的实战中，我们已经通过可视化工具Ideal Graph Visualizer看到过在理想图上翻译和优化输入代码的整体过程，</p>
<p>从编译器内部来看即：<strong>字节码→理想图→优化→机器码（以Mach NodeGraph表示）的转变过程</strong>。在本节里面，我们以例子和对照Graal源码的形式，详细讲解输入代码与理想图的转化对应关系，以便读者理解Graal是如何基于理想图去优化代码的。</p>
<h4 id="理想图"><a href="#理想图" class="headerlink" title="理想图"></a>理想图</h4><p>理想图是一种有向图，<strong>用节点来表示程序中的元素，譬如变量、操作符、方法、字段等</strong>，而<strong>用边来表示数据或者控制流</strong>。我们先从最简单的例子出发。譬如有一个表达式：x+y，在理想图中可以表示为x、y两个节点的数据流流入加法操作符，表示相加操作读取了x、y的值，流出的便则表示数据流的流向，即相加的结果会在哪里被使用，如图11-13所示。</p>
<p><img src="/uploads/jvm/13Compile/IdealGraph01.png"></p>
<p>我们把例子稍微复杂化一些，把表达式x+y变为getX()+getY()，仍是用理想图表达其计算过程，这时候除了数据流向之外，还必须要考虑方法调用的顺序。在理想图中用另外一条边来表示方法的调用（为了便于区分，数据流笔者使用蓝色线（以虚线表示），控制流使用红色线（以实线表示）），说明代码的执行顺序是先调用getX()方法，再调用getY()方法，如图11-14所示。</p>
<p><img src="/uploads/jvm/13Compile/IdealGraph02.png"></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>后端编译与优化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-16-Java内存模型与线程</title>
    <url>/2021/01/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-16-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><p>衡量一个服务性能的高低好坏，<strong>每秒事务处理数（Transactions Per Second，TPS</strong>）是重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又是有非常密切的关系。对于计算量相同的任务，程序线程并发协调得有条不紊，效率自然就会很高；反之 线程之间频繁争用数据，互相阻塞甚至死锁，将会大大降低程序得并发能力。</p>
<h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>我们先花费一点时间去了解一下物理计算机中的并发问题。<strong>物理机遇到的并发问题与虚拟机中的情况有很多相似之处</strong>，物理机对并发的处理方案对虚拟<br>机的实现也有相当大的参考意义。</p>
<p>物理机：</p>
<p>由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲： </p>
<ul>
<li> 将运算需要使用的数据复制到缓存中，让运算能快速的进行，</li>
<li>当运算结束后，在将缓存中的数据同步到内存之中，这样处理器就无须等待缓慢的内存读写了。</li>
</ul>
<p>基于高速缓存的存储交互很好地解决了处理器和内存速度之间的矛盾，但是也为计算机系统带来了更高的复杂度，它引入了一个新的问题：  <strong>缓存一致性（Cache  Coherence）</strong> 。在多路处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存（Main Memory），这种系统被称为 <strong>共享内存多核系统（Shared Memory Multi-processors system）</strong>，如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。如果真的发生这种情况，那同步回到主内存时该以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p>
<p>从本章开始，我们将会频繁见到“<strong>内存模型</strong>”一词，它可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</p>
<ul>
<li>不同架构的物理机器可以拥有不一样的内存模型，</li>
<li>而Java虚拟机也有自己的内存模型，并且这里介绍的<strong>内存访问操作以及硬件的缓存访问操作具有高度的可类比性。</strong></li>
</ul>
<p><img src="/uploads/jvm/14memoryModel/cpu-memory-interaction.png"></p>
<p>除了增加<strong>高速缓存</strong>之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）优化</strong>，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但<strong>并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致</strong>，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有   <strong>指令重排序（Instruction Reorder）优化</strong>。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>《Java虚拟机规范》中曾试图定义一种<strong>“Java内存模型”（Java Memory Model，JMM）</strong>来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是也必须定义得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，</p>
<p>直至JDK 5（实现了JSR-133[3]）发布后，Java内存模型才终于成熟、完善起来了。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><ul>
<li><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</p>
</li>
<li><p>此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了<strong>实例字段、静态字段和构成数组对象的元素</strong>，但是<strong>不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题</p>
</li>
<li><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）</p>
</li>
<li><p>每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本[2]，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据</p>
</li>
<li><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图12-2所示，注意与图12-1进行对比。</p>
</li>
</ul>
<p><img src="/uploads/jvm/14memoryModel/thread-memory-interaction.png"></p>
<p>ps： 如果局部变量是一个reference类型，它引用的对象在Java堆中可被各个线程共享，但是reference本身在Java栈的局部变量表中是线程私有的</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从<strong>主内存拷贝到工作内存</strong>、如何从<strong>工作内存同步回主内存</strong>这一类的实现细节，Java内存模型中定义了以下8中操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）</p>
<ul>
<li>lock（锁定）： 作用于 <strong>主内存的变量</strong>，它把一个变量标识为一条线程独占的状态</li>
<li>unlock(解锁): 作用域主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）： 作用域主内存的变量，它把一个变量的值从主内存传输到 线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）： 作用于 工作内存的变量，它把read操作从主内存中得到的变量值 放入到工作内存的变量副本中。</li>
<li>use（使用）： 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>
<li>store（存储）： 作用于工作内存的变量，它把工作内存中一个变量的值 传送到主内存中，以便随后的write操作使用</li>
<li>write(写入)： 作用于主内存的变量，它把store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。</p>
<p>注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令<br>的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但 <strong>lock操作可以被同一条线程重复执行多次</strong>，多次执行lock后，<strong>只有执行相同次数的unlock操作，变量才会被解锁。</strong></li>
<li>如果对一个变量执行lock操作，那将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量前，需要<strong>重新执行load或assign操作以初始化变量的值</strong>。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字 volatile可以说时java虚拟机提供的最轻量级的同步机制，了解volatile 变量的语义对后面理解多线程操作的其他特性很有意义。</p>
<p>当一个变量被定义为 volatile 之后，它将具备两项特性： </p>
<ul>
<li>第一项是 保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时需要 都需要通过主内存来完成。 比如： 线程A修改了一个普通变量的值，然后向主内存进行回写， 另外一条线程B在线程A回写完成了之后 再对主内存进行读取操作，新变量值才会对线程B可见。</li>
<li>关于volatile变量的可见性，经常会被开发人员误解，他们会误以为这句话的描述时正确的： “<strong>volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反映到其他线程之中</strong>。换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的”  这句话的<strong>论据部分并没有错，</strong>但是由其论据并不能得出“基于volatile变量的运算在并发下是线程安全的”这样的结论。</li>
<li>volatile变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但<strong>由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题</strong>），但是<strong>Java里面的运算操作符并非原子操作</strong>，这导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因，请看代码清单12-1中演示的例子。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析:"></a>结果分析:</h4><p>这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。这是为什么呢？</p>
<p>问题就出在自增运算“race++”之中，我们用Javap反编译这段代码后会得到代码清单12-2所示，发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上已经很容易分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。</p>
<p>代码清单12-2　VolatileTest的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">        Stack=<span class="number">2</span>, Locals=<span class="number">0</span>, Args_size=<span class="number">0</span></span><br><span class="line">        0: getstatic		 #13; //Field race:I</span><br><span class="line">        <span class="number">3</span>: iconst_1</span><br><span class="line">        <span class="number">4</span>: iadd</span><br><span class="line">        5: putstatic		 #13; //Field race:I</span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>实事求是地说，使用字节码来分析并发问题仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器要运行许多行代码才能实现它的语义。如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令。</p>
<p>此处使用-XX：+PrintAssembly参数输出反汇编来分析才会更加严谨一些，</p>
<p><strong>由于volatile 变量只能保证可见性，在不符合一下两条规则的运算场景中</strong>，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁 或者原子类）来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<p>而在像代码清单12-3所示的这类场景中就很适合使用volatile变量来控制并发，当shutdown()方法被调用时，能保证所有线程中执行的doWork()方法都立即停下来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	shutdownRequested = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123;</span><br><span class="line">    <span class="comment">// 代码的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用volatile 变量的第二个语义是  <strong>禁止指令重排序优化</strong>，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序 与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“<strong>线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）”</strong></p>
<p>代码清单12-4　指令重排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">	sleep();</span><br><span class="line">&#125;/</span><br><span class="line">/ 使用线程A中初始化好的配置信息</span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>

<p>上面的代码时一段伪代码，其中描述的是 开发中常见的配置读取过程。只是我们在处理配置文件的时候一般都不会并发，所以没有察觉到这会有问题。</p>
<p>如果定义initialized 变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一条代码 initialized=true 被提前执行。这样在线程B中使用配置信息的代码就可能出现错误，而 volatile 关键字则可以避免此类情况的发生 。</p>
<p>指令重排序是并发编程中最容易导致开发人员产生疑惑的地方之一，除了上面伪代码的例子之外，再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。代码清单12-5所示是一段标准的双锁检测（Double Check Lock，DCL）单例[3]代码，可以观察加入volatile和未加入volatile关键字时所生成的汇编代码的差别。<br>代码清单12-5　DCL单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        	&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，这段代码对instance变量赋值的部分如代码清单12-6所示。<br>代码清单12-6　对instance变量赋值</p>
<p><img src="/uploads/jvm/14memoryModel/MemoryBarries.png" alt="image-20210131213832956"></p>
<p>通过对比发现，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便是赋值操作）多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个<strong>内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置</strong>，注意不要与第3章中介绍的垃圾收集器用于捕获变量访问的内存屏障互相混淆），只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。</p>
<h4 id="volatile性能问题"><a href="#volatile性能问题" class="headerlink" title="volatile性能问题"></a>volatile性能问题</h4><ul>
<li>在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），</li>
<li>但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说volatile就会比synchronized快上多少。</li>
<li>volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</li>
<li>不过即便如此，大多数场景下volatile的总开销仍然要比锁来得更低</li>
<li>我们在volatile与锁中选择的唯一判断依据<strong>仅仅是volatile的语义能否满足使用场景的需求。</strong></li>
</ul>
<h4 id="Java内存模型中对volatile变量定义的特殊规则"><a href="#Java内存模型中对volatile变量定义的特殊规则" class="headerlink" title="Java内存模型中对volatile变量定义的特殊规则"></a>Java内存模型中对volatile变量定义的特殊规则</h4><p>假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：</p>
<ol>
<li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现。  （<strong>这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改</strong>）</li>
<li>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现。（<strong>这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以</strong><br><strong>看到自己对变量V所做的修改。</strong>）</li>
<li>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的<br>对变量W的read或write动作。如果A先于B，那么P先于Q。(<strong>这条规则要求volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序</strong><br><strong>相同。</strong>)</li>
</ol>
<h4 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h4><p>Java内存模型是围绕在并发过程中如何处理原子性、可见性和有序性着三个特征来建立的。</p>
<ol>
<li>原子性</li>
</ol>
<ul>
<li><p>由Java内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写 都具备原子性的（例外就是long和double 的非原子性协定，）</p>
</li>
<li><p>如果应用场景需要一个更大范围的原子性保证，Java内存模型 还提供了lock 和 unlock操作来满足这种需求，尽管虚拟机 未把lock 和unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitor-enter 和 monitor-exit来隐式地使用这两个操作。 这两个字节码指令映射到Java代码中就是同步块-synchronized 关键字，因此在synchronized 块之间地操作也具备原子性。</p>
</li>
</ul>
<ol start="2">
<li>可见性</li>
</ol>
<p>可见性就指 ：当一个线程修改了共享变量地值的时候，其他线程能够立即得知这个修改。之前地volatile 变量就是这样的。</p>
<ul>
<li><p>Java内存模型是通过在变量修改后将新值同步回主内存， 在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
</li>
<li><p>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。</p>
</li>
<li><p>而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</p>
</li>
</ul>
<ol start="3">
<li>有序性</li>
</ol>
<ul>
<li><p>Java程序中天然的有序性可以总结为1句话： <strong>如果在本线程内观察，所有的操作都是有序的</strong>； <strong>如果在一个线程中观察 另一个线程，所有的操作都是无序的</strong>。</p>
</li>
<li><p>前半句是指“<strong>线程内似表现为串行的语义”（Within-Thread As-If-SerialSemantics）</strong>，后半句是指“<strong>指令重排序”现象和“工作内存与主内存同步延迟</strong>”现象。</p>
</li>
<li><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
</li>
</ul>
<h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的定义之中。</p>
<p>先行发生是 Java内存模型中定义的两项操作之间的偏序关系，比如操作A 先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响 能被操作B观察到，影响包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>代码清单12-8　先行发生原则示例1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 以下操作在线程A中执行</span><br><span class="line">i = 1;</span><br><span class="line">// 以下操作在线程B中执行</span><br><span class="line">j = i;</span><br><span class="line">// 以下操作在线程C中执行</span><br><span class="line">i = 2;</span><br></pre></td></tr></table></figure>



<p>假设线程A中的操作“i=1”先行发生于线程B的操作“j=i”，那我们就可以确定在线程B的操作执行后，变量j的值一定是等于1，得出这个结论的依据有两个：</p>
<ul>
<li>一是根据先行发生原则，“i=1”的结果可以被观察到</li>
<li>二是线程C还没登场，线程A操作结束之后没有其他线程会修改变量i的值</li>
</ul>
<p>现在再来考虑线程C，我们依然保持线程A和B之间的先行发生关系，而C出现在线程A和B的操作之间，但是C与B没有先行发生关系，那j的值会是多少呢？</p>
<p>答案是不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候<strong>线程B就存在读取到过期数据的风险</strong>，不具备多线程安全性。</p>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li><strong>程序次序规则（Program Order Rule）</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li><strong>管程锁定规则（Monitor Lock Rule）</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</li>
<li><strong>volatile变量规则（Volatile Variable Rule）</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li>
<li><strong>线程启动规则（Thread Start Rule）</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则（Thread Termination Rule）</strong>：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li>
<li><strong>线程中断规则（Thread Interruption Rule）</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生</li>
<li><strong>对象终结规则（Finalizer Rule）</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li><strong>传递性（Transitivity）</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>Java语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些，下面演示一下如何使用这些规则去判定操作间是否具备顺序性，对于读写共享变量的操作来说，就是线程是否安全。读者还可以从下面这个例子中感受一下“时间上的先后顺序”与“先行发生”之间有什么不同。演示例子如<br>代码清单12-9所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="function">pubilc <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码清单12-9中显示的是一组再普通不过的getter/setter方法，假设存在线程A和B，线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？<br>我们依次分析一下先行发生原则中的各项规则。</p>
<ul>
<li><p>由于两个方法分别由线程A和B调用，不在一个线程中，所以程序次序规则在这里不适用；</p>
</li>
<li><p>由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；</p>
</li>
<li><p>由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；</p>
</li>
<li><p>后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。</p>
</li>
<li><p>因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，</p>
</li>
<li><p>因此我们可以判定，尽管线程A在操作时间上先于线程B，但是无法确定线程B中getValue()方法的返回结果，换句话说，这里面的操作不是线程安全的。</p>
<p>那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：</p>
<ul>
<li>要么把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；</li>
<li>要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来<br>实现先行发生关系。</li>
</ul>
</li>
</ul>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java线程如何实现并不受Java虚拟机规范的约束，这是一个与具体虚拟机相关的话题。</p>
<ul>
<li>Java线程在早期的Classic虚拟机上（JDK 1.2以前），是基于一种被称为“绿色线程”（Green Threads）的用户线程实现的，</li>
<li>但从JDK 1.3起，“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型。</li>
</ul>
<p>以HotSpot为例，它的每一个Java线程都是直接映射到一个<strong>操作系统原生线程来实现的</strong>，而且中间没有额外的间接结构，所以<strong>HotSpot自己是不会去干涉线程调度的</strong>（可以设置线程优先级给操作系统提供调度建议），全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是<strong>由操作系统完成的</strong>，也都是由操作系统全权决定的。</p>
<h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是<strong>协同式（Cooperative Threads-Scheduling）线程调度和抢占式（Preemptive Threads-Scheduling）线程调度。</strong></p>
<ul>
<li><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题.</p>
<p>它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在<br>那里。</p>
</li>
<li><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。譬如在Java中，有Thread::yield()方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么办法的。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。Java使用的线程调度方式就是抢占式调度.</p>
</li>
<li><p>虽然说Java线程调度是系统自动完成的，但是我们仍然可以“建议”操作系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作是通过设置线程优先级来完成的。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）。在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p>
</li>
<li><p>不过，<strong>线程优先级并不是一项稳定的调节手段</strong>，很显然因为主流虚拟机上的Java线程是被映射到系统的原生线程上来实现的，所以线程调度最终还是由操作系统说了算</p>
</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是：</p>
<ul>
<li><p>新建（New）：创建后尚未启动的线程处于这种状态。</p>
</li>
<li><p>运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</p>
</li>
<li><p>无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：</p>
<ul>
<li><p>没有设置Timeout参数的Object::wait()方法；</p>
</li>
<li><p>没有设置Timeout参数的Thread::join()方法；</p>
</li>
<li><p>LockSupport::park()方法。</p>
</li>
</ul>
</li>
<li><p>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p>
<ul>
<li>Thread::sleep()方法；</li>
<li>设置了Timeout参数的Object::wait()方法；</li>
<li>设置了Timeout参数的Thread::join()方法；</li>
<li>LockSupport::parkNanos()方法；</li>
<li>LockSupport::parkUntil()方法。</li>
</ul>
</li>
<li><p>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到<br>一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时<br>间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>
</li>
<li><p>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</p>
</li>
</ul>
<p>上述6种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如图12-6所示。</p>
<p><img src="/uploads/jvm/14memoryModel/thread-status-trans.png"></p>
<h2 id="Java与协程"><a href="#Java与协程" class="headerlink" title="Java与协程"></a>Java与协程</h2><h3 id="内核线程的局限"><a href="#内核线程的局限" class="headerlink" title="内核线程的局限"></a>内核线程的局限</h3><p>可以通过一个具体场景来解释目前Java线程面临的困境。今天对Web应用的服务要求，不论是在请求数量上还是在复杂度上，与十多年前相比已不可同日而语，这一方面是源于业务量的增长，另一方面来自于为了应对业务复杂化而不断进行的服务细分。现代B/S系统中一次对外部业务请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在减少单个服务复杂度、增加复用性的同时，也不可避免地增加了服务的数量，缩短了留给每个服务的响应时间。这要求每一个服务都必须在极短的时间内完成计算，这样组合多个服务的总耗时才不会太长；也要求每一个服务提供者都要能同时处理数量更庞大的请求，这样才不会出现请求由于某个服务被阻塞而出现等待。</p>
<p>Java目前的并发编程机制就与上述架构趋势产生了一些矛盾，1：1的内核线程模型是如今Java虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。</p>
<p>传统的Java Web服务器的线程池的容量通常在几十个到两百之间，当程序员把数以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。现实的需求在迫使Java去研究新的解决方案，同大家又开始怀念以前绿色线程的种种好处</p>
<h3 id="协程的复苏"><a href="#协程的复苏" class="headerlink" title="协程的复苏"></a>协程的复苏</h3><p>Q&amp;A : 为什么内核线程调度切换起来成本就要更高？</p>
<p>内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本。</p>
<p>假设发生了这样一次线程切换：<strong>线程A -&gt; 系统中断 -&gt; 线程B</strong></p>
<p>处理器要去执行线程A的程序代码时，并不是仅有代码程序就能跑得起来，程序是数据与代码的组合体，代码执行时还必须要有上下文数据的支撑。而这里说的“上下文”，</p>
<ul>
<li>以程序员的角度来看，是方法调用过程中的各种局部的变量与资源；</li>
<li>以线程的角度来看，是方法的调用栈中存储的各类信息；</li>
<li>而以操作系统和硬件的角度来看，则是存储在内存、缓存和寄存器中的一个个具体数值。</li>
<li>物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源，当中断发生，从线程A切换到线程B去执行之前，操作系统首先要把线程A的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态，这样线程B被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。</li>
</ul>
<p>由于最初多数的用户线程是被设计成协同式调度（Cooperative Scheduling）的，所以它有了一个别名——“协程”（Coroutine）。又由于这时候的协程会<br>完整地做调用栈的保护、恢复工作，所以今天也被称为“有栈协程”（Stackfull Coroutine），起这样的名字是为了便于跟后来的“无栈协程”（Stackless Coroutine）区分开。无栈协程不是本节的主角，不过还是可以简单提一下它的典型应用，即各种语言中的await、async、yield这类关键字。无栈协程本质上<br>是一种有限状态机，状态保存在闭包里，自然比有栈协程恢复调用栈要轻量得多，但功能也相对更有限。</p>
<ul>
<li><p>协程的主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多</p>
</li>
<li><p>协程当然也有它的局限，需要在应用层面实现的内容（调用栈、调度器这些）特别多，这个缺点就不赘述了。除此之外，协程在最初，甚至在今天很多语言和框架中会被设计成协同式调度，这样在语言运行平台或者框架上的调度器就可以做得非常简单</p>
</li>
<li><p>具体到Java语言，还会有一些别的限制，譬如HotSpot这样的虚拟机，Java调用栈跟本地调用栈是做在一起的。如果在协程中调用了本地方法，还能否正常切换协程而不影响整个线程？另外，如果协程中遇传统的线程同步措施会怎样？譬如Kotlin提供的协程实现，一旦遭遇synchronize关键字，那挂起来的仍将是整个线程。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java内存模型与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-17-线程安全与锁优化</title>
    <url>/2021/02/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-17-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>《Java并发编程实战（Java Concurrency In Practice）》的作者Brian Goetz为“线程安全”做出了一个比较恰当的定义：</p>
<ul>
<li>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是 线程安全的</li>
<li>这个定义就很严谨而且有可操作性，它要求线程安全的代码都必须具备一个共同特征：<strong>代码本身封装了所有必要的正确性保障手段（如互斥同步等</strong>），令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。这点听起来简单，但其实并不容易做到，在许多场景中，我们都会将这个定义弱化一些</li>
</ul>
<h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><ul>
<li><p>在Java语言中，线程安全具体是如何体现的？</p>
</li>
<li><p>有哪些操作是线程安全的？</p>
</li>
</ul>
<p>为了更深入地理解线程安全，在这里我们可以不把线程安全当作一个非真即假的二元排他选项来看待，而是按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下五类：<strong>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</strong></p>
<h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>在Java语言里面，<strong>不可变（Immutable）的对象一定是线程安全的</strong>，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。  在讲解“final关键字带来的可见性”时曾经提到过一点：  只要一个不可变对象被正确的构建出来（即没有发生this 引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它再多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。</p>
<ul>
<li><p>Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。</p>
</li>
<li><p>如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。</p>
</li>
<li><p>不妨类比java.lang.String类的对象实例，它是一个典型的不可变对象，用户调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象</p>
</li>
<li><p>保证对象行为不影响自己状态的途径有很多种，最简单的一种就是把对象里面带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的，例如代码清单13-1中所示的java.lang.Integer构造函数，它通过将内部状态变量value定义为final来保障状态不变</p>
</li>
<li><p>代码清单13-1　JDK中Integer类的构造函数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The value of the &lt;code&gt;Integer&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a newly allocated &lt;code&gt;Integer&lt;/code&gt; object that</span></span><br><span class="line"><span class="comment">* represents the specified &lt;code&gt;int&lt;/code&gt; value.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value the value to be represented by the</span></span><br><span class="line"><span class="comment">* &lt;code&gt;Integer&lt;/code&gt; object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java类库API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类型及java.lang.Number的部分子类，如Long和Double等数值包装类型、BigInteger和BigDecimal等大数据类型。但同为Number子类型的原子类AtomicInteger和AtomicLong则是可变的，读者不妨看看这两个原子类的源码，想一想为什么它们要设计成可变的。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This class intended to be implemented using VarHandles, but there</span></span><br><span class="line"><span class="comment">     * are unresolved cyclic startup dependencies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; <span class="comment">//因为 被 volatile修饰了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>绝对的线程安全能够完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的，甚至不切实际的代价。</p>
<p>在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p>
<p>我们可以通过Java API中一个不是“绝对线程安全”的“线程安全类型”来看看这个语境里的“绝对”究竟是什么意思。</p>
<p>如果说java.util.Vector是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，<strong>因为它的add()、get()和size()等方法都是被synchronized修饰的</strong>，尽管这样效率不高，但保证了具备原子性、可见性和有序性。不过，即使它所有的方法都被修饰成synchronized，也不意味着调用它的时候就永远都不再需要同步手段了，请看看代码清单13-2中的测试代码。</p>
<p>代码清单13-2　对Vector线程安全的测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTestCase_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        System.out.println((vector.get(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line">            <span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">Exception in thread <span class="string">&quot;Thread-469&quot;</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="number">17</span></span><br><span class="line">	at java.base/java.util.Vector.get(Vector.java:<span class="number">777</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter13.VectorTestCase_1$<span class="number">2.</span>run(VectorTestCase_1.java:<span class="number">31</span>)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:<span class="number">844</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尽管这里使用到的Vector的get()、remove()和size()方法都是同步的，</p>
<ul>
<li>但是在多线程的环境中，如果不在方法调用端做额外的同步措施，使用这段代码仍然是不安全的。</li>
<li>因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i已经不再可用，再用访问数组就会抛出一个ArrayIndexOutOfBoundsException异常。</li>
<li>如果要保证这段代码能正确执行下去，我们不得不把removeThread和printThread的定义改成代码清单13-3所示的这样</li>
</ul>
<p>代码清单13-3　必须加入同步保证Vector访问的线程安全性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTestCase_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            vector.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            System.out.println((vector.get(i)));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>假如Vector一定要做到绝对的线程安全，那就必须<strong>在它内部维护一组一致性的快照访问</strong>才行，每次对其中元素进行改动都要产生新的快照，这样要付出的时间和空间成本都是非常大的。</li>
</ul>
<h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，</p>
<ul>
<li>但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。代码清单13-2和代码清单13-3就是相对线程安<br>全的案例。</li>
<li>在Java语言中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。</li>
</ul>
<h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，</p>
<ul>
<li>但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，</li>
<li>通常就是指这种情况。Java类库API中大部分的类都是线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</li>
</ul>
<h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul>
<li>了解过什么是线程安全之后，紧接着的一个问题就是我们应该如何实现线程安全。这听起来似乎是一件由代码如何编写来决定的事情，不应该出现在讲解Java虚拟机的书里。确实，如何实现线程安全与代码编写有很大的关系，</li>
<li>但虚拟机提供的同步和锁机制也起到了至关重要的作用。如何编写代码实现线程安全，以及虚拟机如何实现同步与锁这两方面都会涉及，相对而言更偏重后者一些，只要读者明白了Java虚拟机线程安全措施的原理与运作过程，自己再去思考代码如何编写就不是一件困难的事情了。</li>
</ul>
<h4 id="互斥同步（Mutual-Exclusion-amp-Synchronization）"><a href="#互斥同步（Mutual-Exclusion-amp-Synchronization）" class="headerlink" title="互斥同步（Mutual Exclusion &amp; Synchronization）"></a>互斥同步（Mutual Exclusion &amp; Synchronization）</h4><p>互斥同步（Mutual Exclusion &amp; Synchronization）是一种最常见也是最主要的并发正确性保障手段。</p>
<ul>
<li><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。</p>
</li>
<li><p>而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。</p>
</li>
<li><p>因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p>
</li>
</ul>
<ul>
<li>在Java里面，最基本的互斥同步手段就是<strong>synchronized</strong>关键字，这是一种块结构（BlockStructured）的同步语法。</li>
<li>synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。</li>
<li>这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。</li>
<li>如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；</li>
<li>如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</li>
</ul>
<p>根据《Java虚拟机规范》的要求，<strong>在执行monitorenter指令时，首先要去尝试获取对象的锁。</strong>如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，</p>
<p>而<strong>在执行monitorexit指令时会将锁计数器的值减一</strong>。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p>
<p>我们可以得出两个关于synchronized的直接推论，这是使用它时需特别注意的：</p>
<ul>
<li>被synchronized修饰的同步块<strong>对同一条线程来说是可重入的</strong>。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li>
<li>被synchronized修饰的同步块<strong>在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入</strong>。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li>
</ul>
<p>从执行成本的角度看，持有锁是一个重量级（Heavy-Weight）的操作。</p>
<p>在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。</p>
<p>尤其是对于代码特别简单的同步块（譬如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。因此才说，synchronized是Java语言中一个重量级的操作，有经验的程序员都只会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，以避免频繁地切入核心态之中</p>
<h3 id="锁Lock"><a href="#锁Lock" class="headerlink" title="锁Lock"></a>锁Lock</h3><p>除了synchronized关键字以外，自JDK 5起（实现了JSR 166[1]），Java类库中新提供了java.util.concurrent包（下文称J.U.C包），其中的<br><strong>java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段</strong>。基于Lock接口，用户能够以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔的空间。</p>
<h4 id="重入锁（ReentrantLock）"><a href="#重入锁（ReentrantLock）" class="headerlink" title="重入锁（ReentrantLock）"></a>重入锁（ReentrantLock）</h4><p>重入锁（ReentrantLock）是Lock接口最常见的一种实现[2]，顾名思义，它与synchronized一样是可重入[3]的。在基本用法上，ReentrantLock也与synchronized很相似，只是代码写法上稍有区别而已。不过，ReentrantLock与synchronized相比增加了一些高级功能，</p>
<p>主要有以下三项：等待可中断、可实现公平锁及锁可以绑定多个条件。</p>
<ul>
<li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。</li>
<li>锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。</li>
</ul>
<p>ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于synchronized，那synchronized修饰符是否应该被直接抛弃，不再使用了呢？当然不是，基于以下理由，仍然推荐在synchronized与ReentrantLock都可满足需要时优先使用synchronized：</p>
<ul>
<li>synchronized是在<strong>Java语法层面的同步，足够清晰，也足够简单</strong>。每个Java程序员都熟悉synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized。</li>
<li>Lock应该<strong>确保在finally块中释放锁</strong>，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放。</li>
<li>从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li>
</ul>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><ul>
<li>互斥同步面临的<strong>主要问题是进行线程阻塞和唤醒所带来的性能开销</strong>，因此这种同步也被称为阻塞同步（Blocking Synchronization）。</li>
<li>从解决问题的方式上看，<strong>互斥同步属于一种悲观的并发策略</strong>，其总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享的数据是否真的会出现竞争，它都会进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁），这将会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。</li>
</ul>
<p>随着硬件指令集的发展，我们已经有了另外一个选择：<strong>基于冲突检测的乐观并发策略</strong>，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，<strong>最常用的补偿措施是不断地重试</strong>，直到出现没有竞争的共享数据为止。<strong>这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步（Non-Blocking Synchronization</strong>），使用这种措施的代码也常被称为<strong>无锁（Lock-Free）编程。</strong></p>
<p>为什么说使用乐观并发策略需要“硬件指令集的发展”？</p>
<p>因为我们必须要求<strong>操作和冲突检测这两个步骤具备原子性</strong>。靠什么来保证原子性？如果这里再使用互斥同步来保证就完全失去意义了，所以我们只能靠硬件来实现这件事情，<strong>硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成</strong>，这类指令常用的有：</p>
<ul>
<li>测试并设置（Test-and-Set）；</li>
<li>获取并增加（Fetch-and-Increment）；</li>
<li>·交换（Swap）；</li>
<li><strong>比较并交换（Compare-and-Swap，下文称CAS）</strong>；</li>
<li>加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）</li>
</ul>
<p>前面的三条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能也是类似的.</p>
<p>因为Java里最终暴露出来的是CAS操作，所以我们以CAS指令为例进行讲解。</p>
<h4 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h4><ul>
<li>CAS指令需要有三个操作数，分别是<strong>内存位置</strong>（在Java中可以简单地理解为变量的内存地址，用V表示）、<strong>旧的预期值</strong>（用A表示）和<strong>准备设置的新值</strong>（用B表示）。</li>
<li>CAS指令执行时，<strong>当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值</strong>，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</li>
<li>在JDK 5之后，Java类库中才开始使用CAS操作，该操作由<strong>sun.misc.Unsafe</strong>类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供。</li>
<li>HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了[5]。</li>
<li>不过由于Unsafe类在设计上就不是提供给用户程序调用的类（Unsafe::getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的Class才能访问它），因此在JDK 9之前只有Java类库可以使用CAS，譬如J.U.C包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作来实现。</li>
<li>而如果用户程序也有使用CAS操作的需求，那要么就采用反射手段突破Unsafe的访问限制，要么就只能通过Java类库API来间接使用它。直到JDK 9之后，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作</li>
</ul>
<p>下面笔者将用一段在前面章节中没有解决的问题代码来介绍如何通过CAS操作避免阻塞同步。测试的代码如代码清单12-1所示，为了节省版面笔者就不重复贴到这里了。这段代码里我们曾经通过20个线程自增10000次的操作来<strong>证明volatile变量不具备原子性</strong>，那么如何才能让它具备原子性呢？之前我们的解决方案是<strong>把race++操作或increase()方法用同步块包裹起来</strong>，这毫无疑问是一个解决方案，但是如果改成代码清单13-4所示的写法，效率将会提高许多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomic变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger race = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用AtomicInteger代替int后，程序输出了正确的结果，这一切都要归功于incrementAndGet()方法的原子性。它的实现其实非常简单，如代码清单13-5所示</li>
<li>代码清单13-5　incrementAndGet()方法的JDK源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Atomically increments the current value,</span></span><br><span class="line"><span class="comment">   * with memory effects as specified by &#123;<span class="doctag">@link</span> VarHandle#getAndAdd&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Equivalent to &#123;<span class="doctag">@code</span> addAndGet(1)&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Atomically adds the given value to the current value of a field</span></span><br><span class="line"><span class="comment">   * or array element within the given object &#123;<span class="doctag">@code</span> o&#125;</span></span><br><span class="line"><span class="comment">   * at the given &#123;<span class="doctag">@code</span> offset&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> o object/array to update the field/element in</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> offset field/element offset</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> v;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          v = getIntVolatile(o, offset);</span><br><span class="line">      &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Atomically updates Java variable to &#123;<span class="doctag">@code</span> x&#125; if it is currently</span></span><br><span class="line"><span class="comment">   * holding &#123;<span class="doctag">@code</span> expected&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment">   * and write.  Corresponds to C11 atomic_compare_exchange_strong.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>incrementAndGet()方法在一个无限循环中，不断尝试将一个比当前值大一的新值赋值给自己。如果失败了，那说明在执行CAS操作的时候，旧值已经发生改变，于是再次循环进行下一次操作，直到设置成功为止。</p>
<h4 id="CAS操作的“ABA问题”"><a href="#CAS操作的“ABA问题”" class="headerlink" title="CAS操作的“ABA问题”"></a>CAS操作的“ABA问题”</h4><p>尽管CAS看起来很美好，既简单又高效，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是真正完美的，它存在一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那就能说明它的值没有被其他线程改变过了吗？</p>
<p>这是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA问题”</p>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，也并非一定要进行阻塞或非阻塞同步，<strong>同步与线程安全两者没有必然的联系</strong>。<strong>同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性</strong>，因此会有一些代码天生就是线程安全的，笔者简单介绍其中的两类。</p>
<h4 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h4><ul>
<li>可重入代码（Reentrant Code）：这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。</li>
<li>在特指多线程的上下文语境里（不涉及信号量等因素），我们可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重入性是更为基础的特性，它可以保证代码线程安全，</li>
<li>即所有可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的。</li>
<li>可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。</li>
<li>我们可以通过一个比较简单的原则来判断代码是否具备可重入性：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</li>
</ul>
<h4 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h4><ul>
<li>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可<br>见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</li>
<li>大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</li>
<li>Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字将它声明为“易变的”；</li>
<li>如果一个变量只要被某个线程独享，可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</li>
</ul>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>高效并发是从JDK 5升级到JDK 6后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术，</p>
<p>如<strong>适应性自旋（Adaptive Spinning）、锁消除（LockElimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（BiasedLocking）</strong>等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率。</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><ul>
<li>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力</li>
<li>同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得</li>
<li>如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</li>
<li>为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</li>
<li><strong>自旋等待不能代替阻塞</strong>，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果<strong>锁被占用的时间很</strong><br><strong>短，自旋等待的效果就会非常好</strong>，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。</li>
<li>因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是十次，用户也可以使用参数-XX：PreBlockSpin来自行更改。</li>
</ul>
<ul>
<li>在JDK 6中对自旋锁的优化，引入了自适应的自旋。</li>
<li>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。</li>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。</li>
<li>另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。</li>
<li>有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了。</li>
</ul>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul>
<li>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是<strong>对被检测到不可能存在共享数据竞争的锁进行消除</strong></li>
<li>锁消除的主要判定依据<strong>来源于逃逸分析的数据支持，</strong>如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可<br>以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</li>
</ul>
<p>代码清单13-6　一段看起来没有同步的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也知道，由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编译器会对String连接做自动优化。在JDK 5之前，字符串加法会转化为StringBuffer对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。即代码清单13-6所示的代码可能会变成代码清单13-7所示的样子[1]。</p>
<p>代码清单13-7　Javac转化后的字符串连接操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，经过逃逸分析后会发现它的动态作用域被限制在concatString()方法内<br>部。也就是sb的所有引用都永远不会逃逸到concatString()方法之外，其他线程无法访问到它，所以这里虽然有锁，但是可以被安全地消除掉。在解释执行时这里仍然会加锁，但在经过服务端编译器的即时编译之后，这段代码就会忽略所有的同步措施而直接执行。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。</p>
<p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>代码清单13-7所示连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，</p>
<p>以代码清单13-7为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。</p>
<ul>
<li><p>不过，需要强调一点，<strong>轻量级锁并不是用来代替重量级锁的</strong>，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
</li>
<li><p>要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须要对HotSpot虚拟机对象的内存布局（尤其是对象头部分）有所了解</p>
</li>
</ul>
<p>HotSpot虚拟机的对象头（Object Header）分为两部分，</p>
<ul>
<li><p>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“MarkWord”。这部分是实现轻量级锁和偏向锁的关键。</p>
</li>
<li><p>另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</p>
</li>
<li><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。</p>
</li>
<li><p>它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，对象未被锁定的状态下，Mark Word的32个比特空间里的25个比特将用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，还有1个比特固定为0（这表示未进入偏向模式）。对象除了未被锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种不同状态，这些状态下对象头的存储内容如表13-1所示。</p>
</li>
</ul>
<p><img src="source/uploads/jvm/15lock/01MarkWord.png"></p>
<h4 id="轻量级锁的工作过程"><a href="#轻量级锁的工作过程" class="headerlink" title="轻量级锁的工作过程"></a>轻量级锁的工作过程</h4><ol>
<li><p>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（LockRecord）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3所示。</p>
<p><img src="source/uploads/jvm/15lock/02stackAndObjectHeader.png"></p>
</li>
<li><p>然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图13-4所示</p>
</li>
</ol>
<p><img src="source/uploads/jvm/15lock/03AfterstackAndObjectHeader.png"></p>
<p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，</p>
<p>如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，</p>
<p>否则就说明这个锁对象已经被其他线程抢占了。</p>
<p>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，<strong>必须要膨胀为重量级锁</strong>，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</p>
<p>上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的DisplacedMark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说<strong>轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量</strong>，那<strong>偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了</strong>。</p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<h4 id="偏向锁过程"><a href="#偏向锁过程" class="headerlink" title="偏向锁过程"></a>偏向锁过程</h4><p>假设当前虚拟机启用了偏向锁（启用参数-XX：+UseBiased Locking，这是自JDK 6起HotSpot虚拟机的默认值），那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操等）。</p>
<p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图13-5所示。</p>
<p><img src="source/uploads/jvm/15lock/04pianxiangLOCK"></p>
<p>细心的读者看到这里可能会发现一个问题：当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？</p>
<ul>
<li>在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。</li>
<li>作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变</li>
<li>因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</li>
</ul>
<p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>线程安全与锁优化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-06-类文件结构</title>
    <url>/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><h3 id="平台无关性："><a href="#平台无关性：" class="headerlink" title="平台无关性："></a>平台无关性：</h3><ul>
<li>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石</li>
</ul>
<h3 id="语言无关性："><a href="#语言无关性：" class="headerlink" title="语言无关性："></a>语言无关性：</h3><ul>
<li>Java技术发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，</li>
<li>他们在发布规范文档的时候，也刻意把Java的规范拆分成了：</li>
<li><strong><em>《Java语言规范》（The Java Language Specification）</em></strong></li>
<li><strong><em>及《Java虚拟机规范》（The Java Virtual Machine Specification）</em></strong></li>
</ul>
<p><strong><em>在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上”</em></strong><br><strong><em>（In the future，we will consider bounded extensions to the Java virtual machine to provide better support for other languages）</em></strong></p>
<ul>
<li><strong><em>作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，以Class文件作为他们产品的交付媒介。</em></strong></li>
</ul>
<p>例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把它们的源程序代码编译成Class文件。虚拟机丝毫不关心Class的来源是什么语言</p>
<ul>
<li>Java语言中的各种语法、关键字、常量变量和运算符号的语义 最终都会由多条字节码指令组合来表达 ，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。（类似于 java语言的功能只是 字节码功能的一个子集）</li>
<li>因此有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于java的语言特性提供了发挥空间</li>
</ul>
<p><img src="/uploads/jvm/08-JVM-nobindLanguage.png"></p>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>注意：</p>
<ul>
<li>任何一个Class文件都对应着唯一的一个类或接口的定义信息</li>
<li>类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）</li>
</ul>
<ul>
<li>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在</li>
<li>当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割成若干个8个字节进行存储。</li>
</ul>
<p><strong><em>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”</em></strong></p>
<ul>
<li>无符号数： 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表：  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</li>
</ul>
<p><img src="/uploads/jvm/09-jvm-wufahao-info.png"></p>
<ul>
<li>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</li>
</ul>
<h3 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h3><p>Class的结构不像XML等描述语言，由于它没有任何分隔符号，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>魔数：</p>
<ul>
<li><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件</p>
</li>
<li><p>使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动</p>
</li>
<li><p>Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE（咖啡宝贝？）</p>
</li>
<li><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，</p>
</li>
<li><p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul>
<li>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</li>
</ul>
<h4 id="常量池容量计数值"><a href="#常量池容量计数值" class="headerlink" title="常量池容量计数值"></a>常量池容量计数值</h4><ul>
<li><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）</p>
</li>
<li><p>与Java语言习惯不同，这个容量计数器从1开始，而不是从0开始。</p>
</li>
<li><p>之所以从1开始是因为 ：  在Class文件格式规范制定之时，设计者将第0项常量控出来是有特殊考虑，目的在于 <strong><em>当某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义 ，可以把索引值设置为0</em></strong>来表示。 </p>
</li>
<li><p>如下 图所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。</p>
<p><img src="/uploads/jvm/10-jvm-constantPool.png"></p>
</li>
</ul>
<h4 id="常量类型："><a href="#常量类型：" class="headerlink" title="常量类型："></a>常量类型：</h4><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p>
<ul>
<li><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p>
</li>
<li><p>符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
<h4 id="JVM动态连接"><a href="#JVM动态连接" class="headerlink" title="JVM动态连接"></a>JVM动态连接</h4><ul>
<li>在Class文件中不会保存各个方法、字段最终在内存中的布局信息</li>
<li>这些字段、方法的符号引用不经过虚拟机在运行期转换的话 是无法得到真正的内存入口地址，也就无法直接被虚拟机直接使用</li>
<li>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</li>
</ul>
<h4 id="常量池的项目类型"><a href="#常量池的项目类型" class="headerlink" title="常量池的项目类型"></a>常量池的项目类型</h4><ul>
<li>常量池中每一项常量都是一个表，</li>
<li>最初常量表中共有11种结构 各不相同的表结构数据，后来为了更好的支持动态语言调用，额外增加了4种动态语言相关的常量（）<ul>
<li>JDK 7时增加了前三种：<strong>CONSTANT_MethodHandle_info</strong>、<strong>CONSTANT_MethodType_info</strong>和<strong>CONSTANT_InvokeDynamic_info</strong>。出于性能和易用性的考虑（JDK 7设计时已经考虑到，预留了17个常量标志位），在JDK 11中又增加了第四种常量<strong>CONSTANT_Dynamic_info</strong>。</li>
</ul>
</li>
<li>为了支持Java模块化系统（Jigsaw），又加入了<strong>CONSTANT_Module_info</strong>和<strong>CONSTANT_Package_info</strong>两个常量</li>
<li>截至JDK13，常量表中分别有17种不同类型的常量。</li>
</ul>
<p><img src="/uploads/jvm/12-jvm-constantPool-projectType.png"></p>
<h4 id="常量结构："><a href="#常量结构：" class="headerlink" title="常量结构："></a>常量结构：</h4><ul>
<li>之所以说常量池时最烦琐的数据，是因为这<strong>17种常量类型各自有着完全独立的数据结构</strong>，两两之间被没有什么共性和联系</li>
</ul>
<h5 id="CONSTANT-Class-info"><a href="#CONSTANT-Class-info" class="headerlink" title="CONSTANT_Class_info"></a>CONSTANT_Class_info</h5><ul>
<li><p>回头看看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，</p>
</li>
<li><p>查表6-3的标志列可知这个常量属于<strong>CONSTANT_Class_info</strong>类型，此类型的常量代表一个<strong>类或者接口的符号引用</strong>。</p>
</li>
<li><p>CONSTANT_Class_info的结构比较简单，如表6-4所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>其中 tag 是标志位，它用于区分常量类型；</li>
<li>name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了整个类（或者接口）的全限定名。</li>
<li>本例中的 name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量。</li>
<li>继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个<strong>CONSTANT_Utf8_info</strong>类型的常量。</li>
</ul>
<h5 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a>CONSTANT_Utf8_info</h5><p> CONSTANT_Utf8_info 类型的结构如表6-5所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody></table>
<ul>
<li>length值说明了这个UTF-8编码的字符串长度是多少字节，</li>
<li>它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串</li>
<li>UTF-8缩略编码与普通UTF-8编码的区别是：<br>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，<br>从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符<br>的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</li>
<li>由于Class文件中方法、字段等都需要引用 CONSTANT_Utf8_info 型常量来描述名称，所以 CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度（length的最大值），即u2类型能表达的最大值65535。</li>
<li><strong><em>所以Java程序中如果定义了超过64KB</em></strong> 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</li>
</ul>
<h4 id="javap-工具"><a href="#javap-工具" class="headerlink" title="javap 工具"></a>javap 工具</h4><p>在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。</p>
<p>代码清单6-2中列出了使用javap工具的-verbose参数输出的TestClass.class文件字节码内容（为节省篇幅，此清单中省略了常量池以外的信息）。</p>
<p><strong><em>代码清单6-2　使用javap命令输出常量表</em></strong></p>
<p><img src="/uploads/jvm/13-jvm-constantPool-javap.png"></p>
<ul>
<li>从代码清单6-2中可以看到，计算机已经帮我们把整个常量池的21项常量都计算了出来</li>
<li>其中有些常量似乎从来没有在代码中出现过，如“I”“V”“<init>”“LineNumberTable”“LocalVariableTable”等，这些看起来在源代码中不存在的常量是哪里来的？</li>
<li>这部分常量的确不来源于Java源代码，它们都是编译器自动生成的。会被字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用，它们将会被用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么</li>
<li>因为Java中的“类”是无穷无尽的，无法通过简单的无符号数来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达</li>
</ul>
<h4 id="常量池中的17种数据类型的结构总表"><a href="#常量池中的17种数据类型的结构总表" class="headerlink" title="常量池中的17种数据类型的结构总表"></a>常量池中的17种数据类型的结构总表</h4><p><img src="/uploads/jvm/14-jvm-constantPool-01.png"></p>
<p><img src="/uploads/jvm/14-jvm-constantPool-02.png"></p>
<p><img src="/uploads/jvm/14-jvm-constantPool-03.png"></p>
<h3 id="访问标志（access-flags）"><a href="#访问标志（access-flags）" class="headerlink" title="访问标志（access flags）"></a>访问标志（access flags）</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access flags），这个标志用于识别一些类或者接口层次的访问信息。包括：</p>
<ul>
<li>这个Class是类还是接口</li>
<li>是否定义为public</li>
<li>是否定义为abstract类型</li>
<li>如果是类，是否被声明为final</li>
<li>等等，具体的标志位以及标志的含义见下：</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令的新语义，<br>invokespecial指令的语义在JDK1.0.2发生过改变，为了区别这条指令使用哪种语义，<br>JDK1.0.2之后编译出来的类 这个标志都必须为 真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口和抽象类来说，此标志为真，其他类型都是 假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识 这个类并非由用户代码产生的</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这是一个枚举</td>
</tr>
<tr>
<td>ACC_MODULE</td>
<td>0x8000</td>
<td>标识这是一个模块</td>
</tr>
</tbody></table>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><ul>
<li>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，</li>
<li>而接口索引集合（interfaces）是一组u2类型的数据的集合</li>
<li>Class文件中由这三项数据来确定该类型的继承关系</li>
</ul>
<h4 id="类索引："><a href="#类索引：" class="headerlink" title="类索引："></a>类索引：</h4><p>用于确定这个类的全限定名</p>
<h4 id="父类索引："><a href="#父类索引：" class="headerlink" title="父类索引："></a>父类索引：</h4><p>用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了<br>java.lang.Object外，所有Java类的父类索引都不为0</p>
<h4 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h4><p>用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>
<ul>
<li><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型CONSTANT_Class_info的类描述符常量，</p>
</li>
<li><p>通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</p>
</li>
</ul>
<p><img src="/uploads/jvm/15-jvm-class-index.png"></p>
<h3 id="字段表-field-info-集合"><a href="#字段表-field-info-集合" class="headerlink" title="字段表(field_info)集合"></a>字段表(field_info)集合</h3><ul>
<li>字段表（field_info）用于描述接口或者类中声明的变量。</li>
<li>Java语言中的“字段”（Field）包括**<em>类级变量以及实例级变量**</em>，</li>
<li>但**<em>不包括在方法内部声明的局部变量**</em></li>
</ul>
<h4 id="字段可以包括的修饰符有"><a href="#字段可以包括的修饰符有" class="headerlink" title="字段可以包括的修饰符有:"></a>字段可以包括的修饰符有:</h4><p>字段的作用域（public、private、protected修饰符）、是<strong>实例变量还是类变量（static修饰符）</strong>、可变性（final）、</p>
<p><strong>并发可见性（volatile修饰符，是否强制从主内存读写</strong>）、<strong>可否被序列化（transient修饰符</strong>）、字段数据类型（基本类型、对象、数组）、字段名称。</p>
<ul>
<li>字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li>
</ul>
<h4 id="字段表的最终格式"><a href="#字段表的最终格式" class="headerlink" title="字段表的最终格式:"></a>字段表的最终格式:</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如表6-9所示。</p>
<p>表6-9　字段访问标志<br><img src="/uploads/jvm/16-jvm-attribute-accessFlags.png"></p>
<p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符</p>
<h4 id="全限定名："><a href="#全限定名：" class="headerlink" title="全限定名："></a>全限定名：</h4><p>以代码清单6-1中的代码为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”号表示全限定名结束。</p>
<h4 id="简单名称："><a href="#简单名称：" class="headerlink" title="简单名称："></a>简单名称：</h4><p>简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</p>
<h4 id="描述符："><a href="#描述符：" class="headerlink" title="描述符："></a>描述符：</h4><ul>
<li><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p>
</li>
<li><p>根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，</p>
</li>
<li><p>而对象类型则用字符L加对象的全限定名来表示</p>
</li>
</ul>
<p><img src="/uploads/jvm/17-jvm-attribute-desc.png"></p>
<ul>
<li>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。</li>
<li>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，</li>
<li>方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</li>
</ul>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h4><ul>
<li><p><strong>字段表集合中不会列出从父类或者父接口中继承而来的字段</strong></p>
</li>
<li><p>但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</p>
</li>
<li><p>另外，在<strong>Java语言中字段是无法重载的</strong>，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，</p>
</li>
<li><p>但是<strong>对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法</strong>的</p>
</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul>
<li><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，</p>
</li>
<li><p>依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项</p>
</li>
</ul>
<p>表6-11　方法表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<ul>
<li>因为<strong>volatile关键字和transient关键字不能修饰方法</strong>，所以<strong>方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志</strong>。</li>
<li>与之相对，<strong>synchronized、native、strictfp和abstract关键字可以修饰方法</strong>，<strong>方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、</strong><br><strong>ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志</strong>。</li>
<li>对于方法表，所有标志位及其取值可参见表6-12。</li>
</ul>
<p><img src="/uploads/jvm/18-jvm-method_access_flag.png"></p>
<h4 id="方法里的代码去哪了"><a href="#方法里的代码去哪了" class="headerlink" title="方法里的代码去哪了"></a>方法里的代码去哪了</h4><ul>
<li>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了</li>
<li>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，</li>
<li>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器“<clinit>()”方法和实例构造器“<init>()”方法 </li>
</ul>
<h4 id="重载（-Java语言）"><a href="#重载（-Java语言）" class="headerlink" title="重载（ Java语言）"></a>重载（ Java语言）</h4><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名 。</p>
<h5 id="特征签名："><a href="#特征签名：" class="headerlink" title="特征签名："></a>特征签名：</h5><ul>
<li><p>指 一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名中，所以java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</p>
</li>
<li><p>但是 在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</p>
</li>
<li><p>Java代码的方法特征签名只包括方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表，</p>
</li>
</ul>
<h3 id="属性表（attribute-info）集合"><a href="#属性表（attribute-info）集合" class="headerlink" title="属性表（attribute_info）集合"></a>属性表（attribute_info）集合</h3><p>后续各类属性表中 都会包含xx_index，那是代表对 常量池的引用，例如：</p>
<p>跟随access_flags标志的是两项索引值：<strong>name_index</strong> 和 <strong>descriptor_index</strong>。它们都是对<strong>常量池项的引用</strong>，分别代表着<strong>字段的简单名称以及字段和方法的描述符</strong></p>
<ul>
<li>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</li>
<li>为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项，这些属性具体见表6-13。</li>
</ul>
<p>表6-13　虚拟机规范预定义的属性</p>
<p><img src="/uploads/jvm/19-jvm-attributeinfo-01.png"></p>
<p><img src="/uploads/jvm/19-jvm-attributeinfo-02.png"></p>
<h4 id="Code属性（重点）："><a href="#Code属性（重点）：" class="headerlink" title="Code属性（重点）："></a>Code属性（重点）：</h4><p>理解Code属性是学习后面字节码执行引擎的必要基础，能直接阅读字节码也是工作中分析java代码语义问题的必要工具和基本技能</p>
<p>Code属性是Class文件中最重要的一个属性</p>
<ul>
<li><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。</p>
</li>
<li><p>Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，</p>
</li>
<li><p>譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。</p>
</li>
</ul>
<p>表6-15　Code属性表的结构</p>
<p><img src="/uploads/jvm/20-jvm-attributeinfo-Code.png"></p>
<ul>
<li><strong>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称，</strong></li>
<li><strong>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节</strong>。</li>
<li>max_stack代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度</li>
<li>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</li>
<li>方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理程序的参数（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</li>
<li>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那顾名思义每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令。</li>
<li><strong><em>ps:</em></strong>   关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了*<strong>一个方法不允许超过65535条字节码指令**<em>，即它实际只使用了u2的长度，</em></strong>如果超过这个限制，Javac编译器就会拒绝编译***。一般来讲，编写Java代码时只要不是刻意去编写一个超级长的方法来为难编译器，是不太可能超过这个最大值的限制的。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就有可能因为方法生成字节码超长的原因而导致编译失败。</li>
</ul>
<p>如果**<em>把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分**</em>，那么在整<br>个Class文件里，<strong>Code属性用于描述代码</strong>，<strong>所有的其他数据项目都用于描述元数据</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 原始Java代码</span><br><span class="line">public class TestClass &#123;</span><br><span class="line">    private int m;</span><br><span class="line">    public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">    	<span class="built_in">return</span> m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////编译后</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\&gt;javap -verbose TestClass</span><br><span class="line">// 常量表部分的输出见代码清单6-1，因版面原因这里省略掉</span><br><span class="line">&#123;</span><br><span class="line">public org.fenixsoft.clazz.TestClass();</span><br><span class="line">//构造方法</span><br><span class="line">    Code:</span><br><span class="line">        Stack=1, Locals=1, Args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial <span class="comment">#10; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        4: <span class="built_in">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">    	line 3: 0</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start Length Slot Name Signature</span><br><span class="line">        0 5 0 this Lorg/fenixsoft/clazz/TestClass;</span><br><span class="line"></span><br><span class="line">// 方法 2</span><br><span class="line">public int inc();</span><br><span class="line">Code:</span><br><span class="line">    Stack=2, Locals=1, Args_size=1</span><br><span class="line">    0: aload_0</span><br><span class="line">    1: getfield <span class="comment">#18; //Field m:I</span></span><br><span class="line">    4: iconst_1</span><br><span class="line">    5: iadd</span><br><span class="line">    6: ireturn</span><br><span class="line">LineNumberTable:</span><br><span class="line">	line 8: 0</span><br><span class="line">LocalVariableTable:</span><br><span class="line">    Start Length Slot Name Signature</span><br><span class="line">    0 7 0 this Lorg/fenixsoft/clazz/TestClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问:"></a>疑问:</h4><ul>
<li>这个类有两个方法——实例构造器<init>()和inc()，这两个方法很明显都是没有参数的，为什么Args_size会为1？</li>
<li>而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么会等于1？</li>
</ul>
<h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><ul>
<li><p>一条Java语言里面的潜规则：在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，</p>
</li>
<li><p>而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。</p>
</li>
<li><p>因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。</p>
</li>
<li><p>这个处理只对实例方法有效，如果代码清单6-1中的inc()方法被声明为static，那Args_size就不会等于1而是等于0了。</p>
</li>
<li></li>
</ul>
<h4 id="异常表："><a href="#异常表：" class="headerlink" title="异常表："></a>异常表：</h4><p>如果存在异常表，那它的格式应如表6-16所示，包含四个字段，这些字段的含义为：如果当字节码从第start_pc行[1]到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。</p>
<p>表6-16　属性表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>start_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>end_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>handler_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>catch_pc</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>异常表实际上是Java代码的一部分，尽管字节码中有最初为处理异常而设计的跳转指令，</li>
<li>但《Java虚拟机规范》中明确要求Java语言的编译器<strong>应当选择使用异常表</strong>而不是通过跳转指令来实现Java异常及finally处理机制[2]。</li>
</ul>
<p>代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了<strong>在字节码层面try-catchfinally是如何体现的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Java源码</span><br><span class="line">public int inc() &#123;</span><br><span class="line">    int x;</span><br><span class="line">    try &#123;</span><br><span class="line">        x &#x3D; 1;</span><br><span class="line">    	return x;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    	x &#x3D; 2;</span><br><span class="line">   	 	return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	x &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 编译后的ByteCode字节码及异常表</span><br><span class="line">public int inc();</span><br><span class="line">    Code:</span><br><span class="line">        Stack&#x3D;1, Locals&#x3D;5, Args_size&#x3D;1</span><br><span class="line">            0: iconst_1 &#x2F;&#x2F; try块中的x&#x3D;1</span><br><span class="line">            1: istore_1</span><br><span class="line">            2: iload_1 &#x2F;&#x2F; 保存x到returnValue中，此时x&#x3D;1</span><br><span class="line">            3: istore   4</span><br><span class="line">            5: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            6: istore_1</span><br><span class="line">            7: iload     4 &#x2F;&#x2F; 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            9: ireturn</span><br><span class="line">            10: astore_2 &#x2F;&#x2F; 给catch中定义的Exception e赋值，存储在变量槽 2中</span><br><span class="line">            11: iconst_2 &#x2F;&#x2F; catch块中的x&#x3D;2</span><br><span class="line">            12: istore_1</span><br><span class="line">            13: iload_1 &#x2F;&#x2F; 保存x到returnValue中，此时x&#x3D;2</span><br><span class="line">            14: istore    4</span><br><span class="line">            16: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            17: istore_1</span><br><span class="line">            18: iload      4 &#x2F;&#x2F; 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            20: ireturn</span><br><span class="line">            21: astore_3 &#x2F;&#x2F; 如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</span><br><span class="line">            22: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            23: istore_1</span><br><span class="line">            24: aload_3 &#x2F;&#x2F; 将异常放置到栈顶，并抛出</span><br><span class="line">            25: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">    from to target type</span><br><span class="line">        0 5 10 Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">        0 5 21 any</span><br><span class="line">        10 16 21 any</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>编译器为这段Java源码生成了三条异常表记录，对应三条可能出现的代码执行路径。从Java代码的语义上讲，这三条执行路径分别为：</p>
<ul>
<li>如果try语句块中出现属于Exception或其子类的异常，转到catch语句块处理；</li>
<li>如果try语句块中出现不属于Exception或其子类的异常，转到finally语句块处理；</li>
<li>如果catch语句块中出现任何异常，转到finally语句块处理。</li>
</ul>
<p>返回到我们上面提出的问题，这段代码的返回值应该是多少？熟悉Java语言的读者应该很容易说出答案：</p>
<ul>
<li>如果没有出现异常，返回值是1；</li>
<li>如果出现了Exception异常，返回值是2；</li>
<li>如果出现了Exception以外的异常，方法非正常退出，没有返回值。</li>
</ul>
<p>我们一起来分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。</p>
<ol>
<li>字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且*<strong>将此时x的值复制一份副本到最后一***<br>*</strong>个本地变量表的变量槽中*<strong>（**<em>这个变量槽里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为</em></strong><br><strong><em>方法返回值使用</em></strong>。为了讲解方便，给这个变量槽起个名字：returnValue）。</li>
<li>如果这时候没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后*<strong>将之前保存在returnValue中的整数1***  读入到 *</strong>操作栈***<br><strong><em>顶</em></strong>，**<em>最后ireturn指令会以int形式返回操作栈顶中的值**</em>，方法结束。</li>
<li>如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是<strong>将2赋值给变量x</strong>，然后将变量*<strong>x此时的值赋给returnValue*<strong>，最后</strong>再**<br><strong>将变量x的值改为3</strong>。*</strong>方法返回前同样将returnValue中保留的整数2读到了操作栈顶***。</li>
<li>从第21行开始的代码，作用是<strong>将变量x的值赋为3</strong>，并<strong>将栈顶的异常抛出</strong>，方法结束。</li>
</ol>
<p><strong><em>总结一下：</em></strong></p>
<ul>
<li>如果先给x赋值，再将x值 复制一个副本到本地变量表的 变量槽中，该变量槽中的值在ireturn指令执行时 会被读到操作栈顶，就是最终要 return的值，而不是 x的变量值</li>
<li>如果没有异常，还是会走finally的方法块给x进行赋值，但是最终返回的是 之前本地变量表的变量槽中的值，并不是走完finally块的时候 x的值 </li>
<li>如果发生了异常，且异常属于 catch方法的异常或者其异常子类，则 进catch方法块，给x赋值为2，然后将x=2 的值赋给returnValue，然后执行finally 的x=3,最后将 returnValue的值读到栈顶，输出</li>
<li>如果发生了catch块之外的异常，则 先执行finally 的x=3，再将异常堆栈信息读到栈顶，抛出去，最终不会return x，而是以异常堆栈的形式结束</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    // Java源码</span><br><span class="line">    public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">        int x;</span><br><span class="line">        try &#123;</span><br><span class="line">            x = 1;</span><br><span class="line">            List&lt;Object&gt; list = Arrays.asList();</span><br><span class="line">//            list.get(1);</span><br><span class="line">            System.out.println(1 / 0);</span><br><span class="line">            System.out.println(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">//            ClassCastException(<span class="string">&quot;异常外&quot;</span>)</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">            x = 2;</span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            x = 3;</span><br><span class="line">//            <span class="built_in">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test2 test2 = new Test2();</span><br><span class="line">        int inc = test2.inc();</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><ul>
<li><p>这里的Exceptions属性是在方法表中与Code属性平级的一项属性，不要与前面刚刚讲解完的异常表产生混淆。</p>
</li>
<li><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。</p>
<p>它的结构见表6-17。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_exceptions</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>exception_index_table</td>
<td>number_of_exceptons</td>
</tr>
</tbody></table>
<p>此属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示；exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p>
<h4 id="LocalVariableTable及LocalVariableTypeTable属性"><a href="#LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTable及LocalVariableTypeTable属性"></a>LocalVariableTable及LocalVariableTypeTable属性</h4><ul>
<li><p>LocalVariableTable属性用于描述**<em>栈帧中局部变量表的变量与Java源码中定义的变量之间的关系**</em>，</p>
</li>
<li><p>它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p>
</li>
<li><p>如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
</li>
<li><p>LocalVariableTable属性的结构如表6-19所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>local_variable_table_length</td>
<td>1</td>
</tr>
<tr>
<td>loca_variable_info</td>
<td>loca_variable_table</td>
<td>local_variable_table_length</td>
</tr>
</tbody></table>
<p>其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构如表6-20所示。<br>| 类型               | 名称                       | 数量                |<br>| —————— | ————————– | ——————- |<br>| u2                 |start_pc       | 1                   |<br>| u2                 | length           | 1                   |<br>| u2                 |name_index | 1                   |<br>| u2                 | descriptor_index                     |1 |<br>| u2                 | index | 1                   |</p>
<ul>
<li>start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围</li>
<li>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</li>
<li>index是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时（double和long），它占用的变量槽为index和index+1两个</li>
</ul>
<h4 id="LocalVariableTypeTable（用于支持泛型）"><a href="#LocalVariableTypeTable（用于支持泛型）" class="headerlink" title="LocalVariableTypeTable（用于支持泛型）"></a>LocalVariableTypeTable（用于支持泛型）</h4><ul>
<li><p>在JDK 5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”——LocalVariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。</p>
</li>
<li><p>对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[3]，描述符就不能准确描述泛型类型了。因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。</p>
</li>
</ul>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><ul>
<li><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。</p>
</li>
<li><p>类似“int x=123”和“static int x=123”这样的变量定义在Java程序里面是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。</p>
</li>
<li><p>对**<em>非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>()方法中进行的**</em>；</p>
</li>
<li><p>而对于**<em>类变量**</em>，则有两种方式可以选择：</p>
</li>
<li><ul>
<li>在类构造器<clinit>()方法中</li>
<li>或者使用ConstantValue属性。</li>
</ul>
</li>
<li><p>目前Oracle公司实现的Javac编译器的选择是，如果**<em>同时使用final和static来修饰一个变量**</em>（按照习惯，这里称“常量”更贴切），并且这个变量的<strong>数据类型是基本类型或者java.lang.String</strong>的话，就将会<strong>生成ConstantValue属性</strong>来进行初始化；</p>
</li>
<li><p>如果这个变量<strong>没有被final修饰</strong>，或者<strong>并非基本类型及字符串</strong>，则将会选择在<clinit>()方法中进行初始化。</p>
</li>
<li><p>虽然有final关键字才更符合“ConstantValue”的语义，但<strong>《Java虚拟机规范》中并没有强制要求字段必须设置ACC_FINAL标志，只要求有ConstantValue属性的字段必须设置ACC_STATIC标志而已，</strong></p>
</li>
<li><p><strong>对final关键字的要求是Javac编译器自己加入的限制</strong>。而对ConstantValue的属性值只能限于基本类型和String这点，其实并不能算是什么限制，这是理所当然的结果。</p>
</li>
</ul>
<p>因为此属性的属性值只是一个常量池的索引号，**<em>由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量**</em>，所以就算<br>ConstantValue属性想支持别的类型也无能为力。</p>
<p>ConstantValue属性的结构如表6-23所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_value_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>从数据结构中可以看出ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。</li>
<li>constantvalue_index数据项代表了常量池中一个字面量常量的引用，</li>
<li>根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</li>
</ul>
<h4 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h4><ul>
<li>InnerClasses属性用于记录<strong>内部类与宿主类之间的关联</strong>。</li>
<li>如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</li>
<li>InnerClasses属性的结构如表6-24所示。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_classes</td>
<td>1</td>
</tr>
<tr>
<td>loca_classes_info</td>
<td>inner_classes</td>
<td>number_of_classes</td>
</tr>
</tbody></table>
<p>数据项number_of_classes代表需要记录多少个内部类信息，</p>
<p>每一个内部类的信息都由一个inner_classes_info表进行描述。</p>
<p>inner_classes_info表的结构如表6-25所示。<br>| 类型               | 名称                       | 数量                |<br>| —————— | ————————– | ——————- |<br>| u2                 |inner_class_of_index     | 1                   |<br>| u4                 | outer_class_of_index          | 1                   |<br>| u2                 | inner_name_index | 1                   |<br>| loca_classes_info |      inner_classes_access_flag                     |1 |</p>
<ul>
<li>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</li>
<li>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为0。</li>
<li>inner_class_access_flags是内部类的访问标志，类似于类的access_flags，</li>
</ul>
<h4 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h4><ul>
<li>Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</li>
<li>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</li>
<li>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，</li>
<li>在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位。</li>
<li>编译器通过生成一些在源代码中不存在的Synthetic方法、字段甚至是整个类的方式，实现了越权访问（越过private修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法（Bridge Method）。</li>
<li>所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位中的一项，</li>
<li>唯一的例外是实例构造器“<init>()”方法和类构造器“<clinit>()”方法。</li>
</ul>
<h4 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h4><ul>
<li><p>StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code属性的属性表中。</p>
</li>
<li><p>这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（TypeChecker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
</li>
<li><p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。</p>
</li>
<li><p>类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p>
</li>
<li><p>StackMapTable属性的结构如表6-28所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_entries</td>
<td>1</td>
</tr>
<tr>
<td>stack_map_frame</td>
<td>stack_map_frame_entries</td>
<td>number_of_entries</td>
</tr>
</tbody></table>
<ul>
<li>在Java SE 7版之后的《Java虚拟机规范》中，明确规定对于版本号大于或等于50.0的Class文件，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性，这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。</li>
<li>一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</li>
</ul>
<h4 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h4><ul>
<li>Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。</li>
<li>在JDK 5里面大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（ParameterizedType），则Signature属性会为它记录泛型签名信息。</li>
<li>之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</li>
<li>使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。</li>
<li>但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，</li>
<li>现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。<br>Signature属性的结构如表6-29所示</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>signature_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>其中signature_index项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名或方法类型签名或字段类型签名。</li>
<li>如果当前的Signature属性是类文件的属性，则这个结构表示类签名，</li>
<li>如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，</li>
<li>如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。</li>
</ul>
<h4 id="MethodParameters属性"><a href="#MethodParameters属性" class="headerlink" title="MethodParameters属性"></a>MethodParameters属性</h4><ul>
<li>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。</li>
<li>MethodParameters的作用是记录方法的各个形参名称和信息。</li>
</ul>
<h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><ul>
<li>最初，基于存储空间的考虑，Class文件默认是不储存方法参数名称的，因为给参数起什么名字对计算机执行程序来说是没有任何区别的，所以只要在源码中妥当命名就可以了。</li>
<li>随着Java的流行，这点确实为程序的传播和二次复用带来了诸多不便，由于Class文件中没有参数的名称，如果只有单独的程序包而不附加JavaDoc的话，在IDE中编辑使用包里面的方法时是无法获得方法调用的智能提示的，这就阻碍了JAR包的传播。</li>
<li>后来，“-g：var”就成为了Javac以及许多IDE编译Class时采用的默认值，这样会将方法参数的名称生成到LocalVariableTable属性之中。</li>
<li>不过此时问题仍然没有全部解决，LocalVariableTable属性是Code属性的子属性——没有方法体存在，自然就不会有局部变量表，</li>
<li>但是对于其他情况，譬如抽象方法和接口方法，是理所当然地可以不存在方法体的，对于方法签名来说，还是没有找到一个统一完整的保留方法参数名称的地方。</li>
<li>所以JDK 8中新增的这个属性，使得编译器可以（编译时加上-parameters参数）将方法名称也写进Class文件中，而且MethodParameters是方法表的属性，与Code属性平级的，可以运行时通过反射API获取</li>
</ul>
<p>MethodParameters的结构如表6-32所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>parameters_count</td>
<td>1</td>
</tr>
<tr>
<td>parameter</td>
<td>parameters</td>
<td>parameters_count</td>
</tr>
</tbody></table>
<p>其中，引用到的parameter结构如表6-33所示。<br>表6-33　parameter属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
</tbody></table>
<h4 id="模块化相关属性"><a href="#模块化相关属性" class="headerlink" title="模块化相关属性"></a>模块化相关属性</h4><ul>
<li>JDK 9的一个重量级功能是Java的模块化功能，</li>
<li>因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，</li>
<li>所以，Class文件格式也扩展了**<em>Module、ModulePackages和ModuleMainClas**</em>s三个属性用于支持Java模块化相关功能</li>
</ul>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module:"></a>Module:</h5><p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块*<strong>requires、exports、opens、uses**<em>和</em></strong>provides***定义的全部内容</p>
<p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储<br>了这个模块requires、exports、opens、uses和provides定义的全部内容，其结构如表6-34所示。</p>
<p>表6-34　Module属性结构</p>
<p><img src="/uploads/jvm/22-jvm-Module.png"></p>
<p><strong><em>TODO： 暂时用不到，就先不了解了</em></strong></p>
<h5 id="ModulePackages"><a href="#ModulePackages" class="headerlink" title="ModulePackages"></a>ModulePackages</h5><p>ModulePackages是另一个用于支持Java模块化的变长属性，它用于描述该模块中所有的包，不论是<br>不是被export或者open的。</p>
<h5 id="ModuleMainClass"><a href="#ModuleMainClass" class="headerlink" title="ModuleMainClass"></a>ModuleMainClass</h5><p>ModuleMainClass属性是一个定长属性，用于确定该模块的主类（Main Class），其结构</p>
<h4 id="运行时注解相关属性"><a href="#运行时注解相关属性" class="headerlink" title="运行时注解相关属性"></a>运行时注解相关属性</h4><h5 id="背景：-1"><a href="#背景：-1" class="headerlink" title="背景："></a>背景：</h5><ul>
<li>早在JDK 5时期，Java语言的语法进行了多项增强，其中之一是提供了对注解（Annotation）的支持。</li>
<li>为了存储源码中注解信息，Class文件同步增加了 <strong><em>RuntimeVisibleAnnotations</em></strong>  、*<strong>RuntimeInvisibleAnnotations**<em>、</em></strong>RuntimeVisibleParameterAnnotations*** 和 <strong><em>RuntimeInvisibleParameterAnnotations</em></strong>四个属性。</li>
<li>到了JDK 8时期，进一步加强了Java语言的注解使用范围，又新增类型注解（JSR 308），所以Class文件中也同步增加了 <strong><em>RuntimeVisibleTypeAnnotations</em></strong> 和<br>**<em>RuntimeInvisibleTypeAnnotations**</em> 两个属性。</li>
<li>由于这六个属性不论结构还是功能都比较雷同，因此我们把它们合并到一起，以**<em>RuntimeVisibleAnnotations**</em>为代表进行介绍。</li>
<li><strong>RuntimeVisibleAnnotations</strong>是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，</li>
<li>当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</li>
<li></li>
<li>RuntimeVisibleAnnotations属性的结构如表6-38所示。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_annotations</td>
<td>1</td>
</tr>
<tr>
<td>annotation</td>
<td>annotations</td>
<td>num_annotations</td>
</tr>
</tbody></table>
<p>num_annotations是annotations数组的计数器，annotations中每个元素都代表了一个运行时可见的注解，注解在Class文件中以annotation结构来存储，</p>
<p>具体如表6-39所示<br>表6-39　annotation属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>type_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_element_value_pairs</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>element_value_pairs</td>
<td>num_element_value_pair</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>类文件结构</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解jvm-11-虚拟机字节码执行引擎</title>
    <url>/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>执行引擎是Java虚拟机核心的组成部分之一。</p>
</li>
<li><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，</p>
</li>
<li><p>其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，</p>
</li>
<li><p>而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
</li>
</ul>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><h3 id="栈帧（Stack-Frame）"><a href="#栈帧（Stack-Frame）" class="headerlink" title="栈帧（Stack Frame）"></a>栈帧（Stack Frame）</h3><ul>
<li><p>Java虚拟机以方法作为最基本的执行单元，而 <strong>栈帧</strong> （Stack Frame）则是用于java虚拟机进行方法调用和方法执行背后的数据结构， 它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p>
</li>
<li><p>栈帧存储了方法的<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>和<strong>方法返回地址</strong> 等信息，</p>
</li>
<li><p>每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从<strong>入栈到出栈</strong>的过程</p>
</li>
<li><p>在编译Java程序源码的时候，栈帧需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。</p>
</li>
<li><p>一个栈帧需要分配多少内存，并不会收到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式</p>
</li>
</ul>
<ul>
<li>一个线程中的方法调用链 可能会很长，以java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。</li>
<li>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame）,与这个栈帧关联的方法 被称为 “当前方法”（Current Method）。</li>
<li>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，</li>
</ul>
<h3 id="栈帧的概念结构"><a href="#栈帧的概念结构" class="headerlink" title="栈帧的概念结构"></a>栈帧的概念结构</h3><p><img src="/uploads/jvm/10StackFrame/01-StackFrameConstruct.png"></p>
<h4 id="局部变量表（Local-Variables-Table）"><a href="#局部变量表（Local-Variables-Table）" class="headerlink" title="局部变量表（Local Variables Table）"></a>局部变量表（Local Variables Table）</h4><ul>
<li><p>局部变量表 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量表。 </p>
</li>
<li><p>在Java程序被编译成Class文件时，就在方法的Code属性中的<strong>max_locals</strong> 数据项中确定了该方法所需分配的局部变量表的最大容量</p>
</li>
<li><p>局部变量表的容量以 变量槽（Variable slot）为最小单位，</p>
</li>
<li><p>《Java虚拟机规范》被没有明确指出一个变量槽应占用的 内存空间大小，只有向导性的说每个变量槽 Variable Slot 都应该能存放一个  boolean 、 byte、 char、 short、 int、 float、 reference 或看return Address类型的数据</p>
</li>
</ul>
<h5 id="局部变量表中的数据类型"><a href="#局部变量表中的数据类型" class="headerlink" title="局部变量表中的数据类型"></a>局部变量表中的数据类型</h5><ul>
<li>一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference[1]和returnAddress这8种类型。</li>
<li>而第7种reference类型表示对一个对象实例的引用，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则将无法实现《Java语言规范》中定义的语法约定</li>
<li>第8种returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转，但现在也已经全部改为采用异常表来代替了</li>
<li>对于64位的数据类型，Java虚拟机会以 <strong>高位对齐</strong> 的方式为其分配 <strong>两个连续的变量槽空间</strong> 。Java语言中明确的64位的数据类型只有 long 和 double 两种。</li>
<li>这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中允许把一次long和double数据类型读写分割为两次32位读写的做法有些类<br>似。</li>
<li>由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。</li>
</ul>
<ul>
<li><p>Java虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会<strong>同时使用第N和N+1两个变量槽</strong>.</p>
</li>
<li><p>对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机<strong>不允许采用任何方式单独访问其中的某一个</strong>，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。</p>
</li>
<li><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<strong>参数值到参数列表</strong>的传递过程，即 <strong>实参到形参</strong>的传递。如果执行的时实例方法（没有被 static 修饰的方法），那局部变量表中的<strong>第0 位索引</strong>的变量槽 默认是 用于传递<strong>方法实例的引用</strong>，在方法中可以通过 关键字“this” 来访问到这个隐含的参数。 其余的参数 则是按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
</li>
</ul>
<h5 id="局部变量表的重用"><a href="#局部变量表的重用" class="headerlink" title="局部变量表的重用"></a>局部变量表的重用</h5><ul>
<li>为了尽可能的节省栈帧耗用的内存空间，<strong>局部变量表中的变量槽是可以重用</strong>的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体（就是一个方法体中的局部变量可能用到一半就不使用了，比如方法体有10行，而局部变量只在其中的3-4行被使用，那这个局部变量就没有覆盖整个方法体），如果当前字节码PC计数器的值 已经超过了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。</li>
<li>不过这样的设计除了节省栈帧空间外，还会伴随少量的<strong>副作用</strong></li>
<li>例如 在某些情况下变量槽的复用会直接影响到系统的GC 行为，如下如代码所示</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M </span></span><br><span class="line"><span class="comment"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseVariableSlot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result: (我这里使用的JDK <span class="number">9</span>)</span><br><span class="line">[<span class="number">0.028</span>s][info][gc] Using G1</span><br><span class="line">[<span class="number">0.142</span>s][info][gc] GC(<span class="number">0</span>) <span class="function">Pause Initial <span class="title">Mark</span> <span class="params">(G1 Humongous Allocation)</span> 2M-&gt;1<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 1.368ms</span></span><br><span class="line"><span class="function">[0.142s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle</span></span><br><span class="line"><span class="function">[0.171s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Remark 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.724ms</span></span><br><span class="line"><span class="function">[0.171s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Cleanup 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.174ms</span></span><br><span class="line"><span class="function">[0.175s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">2</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 3.810ms</span></span><br><span class="line"><span class="function">[0.175s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle 33.128ms</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span></span><br></pre></td></tr></table></figure>

<p>代码中可以看到：</p>
<p>向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上“-verbose：gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收掉这64MB的内存。</p>
<p>代码没有回收掉 placeHolder所占的内存说的过去，因为执行system.gc()时，变量 placeholder 还处于作用域之内，虚拟机自然不敢回收掉placeholder 的内存。</p>
<p>我们修改一下代码，改成这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M</span></span><br><span class="line"><span class="comment"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseVariableSlot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result： 同上</span><br><span class="line">    [<span class="number">0.026</span>s][info][gc] Using G1</span><br><span class="line">[<span class="number">0.137</span>s][info][gc] GC(<span class="number">0</span>) <span class="function">Pause Initial <span class="title">Mark</span> <span class="params">(G1 Humongous Allocation)</span> 2M-&gt;1<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 1.593ms</span></span><br><span class="line"><span class="function">[0.137s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle</span></span><br><span class="line"><span class="function">[0.162s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Remark 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.727ms</span></span><br><span class="line"><span class="function">[0.165s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">2</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 3.594ms</span></span><br><span class="line"><span class="function">[0.166s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Cleanup 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.001ms</span></span><br><span class="line"><span class="function">[0.166s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle 28.351ms</span></span><br></pre></td></tr></table></figure>

<p>加入了花括号之后，placeholder的作用域被限制在了 花括号之内，从代码逻辑上讲，在执行 system.gc()的时候，placeholder 已经不可能再被访问了，但执行这段程序的时候，发现 64M的内存 还是没有被回收掉，</p>
<p>为什么呢，解释之前我们再修改一下代码,先对这段代码进行第二次修改，在调用System.gc()之前加入一行“int  a=0；”，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M</span><br><span class="line"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> */</span><br><span class="line">public class ReuseVariableSlot &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            byte[] placeholder = new byte[64 * 1024 * 1024];</span><br><span class="line">        &#125;</span><br><span class="line">         int a = 0;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> result: </span><br><span class="line"> [0.026s][info][gc] Using G1</span><br><span class="line">[0.145s][info][gc] GC(0) Pause Initial Mark (G1 Humongous Allocation) 2M-&gt;1M(80M) 1.527ms</span><br><span class="line">[0.145s][info][gc] GC(1) Concurrent Cycle</span><br><span class="line">[0.170s][info][gc] GC(1) Pause Remark 66M-&gt;66M(80M) 0.789ms</span><br><span class="line">[0.170s][info][gc] GC(1) Pause Cleanup 66M-&gt;66M(80M) 0.351ms</span><br><span class="line">[0.170s][info][gc] GC(1) Concurrent Cycle 25.457ms</span><br><span class="line">[0.174s][info][gc] GC(2) Pause Full (System.gc()) 66M-&gt;1M(80M) 3.362ms </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现加上 int a = 0; 之后，发现内存被回收了 （[info][gc] GC(2) Pause Full (System.gc()) 66M-&gt;1M(80M) 3.362ms ）</p>
<h5 id="代码总结："><a href="#代码总结：" class="headerlink" title="代码总结："></a>代码总结：</h5><p>上面的代码 ，<strong>placeholder 能否被回收</strong> 的根本原因是：  </p>
<ul>
<li>局部变量表的变量槽 是否还存有 关于placeholder数组对象的 <strong>引用</strong></li>
<li>第一次修改中（加花括号），代码虽然 已经离开了placeholder的作用域，但在之后，在没有发生过任何对局部变量表的读写 操作，placeholder 原本所占用的变量槽  还没有被其他变量所复用，所以作为 GC ROOTs 一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断。再绝大部分情况下影响很轻微。 但如果遇到 一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大部分内存但实际已经不会再使用的变量， 手动 将其设置为 null值 （用来代替 int a=0，把变量对应的局部变量槽清空）便不见得是一个绝对无意义的操作 。这是<strong>奇技淫巧</strong> ，并不是很认同。</li>
<li>这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到即时编译器的编译条件）下的“奇技”来使用。Java语言的一本非常著名的书籍《Practical Java》中将把“不使用的对象应手动赋值为null”作为一条推荐的编码规则（笔者并不认同这条规则），但是并没有解释具体原因</li>
<li>这是<strong>奇技淫巧</strong> ，并不是很认同。因为：<ul>
<li>从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法</li>
<li>更关键的是，从执行角度来讲，使用赋null操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，概念模型与实际执行过程是外部看起来等效，内部看上去则可以完全不同。当虚拟机使用解释器执行时，通常与概念模型还会比较接近，但经过即时编译器施加了各种编译优化措施以后，两者的差异就会非常大，只保证程序执行的结果与概念一致。在实际情况中，即时编译才是虚拟机执行代码的主要方式，赋null值的操作在经过即时编译优化后几乎是一定会被当作无效操作消除掉的，这时候将变量设置为null就是毫无意义的行为。字节码被即时编译为本地代码后，对GC Roots的枚举也与解释执行时期有显著差别，以前面的例子来看，经过第一次修改的代码（第二个方法）在经过即时编译后，System.gc()执行时就可以正确地回收内存，根本无须写成代码（第三个方法）的样子。</li>
</ul>
</li>
</ul>
<h5 id="局部变量表不存在准备阶段"><a href="#局部变量表不存在准备阶段" class="headerlink" title="局部变量表不存在准备阶段"></a>局部变量表不存在准备阶段</h5><ul>
<li><p>局部变量表不像类变量那样存在“准备阶段”，</p>
</li>
<li><p>之前我们在《虚拟机的类加载过程》学过，类的字段变量 有2次赋初始值的过程，  一次是在 准备阶段，赋予系统初始值；另外一次是在 初始化阶段，赋予程序员在代码中定义的初始值。 因此 即使在初始化阶段 程序员没有为类变量赋值也没有关系，类变量仍然具有一个决定的初始值（零值，默认值），不会产生歧义。</p>
</li>
<li><p>但是 局部变量就不一样 了，如果一个局部变量定义了，但没有赋初始值，那它是完全不能使用的。</p>
</li>
<li><p>所以不要认为 Java中任何情况都存在 诸如 整型变量默认为0、布尔型变量默认为 false 等这样的默认值规则。</p>
</li>
<li><p>如果局部变量不赋初始值，编译期在编译期间能检查到并提示出来，ide工具是会报错的。</p>
</li>
<li><p>即使编译能通过或者 通过手动的方式生成字节码，在《虚拟机的类加载过程》的字节码验证阶段，也会被虚拟机发现，从而导致 类加载失败。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a; <span class="comment">//</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result:  编译期报错：  可能尚未初始化变量a</span><br></pre></td></tr></table></figure>



<h3 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h3><ul>
<li><p>操作数栈 （Operand Stack）也常被称为操作栈，它是一个<strong>先入后出</strong> (Last In First Out,LIFO） 栈。 </p>
</li>
<li><p>同局部变量表一样， 操作数栈的最大深度也在编译的时候被写入到 Code 属性的 <strong>max_stacks</strong> 数据项之中。</p>
</li>
<li><p>操作数栈的每一个元素 都可以是包括long 和 double 在内的<strong>任意java数据类型</strong> 。32位 数据类型 所占的栈容量为 1，64 位数据类型所占的栈容量为  2。</p>
</li>
<li><p>javac 编译器的数据流分析工作保证了 在方法执行的任何时候，操作数栈的深度 都不会超过 在 max_stacks 数据项设定的最大值。</p>
</li>
</ul>
<h5 id="方法执行时的操作栈动作"><a href="#方法执行时的操作栈动作" class="headerlink" title="方法执行时的操作栈动作"></a>方法执行时的操作栈动作</h5><ul>
<li><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。  在方法的执行过程中，会有各种<strong>字节码指令</strong> 往  <strong>操作数栈</strong> 中写入和提取 内容， 也就是出栈和入栈操作。</p>
<p>譬如 在做算术运算的时候 ，通过将运算涉及的操作数栈 压入栈顶后 ，然后 调用运算指令来执行。</p>
</li>
</ul>
<p>又譬如 在调用其他方法的时候 ，通过操作数栈 来进行方法参数的传递。</p>
<p>举个例子， 例如整数加法 的字节码 iadd, 这条指令在运行的时候 ，要求操作数栈中最接近 栈顶的2个元素 已经存入了2个int 型的数值，当执行 iadd这个指令时候，会把这2 个int 值出栈 并相加，然后将 相加的结果重新入栈 。</p>
<h5 id="字节码指令严格匹配操作栈元素数据类型"><a href="#字节码指令严格匹配操作栈元素数据类型" class="headerlink" title="字节码指令严格匹配操作栈元素数据类型"></a>字节码指令严格匹配操作栈元素数据类型</h5><p>操作数栈中元素的数据类型必须 与字节码指令的序列严格匹配，在编译程序代码的时候，编译期必须严格保证这一点，在类校验阶段的数据流分析中还要 再次验证这一点。</p>
<p>例如： iadd指令只能 用于整型数据的加法，该指令在执行时，最接近栈顶的2个元素的数据类型 必须为int 型，不能出现一个long 和一个float 使用iadd指令相加的 情况。</p>
<h5 id="栈帧的优化"><a href="#栈帧的优化" class="headerlink" title="栈帧的优化"></a>栈帧的优化</h5><ul>
<li><p>Java虚拟机的<strong>解释执行引擎</strong> 被称为“<strong>基于栈的执行引擎</strong>”, 里面的栈 就是操作数栈。后续还会对基于栈的代码执行过程进行更详细的讲解。介绍它与更常见的<strong>基于寄存器的执行引擎</strong>有那些差别</p>
</li>
<li><p>在概念 模型中，两个不同栈帧（Stack Frame）作为不同方法的虚拟机栈 元素，是<strong>完全互相独立</strong>的。  但是在大多数虚拟机的实现中，会对这块进行一些<strong>优化处理</strong> ，令2个 不同方法的栈帧出现一部分 <strong>重叠</strong>。让下面的栈帧的部分操作数栈 与 上面栈帧的部分局部变量表 重叠在一起，这样做不仅节约了 一些空间，更重要的是 在进行方法调用的时候 就可以直接共用 一部分数据，无需进行<strong>额外的 参数 复制传递</strong>了 。重叠的过程如下图所示： </p>
</li>
</ul>
<p><img src="/uploads/jvm/10StackFrame/02-StackFrameOverlap.png"></p>
<h3 id="动态连接（Dynamic-Linking）"><a href="#动态连接（Dynamic-Linking）" class="headerlink" title="动态连接（Dynamic Linking）"></a>动态连接（Dynamic Linking）</h3><p>每个栈帧 都包含一个指向<strong>运行时常量池</strong> 中<strong>该栈帧所属方法的引用</strong>，持有这个引用 是为了支持方法调用过程中的<strong>动态连接</strong>。</p>
<p>通过之前文章，我们知道 Class文件 的常量池中存有 大量的符号引用，字节码中的<strong>方法调用指令</strong> 就以 常量池里<strong>指向方法的符号连接</strong> 作为参数。</p>
<ul>
<li>这些符号引用一部分将在 <strong>类加载阶段</strong>或者<strong>第一次使用的时候</strong>就被转化为<strong>直接引用</strong>，这种转化称为  <strong>静态解析</strong></li>
<li>另外一部分将在<strong>每一次运行期间</strong>都<strong>转化 为直接引用</strong>，这部分就称为 <strong>动态连接</strong>。后续后详细讲解</li>
</ul>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有 2种 方式退出这个方法。</p>
<ul>
<li>第一种退出方式是执行引擎遇到任意一个方法<strong>返回的字节码指令</strong>，这时候 可能会有返回值 传递给上层方法调用者 （调用当前方法的方法称为 <strong>主调方法</strong> 或者 “<strong>调用者</strong>”）， 方法是否有返回值 以及返回值的类型 将根据 何种方法返回指令来决定，这种退出方式 称为 “<strong>正常调用完成（Normal Method Invocation Completion）</strong>”</li>
<li>另外一种退出方式 就是方法执行过程中 遇到了异常，并且这个异常没有在方法体内得到妥善处理。  无论是Java虚拟机内部的异常，还是代码中<strong>athrow字指令</strong> 产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式 称为 “**异常调用完成(Abrupt Method Invocation Completion)**”  。一个方法使用异常完成出口的方式退出，是不会给他的上层调用者 提供任何返回值的。</li>
</ul>
<p>无论采用何种退出方式，在方法退出之后，都必须<strong>返回最初方法被调用的位置</strong>，程序才能继续执行。</p>
<p>方法返回时 可能需要在栈帧中 保存一些信息，用来帮助<strong>恢复它的上层主调方法的执行状态</strong> 。 </p>
<p>一般来说，方法正常退出时，<strong>主调方法的PC计数器的值 就可以作为返回地址</strong>，栈帧中很可能 会保存这个计数器值。</p>
<p>而异常退出的时候，返回地址就是 通过异常处理器 来确定的，栈帧中 一般不会保存这部分信息 （主调方法的PC计数器值）</p>
<h5 id="方法退出的过程"><a href="#方法退出的过程" class="headerlink" title="方法退出的过程"></a>方法退出的过程</h5><p>方法退出的过程实际上等同于<strong>把 当前栈帧出栈</strong>，因此退出时可能执行的操作有：</p>
<ul>
<li>恢复上层主调方法的局部变量表和操作数栈，</li>
<li>把返回值（如果有的话） 压入 调用者（主调方法对应的）栈帧的操作数栈中，</li>
<li>调整PC计数器值 以指向方法调用指令后面的 的一条指令等。</li>
</ul>
<p>这些都是 基于概念模型的讨论，只有具体到某一款 java虚拟机实现，会执行哪些操作才能确定下来</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>
<p>在讨论概念时候，一般会把 <strong>动态连接，方法返回地址 与 其他附加信息</strong>全部归为一类，称为<strong>栈帧信息</strong> 。</p>
<h2 id="方法调用详解（TODO）"><a href="#方法调用详解（TODO）" class="headerlink" title="方法调用详解（TODO）"></a>方法调用详解（TODO）</h2><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体执行过程。</p>
<p>在程序执行时，进行方法调用是最普遍最频繁的操作之一，Class文件的编译过程中 不包含传统程序语言编译的连接步骤，一切方法调用在Class文件 里面存储的都是 符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。 这个特性给了Java带来了更强大的动态扩展能力，也使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用的目标方法在Class 文件里面都是一个 常量池的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是:  方法在程序真正执行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。 换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<strong>解析</strong>（<strong>Resolution</strong>）</p>
<h4 id="编译期可知，运行期不可变"><a href="#编译期可知，运行期不可变" class="headerlink" title="编译期可知，运行期不可变"></a>编译期可知，运行期不可变</h4><p>在Java语言中，符合“编译期可知，运行期不可变”这个要求的方法，主要有 <strong>静态方法</strong> 和<strong>私有方法</strong>两大类，前者与类型直接关联，后者在外部不可访问，这两种方法各自的特点决定了他们都不可能通过继承或 别的方式重写出其他版本，因为它们都适合在类解析阶段进行解析。</p>
<h4 id="方法调用字节码指令"><a href="#方法调用字节码指令" class="headerlink" title="方法调用字节码指令"></a>方法调用字节码指令</h4><p>调用不同类型的方法，字节码指令集里面设计了不同的指令。在Java虚拟机支持 以下5条方法调用字节码指令，分别是：</p>
<ol>
<li>invokestatic ： 用于调用静态方法</li>
<li>invokespecial：  用于调用实例构造器<init>()方法、私有方法和父类中的方法</li>
<li>invokevirtual :  用于调用所有的虚方法</li>
<li>invokeinterface: 用于调用接口方法，会在运行时在确定一个实现该接口的对象</li>
<li>invokedynamic：  现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ol>
<h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><ul>
<li>前面的1-4条调用指令，分配逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</li>
<li>只要能被invokespecial 和 invokestatic指令调用的方法，都可以在解析阶段中确定唯一的调用版本 ，Java语言里符合这个条件的方法 有： </li>
</ul>
<p><strong>静态方法、私有方法、实例构造器、父类方法</strong>4种，再加上被 final修饰的方法（尽管它用invokevirtual）指令调用，这5种方法调用会再类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“<strong>非虚方法</strong>”（<strong>Non-Virtual Method</strong>），与之相反的，其他方法就被称为 <strong>虚方法（Virtual Method）</strong></p>
<p>方法静态解析演示：</p>
<p>演示了一种常见的解析调用的例子，该样例中，<strong>静态方法sayHello 只可能属于类型 StaticResolution ，没有任何途径可以覆盖或隐藏这个方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态解析演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticResolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticResolution.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 javap -verbose StaticResolution.class   得到下面结果：</p>
<p>使用javap命令查看这段程序对应的字节码，会发现的确是通过<strong>invokestatic</strong>命令来调用sayHello()方法，而且其调用的方法版本已经在编译时就明确以<strong>常量池项的形式</strong>固化在字节码指令的参数之中（ #5 = Methodref ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Last modified <span class="number">2021</span>-<span class="number">1</span>-<span class="number">18</span>; size <span class="number">672</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">4041d</span>61106416a1bb60c338694bf8d00</span><br><span class="line">  Compiled from <span class="string">&quot;StaticResolution.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter8</span>.<span class="title">StaticResolution</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">53</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#22         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #25            // hello world</span><br><span class="line">   #4 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Methodref          #6.#28         // org/fenixsoft/jvm/chapter8/StaticResolution.sayHello:()V</span><br><span class="line">   #6 = Class              #29            // org/fenixsoft/jvm/chapter8/StaticResolution</span><br><span class="line">   #7 = Class              #30            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticResolution;</span><br><span class="line">  #15 = Utf8               sayHello</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               StaticResolution.java</span><br><span class="line">  #22 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #23 = Class              #31            // java/lang/System</span><br><span class="line">  #24 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;</span><br><span class="line">  #25 = Utf8               hello world</span><br><span class="line">  #26 = Class              #34            // java/io/PrintStream</span><br><span class="line">  #27 = NameAndType        #35:#36        // println:(Ljava/lang/String;)V</span><br><span class="line">  #28 = NameAndType        #15:#9         // sayHello:()V</span><br><span class="line">  #29 = Utf8               org/fenixsoft/jvm/chapter8/StaticResolution</span><br><span class="line">  #30 = Utf8               java/lang/Object</span><br><span class="line">  #31 = Utf8               java/lang/System</span><br><span class="line">  #32 = Utf8               out</span><br><span class="line">  #33 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #34 = Utf8               java/io/PrintStream</span><br><span class="line">  #35 = Utf8               println</span><br><span class="line">  #36 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.jvm.chapter8.StaticResolution();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticResolution;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: invokestatic  #5                  // Method sayHello:()V</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticResolution.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java中的非虚方法除了使用  <strong>invokespecial、invokestatic</strong> 调用的方法之外，还有一种就是 <strong>被final 修饰的实例方法</strong>。历史设计的原因，final 方法使用的是 <strong>invokevirtual</strong> 指令调用的，但是因为它无法被覆盖，没有其他版本的可能，所以也无须 对方法接收者 进行多态选择，又或者说 多态选择的结果肯定是唯一的。</p>
<p>再《Java语言规范》中明确定义了被 final修饰的方法是一种<strong>非虚方法</strong>.</p>
<h4 id="解析调用："><a href="#解析调用：" class="headerlink" title="解析调用："></a>解析调用：</h4><p>解析调用一定是一个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部 转变为 明确的直接引用，不必延迟到运行期再去完成。</p>
<h4 id="分派调用："><a href="#分派调用：" class="headerlink" title="分派调用："></a>分派调用：</h4><p>另一种主要的方法调用形式：  <strong>分派（Dispatch）</strong>调用则复杂许多，它可能是静态的也可能是动态的，按照分派依据 的宗量数可分为 <strong>单分派</strong> 和 <strong>多分派</strong>。 这两类分派两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派 4种分派组合情况 </p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>As we all know, Java 是一门面向对象的程序语言，因为java具备面向对象的 3个基本特征：  <strong>继承、封装 和多态。</strong></p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p> <strong>“分派”（Dispatch）</strong> 这个词本身就具有动态性，一般不应用在静态语境中。这部分原本在 英文原版的《Java虚拟机规范》和 《Java语言规范》里的说法都是:  </p>
<p>“Method Overload Resolution 方法重载解析” ,但部分外文资料和国内翻译的许多中文资料都将这种行为 称为 “静态分派”。</p>
<p>为了解释静态分派和重载（Overload），笔者准备了一段经常出现在面试题中的程序代码，读者不妨先看一遍，想一下程序的输出结果是什么。后面的话题将围绕这个类的方法来编写重载代码，以分析虚拟机和编译器确定方法版本的过程。程序如代码清单8-6所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    hello,guy!</span><br><span class="line">hello,guy!</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>为什么虚拟机会选择执行参数类型为Human的重载版本呢？在解决这个问题之前，我们先通过如下代码来定义两个关键概念：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

<ul>
<li>我们把上面代码中的 “Human” 称为 变量的 <strong>“静态类型”（static Type）</strong>，或者叫 <strong>“外观类型”（Apparent Type）</strong>,</li>
<li>“Man” 则被称为变量的 <strong>“实际类型”（Actual Type）</strong>或者叫做 <strong>“运行时类型”（Runtime Type）</strong>.</li>
<li>静态类型和实际类型在程序中都可能会发生变化，区别是 静态类型的变化仅仅在使用时发生， 变量本身的静态类型不会被改变，并且最终的静态类型在编译期可知的；而 实际类型变化的结果在运行期才可确定，编译期在编译程序的时候并不知道一个对象的实际类型时什么</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象human 的实际类型是可变的，编译期间 它完全是个 “薛定谔的人”，到底是 Man 还是woman，必须等到程序运行到这行的时候才能确定。</p>
</li>
<li><p>而human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()<br>方法的调用，在编译期完全可以明确转型的是Man还是Woman。</p>
</li>
</ul>
<p>main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全<strong>取决于传入参数的数量和数据类型</strong>。</p>
<p>代码中故意<strong>定义了两个静态类型相同</strong>，而<strong>实际类型不同的变量</strong>，但虚拟机（或者准确地说是编译器）<strong>在重载时是通过参数的静态类型</strong>而<strong>不是实际类型</strong>作为判定依据的。由于<strong>静态类型在编译期可知</strong>，所以<strong>在编译阶段</strong>，Javac编译器就<strong>根据参数的静态类型决定了会使用哪个重载版本</strong>，因此选择了<strong>sayHello(Human)作为调用目标</strong>，并把<strong>这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter8</span>.<span class="title">StaticDispatch</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">53</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #14.#44        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #45.#46        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #47            // hello,guy!</span><br><span class="line">   #4 = Methodref          #48.#49        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = String             #50            // hello,gentleman!</span><br><span class="line">   #6 = String             #51            // hello,lady!</span><br><span class="line">   #7 = Class              #52            // org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">   #8 = Methodref          #7.#44         // org/fenixsoft/jvm/chapter8/StaticDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 = Class              #53            // org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">  #10 = Methodref          #9.#44         // org/fenixsoft/jvm/chapter8/StaticDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = Class              #54            // org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">  #12 = Methodref          #11.#44        // org/fenixsoft/jvm/chapter8/StaticDispatch.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #13 = Methodref          #11.#55        // org/fenixsoft/jvm/chapter8/StaticDispatch.sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #14 = Class              #56            // java/lang/Object</span><br><span class="line">  #15 = Utf8               Woman</span><br><span class="line">  #16 = Utf8               InnerClasses</span><br><span class="line">  #17 = Utf8               Man</span><br><span class="line">  #18 = Class              #57            // org/fenixsoft/jvm/chapter8/StaticDispatch$Human</span><br><span class="line">  #19 = Utf8               Human</span><br><span class="line">  #20 = Utf8               &lt;init&gt;</span><br><span class="line">  #21 = Utf8               ()V</span><br><span class="line">  #22 = Utf8               Code</span><br><span class="line">  #23 = Utf8               LineNumberTable</span><br><span class="line">  #24 = Utf8               LocalVariableTable</span><br><span class="line">  #25 = Utf8               this</span><br><span class="line">  #26 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">  #27 = Utf8               sayHello</span><br><span class="line">  #28 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #29 = Utf8               guy</span><br><span class="line">  #30 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">  #31 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;)V</span><br><span class="line">  #32 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;</span><br><span class="line">  #33 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;)V</span><br><span class="line">  #34 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;</span><br><span class="line">  #35 = Utf8               main</span><br><span class="line">  #36 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #37 = Utf8               args</span><br><span class="line">  #38 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #39 = Utf8               man</span><br><span class="line">  #40 = Utf8               woman</span><br><span class="line">  #41 = Utf8               sr</span><br><span class="line">  #42 = Utf8               SourceFile</span><br><span class="line">  #43 = Utf8               StaticDispatch.java</span><br><span class="line">  #44 = NameAndType        #20:#21        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #45 = Class              #58            // java/lang/System</span><br><span class="line">  #46 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #47 = Utf8               hello,guy!</span><br><span class="line">  #48 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #49 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #50 = Utf8               hello,gentleman!</span><br><span class="line">  #51 = Utf8               hello,lady!</span><br><span class="line">  #52 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">  #53 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">  #54 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">  #55 = NameAndType        #27:#28        // sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #56 = Utf8               java/lang/Object</span><br><span class="line">  #57 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Human</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.jvm.chapter8.StaticDispatch();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Human)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello,guy!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Man)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #5                  // String hello,gentleman!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">23</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Woman)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #6                  // String hello,lady!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">27</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #7                  // class org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #8                  // Method org/fenixsoft/jvm/chapter8/StaticDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: new           #9                  // class org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        12: invokespecial #10                 // Method org/fenixsoft/jvm/chapter8/StaticDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        16: new           #11                 // class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">        <span class="number">19</span>: dup</span><br><span class="line">        20: invokespecial #12                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">23</span>: astore_3</span><br><span class="line">        <span class="number">24</span>: aload_3</span><br><span class="line">        <span class="number">25</span>: aload_1</span><br><span class="line">        26: invokevirtual #13                 //这里： Method sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">        <span class="number">29</span>: aload_3</span><br><span class="line">        <span class="number">30</span>: aload_2</span><br><span class="line">        31: invokevirtual #13                 //这里： Method sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">        <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">31</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">32</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">33</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">34</span>: <span class="number">24</span></span><br><span class="line">        line <span class="number">35</span>: <span class="number">29</span></span><br><span class="line">        line <span class="number">36</span>: <span class="number">34</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">35</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">27</span>     <span class="number">1</span>   man   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">           <span class="number">16</span>      <span class="number">19</span>     <span class="number">2</span> woman   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">           <span class="number">24</span>      <span class="number">11</span>     <span class="number">3</span>    sr   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticDispatch.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     static #15= #9 of #11; //Woman=class org/fenixsoft/jvm/chapter8/StaticDispatch$Woman of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">     static #17= #7 of #11; //Man=class org/fenixsoft/jvm/chapter8/StaticDispatch$Man of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">     static abstract #19= #18 of #11; //Human=class org/fenixsoft/jvm/chapter8/StaticDispatch$Human of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br></pre></td></tr></table></figure>



<p>所有依赖静态类型来决定执行版本的分派动作，都被称为 <strong>静态分派</strong>。 静态分配的最典型应用表现就是 <strong>方法重载</strong>。 静态分派 发生在编译阶段，因此确定静态分派的动作实际上并不是由虚拟机来执行的 ，这点也是为什么一些资料选择把它归入 为 “解析”而不是 “分派”的原因。</p>
<h5 id="重载方法匹配优先级"><a href="#重载方法匹配优先级" class="headerlink" title="重载方法匹配优先级"></a>重载方法匹配优先级</h5><p>需要注意Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个“相对更合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是个比较稀罕的事件，产生这种模糊结论的主要原因是字面量天生的模糊性，它不需要定义，所以字面量就没有显式的静态类型，它的静态类型只能通过语言、语法的规则去理解和推断。代码清单8-7演示了何谓“更加合适的”版本。</p>
<p>代码清单8-7　重载方法匹配优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Character&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Serializable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一次运行结果： <strong>hello char</strong>，这很好理解，’a’是一个char类型的数据，自然会寻找参数类型为char的重载方法，</p>
</li>
<li><p>如果注释掉 sayHello(char arg)方法，那输出会变为：<strong>hello int</strong> ，这时发生了一次自动类型转换，’a’除了可以代表一个字符串，还可以代表数字97（字符’a’的<br>Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的</p>
</li>
<li><p>我们继续注释掉sayHello(int arg)方法，那输出会变为： <strong>hello long</strong> .这时发生了两次自动类型转换，’a’转型为整数97之后，进一步转型为长整数97L，匹配了参数类型为long的重载。笔者在代码中没有写其他的类型如float、double等的重载，不过实际上自动转型还能继续发生多次，按照<strong>char&gt;int&gt;long&gt;float&gt;double的顺序转型进行匹配</strong>，但<strong>不会匹配到byte和short类型的重载</strong>，因为<strong>char到byte或short的转型是不安全的</strong>。</p>
</li>
<li><p>继续注释掉sayHello(long arg)方法，那输出会变为 : <strong>hello Character</strong>  ，这时发生了一次自动装箱，’a’被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为Character的重载</p>
</li>
<li><p>继续注释掉sayHello(Character arg)方法，那输出会变为： <strong>hello Serializable</strong>,  出现hello Serializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类所实现的接口类型，所以紧接着又发生一次自动转型。char可以转型成int，<br>但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现了另外一个接口java.lang.Comparable<Character>，如果同时出现两个参数分别为Serializable和Comparable<Character>的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示“类型模糊”（Type Ambiguous），并拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如：sayHello((Comparable<Character>)’a’)，才能编译通过</p>
</li>
<li><p>继续注释掉sayHello(Serializable arg)方法，输出会变为： <strong>hello Object</strong> ，这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。</p>
</li>
<li><p>我们把sayHello(Objectarg)也注释掉，输出将会变为： <strong>hello char …</strong>,7个重载方法已经被注释得只剩1个了，可见变长参数的重载优先级是最低的，这时候字符’a’被当作了一个char[]数组的元素。笔者使用的是char类型的变长参数，读者在验证时还可以选择int类型、Character类型、Object类型等的变长参数重载来把上面的过程重新折腾一遍。但是要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的[2]。</p>
</li>
</ul>
<p>另外还有一点读者可能比较容易混淆：笔者讲述的<strong>解析与分派这两者之间的关系并不是二选一的排他关系</strong>，它们是在<strong>不同层次上去筛选、确定目标方法</strong>的过程。例如前面说过静态方法会在编译期确定、在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，<strong>选择重载版本的过程也是通过静态分派</strong>完成的</p>
<ul>
<li>可以这么理解吗： <strong>overload重载是gen据静态类型来决定的（静态分派），  override是根据 实际类型来决定的（动态分派）。</strong></li>
</ul>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>看一下Java语言里动态分派的实现过程，它与Java语言多态性的另外一个重要体现[3]——重写（Override）有着很密切的关联。我们还是用前面的Man和Woman一起 sayHello的例子来讲解动态分派，请看代码清单8-8中所示的代码。</p>
<p>代码清单8-8　方法动态分派演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>

<h5 id="Java虚拟机是如何判断应该调用哪个方法"><a href="#Java虚拟机是如何判断应该调用哪个方法" class="headerlink" title="Java虚拟机是如何判断应该调用哪个方法"></a>Java虚拟机是如何判断应该调用哪个方法</h5><ul>
<li>可以这么理解吗： <strong>overload重载是gen据静态类型来决定的（静态分派），  override是根据 实际类型来决定的（动态分派）。</strong></li>
</ul>
<p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为<strong>静态类型同样都是Human的两个变量</strong>man和woman在调用sayHello()方法时产生了不同的行为，甚至变量man在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是因为这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？我们使用javap命令输出这段代码的字节码，尝试从中寻找答案，输出结果如代码清单8-9所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">	Code:</span><br><span class="line">        Stack=2, Locals=3, Args_size=1</span><br><span class="line">        0: new <span class="comment">#16; //class org/fenixsoft/polymorphic/DynamicDispatch$Man</span></span><br><span class="line">        3: dup</span><br><span class="line">        4: invokespecial <span class="comment">#18; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        7: astore_1</span><br><span class="line">        8: new <span class="comment">#19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span></span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial <span class="comment">#21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        24: new <span class="comment">#19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span></span><br><span class="line">        27: dup</span><br><span class="line">        28: invokespecial <span class="comment">#21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        31: astore_1</span><br><span class="line">        32: aload_1</span><br><span class="line">        33: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        36: <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>0～15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表的变量槽中，这些动作实际对应了Java源码中的这两行： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>

<p>接下来的16～21行是关键部分，16和20行的<strong>aload指令</strong>分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为接收者（Receiver）；</p>
<p>17和21行是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）都完全一样，但是这两句指令最终执行的目标方法并不相同。那看来解决问题的关键还必须从invokevirtual指令本身入手，要弄清楚它是如何确定调用方法版本、如何实现多态查找来着手分析才行。根据《Java虚拟机规范》，invokevirtual指令的运行时解析过程[4]大致分为以下几步：</p>
<ol>
<li><strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</strong>。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，<strong>如果通过则返回这个方法的直接引用</strong>，查找过程结束；不通过则返回java.lang.<strong>IllegalAccessError</strong>异常。</li>
<li>否则，按照<strong>继承关系从下往上依次</strong>对C的各个父类进行第二步的<strong>搜索和验证</strong>过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.<strong>AbstractMethodError</strong>异常。</li>
</ol>
<p>正是因为invokevirtual指令执行的<strong>第一步就是在运行期确定接收者的实际类型</strong>，所以两次调用中的invokevirtual指令并<strong>不是把常量池中方法的符号引用解析到直接引用上</strong>就结束了，还会<strong>根据方法接收者的实际类型来选择方法版本</strong>，这个过程就是<strong>Java语言中方法重写的本质</strong>。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为<strong>动态分派。</strong></p>
<p>既然这种多态性的<strong>根源在于虚方法调用指令invokevirtual的执行逻辑</strong>，那自然我们得出的结论就<strong>只会对方法有效，对字段是无效的，因为字段不使用这条指令</strong>。事实上，在Java里面只有虚方法存在，字段永远不可能是虚的，</p>
<p>换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。<strong>当子类声明了与父类同名的字段时</strong>，虽然在子类的内存中两个字段都会存在，但是<strong>子类的字段会遮蔽父类的同名字段</strong>。</p>
<p>为了加深理解，又编撰了一份“劣质面试题式”的代码片段，请阅读代码清单8-10，思考运行后会输出什么结果。</p>
<p>代码清单8-10　字段没有多态性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段不参与多态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHasNoPolymorphic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            money = <span class="number">2</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Father, i have $&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            money = <span class="number">4</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Son,  i have $&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father gay = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">&quot;This gay has $&quot;</span> + gay.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果为: </span><br><span class="line">I am Son,  i have $<span class="number">0</span></span><br><span class="line">I am Son,  i have $<span class="number">4</span></span><br><span class="line">This gay has $<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出两句都是“I am Son”，</p>
<ul>
<li>这是因为Son类在创建的时候，首先隐式调用了<strong>Father的构造函数</strong>，而Father构造函数中<strong>对showMeTheMoney()的调用是一次虚方法调用</strong>，实际执行的版本是Son::showMeTheMoney()方法，所以输出的是“I am Son”，这点经过前面的分析相信读者是没有疑问的了。</li>
<li>而这时候虽然父类的money字段已经被初始化成2了，但Son::showMeTheMoney()方法中访问的却是<strong>子类的money字段</strong>，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。</li>
<li>main()的最后一句<strong>通过静态类型访问到了父类中的money</strong>，输出了2。</li>
</ul>
<p><strong>todo  消化一下</strong></p>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><h5 id="宗量"><a href="#宗量" class="headerlink" title="宗量"></a>宗量</h5><p>方法的接收者与方法的参数统称为方法的<strong>宗量</strong></p>
<p>根据分派基于多少种宗量，可以将分派划分为<strong>单分派</strong>和<strong>多分派</strong>两种。</p>
<p>单分派 是根据<strong>一个宗量对目标进行选择</strong>，</p>
<p>多分派则是根据<strong>多于一个宗量对目标方法进行选择。</strong></p>
<p>代码清单：  单分派和多分派</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果： </span><br><span class="line">    father choose <span class="number">360</span></span><br><span class="line">	son choose qq</span><br></pre></td></tr></table></figure>

<ul>
<li>main（）里调用了两次hardChoice 方法，这两次hardChoice 方法的选择结果在程序输出 中已经显示得很清楚了。 </li>
<li>我们关注得首先是 编译阶段中编译 器的选择过程，也就是静态分派的过程。</li>
<li>选择目标的依据有两点：<ul>
<li>一个是静态类型是 Father 还是SON</li>
<li>二是方法参数是QQ还是360</li>
</ul>
</li>
</ul>
<p>这次选择结果的最终产物是产生了2条invokevirtual 指令，两条指令的参数 分别是常量池中指向 Father:: hardChoice(360)  以及 Father:: hardChoice(QQ)方法的符号引用</p>
<ul>
<li>因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型</li>
</ul>
<h5 id="动态分派的过程"><a href="#动态分派的过程" class="headerlink" title="动态分派的过程"></a>动态分派的过程</h5><p>再看看运行阶段中虚拟机的选择，也就是<strong>动态分派</strong>的过程。</p>
<p>在执行 “son.hardChoice(new QQ()) ” 这行方法时，更准确的说，是在执行这行代码所对应的  Invokevirtual指令时，由于编译期已经决定目标方法的签名 必须为 hardChoice（QQ） ,虚拟机此时 不会关心传递过来的参数 “QQ”到底是 “腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型 都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的接收者的实际类型是 Father 还是 Son 。</p>
<p>因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型 。</p>
<p>根据上述论证的结果，我们可以总结一句： </p>
<p>如今的Java语言是一门静态多分派、动态单分派的语言。</p>
<p>强调”如今的Java语言”是因为这个结论未必会恒久不变。JDK10 时Java语法中新出现 var关键字，</p>
<p>var 是在编译时根据声明语句中赋值符右侧的表达式类型来静态地推断类型。这本质时一种语法糖：</p>
<h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>前面介绍的分派过程，作为对Java虚拟机概念模型的解释基本上已经足够了，它已经解决了虚拟机在分派中“<strong>会做什么</strong>”这问题，但是 问Java虚拟机 “<strong>具体如果做到</strong>” 的，答案则可能因为 各种虚拟机的实现不同会有些差别。</p>
<p>动态分派 是执行非常频繁的动作，而且动态分派的方法版本 选择过程 需要运行时在接收者类型的方法元数据中 选择合适的目标方法，因此Java虚拟机实现基于执行性能的考虑，真实运行时一般不会如此频繁的去反复搜索类型元数据。</p>
<p>面对这种情况，一种基础而且常见的优化手段 是为类型在方法中建一个虚方法表（Virtual Method Table，也称为 vtable），与此对应的，在invokeinterface 执行时也会用到 接口方法表-Interface Method Table，简称itable。 使用虚方法表 索引来代替元数据查找以提高性能。  我们来看看上面代码 所对应的虚方法表结构示例： 如下图所示</p>
<p><img src="/uploads/jvm/11diapatch/methodTable.png"></p>
<p>虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是 一致的，都指向父类的实现入口。</p>
<p>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为 指向子类实现版本的入口地址。</p>
<p>在上图中，son重写了来自 Father的全部方法，因此son的方法表 没有指向Father类型数据的箭头。</p>
<p>但是son 和 Father都没有重写来自Object的方法，所以他们的方法表中所有从Object 继承来的方法都指向了Object的类型数据。</p>
<p>为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中 都应当具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。 <strong>虚方法表一般在类加载的连接阶段进行初始化</strong>，准备了类的变量初始值后，虚拟机 会把 该<strong>类的虚方法表也一同初始化完毕。</strong></p>
<p>上面说的<strong>查虚方法表</strong> 是 <strong>分派调用</strong>的一种<strong>优化手段</strong>，<strong>由于Java对象里面的方法 默认（即不使用final 修饰）就是虚方法</strong>，虚拟机除了使用虚方法表外，为了进一步提高性能，还会使用<strong>类型继承分析（Class Hierarchy Analysis，CHA）</strong> ，<strong>守护内联（Guarded Inlining）</strong>，<strong>内联缓存（Inline Cache）</strong> 等多种非稳定的激进优化来争取更大的性能空间，</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>虚拟机字节码执行引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>读取poi大文件的两种方案</title>
    <url>/2021/03/28/%E8%AF%BB%E5%8F%96poi%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近有个业务需求，功能是：要通过excel 装载大量数据并上传至系统，excel的格式是.xlsx,后台需要解析excel的每条数据，进行一系列 有效性以及权限等校验。<br>验证通过的需要落数据库， 验证不通过的需要 生成一个异常数据的excel，将每条数据的错误原因 备注在 源数据的最后一列 。</p>
<p>其实举个例子，比如 5w条数据放在excel，excel的大小大概是 2M左右，在放在List里面不算大，可是使用用户模式POI去一次性解析放在List<T>中，这个过程 需要的内存肯定是 20M 往上， 10倍都是保守估计， 所以不要看excel文件不大，解析可是非常耗内存的， 可能是 xlsx的功能太多了，文件格式 太复杂了</p>
<p>所以建议当数据量大的时候，使用.csv的文件去上传， 因为csv 可以使用excel打开，也可以用文本打开，单元格数据用的 逗号隔开的， 只需要用splitBy 逗号就行了，很便捷 </p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>其实如果数据量不大的情况下，我们 可以使用简单的poi 将excel 一次性加载至内存中，然后逐条数据一次解析验证 。</p>
<p>可是当 excel 的数据量特别大的时候，就有可能发生OOM的情况，系统直接就卡死了。这是我们不能容忍的 。解决这个问题的方案这边其实有3种：</p>
<h3 id="方案1：poi事件模式-分页处理"><a href="#方案1：poi事件模式-分页处理" class="headerlink" title="方案1：poi事件模式+分页处理"></a>方案1：poi事件模式+分页处理</h3><p>看poi的文档，其实poi 的api提供了2种 模式，</p>
<ul>
<li>一种就是我们常用的用户模式usermodel，就是将excel的内容一次性全部加载至 内存中，</li>
<li>还有一种用的是 事件模式，因为其实将 的excel文件后缀名.xlsx 改为 .zip，打开zip包 就可以知道其实excel的底层数据是以 xml的形式存储的。所以 事件模式就是 使用sax解析excel 。</li>
</ul>
<p>poi提供一套api去处理 解析过程，这个api对用户不是很友好，有点晦涩难懂，我们可以通过自行封装这一套 api然后  进行分页paging 分批的去读取数据到内存中  如下所示：</p>
<h4 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- apache poi 操作Microsoft Document --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Apache POI - Java API To Access Microsoft Format Files--&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Apache POI - Java API To Access Microsoft Format Files--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- poi eventmodel方式 依赖包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;xerces&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xercesImpl&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.11.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h4 id="获取excel-的总行数"><a href="#获取excel-的总行数" class="headerlink" title="获取excel 的总行数"></a>获取excel 的总行数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.poi.sax;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.poi.openxml4j.opc.OPCPackage;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.eventusermodel.XSSFReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.model.SharedStringsTable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.Attributes;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.ContentHandler;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.InputSource;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.SAXException;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.XMLReader;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.helpers.DefaultHandler;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.helpers.XMLReaderFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XSSF and SAX (Event API) basic example.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> XLSX2CSV&#125; for a fuller example of doing</span></span><br><span class="line"><span class="comment"> *  XSLX processing with the XSSF Event code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExcel2007ForMaxRow</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new add</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> maxRow = <span class="number">0</span>;<span class="comment">//记录总行数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filename = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExcel2007ForMaxRow</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(filename)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;文件名不能空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">        processFirstSheet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定获取第一个sheet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processFirstSheet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        OPCPackage pkg = OPCPackage.open(filename);</span><br><span class="line">        XSSFReader r = <span class="keyword">new</span> XSSFReader( pkg );</span><br><span class="line">        SharedStringsTable sst = r.getSharedStringsTable();</span><br><span class="line"></span><br><span class="line">        XMLReader parser = fetchSheetParser(sst);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To look up the Sheet Name / Sheet Order / rID,</span></span><br><span class="line">        <span class="comment">//  you need to process the core Workbook stream.</span></span><br><span class="line">        <span class="comment">// Normally it&#x27;s of the form rId# or rSheet#</span></span><br><span class="line">        InputStream sheet2 = r.getSheet(<span class="string">&quot;rId1&quot;</span>);</span><br><span class="line">        InputSource sheetSource = <span class="keyword">new</span> InputSource(sheet2);</span><br><span class="line">        parser.parse(sheetSource);</span><br><span class="line">        sheet2.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> XMLReader <span class="title">fetchSheetParser</span><span class="params">(SharedStringsTable sst)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        XMLReader parser =</span><br><span class="line">                XMLReaderFactory.createXMLReader(</span><br><span class="line">                        <span class="string">&quot;org.apache.xerces.parsers.SAXParser&quot;</span></span><br><span class="line">                );</span><br><span class="line">        ContentHandler handler = <span class="keyword">new</span> MaxRowHandler();</span><br><span class="line">        parser.setContentHandler(handler);</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * See org.xml.sax.helpers.DefaultHandler javadocs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">MaxRowHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">            <span class="comment">// c =&gt; cell</span></span><br><span class="line">            <span class="keyword">if</span>(name.equals(<span class="string">&quot;c&quot;</span>)) &#123;</span><br><span class="line">                String index = attributes.getValue(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(Pattern.compile(<span class="string">&quot;A[0-9]+$&quot;</span>).matcher(index).find())&#123;</span><br><span class="line">                    maxRow++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyExcel2007ForMaxRow reader = <span class="keyword">new</span> MyExcel2007ForMaxRow(<span class="string">&quot;/home/yinshi/Documents/CodeSource/test-write07.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n---&quot;</span>+reader.maxRow);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="分页获取数据"><a href="#分页获取数据" class="headerlink" title="分页获取数据"></a>分页获取数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.poi.sax;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yinshi.gitstats.entity.TmCase;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.openxml4j.opc.OPCPackage;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.eventusermodel.XSSFReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.model.SharedStringsTable;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFRichTextString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.*;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.helpers.DefaultHandler;</span><br><span class="line"><span class="keyword">import</span> org.xml.sax.helpers.XMLReaderFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * XSSF and SAX (Event API) basic example.</span></span><br><span class="line"><span class="comment"> * See &#123;<span class="doctag">@link</span> XLSX2CSV&#125; for a fuller</span></span><br><span class="line"><span class="comment"> * example of doing XSLX processing with the XSSF Event code.</span></span><br><span class="line"><span class="comment"> * 目前函数又个缺陷，便是starElement函数中发现新行的策略有问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExcel2007ForPaging_high_baK_bak</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private TmCaseRepo tmCaseRepo;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表Excel中必须有值的起始列(A、B、C....AA、AB...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String indexC4Data = <span class="string">&quot;A&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储所有行的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;IndexValue&gt;&gt; dataList = <span class="keyword">new</span> ArrayList&lt;List&lt;IndexValue&gt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 临时存储当前行的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;IndexValue&gt; rowData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> startRow;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> endRow;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String filename;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一行文件有几个字段（列的数量）</span></span><br><span class="line"><span class="comment">     * 首先需要 xlsx 的excel文件的header有几个字段，建议还是手动传进来，</span></span><br><span class="line"><span class="comment">     * 1. 场景：防止一些没有header的文件，</span></span><br><span class="line"><span class="comment">     * 2. 场景： 如果一行有9列，其中第4列之后就再也没有值了，后（9-4）=5个字段，就需要手动补充空格了，否则将list转为对象vo的时候，</span></span><br><span class="line"><span class="comment">     * 容易数组越界异常，建议还是在这里给它补充完成 ，如果不在这里补充完整，也可以在 list转vo的时候，把list的剩余字段补上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> columnSize;</span><br><span class="line"><span class="comment">//    private int startRow;</span></span><br><span class="line"><span class="comment">//    private int endRow;</span></span><br><span class="line"><span class="comment">//    private int currentRow = 0;</span></span><br><span class="line"><span class="comment">//    private String filename;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //    @PostConstruct</span></span><br><span class="line"><span class="comment">//    private void init(String filename, int startRow, int endRow) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//        if (StringUtils.isEmpty(filename)) &#123;</span></span><br><span class="line"><span class="comment">//            throw new Exception(&quot;文件名不能空&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        this.filename = filename;</span></span><br><span class="line"><span class="comment">//        this.startRow = startRow;</span></span><br><span class="line"><span class="comment">//        this.endRow = endRow;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExcel2007ForPaging_high_baK_bak</span><span class="params">(String filename, <span class="keyword">int</span> columnSize, <span class="keyword">int</span> startRow, <span class="keyword">int</span> endRow)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(filename)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;文件名不能空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.columnSize = columnSize;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">        <span class="keyword">this</span>.startRow = startRow;</span><br><span class="line">        <span class="keyword">this</span>.endRow = endRow;</span><br><span class="line">        processFirstSheet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定获取第一个sheet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processFirstSheet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        init(filename,startRow,endRow);</span></span><br><span class="line"></span><br><span class="line">        OPCPackage pkg = OPCPackage.open(filename);</span><br><span class="line">        XSSFReader r = <span class="keyword">new</span> XSSFReader(pkg);</span><br><span class="line">        SharedStringsTable sst = r.getSharedStringsTable();</span><br><span class="line"></span><br><span class="line">        XMLReader parser = fetchSheetParser(sst);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To look up the Sheet Name / Sheet Order / rID,</span></span><br><span class="line">        <span class="comment">// you need to process the core Workbook stream.</span></span><br><span class="line">        <span class="comment">// Normally it&#x27;s of the form rId# or rSheet#</span></span><br><span class="line">        InputStream sheet1 = r.getSheet(<span class="string">&quot;rId1&quot;</span>);</span><br><span class="line">        InputSource sheetSource = <span class="keyword">new</span> InputSource(sheet1);</span><br><span class="line">        parser.parse(sheetSource);</span><br><span class="line">        sheet1.close();</span><br><span class="line">        pkg.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> XMLReader <span class="title">fetchSheetParser</span><span class="params">(SharedStringsTable sst)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        XMLReader parser = XMLReaderFactory.createXMLReader(<span class="string">&quot;org.apache.xerces.parsers.SAXParser&quot;</span>);</span><br><span class="line">        ContentHandler handler = <span class="keyword">new</span> PagingHandler(sst);</span><br><span class="line">        parser.setContentHandler(handler);</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * See org.xml.sax.helpers.DefaultHandler javadocs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PagingHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SharedStringsTable sst;</span><br><span class="line">        <span class="keyword">private</span> String lastContents;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> nextIsString;</span><br><span class="line">        <span class="keyword">private</span> String index = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">PagingHandler</span><span class="params">(SharedStringsTable sst)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sst = sst;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每个单元格开始时的处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String name, Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">            <span class="comment">// c =&gt; cell</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(<span class="string">&quot;c&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">// Print the cell reference</span></span><br><span class="line">                <span class="comment">// System.out.print(attributes.getValue(&quot;r&quot;) + &quot; - &quot;);</span></span><br><span class="line"></span><br><span class="line">                index = attributes.getValue(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">                System.out.println(index);</span><br><span class="line">                <span class="keyword">if</span> (index.contains(<span class="string">&quot;N&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;##&quot;</span> + attributes + <span class="string">&quot;##&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这是一个新行</span></span><br><span class="line">                <span class="keyword">if</span> (Pattern.compile(<span class="string">&quot;^&quot;</span> + indexC4Data + <span class="string">&quot;[0-9]+$&quot;</span>).matcher(index).find()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 存储上一行数据</span></span><br><span class="line">                    <span class="keyword">if</span> (rowData != <span class="keyword">null</span> &amp;&amp; isAccess() &amp;&amp; !rowData.isEmpty()) &#123;</span><br><span class="line">                        dataList.add(rowData);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rowData = <span class="keyword">new</span> ArrayList&lt;IndexValue&gt;();</span><br><span class="line">                    <span class="comment">// 新行要先清除上一行的数据</span></span><br><span class="line">                    currentRow++;<span class="comment">// 当前行+1</span></span><br><span class="line">                    <span class="comment">// System.out.println(currentRow);</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isAccess()) &#123;</span><br><span class="line">                    <span class="comment">// Figure out if the value is an index in the SST</span></span><br><span class="line">                    String cellType = attributes.getValue(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cellType != <span class="keyword">null</span> &amp;&amp; cellType.equals(<span class="string">&quot;s&quot;</span>)) &#123;</span><br><span class="line">                        nextIsString = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nextIsString = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Clear contents cache</span></span><br><span class="line">            lastContents = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 每个单元格结束时的处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String name)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isAccess()) &#123;</span><br><span class="line">                <span class="comment">// Process the last contents as required.</span></span><br><span class="line">                <span class="comment">// Do now, as characters() may be called more than once</span></span><br><span class="line">                <span class="keyword">if</span> (nextIsString) &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = Integer.parseInt(lastContents);</span><br><span class="line">                    lastContents = <span class="keyword">new</span> XSSFRichTextString(sst.getEntryAt(idx)).toString();</span><br><span class="line">                    nextIsString = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// v =&gt; contents of a cell</span></span><br><span class="line">                <span class="comment">// Output after we&#x27;ve seen the string contents</span></span><br><span class="line">                <span class="keyword">if</span> (name.equals(<span class="string">&quot;v&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(lastContents);</span><br><span class="line"></span><br><span class="line">                    rowData.add(<span class="keyword">new</span> IndexValue(index, lastContents));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 目前流的方式值支持  Excel单元格是文本  格式；日期、数字、公式不支持</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isAccess()) &#123;</span><br><span class="line">                lastContents += <span class="keyword">new</span> String(ch, start, length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果文档结束后，发现读取的末尾行正处在当前行中，存储下这行</span></span><br><span class="line"><span class="comment">         * （存在这样一种情况，当待读取的末尾行正好是文档最后一行时，最后一行无法存到集合中，</span></span><br><span class="line"><span class="comment">         * 因为最后一行没有下一行了，所以不为启动starElement()方法， 当然我们可以通过指定最大列来处理，但不想那么做，扩展性不好）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (rowData != <span class="keyword">null</span> &amp;&amp; isAccess() &amp;&amp; !rowData.isEmpty()) &#123;</span><br><span class="line">                dataList.add(rowData);</span><br><span class="line">                System.out.println(<span class="string">&quot;--end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentRow &gt;= startRow &amp;&amp; currentRow &lt;= endRow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexValue</span> </span>&#123;</span><br><span class="line">        String v_index;</span><br><span class="line">        String v_value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IndexValue</span><span class="params">(String v_index, String v_value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.v_index = v_index;</span><br><span class="line">            <span class="keyword">this</span>.v_value = v_value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;IndexValue [v_index=&quot;</span> + v_index + <span class="string">&quot;, v_value=&quot;</span> + v_value + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 去掉数字部分（行信息），直接比较英文部分（列信息），计算前后两个值相距多少空列</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> p</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevel</span><span class="params">(IndexValue p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*char[] other = p.v_index.replaceAll(&quot;[0-9]&quot;, &quot;&quot;).toCharArray();</span></span><br><span class="line"><span class="comment">			char[] self = this.v_index.replaceAll(&quot;[0-9]&quot;, &quot;&quot;).toCharArray();</span></span><br><span class="line"><span class="comment">			if (other.length != self.length)</span></span><br><span class="line"><span class="comment">				return -1;</span></span><br><span class="line"><span class="comment">			for (int i = 0; i &lt; other.length; i++) &#123;</span></span><br><span class="line"><span class="comment">				if (i == other.length - 1) &#123;</span></span><br><span class="line"><span class="comment">					return self[i] - other[i];</span></span><br><span class="line"><span class="comment">				&#125; else &#123;</span></span><br><span class="line"><span class="comment">					if (self[i] != other[i]) &#123;</span></span><br><span class="line"><span class="comment">						return -1;</span></span><br><span class="line"><span class="comment">					&#125;</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			return -1;*/</span></span><br><span class="line"></span><br><span class="line">            String other = p.v_index.replaceAll(<span class="string">&quot;[0-9]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            String self = <span class="keyword">this</span>.v_index.replaceAll(<span class="string">&quot;[0-9]&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> MathUtil.fromNumberSystem26(self) - MathUtil.fromNumberSystem26(other);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取真实的数据（处理空格，空行）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getMyDataList</span><span class="params">(ExcelResultHandler&lt;T&gt; handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.首先需要 xlsx 的excel文件的header有几个字段，建议还是手动传进来，防止一些没有header的文件，以及</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> MAX_LIE = <span class="number">0</span>;</span><br><span class="line">        List&lt;T&gt; myDataList = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">if</span> (dataList == <span class="keyword">null</span> || dataList.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> myDataList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 是否是最后一行的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> islastRow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dataList.size(); i++) &#123;</span><br><span class="line">            List&lt;IndexValue&gt; i_list = dataList.get(i);</span><br><span class="line">            List&lt;String&gt; row = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            TmCase tmCase = <span class="keyword">new</span> TmCase();</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; i_list.size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">//            for (; j &lt; 10 - 1; j++) &#123;</span></span><br><span class="line">                <span class="comment">// 获取当前值,并存储</span></span><br><span class="line">                IndexValue current = i_list.get(j);</span><br><span class="line">                <span class="comment">//去掉空格</span></span><br><span class="line">                String tempV = current.v_value != <span class="keyword">null</span> ? current.v_value.trim() : current.v_value;</span><br><span class="line">                row.add(tempV);</span><br><span class="line">                <span class="comment">// 预存下一个</span></span><br><span class="line">                IndexValue next = i_list.get(j + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 获取差值</span></span><br><span class="line">                <span class="keyword">int</span> level = next.getLevel(current);</span><br><span class="line">                System.out.println(<span class="string">&quot;level:==&gt;&quot;</span> + level);</span><br><span class="line">				<span class="comment">/*if(i==2214)&#123;</span></span><br><span class="line"><span class="comment">					System.out.println(&quot;--&quot;+i);</span></span><br><span class="line"><span class="comment">				&#125;*/</span></span><br><span class="line">                <span class="keyword">if</span> (level &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;---!!!到达最后一行，行号：&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;;level:&quot;</span> + level + <span class="string">&quot;[超出处理范围]&quot;</span>);</span><br><span class="line">                    islastRow = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将差值补充为null，</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; level - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                    <span class="comment">// 空值处理</span></span><br><span class="line">                    row.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 每行的最后一个值，留在最后插入</span></span><br><span class="line"><span class="comment">             * 但最后一行除外</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!islastRow) &#123;</span><br><span class="line">                row.add(i_list.get(j).v_value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果row.size不等于 列数，比如总共9列，可说第5列之后就没有 数据了，那么 i_list.size=5,需要额外补充4个</span></span><br><span class="line">            <span class="keyword">if</span> (row.size() &lt; <span class="keyword">this</span>.columnSize) &#123;</span><br><span class="line">                <span class="keyword">int</span> remain = <span class="keyword">this</span>.columnSize - row.size();</span><br><span class="line">                System.out.println(<span class="string">&quot;还差===》&quot;</span> + remain);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; remain; k++) &#123;</span><br><span class="line">                    row.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            T item = handler.handler(row);</span><br><span class="line">            myDataList.add(item);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myDataList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/home/yinshi/Documents/CodeSource/test-write09.xlsx&quot;</span>);</span><br><span class="line"><span class="comment">//        MyExcel2007ForPaging_high myExcel2007ForPaging_high = new MyExcel2007ForPaging_high();</span></span><br><span class="line"><span class="comment">//        myExcel2007ForPaging_high.processFirstSheet(file.getPath(), 2, 50001);</span></span><br><span class="line">        List&lt;TmCase&gt; myDataList = <span class="keyword">new</span> MyExcel2007ForPaging_high_baK_bak(file.getPath(), <span class="number">10</span>, <span class="number">2</span>, <span class="number">50001</span>).</span><br><span class="line">                getMyDataList(<span class="keyword">new</span> TmCaseExcelResultHandler());</span><br><span class="line">        <span class="keyword">for</span> (TmCase tmCase : myDataList) &#123;</span><br><span class="line">            System.out.println(tmCase.toString());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(myDataList);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="数据行转对象Handler"><a href="#数据行转对象Handler" class="headerlink" title="数据行转对象Handler"></a>数据行转对象Handler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.poi.sax;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExcelResultHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">handler</span><span class="params">(List&lt;String&gt; sourceList)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.poi.sax;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yinshi.gitstats.entity.TmCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TmCaseExcelResultHandler</span> <span class="keyword">implements</span> <span class="title">ExcelResultHandler</span>&lt;<span class="title">TmCase</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TmCase <span class="title">handler</span><span class="params">(List&lt;String&gt; sourceList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transList2TmCase(sourceList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TmCase <span class="title">transList2TmCase</span><span class="params">(List&lt;String&gt; sourceData)</span> </span>&#123;</span><br><span class="line">        System.out.println(sourceData.toString());</span><br><span class="line">        TmCase tmCase = <span class="keyword">new</span> TmCase();</span><br><span class="line">        tmCase.setLoanNo(sourceData.get(<span class="number">0</span>));</span><br><span class="line">        tmCase.setColDateStr(sourceData.get(<span class="number">1</span>));</span><br><span class="line">        tmCase.setColType(sourceData.get(<span class="number">2</span>));</span><br><span class="line">        tmCase.setColPerson(sourceData.get(<span class="number">3</span>));</span><br><span class="line">        tmCase.setColAddress(sourceData.get(<span class="number">4</span>));</span><br><span class="line">        tmCase.setColStatus(sourceData.get(<span class="number">5</span>));</span><br><span class="line">        tmCase.setConcreteColContent(sourceData.get(<span class="number">6</span>));</span><br><span class="line">        tmCase.setRepayDateStr(sourceData.get(<span class="number">7</span>));</span><br><span class="line">        tmCase.setRepayAmtStr(sourceData.get(<span class="number">8</span>));</span><br><span class="line">        tmCase.setErrorMsg(sourceData.get(<span class="number">9</span>));</span><br><span class="line">        <span class="keyword">return</span> tmCase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String remark=<span class="string">&quot;我叫音十黎明&quot;</span>;</span><br><span class="line">        System.out.println(remark.length());</span><br><span class="line">        System.out.println(remark.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.poi.sax;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * /// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">     * /// 将指定的自然数转换为26进制表示。映射关系：[1-26] -&gt;[A-Z]。</span></span><br><span class="line"><span class="comment">     * /// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">     * /// &lt;param name=&quot;n&quot;&gt;自然数（如果无效，则返回空字符串）。&lt;/param&gt;</span></span><br><span class="line"><span class="comment">     * /// &lt;returns&gt;26进制表示。&lt;/returns&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toNumberSystem26</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = n % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">                m = <span class="number">26</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = (<span class="keyword">char</span>) (m + <span class="number">64</span>) + s;</span><br><span class="line">            n = (n - m) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;summary&gt;</span></span><br><span class="line"><span class="comment">     * 将指定的26进制表示转换为自然数。映射关系：[A-Z] -&gt;[1-26]。</span></span><br><span class="line"><span class="comment">     * &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">     * &lt;param name=&quot;s&quot;&gt;26进制表示（如果无效，则返回0）。&lt;/param&gt;</span></span><br><span class="line"><span class="comment">     * &lt;returns&gt;自然数。&lt;/returns&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fromNumberSystem26</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.toUpperCase();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>, j = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--, j *= <span class="number">26</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = arr[i];</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="string">&#x27;A&#x27;</span> || c &gt; <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//A的ASCII值为65</span></span><br><span class="line">            n += ((<span class="keyword">int</span>) c - <span class="number">64</span>) * j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(fromNumberSystem26(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">        System.out.println(toNumberSystem26(<span class="number">27</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对外提供服务类"><a href="#对外提供服务类" class="headerlink" title="对外提供服务类"></a>对外提供服务类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.poi.sax;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yinshi.gitstats.entity.TmCase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderSaxPOIUtils</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//    private static ReaderSaxPOIUtils instance = null;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> TITLELINE_ROW_INDEX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ExcelResultHandler&lt;T&gt; excelResultHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderSaxPOIUtils</span><span class="params">(ExcelResultHandler&lt;T&gt; excelResultHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.excelResultHandler = excelResultHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public static ReaderSaxPOIUtils getInstance() &#123;</span></span><br><span class="line"><span class="comment">//        if (instance == null) &#123;</span></span><br><span class="line"><span class="comment">//            instance = new ReaderSaxPOIUtils();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return instance;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取文件标题</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 一般 文件的header就是第一行，所以</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file            源文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sumOfHeaderRows 代表标题header 占用几行，通常情况下 header就是第一行，sunofRow设置为 1 就可以</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    public List&lt;List&lt;String&gt;&gt; getTitles(File file, int sumOfHeaderRows) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//    public List&lt;List&lt;String&gt;&gt; getTitles(File file, int sumOfHeaderRows) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//        //由于这里标题就是具体内容，所以应该把标题当做要获取的数据</span></span><br><span class="line"><span class="comment">//        return this.getPagingData(file, 1, sumOfHeaderRows, sumOfHeaderRows, 0);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用POI的sax方式分页读取2007的Excel</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageIndex      页号 从1开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pagesizeRows   页内行数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> totalCountRows 实际的总行数（去除标题）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outOfTitleRow  忽略标题行的行数，负数忽略，0代表包含标题，正值代表跳过的标题数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getPagingData</span><span class="params">(File file, <span class="keyword">int</span> pageIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> pagesizeRows, <span class="keyword">int</span> totalCountRows, <span class="keyword">int</span> outOfTitleRow)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总记录行数（除去标题）</span></span><br><span class="line">        <span class="keyword">int</span> sumOfRows = totalCountRows;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SAX解析方式第一行是1，不是0</span></span><br><span class="line">        <span class="keyword">int</span> headLineRowNum = <span class="keyword">this</span>.TITLELINE_ROW_INDEX;</span><br><span class="line">        <span class="keyword">if</span> (outOfTitleRow &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            headLineRowNum += outOfTitleRow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环的默认起始和结束</span></span><br><span class="line">        <span class="keyword">int</span> startRow = headLineRowNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endRow = startRow + pagesizeRows - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最后一行的行号</span></span><br><span class="line">        <span class="keyword">int</span> lastRowNum = sumOfRows + headLineRowNum;</span><br><span class="line">        <span class="keyword">int</span> odd = sumOfRows - ((pageIndex - <span class="number">1</span>) * pagesizeRows);<span class="comment">// 本页之前的所有记录</span></span><br><span class="line">        <span class="keyword">if</span> ((pageIndex - <span class="number">1</span>) * pagesizeRows &gt;= sumOfRows) &#123;<span class="comment">// 本页之前的所有记录已经超过总数了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (odd &gt; <span class="number">0</span> &amp;&amp; odd &lt;= pagesizeRows) &#123;<span class="comment">// 剩下的行数不够本页显示数</span></span><br><span class="line"></span><br><span class="line">            startRow = (headLineRowNum + <span class="number">1</span>) + (pageIndex - <span class="number">1</span>) * pagesizeRows;</span><br><span class="line">            endRow = lastRowNum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 所剩行数充足</span></span><br><span class="line">            startRow = headLineRowNum + (pageIndex - <span class="number">1</span>) * pagesizeRows + <span class="number">1</span>;</span><br><span class="line">            endRow = headLineRowNum + pageIndex * pagesizeRows;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyExcel2007ForPaging_high(file.getPath(), <span class="number">10</span>, startRow, endRow).getMyDataList(excelResultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采用SAX读取2007版的xlsx形式的Excel的最大行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSize4TheFile</span><span class="params">(File f)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyExcel2007ForMaxRow reader = <span class="keyword">new</span> MyExcel2007ForMaxRow(f.getPath());</span><br><span class="line">        <span class="keyword">return</span> reader.maxRow - (<span class="keyword">this</span>.TITLELINE_ROW_INDEX + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/home/yinshi/Documents/CodeSource/test-write08.xlsx&quot;</span>);</span><br><span class="line">        System.out.println(file.getPath());</span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line"><span class="comment">//        TmCaseExcelResultHandler excelResultHandler = new TmCaseExcelResultHandler();</span></span><br><span class="line"><span class="comment">//        ReaderSaxPOIUtils&lt;TmCase&gt; saxPOIUtils = new ReaderSaxPOIUtils&lt;&gt;(excelResultHandler);</span></span><br><span class="line"><span class="comment">//        long size4TheFile = saxPOIUtils.getSize4TheFile(file);</span></span><br><span class="line"><span class="comment">//        System.out.println(size4TheFile);</span></span><br><span class="line"><span class="comment">////        List&lt;List&lt;String&gt;&gt; titles = saxPOIUtils.getTitles(file, 2);</span></span><br><span class="line"><span class="comment">////        System.out.println(&quot;===&gt;&quot; + titles);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        List&lt;TmCase&gt; pagingData = saxPOIUtils.getPagingData(file, 1, 10, (int) size4TheFile, 1);</span></span><br><span class="line"><span class="comment">//        System.out.println(pagingData);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;======&gt;&quot; + pagingData.size());</span></span><br><span class="line">        String fileNma=<span class="string">&quot;222.xlsx&quot;</span>;</span><br><span class="line">        String replace = fileNma.replace(<span class="string">&quot;.xlsx&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(replace);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>getDataList本来 返回的是一个 List&lt;List<String>&gt;类型的结果集，因为一个单元格Cell解析出来的就是一个string字符串，所以一行rowData 代表的是List<String>，那一页sheet 代表的就是 List&lt;List<String>&gt; ,</li>
<li>我本来想使用策略模式，类似与JDBC的ResultHandler 一样，自行处理得到的结果集 ，就是 ExcelResultHandler 做的事情，将得到的rowData 转换为一个 泛型类， 但是感觉这样又有一个弊端， 就是处理 头文件 headerTitle 的数据的时候有些问题，因为头文件本身就不是一个 对象，它就应该是一个 List<String> 的 集合，所以我把  getTitle 方法获取 headerTitle的方法 给注释了 ，总之 这一块需要特殊处理</li>
<li> 再说一下使用方式 ，我们已经获取到了 文件的总行数totaCount ，我们就可以 进行分页了，就像 mybatis分页一样，我们可以自定义pageSize 一页有多少数据，然后使用pageCount= totalCount / pageSize，去计算页数，再在自己的 业务入口类中去 for（int pageIndex=1; pageIndex++;pageIndex&lt;=pageSize）循环获取分页数据进行处理 </li>
<li>最后说一下， 插入数据库 的方法建议自己重写一下，不要一条一条的insert， 太慢了，自己定义一个commitCount，比如2000条提交一次 </li>
</ol>
<h3 id="方案2：流式处理"><a href="#方案2：流式处理" class="headerlink" title="方案2：流式处理"></a>方案2：流式处理</h3><table>
<thead>
<tr>
<th>origin</th>
<th><a href="https://github.com/monitorjbl/excel-streaming-reader.git">https://github.com/monitorjbl/excel-streaming-reader.git</a></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="依赖包-1"><a href="#依赖包-1" class="headerlink" title="依赖包"></a>依赖包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.monitorjbl/xlsx-streamer --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.monitorjbl&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xlsx-streamer&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- apache poi 操作Microsoft Document --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- Apache POI - Java API To Access Microsoft Format Files--&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Apache POI - Java API To Access Microsoft Format Files--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- poi eventmodel方式 依赖包 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;xerces&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;xercesImpl&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.11.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><p>我们可以下载 这个项目的源代码看看,看里面的测试类，也可以大概知道使用方式 StreamingReaderTest</p>
<p>src/test/java/com/monitorjbl/xlsx/StreamingReaderTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.monitorjbl.xlsx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.monitorjbl.xlsx.exceptions.MissingSheetException;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.openxml4j.opc.OPCPackage;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.openxml4j.opc.PackageAccess;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Cell;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.CellType;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.DateUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Row;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Sheet;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.Workbook;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Spliterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Spliterators;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.StreamSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.poi.ss.usermodel.CellType.BOOLEAN;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.poi.ss.usermodel.CellType.NUMERIC;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.poi.ss.usermodel.CellType.STRING;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.poi.ss.usermodel.Row.MissingCellPolicy.CREATE_NULL_AS_BLANK;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.poi.ss.usermodel.Row.MissingCellPolicy.RETURN_BLANK_AS_NULL;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.equalTo;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.nullValue;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.MatcherAssert.assertThat;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.core.Is.is;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertFalse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertNotNull;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertNull;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertThrows;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertTrue;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.fail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingReaderTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@BeforeAll</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Locale.setDefault(Locale.ENGLISH);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetDateCellValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/test/resources/data_types.xlsx&quot;</span>);</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">      List&lt;List&lt;Cell&gt;&gt; obj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        List&lt;Cell&gt; o = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          o.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(o);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Date dt = obj.get(<span class="number">4</span>).get(<span class="number">1</span>).getDateCellValue();</span><br><span class="line">      assertNotNull(dt);</span><br><span class="line">      <span class="keyword">final</span> GregorianCalendar cal = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">      cal.setTime(dt);</span><br><span class="line">      assertEquals(cal.get(Calendar.YEAR), <span class="number">2014</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Verify LocalDateTime version is correct as well</span></span><br><span class="line">      LocalDateTime localDateTime = obj.get(<span class="number">4</span>).get(<span class="number">1</span>).getLocalDateTimeCellValue();</span><br><span class="line">      assertEquals(<span class="number">2014</span>, localDateTime.getYear());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        obj.get(<span class="number">0</span>).get(<span class="number">0</span>).getDateCellValue();</span><br><span class="line">        fail(<span class="string">&quot;Should have thrown IllegalStateException&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(IllegalStateException e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetDateCellValue1904</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/1904Dates.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">      List&lt;List&lt;Cell&gt;&gt; obj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        List&lt;Cell&gt; o = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          o.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(o);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Date dt = obj.get(<span class="number">1</span>).get(<span class="number">5</span>).getDateCellValue();</span><br><span class="line">      assertNotNull(dt);</span><br><span class="line">      <span class="keyword">final</span> GregorianCalendar cal = <span class="keyword">new</span> GregorianCalendar();</span><br><span class="line">      cal.setTime(dt);</span><br><span class="line">      assertEquals(cal.get(Calendar.YEAR), <span class="number">1991</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        obj.get(<span class="number">0</span>).get(<span class="number">0</span>).getDateCellValue();</span><br><span class="line">        fail(<span class="string">&quot;Should have thrown IllegalStateException&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(IllegalStateException e) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFirstCellNum</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/gaps.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">      List&lt;List&lt;Cell&gt;&gt; obj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      List&lt;Row&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        rows.add(r);</span><br><span class="line">        List&lt;Cell&gt; o = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          o.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(o);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assertEquals(<span class="number">3</span>, rows.size());</span><br><span class="line">      assertEquals(<span class="number">3</span>, rows.get(<span class="number">2</span>).getFirstCellNum());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGaps</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/gaps.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      List&lt;List&lt;Cell&gt;&gt; obj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        List&lt;Cell&gt; o = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          o.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(o);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assertEquals(<span class="number">3</span>, obj.size());</span><br><span class="line">      List&lt;Cell&gt; row;</span><br><span class="line"></span><br><span class="line">      row = obj.get(<span class="number">0</span>);</span><br><span class="line">      assertEquals(<span class="number">2</span>, row.size());</span><br><span class="line">      assertEquals(STRING, row.get(<span class="number">0</span>).getCellType());</span><br><span class="line">      assertEquals(STRING, row.get(<span class="number">1</span>).getCellType());</span><br><span class="line">      assertEquals(<span class="string">&quot;Dat&quot;</span>, row.get(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;Dat&quot;</span>, row.get(<span class="number">0</span>).getRichStringCellValue().getString());</span><br><span class="line">      assertEquals(<span class="number">0</span>, row.get(<span class="number">0</span>).getColumnIndex());</span><br><span class="line">      assertEquals(<span class="number">0</span>, row.get(<span class="number">0</span>).getRowIndex());</span><br><span class="line">      assertEquals(<span class="string">&quot;gap&quot;</span>, row.get(<span class="number">1</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;gap&quot;</span>, row.get(<span class="number">1</span>).getRichStringCellValue().getString());</span><br><span class="line">      assertEquals(<span class="number">2</span>, row.get(<span class="number">1</span>).getColumnIndex());</span><br><span class="line">      assertEquals(<span class="number">0</span>, row.get(<span class="number">1</span>).getRowIndex());</span><br><span class="line"></span><br><span class="line">      row = obj.get(<span class="number">1</span>);</span><br><span class="line">      assertEquals(<span class="number">2</span>, row.size());</span><br><span class="line">      assertEquals(STRING, row.get(<span class="number">0</span>).getCellType());</span><br><span class="line">      assertEquals(STRING, row.get(<span class="number">1</span>).getCellType());</span><br><span class="line">      assertEquals(<span class="string">&quot;guuurrrrrl&quot;</span>, row.get(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;guuurrrrrl&quot;</span>, row.get(<span class="number">0</span>).getRichStringCellValue().getString());</span><br><span class="line">      assertEquals(<span class="number">0</span>, row.get(<span class="number">0</span>).getColumnIndex());</span><br><span class="line">      assertEquals(<span class="number">6</span>, row.get(<span class="number">0</span>).getRowIndex());</span><br><span class="line">      assertEquals(<span class="string">&quot;!&quot;</span>, row.get(<span class="number">1</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;!&quot;</span>, row.get(<span class="number">1</span>).getRichStringCellValue().getString());</span><br><span class="line">      assertEquals(<span class="number">6</span>, row.get(<span class="number">1</span>).getColumnIndex());</span><br><span class="line">      assertEquals(<span class="number">6</span>, row.get(<span class="number">1</span>).getRowIndex());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultipleSheets_alpha</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/sheets.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      List&lt;List&lt;Cell&gt;&gt; obj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        List&lt;Cell&gt; o = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          o.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(o);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assertEquals(<span class="number">1</span>, obj.size());</span><br><span class="line">      List&lt;Cell&gt; row;</span><br><span class="line"></span><br><span class="line">      row = obj.get(<span class="number">0</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, row.size());</span><br><span class="line">      assertEquals(<span class="string">&quot;stuff&quot;</span>, row.get(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;stuff&quot;</span>, row.get(<span class="number">0</span>).getRichStringCellValue().getString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultipleSheets_zulu</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/sheets.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">      List&lt;List&lt;Cell&gt;&gt; obj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">1</span>)) &#123;</span><br><span class="line">        List&lt;Cell&gt; o = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          o.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(o);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assertEquals(<span class="number">1</span>, obj.size());</span><br><span class="line">      List&lt;Cell&gt; row;</span><br><span class="line"></span><br><span class="line">      row = obj.get(<span class="number">0</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, row.size());</span><br><span class="line">      assertEquals(<span class="string">&quot;yeah&quot;</span>, row.get(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;yeah&quot;</span>, row.get(<span class="number">0</span>).getRichStringCellValue().getString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSheetName_zulu</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/sheets.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line"></span><br><span class="line">      List&lt;List&lt;Cell&gt;&gt; obj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheet(<span class="string">&quot;SheetZulu&quot;</span>)) &#123;</span><br><span class="line">        List&lt;Cell&gt; o = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          o.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(o);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assertEquals(<span class="number">1</span>, obj.size());</span><br><span class="line">      List&lt;Cell&gt; row;</span><br><span class="line"></span><br><span class="line">      row = obj.get(<span class="number">0</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, row.size());</span><br><span class="line">      assertEquals(<span class="string">&quot;yeah&quot;</span>, row.get(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;yeah&quot;</span>, row.get(<span class="number">0</span>).getRichStringCellValue().getString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSheetName_alpha</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/sheets.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      List&lt;List&lt;Cell&gt;&gt; obj = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheet(<span class="string">&quot;SheetAlpha&quot;</span>)) &#123;</span><br><span class="line">        List&lt;Cell&gt; o = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          o.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        obj.add(o);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      assertEquals(<span class="number">1</span>, obj.size());</span><br><span class="line">      List&lt;Cell&gt; row;</span><br><span class="line"></span><br><span class="line">      row = obj.get(<span class="number">0</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, row.size());</span><br><span class="line">      assertEquals(<span class="string">&quot;stuff&quot;</span>, row.get(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;stuff&quot;</span>, row.get(<span class="number">0</span>).getRichStringCellValue().getString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSheetName_missingInStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/sheets.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      assertThrows(MissingSheetException.class, ()-&gt;wb.getSheet(<span class="string">&quot;asdfasdfasdf&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSheetName_missingInFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/sheets.xlsx&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>(Workbook wb = StreamingReader.builder().open(f)) &#123;</span><br><span class="line">      wb.getSheet(<span class="string">&quot;asdfasdfasdf&quot;</span>);</span><br><span class="line">      fail(<span class="string">&quot;Should have failed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(MissingSheetException e) &#123;</span><br><span class="line">      assertTrue(f.exists());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIteration</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/large.xlsx&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        Workbook wb = StreamingReader.builder()</span><br><span class="line">            .rowCacheSize(<span class="number">5</span>)</span><br><span class="line">            .open(f)) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        assertEquals(i, r.getCell(<span class="number">0</span>).getNumericCellValue(), <span class="number">0</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;#&quot;</span> + i, r.getCell(<span class="number">1</span>).getStringCellValue());</span><br><span class="line">        assertEquals(<span class="string">&quot;#&quot;</span> + i, r.getCell(<span class="number">1</span>).getRichStringCellValue().getString());</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeadingZeroes</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/leadingZeroes.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(Workbook wb = StreamingReader.builder().open(f)) &#123;</span><br><span class="line">      Iterator&lt;Row&gt; iter = wb.getSheetAt(<span class="number">0</span>).iterator();</span><br><span class="line">      iter.hasNext();</span><br><span class="line"></span><br><span class="line">      Row r1 = iter.next();</span><br><span class="line">      assertEquals(<span class="number">1</span>, r1.getCell(<span class="number">0</span>).getNumericCellValue(), <span class="number">0</span>);</span><br><span class="line">      assertEquals(<span class="string">&quot;1&quot;</span>, r1.getCell(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(NUMERIC, r1.getCell(<span class="number">0</span>).getCellType());</span><br><span class="line"></span><br><span class="line">      Row r2 = iter.next();</span><br><span class="line">      assertEquals(<span class="number">2</span>, r2.getCell(<span class="number">0</span>).getNumericCellValue(), <span class="number">0</span>);</span><br><span class="line">      assertEquals(<span class="string">&quot;0002&quot;</span>, r2.getCell(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;0002&quot;</span>, r2.getCell(<span class="number">0</span>).getRichStringCellValue().getString());</span><br><span class="line">      assertEquals(STRING, r2.getCell(<span class="number">0</span>).getCellType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadingEmptyFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/empty_sheet.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>(Workbook wb = StreamingReader.builder().open(f)) &#123;</span><br><span class="line">      Iterator&lt;Row&gt; iter = wb.getSheetAt(<span class="number">0</span>).iterator();</span><br><span class="line">      assertThat(iter.hasNext(), is(<span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpecialStyles</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/special_types.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;Cell&gt;&gt; contents = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span>(Workbook wb = StreamingReader.builder().open(f)) &#123;</span><br><span class="line">      <span class="keyword">for</span>(Row row : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        contents.put(row.getRowNum(), <span class="keyword">new</span> ArrayList&lt;Cell&gt;());</span><br><span class="line">        <span class="keyword">for</span>(Cell c : row) &#123;</span><br><span class="line">          <span class="keyword">if</span>(c.getColumnIndex() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            contents.get(row.getRowNum()).add(c);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;dd/MM/yyyy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assertThat(contents.size(), equalTo(<span class="number">2</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).size(), equalTo(<span class="number">4</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).get(<span class="number">0</span>).getStringCellValue(), equalTo(<span class="string">&quot;Thu\&quot;, \&quot;Dec 25\&quot;, \&quot;14&quot;</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).get(<span class="number">0</span>).getDateCellValue(), equalTo(df.parse(<span class="string">&quot;25/12/2014&quot;</span>)));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).get(<span class="number">1</span>).getStringCellValue(), equalTo(<span class="string">&quot;02/04/15&quot;</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).get(<span class="number">1</span>).getDateCellValue(), equalTo(df.parse(<span class="string">&quot;04/02/2015&quot;</span>)));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).get(<span class="number">2</span>).getStringCellValue(), equalTo(<span class="string">&quot;14\&quot;. \&quot;Mar\&quot;. \&quot;2015&quot;</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).get(<span class="number">2</span>).getDateCellValue(), equalTo(df.parse(<span class="string">&quot;14/03/2015&quot;</span>)));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).get(<span class="number">3</span>).getStringCellValue(), equalTo(<span class="string">&quot;2015-05-05&quot;</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">0</span>).get(<span class="number">3</span>).getDateCellValue(), equalTo(df.parse(<span class="string">&quot;05/05/2015&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).size(), equalTo(<span class="number">4</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).get(<span class="number">0</span>).getStringCellValue(), equalTo(<span class="string">&quot;3.12&quot;</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).get(<span class="number">0</span>).getNumericCellValue(), equalTo(<span class="number">3.12312312312</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).get(<span class="number">1</span>).getStringCellValue(), equalTo(<span class="string">&quot;1,023,042&quot;</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).get(<span class="number">1</span>).getNumericCellValue(), equalTo(<span class="number">1023042.0</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).get(<span class="number">2</span>).getStringCellValue(), equalTo(<span class="string">&quot;-312,231.12&quot;</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).get(<span class="number">2</span>).getNumericCellValue(), equalTo(-<span class="number">312231.12123145</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).get(<span class="number">3</span>).getStringCellValue(), equalTo(<span class="string">&quot;(132)&quot;</span>));</span><br><span class="line">    assertThat(contents.get(<span class="number">1</span>).get(<span class="number">3</span>).getNumericCellValue(), equalTo(-<span class="number">132.0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBlankNumerics</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/blank_cells.xlsx&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>(Workbook wb = StreamingReader.builder().open(f)) &#123;</span><br><span class="line">      Row row = wb.getSheetAt(<span class="number">0</span>).iterator().next();</span><br><span class="line">      assertThat(row.getCell(<span class="number">1</span>).getStringCellValue(), equalTo(<span class="string">&quot;&quot;</span>));</span><br><span class="line">      assertThat(row.getCell(<span class="number">1</span>).getRichStringCellValue().getString(), equalTo(<span class="string">&quot;&quot;</span>));</span><br><span class="line">      assertThat(row.getCell(<span class="number">1</span>).getDateCellValue(), is(nullValue()));</span><br><span class="line">      assertThat(row.getCell(<span class="number">1</span>).getNumericCellValue(), equalTo(<span class="number">0.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFirstRowNumIs0</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    File f = <span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/data_types.xlsx&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>(Workbook wb = StreamingReader.builder().open(f)) &#123;</span><br><span class="line">      Row row = wb.getSheetAt(<span class="number">0</span>).iterator().next();</span><br><span class="line">      assertThat(row.getRowNum(), equalTo(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNoTypeCell</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/no_type_cell.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is)) &#123;</span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          assertEquals(<span class="string">&quot;1&quot;</span>, c.getStringCellValue());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncryption</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/encrypted.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().password(<span class="string">&quot;test&quot;</span>).open(is)) &#123;</span><br><span class="line">      OUTER:</span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Cell c : r) &#123;</span><br><span class="line">          assertEquals(<span class="string">&quot;Demo&quot;</span>, c.getStringCellValue());</span><br><span class="line">          assertEquals(<span class="string">&quot;Demo&quot;</span>, c.getRichStringCellValue().getString());</span><br><span class="line">          <span class="keyword">break</span> OUTER;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStringCellValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/blank_cell_StringCellValue.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(r.getRowNum() == <span class="number">1</span>) &#123;</span><br><span class="line">          assertEquals(<span class="string">&quot;&quot;</span>, r.getCell(<span class="number">1</span>).getStringCellValue());</span><br><span class="line">          assertEquals(<span class="string">&quot;&quot;</span>, r.getCell(<span class="number">1</span>).getRichStringCellValue().getString());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNullValueType</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/null_celltype.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">for</span>(Row r : wb.getSheetAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Cell cell : r) &#123;</span><br><span class="line">          <span class="keyword">if</span>(r.getRowNum() == <span class="number">0</span> &amp;&amp; cell.getColumnIndex() == <span class="number">8</span>) &#123;</span><br><span class="line">            assertEquals(NUMERIC, cell.getCellType());</span><br><span class="line">            assertEquals(<span class="string">&quot;8:00:00&quot;</span>, cell.getStringCellValue());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInlineCells</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/inline.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      Row row = wb.getSheetAt(<span class="number">0</span>).iterator().next();</span><br><span class="line">      assertEquals(<span class="string">&quot;First inline cell&quot;</span>, row.getCell(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;First inline cell&quot;</span>, row.getCell(<span class="number">0</span>).getRichStringCellValue().getString());</span><br><span class="line">      assertEquals(<span class="string">&quot;Second inline cell&quot;</span>, row.getCell(<span class="number">1</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;Second inline cell&quot;</span>, row.getCell(<span class="number">1</span>).getRichStringCellValue().getString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMissingRattrs</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/missing-r-attrs.xlsx&quot;</span>));</span><br><span class="line">        StreamingReader reader = StreamingReader.builder().read(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      Row row = reader.iterator().next();</span><br><span class="line">      assertEquals(<span class="number">0</span>, row.getRowNum());</span><br><span class="line">      assertEquals(<span class="string">&quot;1&quot;</span>, row.getCell(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;5&quot;</span>, row.getCell(<span class="number">4</span>).getStringCellValue());</span><br><span class="line">      row = reader.iterator().next();</span><br><span class="line">      assertEquals(<span class="number">1</span>, row.getRowNum());</span><br><span class="line">      assertEquals(<span class="string">&quot;6&quot;</span>, row.getCell(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;10&quot;</span>, row.getCell(<span class="number">4</span>).getStringCellValue());</span><br><span class="line">      row = reader.iterator().next();</span><br><span class="line">      assertEquals(<span class="number">6</span>, row.getRowNum());</span><br><span class="line">      assertEquals(<span class="string">&quot;11&quot;</span>, row.getCell(<span class="number">0</span>).getStringCellValue());</span><br><span class="line">      assertEquals(<span class="string">&quot;15&quot;</span>, row.getCell(<span class="number">4</span>).getStringCellValue());</span><br><span class="line"></span><br><span class="line">      assertFalse(reader.iterator().hasNext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClosingFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    OPCPackage o = OPCPackage.open(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/blank_cell_StringCellValue.xlsx&quot;</span>), PackageAccess.READ);</span><br><span class="line">    o.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldIgnoreSpreadsheetDrawingRows</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/has_spreadsheetdrawing.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      Iterator&lt;Row&gt; iterator = wb.getSheetAt(<span class="number">0</span>).iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        iterator.next();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShouldReturnNullForMissingCellPolicy_RETURN_BLANK_AS_NULL</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/blank_cells.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      Row row = wb.getSheetAt(<span class="number">0</span>).iterator().next();</span><br><span class="line">      assertNotNull(row.getCell(<span class="number">0</span>, RETURN_BLANK_AS_NULL)); <span class="comment">//Remain unchanged</span></span><br><span class="line">      assertNull(row.getCell(<span class="number">1</span>, RETURN_BLANK_AS_NULL));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShouldReturnBlankForMissingCellPolicy_CREATE_NULL_AS_BLANK</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/null_cell.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      Row row = wb.getSheetAt(<span class="number">0</span>).iterator().next();</span><br><span class="line">      assertEquals(<span class="string">&quot;B1 is Null -&gt;&quot;</span>, row.getCell(<span class="number">0</span>, CREATE_NULL_AS_BLANK).getStringCellValue()); <span class="comment">//Remain unchanged</span></span><br><span class="line">      assertEquals(<span class="string">&quot;B1 is Null -&gt;&quot;</span>, row.getCell(<span class="number">0</span>, CREATE_NULL_AS_BLANK).getRichStringCellValue().getString()); <span class="comment">//Remain unchanged</span></span><br><span class="line">      assertThat(row.getCell(<span class="number">1</span>), is(nullValue()));</span><br><span class="line">      assertNotNull(row.getCell(<span class="number">1</span>, CREATE_NULL_AS_BLANK));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle a file with a blank SST reference, like &lt;c r=&quot;L42&quot; s=&quot;1&quot; t=&quot;s&quot;&gt;&lt;v&gt;&lt;/v&gt;&lt;/c&gt;</span></span><br><span class="line">  <span class="comment">// Normally, if Excel saves the file, that whole &lt;c ...&gt;&lt;/c&gt; wouldn&#x27;t even be there.</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShouldHandleBlankSSTReference</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/blank_sst_reference_doctored.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      Iterator&lt;Row&gt; iterator = wb.getSheetAt(<span class="number">0</span>).iterator();</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        iterator.next();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The last cell on this sheet should be a NUMERIC but there is a lingering &quot;f&quot;</span></span><br><span class="line">  <span class="comment">// tag that was getting attached to the last cell causing it to be a FORUMLA.</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForumulaOutsideCellIgnored</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/formula_outside_cell.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">      Iterator&lt;Row&gt; rows = wb.getSheetAt(<span class="number">0</span>).iterator();</span><br><span class="line">      Cell cell = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">while</span>(rows.hasNext()) &#123;</span><br><span class="line">        Iterator&lt;Cell&gt; cells = rows.next().iterator();</span><br><span class="line">        <span class="keyword">while</span>(cells.hasNext()) &#123;</span><br><span class="line">            cell = cells.next();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      assertNotNull(cell);</span><br><span class="line">      assertThat(cell.getCellType(), is(CellType.NUMERIC));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFormulaWithDifferentTypes</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">      InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/formula_test.xlsx&quot;</span>));</span><br><span class="line">      Workbook wb = StreamingReader.builder().open(is)</span><br><span class="line">    ) &#123;</span><br><span class="line">      Sheet sheet = wb.getSheetAt(<span class="number">0</span>);</span><br><span class="line">      Iterator&lt;Row&gt; rowIterator = sheet.rowIterator();</span><br><span class="line"></span><br><span class="line">      Row next = rowIterator.next();</span><br><span class="line">      Cell cell = next.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      assertThat(cell.getCellType(), is(CellType.STRING));</span><br><span class="line"></span><br><span class="line">      next = rowIterator.next();</span><br><span class="line">      cell = next.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      assertThat(cell.getCellType(), is(CellType.FORMULA));</span><br><span class="line">      assertThat(cell.getCachedFormulaResultType(), is(CellType.STRING));</span><br><span class="line"></span><br><span class="line">      next = rowIterator.next();</span><br><span class="line">      cell = next.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      assertThat(cell.getCellType(), is(CellType.FORMULA));</span><br><span class="line">      assertThat(cell.getCachedFormulaResultType(), is(CellType.BOOLEAN));</span><br><span class="line"></span><br><span class="line">      next = rowIterator.next();</span><br><span class="line">      cell = next.getCell(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      assertThat(cell.getCellType(), is(CellType.FORMULA));</span><br><span class="line">      assertThat(cell.getCachedFormulaResultType(), is(CellType.NUMERIC));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testShouldIncrementColumnNumberIfExplicitCellAddressMissing</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// On consecutive columns the &lt;c&gt; element might miss an &quot;r&quot; attribute, which indicate the cell position.</span></span><br><span class="line">	<span class="comment">// This might be an optimization triggered by file size and specific to a particular excel version.</span></span><br><span class="line">	<span class="comment">// The excel would read such a file without complaining.</span></span><br><span class="line">    <span class="keyword">try</span>(</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;src/test/resources/sparse-columns.xlsx&quot;</span>));</span><br><span class="line">        Workbook wb = StreamingReader.builder().open(is);</span><br><span class="line">    ) &#123;</span><br><span class="line">    	 Sheet sheet = wb.getSheetAt(<span class="number">0</span>);</span><br><span class="line">    	 </span><br><span class="line">    	 Iterator&lt;Row&gt; rowIterator = sheet.rowIterator();</span><br><span class="line">         Row row = rowIterator.next();</span><br><span class="line">         </span><br><span class="line">         assertThat(row.getCell(<span class="number">0</span>).getStringCellValue(), is(<span class="string">&quot;sparse&quot;</span>));</span><br><span class="line">         assertThat(row.getCell(<span class="number">3</span>).getStringCellValue(), is(<span class="string">&quot;columns&quot;</span>));</span><br><span class="line">         assertThat(row.getCell(<span class="number">4</span>).getNumericCellValue(), is(<span class="number">0.0</span>));</span><br><span class="line">         assertThat(row.getCell(<span class="number">5</span>).getNumericCellValue(), is(<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p>因为我也没有仔细研究， 因为没有采用这个方式，但是 看了一下，应该不是 很难</p>
<h3 id="方案3：-阿里easyExcel"><a href="#方案3：-阿里easyExcel" class="headerlink" title="方案3： 阿里easyExcel"></a>方案3： 阿里easyExcel</h3><ul>
<li><p>最后说一下 使用阿里的easyExcel 的背景，我本来使用第一个方案 实现了 大文件的解析， 可是晚上接到电话，说 行内代码扫描说我的实现方式 存在安全漏洞，需要去修改 ，我震惊了，</p>
</li>
<li><p>但是还是想 了解一下原因,出现问题，分析问题，再解决问题嘛，解决不了咱在换个方案嘛，</p>
</li>
<li><p>但是又害怕 扭不到 行内的安全部门，所以得两手准备，一方面定位安全问题，一方面准备新方案 （ali easyexcel）</p>
</li>
</ul>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>因为也是第一次使用easyExcel，再简单 看了下 说明文档后，大致知道我应该怎么用， 跟我想象中的使用方法还是有差别的 。可以说是开辟了一个新思路吧 </p>
<ul>
<li>我最开始本以为 api也会提供类似与分页的方式 ，来让用户取到数据，然后自行处理，后面发现并不是  ，以读操作为例，</li>
<li>我们需要继承 AnalysisEventListener 类，实现抽象方法，在抽象方法中写 自己的业务逻辑 。</li>
<li>read方法大部分的方法都是 void类型的 ，业务的逻辑都放在了 AnalysisEventListener 中去做，只有一个方法 </li>
</ul>
<p>以下的方法是： api中能为我们提供返回值 的方法，其实原理就是在自定义的listener（SyncReadListener）中新增一个类变量List<resultVO>，然后提供get 和set方法 ，每一条rowData都会经过 invoke 方法，每次处理成功之后，就将invoke处理过后的数据，加入 list，最后 我们就可以拿到 返回值了， </p>
<ul>
<li>其实按照类似的思路，我们也可以自己实现一个带有分页功能的 Listener ，然后对外提供 分页能力，思路大概是： </li>
<li><ul>
<li>新建builder 继承  AbstractExcelReaderParameterBuilder 新增分页方法， </li>
<li>新建类 factory 继承 EasyExcelFactory ，新增分页方法</li>
</ul>
</li>
</ul>
<p>但是感觉好像确实没必要，毕竟我们拿到返回的list<excelVO>，我们还是需要 逐条解析逐条处理。 我们的业务 处理逻辑完全可以写在  listener 里面提供的2个方法  invoke 和 doAfterAllAnalysed 里面 。</p>
<p>** 嘿嘿，没事给自己找事，下次写一个玩玩吧 （TODO tocheck）**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Quickly read small files，no more than 10,000 lines.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     *            the POI filesystem that contains the Workbook stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sheet</span></span><br><span class="line"><span class="comment">     *            read sheet.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> analysis result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> please use &#x27;EasyExcel.read(in).sheet(sheetNo).doReadSync();&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Object&gt; <span class="title">read</span><span class="params">(InputStream in, Sheet sheet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Object&gt; rows = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="keyword">new</span> ExcelReader(in, <span class="keyword">null</span>, <span class="keyword">new</span> AnalysisEventListener&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object object, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">                rows.add(object);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;&#125;</span><br><span class="line">        &#125;, <span class="keyword">false</span>).read(sheet);</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelReaderSheetBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractExcelReaderParameterBuilder</span>&lt;<span class="title">ExcelReaderSheetBuilder</span>, <span class="title">ReadSheet</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synchronous reads return results</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">doReadSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (excelReader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExcelAnalysisException(<span class="string">&quot;Must use &#x27;EasyExcelFactory.read().sheet()&#x27; to call this method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SyncReadListener syncReadListener = <span class="keyword">new</span> SyncReadListener();</span><br><span class="line">        registerReadListener(syncReadListener);</span><br><span class="line">        excelReader.read(build());</span><br><span class="line">        excelReader.finish();</span><br><span class="line">        <span class="keyword">return</span> (List&lt;T&gt;)syncReadListener.getList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Synchronous data reading</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jiaju Zhuang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncReadListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object object, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        list.add(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><p>讲了一堆，进入正题吧，我的业务逻辑  有4点：</p>
<ol>
<li>需要校验头文件 headerTItle 的正确性，如果 valid不通过，需要直接抛出异常，不进行后续解析操作 </li>
<li>需要校验每条数据的 正确性</li>
<li>需要将正确的数据 批量插入数据库中</li>
<li>需要将错误数据写在 ErrorData写在 excel 里面</li>
</ol>
<h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><ol>
<li>关于校验头文件，业务需求使得我们 需要单独 新建一个 HeaderTitleValidListener，在  单纯的只是 checkheader，不做其他操作,校验不通过就抛出异常，中断解析操作</li>
<li> 关于每条数据的正确性，我们需要再新增一个 XXDataListener ，然后我们可以自行封装 一个 业务逻辑的 XXvalidtor ，方法就是 checkData，返回值就是 错误信息，这个需要写入excel的</li>
<li> 正确数据的处理，放在 listener的 invoke 方法中，新增一个类变量 greenDataCacheList，用于存储正确的数据，定义一个常量 COMMIT_COUNT=2000，当 greenDataCacheList 的size= COMMIT_COUNT ，我们就执行一个插入数据库的工作，然后clear greenDataCacheList的数据</li>
<li>将错误数据写在 ErrorData写在 excel 里面，这个其实可以放在 doAfterAllAnalysed里面去做，当然也可以同样的方式放在 invoke 方法里面去做 </li>
</ol>
<p>思路清晰了，实现起来就很简单了 </p>
<h4 id="依赖包-2"><a href="#依赖包-2" class="headerlink" title="依赖包"></a>依赖包</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/com.monitorjbl/xlsx-streamer --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.monitorjbl&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;xlsx-streamer&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;joda-time&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;joda-time&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.8&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- apache poi 操作Microsoft Document --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;poi&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- Apache POI - Java API To Access Microsoft Format Files--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Apache POI - Java API To Access Microsoft Format Files--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- poi eventmodel方式 依赖包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;xerces&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;xercesImpl&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.11.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h4 id="自定义LIstener"><a href="#自定义LIstener" class="headerlink" title="自定义LIstener"></a>自定义LIstener</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.poi.sax.easyexcel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.exception.ExcelCommonException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderTitleValidListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">TmCase</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(HeaderTitleValidListener.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_COUNT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValidHeadertitle(headMap)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExcelCommonException(<span class="string">&quot;头文件异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;HEAD:&#123;&#125;&quot;</span>, JSON.toJSONString(headMap));</span><br><span class="line">        LOGGER.info(<span class="string">&quot;total:&#123;&#125;&quot;</span>, context.readSheetHolder().getTotal());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true： 通过</span></span><br><span class="line"><span class="comment">     * false：  未通过</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidHeadertitle</span><span class="params">(Map&lt;Integer, String&gt; headMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String[] ORGIN_HEADERTITLE = &#123;<span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;年龄&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; ORGIN_HEADERTITLE_List = Arrays.asList(ORGIN_HEADERTITLE);</span><br><span class="line">        <span class="comment">//TODO 校验逻辑</span></span><br><span class="line">        <span class="comment">// 1. 校验excel的头文件是否为空</span></span><br><span class="line">        <span class="comment">// 2. 校验excel的头文件 的长度 headMap.entrySet().size  ORGIN_HEADERTITLE_List.size</span></span><br><span class="line">        <span class="comment">// 3. 校验excel的头文件 every item</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每条shuju</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     *            one row value. Is is same as &#123;<span class="doctag">@link</span> AnalysisContext#readRowHolder()&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(TmCase data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// donothing</span></span><br><span class="line"><span class="comment">//        LOGGER.info(&quot;index:&#123;&#125;&quot;, context.readRowHolder().getRowIndex());</span></span><br><span class="line"><span class="comment">//        LOGGER.info(&quot;解析到一条数据:&#123;&#125;&quot;, JSON.toJSONString(data));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// donothing</span></span><br><span class="line"><span class="comment">//        LOGGER.info(&quot;所有数据解析完成！&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///// 分界线</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.poi.sax.easyexcel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.yinshi.gitstats.entity.TmCase;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LargeDataListener</span> <span class="keyword">extends</span> <span class="title">AnalysisEventListener</span>&lt;<span class="title">TmCase</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(LargeDataListener.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每隔5条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_COUNT = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TmCase&gt; greenDataList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(TmCase data, AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 如果 greenDataList大小==BATCH_COUNT ，则插入数据库，然后 greenDataList.clear</span></span><br><span class="line">        <span class="comment">// 2. 执行数据校验Validtor，校验通过，greenDataList.add</span></span><br><span class="line">        <span class="comment">// 3. Validtor校验不通过，则将 errorMsg ,set到对象中</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterAllAnalysed</span><span class="params">(AnalysisContext context)</span> </span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;Large row count:&#123;&#125;&quot;</span>, count);</span><br><span class="line">        <span class="comment">// 将错误数据写入 excel</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">package</span> com.yinshi.gitstats.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelIgnore;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Table(name = &quot;tm_case&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TmCase</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4112999956266472980L</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;, columnDefinition = &quot;BIGINT&quot;)</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    @ExcelProperty(index = 2, converter = GenderConverter.class)</span></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 0)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;loanNo&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String loanNo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 1)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;colDateStr&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String colDateStr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 2)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;colType&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String colType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 3)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;colPerson&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String colPerson;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 4)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;colAddress&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String colAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 5)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;colStatus&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String colStatus;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 6)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;concreteColContent&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String concreteColContent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 7)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;repayDateStr&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String repayDateStr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 8)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;repayAmtStr&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String repayAmtStr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(index = 9)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;errorMsg&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><p>写的都是伪代码，思路提供了，自行实现吧 ，代码都在公司上，自己电脑只是验证可行性 </p>
</li>
<li><p>可以多看看 easyExcel的 源码，还是很nice的 </p>
<table>
<thead>
<tr>
<th>origin</th>
<th><a href="https://github.com/alibaba/easyexcel.git">https://github.com/alibaba/easyexcel.git</a></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最终通过实验，我们比较一下这写方案的性能差异：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">//参数自行改动</span></span><br><span class="line"> <span class="comment">// VM:  -Xmx40M -Xms40M -XX:+PrintGCDetails -XX:+PrintHeapAtGC</span></span><br><span class="line"><span class="comment">//        readXlsxTest();</span></span><br><span class="line"><span class="comment">//        testSAX();</span></span><br><span class="line">        testEasyExcel();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEasyExcel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/home/yinshi/Documents/CodeSource/test-write071.xlsx&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        EasyExcel.read(file, TmCase.class,</span><br><span class="line">                <span class="keyword">new</span> LargeDataListener()).headRowNumber(<span class="number">2</span>).sheet().doRead();</span><br><span class="line">        System.out.println(<span class="string">&quot;Large data total time spent:&quot;</span>+ (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSAX</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/home/yinshi/Documents/CodeSource/test-write071.xlsx&quot;</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        List&lt;TmCase&gt; myDataList = new MyExcel2007ForPaging_high_baK_bak(file.getPath(), 10, 2, 50001).</span></span><br><span class="line"><span class="comment">//                getMyDataList(new TmCaseExcelResultHandler());</span></span><br><span class="line">        ReaderSaxPOIUtils&lt;TmCase&gt; utils = <span class="keyword">new</span> ReaderSaxPOIUtils&lt;TmCase&gt;(<span class="keyword">new</span> TmCaseExcelResultHandler());</span><br><span class="line">        List&lt;TmCase&gt; pagingData = utils.getPagingData(file, <span class="number">1</span>, <span class="number">2000</span>, <span class="number">50001</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (TmCase tmCase : pagingData) &#123;</span><br><span class="line">            System.out.println(tmCase.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取以 .xlsx 为后缀的 Excel 测试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 文件操作异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readXlsxTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 读取 Excel 文件</span></span><br><span class="line">        <span class="comment">// 获取文件路径和文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/home/yinshi/Documents/CodeSource/test-write071.xlsx&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">// 将输入流转换为工作簿对象</span></span><br><span class="line">        XSSFWorkbook workbook = <span class="keyword">new</span> XSSFWorkbook(fis);</span><br><span class="line">        <span class="comment">// 获取第一个工作表</span></span><br><span class="line"><span class="comment">//        XSSFSheet sheet = workbook.getSheet(&quot;sheet0&quot;);</span></span><br><span class="line">        <span class="comment">// 使用索引获取工作表</span></span><br><span class="line">        XSSFSheet sheet = workbook.getSheetAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取指定行</span></span><br><span class="line">        XSSFRow row = sheet.getRow(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取指定列</span></span><br><span class="line">        XSSFCell cell = row.getCell(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        System.out.println(cell.getStringCellValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><img src="/uploads/poiJVM/excelSize.png"></p>
<p><img src="/uploads/poiJVM/userModelJVM.png"></p>
<p><img src="/uploads/poiJVM/SaxPOI_JVMparams.png"></p>
<p><img src="/uploads/poiJVM/ali_easyExcel_JVM.png"></p>
<p>计算一下，excel 大小为 2.1 M</p>
<p>用户模式需要： 新生代used + 老年代used = (23327+30563 )/1024= 52.6M</p>
<p>sax事件驱动模式： （9408+31764 ） /1024=  40.2 M</p>
<p>阿里easyExcel：（8699+15950）/1024=24.07 M</p>
<p>所以………………厉害</p>
<p><strong>这边再贴一下关于 streamReader  和 sax的解析xml 的安全问题的 源头，以及解决方案</strong></p>
<p>ref : <a href="https://www.dazhuanlan.com/2020/02/02/5e36a1acefeea/">https://www.dazhuanlan.com/2020/02/02/5e36a1acefeea/</a></p>
]]></content>
      <categories>
        <category>poi</category>
      </categories>
      <tags>
        <tag>读取大文件</tag>
      </tags>
  </entry>
</search>
