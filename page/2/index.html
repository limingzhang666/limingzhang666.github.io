<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="HCj467TtuvFkAzzdCvYvbniAeNiUy7TUwp2hG1qGWQE">
  <meta name="baidu-site-verification" content="LppFIbSdZO">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limingzhang666.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","width":320,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="拨开云雾见青天">
<meta property="og:type" content="website">
<meta property="og:title" content="Yinshi&#39;s Blog">
<meta property="og:url" content="https://limingzhang666.github.io/page/2/index.html">
<meta property="og:site_name" content="Yinshi&#39;s Blog">
<meta property="og:description" content="拨开云雾见青天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yinshi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://limingzhang666.github.io/page/2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yinshi's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yinshi's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yinshi"
      src="/images/yinshi01_avatar.jpg">
  <p class="site-author-name" itemprop="name">Yinshi</p>
  <div class="site-description" itemprop="description">拨开云雾见青天</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/limingzhang666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limingzhang666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:laimingcham@163.com" title="E-Mail → mailto:laimingcham@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/limingzhang666" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">java高并发详解-12-深入理解volatile关键字</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-08 18:19:34" itemprop="dateCreated datePublished" datetime="2021-03-08T18:19:34+08:00">2021-03-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-12-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><ul>
<li>Java内存模型（Java Memory Mode，JMM） 指定了Java虚拟机如何与计算机 的主存（RAM）进行工作。</li>
</ul>
<p>Java的内存模型决定了一个线程对共享变量的写入何时对其他线程可见，Java内存模型定义了线程和主内存之间的抽象关系。具体如下：</p>
<ol>
<li>共享变量存储与主内存之中，每个线程都可以访问</li>
<li>每个线程都有私有的工作内存或者称为本地内存</li>
<li>工作内存只存储该线程对共享变量的副本</li>
<li>线程不能直接操作主内存，只有先操作了工作内存之后才能写入主内存</li>
<li>工作内存和Java内存模型一样也是一个抽象的概念，它其实并不存在，它涵盖了缓存、寄存器、编译器优化以及硬件等。</li>
</ol>
<h1 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h1><p>原子性、有序性、 可见性</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>所谓原子性是指在一次的操作和多次操作中，要么所有的操作全部都得到了执行并且不会受到 任何因素的干扰而中断，要么所有的操作都不执行</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>两个原子性的操作结合在一起未必还是原子性的，比如 i++ (其中get i，i+1，set i=x 三者都是原子性操作，但是不代表 i++就是原子性操作)</li>
<li>volatile 关键字不保证 数据的原子性，synchronized关键字保证，自从 JDK1.5 版本开始，其提供的原子类型变量也 可以保证原子性</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性是指 程序代码在执行过程中的先后顺序，由于Java 在编译器以及运行期的优化，导致了 代码的 执行顺序未必就是开发者编写代码时的顺序，</p>
<p>因为会存在 指令重排序的情况（Instruction Recorder）</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指，当一个线程对共享变量进行了修改，那么另外的线程 可以立即看到修改后的最新值 </p>
<h1 id="JMM如何保证三大特性"><a href="#JMM如何保证三大特性" class="headerlink" title="JMM如何保证三大特性"></a>JMM如何保证三大特性</h1><ul>
<li>JVM采用 内存模型的机制来 屏蔽各个平台和操作系统之间内存访问的差异，以实现让 Java程序在各种平台下达到一致的内存访问效果</li>
<li>Java的内存模型规定了所有的变量都是存在于 主内存（RAM）当中的，而每个线程都有自己的工作内存或者本地内存。线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接对主内存 进行操作，并且每一个线程都不能访问其他线程的工作内存或者本地内存 。</li>
</ul>
<h2 id="1-JMM与原子性"><a href="#1-JMM与原子性" class="headerlink" title="1.JMM与原子性"></a>1.JMM与原子性</h2><p>在Java语言中，对基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的，因此诸如此类的操作是  不可被中断的，要么执行，要么不执行，正所谓 一荣俱荣一损俱损。</p>
<p>（1） x=10； 赋值操作</p>
<p>x=10的操作是原子性的，执行线程首先会将x=10，写入工作内存中，然后再将其 写入主内存（）</p>
<p>（2）y=x； 赋值操作</p>
<p>这条操作时非原子性的，因为它 包含如下两个重要的步骤</p>
<ol>
<li>执行线程从主内存中 读取x的值（如果x 已经存在于 执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中</li>
<li>在执行线程的 工作内存中修改y的值为x，然后将y的值写入 主内存之中</li>
</ol>
<p>虽然第一步和第二步 都是原子类型的操作，但是合在 一起就不是原子操作了</p>
<p>（3）y++； 自增操作</p>
<p>这条操作语句时非原子性的，因为它包含3个重要的步骤，具体如下</p>
<ol>
<li><p>执行线程从主内存中读取y的值，然后将其存入当前线程的工作内存之中</p>
</li>
<li><p>在执行线程工作内存中为y执行加1操作</p>
</li>
<li><p>将y的值写入主内存</p>
</li>
</ol>
<p>（4）z=z+1； 加一操作（与自增操作等价）</p>
<p>这条操作语句时非原子性的，因为它包含3个重要的步骤，具体如下：</p>
<ol>
<li>执行线程从主内存中读取z的值（如果z已经存在于执行线程的工作内存中，则直接获取），然后将其存入当前线程的工作内存之中</li>
<li>在执行线程工作内存中为z执行加1操作</li>
<li>将z的值写入主内存 </li>
</ol>
<p>总结：</p>
<ul>
<li>多个原子性的操作在一起就不再是原子性操作了</li>
<li>简单的读取与赋值操作时原子性的，将一个变量赋给另一个变量的操作不是原子性的</li>
<li>java内存模型（JMM）只保证了基本读取和赋值的原子性操作，其他的均不保证，</li>
<li><strong>如果想要使得某些代码片段具备原子性，需要使用关键字 synchronized，或者 JUC中的lock ，</strong></li>
<li>*<em>如果想要使得int 等类型自增操作具备原子性，可以使用JUC 包下的原子封装类型 java.util.concurrent.atomic.**</em></li>
<li><strong>volatile 关键字不具备保证 原子性的语义</strong></li>
</ul>
<h2 id="2-JMM与可见性"><a href="#2-JMM与可见性" class="headerlink" title="2.JMM与可见性"></a>2.JMM与可见性</h2><p>在多线程环境中，如果某个线程首次读取共享变量，则首先 到主内存中获取该变量，然后存入 工作内存中，以后只需要在工作内存中读取该变量即可。 </p>
<p>同样的，如果对该变量执行了修改的操作，则先 将新值写入工作内存中，然后再刷新至 主内存中， <strong>但是什么时候最新的值会被刷新至主内存中是不太确定的</strong>，</p>
<p>java提供了以下三种方式来保证可见性</p>
<ul>
<li>使用关键字 volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行（当然也会缓存到线程自己的工作内存中，当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），对于共享资源的写操作当然是 先修改工作内存，但是修改结束后会立刻将其刷新到主内存中</li>
<li>通过synchronized 关键字能够保证可见性，synchronized 关键字能够保证同一时刻 ，只有一个线程获得锁，然后执行同步党法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存当中</li>
<li>通过JUC 提供的显示锁Lock也能保证可见性，Lock的lock方法能够保证 在同一时刻只有一个线程获得锁，然后执行同步方法，并且会确保在锁 释放（Lock的unlock方法）之前会将对变量的修改刷新到主内存当中</li>
</ul>
<p>总结： <strong>volatile关键字具有保证可见性的语义</strong></p>
<h2 id="3-JMM与有序性"><a href="#3-JMM与有序性" class="headerlink" title="3.JMM与有序性"></a>3.JMM与有序性</h2><p>在Java内存模型中，允许编译器和处理器对指令进行重排序/。但是在多线程的情况下，重排序会影响到程序的正确运行，Java提供了3种保证有序性的方式</p>
<ul>
<li>使用volatile 关键字来保证有序性</li>
<li>使用 synchronized关键字来保证有序性、</li>
<li>使用  显示锁Lock 来保证有序性</li>
</ul>
<p>另外Java的内存模型具备一些天生的有序性规则，不需要任何同步手段就能够保证有序性，这个规则被称为Happens-before原则。</p>
<p>happens-before原则</p>
<ul>
<li>程序次序规则： 在一个线程内，代码按照编写的次序执行，编写在后面的操作发生于 编写在前面的操作之后</li>
<li>锁定规则： 一个unlock操作要先行发生于对同一个锁的lock操作</li>
<li>volatile变量规则：  对一个变量的写操作 要早于对这个变量之后的读操作</li>
<li>传递规则</li>
<li>线程启动规则： THread对象的start 方法先行于对该线程的任何动作，</li>
<li>线程中断规则：  对线程执行interrupt方法肯定要优先于捕获到中断信号 </li>
<li>线程的终结规则：</li>
</ul>
<p>总结： volatile关键字具有保证顺序性的语义</p>
<h1 id="volatile关键字深入解析"><a href="#volatile关键字深入解析" class="headerlink" title="volatile关键字深入解析"></a>volatile关键字深入解析</h1><p>被volatile 修饰的实例变量 或者类变量具备如下两层语义</p>
<ul>
<li>保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰的变量，另一个线程会立即看到最新的值</li>
<li>禁止对指令进行重排序操作</li>
<li>volatile 并不保证 原子性</li>
</ul>
<h2 id="volatile的原理和实现机制"><a href="#volatile的原理和实现机制" class="headerlink" title="volatile的原理和实现机制"></a>volatile的原理和实现机制</h2><p>通过对OpenJDK下 unsafe.cpp 源码的阅读会发现 被volatile修饰的变量存在于 一个 lock 的前缀，源码如下：</p>
<p>“lock；” 前缀实际上相当于是一个 内存屏障，该内存屏障会为 指令的执行 提供如下几个保障。</p>
<ul>
<li>确保指令重排序时不会将其后面的代码排到内存屏障之前</li>
<li>确保指令重排序时不会将其后面的代码派操内存屏障之后</li>
<li>确保在执行内存屏障修饰的指令时前面的代码全部执行完成</li>
<li>强制将线程工作内存中的值 修改刷新至主内存中</li>
<li>如果是写操作，则会导致其他线程工作内存（CPU Cache）中缓存数据失效</li>
</ul>
<h2 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h2><ol>
<li>开关控制利用可见性的特点</li>
<li>状态标记利用顺序性特点</li>
</ol>
<h2 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h2><p> 1.使用上的区别</p>
<ul>
<li>volatile关键字<strong>只能用于修饰实例变量或者类变量</strong>，不能用于修饰方法以及方法参数 和局部变量、常量等</li>
<li>synchronized 关键字不能用于对变量的修饰，只能用于修饰方法或者语句块 </li>
<li>volatile 修饰的变量可以为null ，synchronized 关键字同步语句块的monitor对象不能为null </li>
</ul>
<ol start="2">
<li>对原子性的保证</li>
</ol>
<ul>
<li>volatile无法保证原子性</li>
<li>由于synchronized 是一种排他的机制，因此被 synchronized 关键字修饰的同步代码 是无法被中途打断的，因此可以能够保证代码的原子性</li>
</ul>
<ol start="3">
<li>对可见性的保证</li>
</ol>
<ul>
<li>两者均可以保证共享资源在多线程间的可见性，但是实现机制完全不同</li>
<li>synchronized 借助于JVM指令 monitor enter 和 monitor exit 对通过排他的方式使得 同步代码串行化，在monitor exit时所有共享资源都将会被刷新到主内存中</li>
<li>volatile 使用机器指令“lock；”的方式迫使其他线程工作内存中的数据失效，不得到 主内存中进行再次加载</li>
</ul>
<ol start="4">
<li>对有序性的保证</li>
</ol>
<ul>
<li>volatile关键字禁止JVM 编译器以及处理器对其进行重排序，所以 它能够保证有序性</li>
<li>synchronized 关键字所修饰的同步方法 也可以保证顺序性，但是这种顺序性 是以程序的串行化执行换来的，  在synchronized 关键字所修饰的代码块中 代码指令也会发生指令重排序的情况</li>
</ul>
<ol start="5">
<li>其他</li>
</ol>
<ul>
<li>volatile不会使得线程陷入阻塞</li>
<li>synchronized 关键字会使得 线程进入阻塞状态</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>并发编程的3个重要特性： 原子性，可见性 和有序性</p>
</li>
<li><p>java 如何保证这3个重要特性，synchronized主要是 排他机制，确保每次都只有一个线程通过。volatile 主要是通过内存屏障“lock；”以及防止指令重排序的方式来实现</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">java高并发详解-11-线程上下文类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-08 15:16:35" itemprop="dateCreated datePublished" datetime="2021-03-08T15:16:35+08:00">2021-03-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/08/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-11-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前面讲java类加载器的知识为了解释线程的上下文类加载器原理和使用场景</p>
<h1 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h1><h2 id="为什么需要线程上下文类加载器"><a href="#为什么需要线程上下文类加载器" class="headerlink" title="为什么需要线程上下文类加载器"></a>为什么需要线程上下文类加载器</h2><p>根据Thread 类的文档 你会发现线程上下文方法是  从JDK1.2 开始引入的，getContextClassLoader() 和 setContextClassLoader（ClassLoader cl）分别用于获取和设置当前线程线程的上下文类加载器，如果当前线程没有设置上下文类加载器，那么它将和父线程保持同样的类加载器。</p>
<ul>
<li>站在开发者的角度，其他线程都是由Main线程，也就是main函数所在的线程派生的，它是其他线程的父线程或者祖先线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getContextClassLoader());</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果:</span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">14d</span>ad5dc</span><br><span class="line">    </span><br><span class="line">    Loading <span class="class"><span class="keyword">class</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>&#x27;. <span class="title">This</span> <span class="title">is</span> <span class="title">deprecated</span>. <span class="title">The</span> <span class="title">new</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> `<span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span>&#x27;. <span class="title">The</span> <span class="title">driver</span> <span class="title">is</span> <span class="title">automatically</span> <span class="title">registered</span> <span class="title">via</span> <span class="title">the</span> <span class="title">SPI</span> <span class="title">and</span> <span class="title">manual</span> <span class="title">loading</span> <span class="title">of</span> <span class="title">the</span> <span class="title">driver</span> <span class="title">class</span> <span class="title">is</span> <span class="title">generally</span> <span class="title">unnecessary</span>.</span></span><br></pre></td></tr></table></figure>



<p>为什么要有线程上下文类加载器呢，这就与<strong>JVM类加载器双亲委托机制自身的缺陷有关。</strong></p>
<ul>
<li>jdk的核心库中提供了很多SPI （Service Provider Interface），常见的SPI 包括JDBC、JCE、JNDI、JAXP 和JBI 等，JDK只规定了这些接口之间的逻辑关系，但不提供具体的实现，具体的实现需要由 第三方厂商来提供，</li>
<li>作为Java程序员 都写过JDBC的程序，在编写JDBC程序时几乎百分之百的都在与 java.sql 包下的类打交道</li>
</ul>
<p>如下图所示，Java使用JDBC这个SPI 完全透明了 应用程序和第三方厂商数据库驱动的具体实现， 不管数据库类型如何切换，应用程序只需要替换JDBC 的驱动jar包以及数据库的驱动名称即可，而不用进行任何更新 。</p>
<p><img src="/uploads/java-concurrency-master/JDBC_SPI.png"></p>
<p>这样做的好处是：</p>
<ul>
<li>JDBC 提供了高度抽象，应用程序只需要面向接口编程即可，不用关心各大数据厂商的具体实现 。</li>
<li>但是问题在于 java.lang.sql 中的所有接口都是JDK 提供，<strong>加载这些接口的类加载器是 根加载器</strong>,  但是 <strong>第三方厂商提供的类库驱动 是由系统类加载器加载的，</strong></li>
<li>由于JVM 类加载器的双亲委托机制，比如 Connections、 Statement、 RowSet 等 都是由 <strong>根加载器加载</strong>，第三方的JDBC 驱动包中的实现不会被加载 。</li>
</ul>
<p>通过分析 Mysql数据库的源码，来看看是如果解决这个 接口与实现类的 加载器不一致的问题</p>
<h2 id="数据库驱动的初始化源码分析"><a href="#数据库驱动的初始化源码分析" class="headerlink" title="数据库驱动的初始化源码分析"></a>数据库驱动的初始化源码分析</h2><p>在编写所有的 JDBC程序时，首先都需要 调用Class.forName(“xxxx.xxxx.xxxx.Driver”)对数据库驱动进行加载，打开 Mysql驱动 Driver源码，代码如清单11-2 所示</p>
<h3 id="Driver源码"><a href="#Driver源码" class="headerlink" title="Driver源码"></a>Driver源码</h3><ul>
<li>这个时老版本的 （com.mysql.jdbc.Driver）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Backwards compatibility to support apps that call &lt;code&gt;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">mysql</span>.<span class="title">cj</span>.<span class="title">jdbc</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Loading class `com.mysql.jdbc.Driver&#x27;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver&#x27;. &quot;</span></span><br><span class="line">                + <span class="string">&quot;The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个是新版本的，推荐使用的（com.mysql.cj.jdbc.Driver）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 在Mysql 的静态方法中 将Driver 实例注册到DriverManager中 </span></span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     *             if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Driver类的静态代码块主要是 将Mysql 的Driver实例注册给 DriverManager，因此直接使用 DriverManager.registerDriver（new com.mysql.jdbc.Driver（））其作用与 Class.forName (“xxx.xxx.xxx.Driver”)是完全等价的 </li>
</ul>
<h3 id="DriverManager源码"><a href="#DriverManager源码" class="headerlink" title="DriverManager源码"></a>DriverManager源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//  Worker method called by the public getConnection() methods.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application&#x27;s</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 注释 1</span></span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//..................</span></span><br><span class="line"><span class="comment">// 注释 2</span></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">            <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">            <span class="comment">// skip it.</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">.。。。。。。。</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">        </span><br><span class="line"> <span class="comment">// 注释 3 </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDriverAllowed</span><span class="params">(Driver driver, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                aClass =  Class.forName(driver.getClass().getName(), <span class="keyword">true</span>, classLoader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             result = ( aClass == driver.getClass() ) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在注释1处 获取当前线程的上下文类加载器 ，该类就是调用Class.forName(“X”) 所在线程的线程上下文类加载器，通常是系统类加载器</li>
<li>注释2 中通过递归DriverManager 中已经注册的驱动类，然后验证 该数据库驱动 是否可以被指定的类加载器加载（线程上下文类加载器），如果验证通过，则返回Connection，此刻返回的 Connection 则是数据库厂商提供的实例</li>
<li>注释3 关键地方在于Class.forName(driver.getClass().getName(), true, classLoader);  其使用线程上下文类加载器及逆行数据库驱动的加载以及初始化  </li>
</ol>
<p>总结一下数据库驱动加载的整个过程，</p>
<ul>
<li>由于JDK 定义了SPI的标准接口，加之这些接口被作为 JDK 核心标准类库的一部分，既想要完全透明标准接口的实现，又想与JDK 核心库进行捆绑， 由于JVM 类加载器双亲委托机制的限制，启动类加载器不可能 加载得到第三方厂商提供的具体实现 。</li>
<li> 为了解决这一问题，JDK 只好提供一种不太优雅的设计-线程上下文类加载器 </li>
<li>有了线程上下文类加载器，启动类加载器（根加载器）反倒需要委托子类加载器去加载厂商提供的SPI 具体实现。父委托变成了子委托的方式</li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li><p>分析Mysql驱动加载过程的源码，清晰地理解线程上下文加载器所发挥地作用了 </p>
</li>
<li><p>在Thread 类中增加 getContextClassLoader() 和 setContextClassLoader（ClassLoader cl）方法实属无奈之举，它不仅破坏了类加载器地父委托机制，而且反其道行之，允许“子委托机制”，</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">java高并发详解-10-JVM类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-01 22:46:10" itemprop="dateCreated datePublished" datetime="2021-03-01T22:46:10+08:00">2021-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/01/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-10-JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM类加载器"><a href="#JVM类加载器" class="headerlink" title="JVM类加载器"></a>JVM类加载器</h1><ul>
<li>类加载器就是负责类的加载的职责，对于任意一个class，都需要由加载它的类加载器和这个类本身确立其在JVM中的唯一性，这也就是 运行时包</li>
<li>任何一个对象的class 在JVM中只存在唯一的一份，比如 String.class 、Object.class 在堆内存以及方法区中肯定是唯一的 。</li>
<li>但是绝不可以理解为我们自定义的类 在JVM中同样也是这样。</li>
</ul>
<h2 id="JVM内置三大类加载器"><a href="#JVM内置三大类加载器" class="headerlink" title="JVM内置三大类加载器"></a>JVM内置三大类加载器</h2><ul>
<li>JVM为我们提供了 三大内置的类加载器，不同的类加载器负责 将不同的类加载到JVM 内存之中，并且他们之间严格遵守着父委托的机制 </li>
</ul>
<p><img src="/uploads/java-concurrency-master/CLassLoader-father.png"></p>
<h2 id="根类加载器介绍"><a href="#根类加载器介绍" class="headerlink" title="根类加载器介绍"></a>根类加载器介绍</h2><p>根加载器又称为 Bootstrap类加载器，该类加载器是最为顶层的加载器，其没有任何父加载器，它是由 根加载器 所加载的，可以通过 -Xbootclasspath 来指定根加载器 的路径，也 可以通过系统属性来得知当前JVM 的根加载器都加载了哪些资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootStrapClassLoader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bootstrap:&quot;</span> + String.class.getClassLoader());</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果:</span><br><span class="line">Bootstrap:<span class="keyword">null</span></span><br><span class="line">D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\resources.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\rt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\sunrsasign.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jsse.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jce.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\charsets.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfr.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\classes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="扩展类加载器介绍"><a href="#扩展类加载器介绍" class="headerlink" title="扩展类加载器介绍"></a>扩展类加载器介绍</h2><p>扩展类加载器的父加载器是根加载器，它主要用于加载 JAVA_HOME下的 jre\lib\ext 子目录里面的类库。扩展类加载器是由纯java语言实现的，它是 java.lang.URLClassLoader的子类，它的完整类名 是 sun.misc.Launcher$ExtClassLoader。扩展类加载器所加载的类库 可以通过系统属性 java.ext.dirs获得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">//        Class&lt;?&gt; helloClass = Class.forName(&quot;Hello&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(helloClass.getClassLoader());</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果： D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext;C:\Windows\Sun\Java\lib\ext</span><br></pre></td></tr></table></figure>

<h2 id="系统类加载器介绍"><a href="#系统类加载器介绍" class="headerlink" title="系统类加载器介绍"></a>系统类加载器介绍</h2><p>系统类加载器是一种常见的类加载器，其负责加载 classpath下的类库资源。我们在进行项目开发的时候引入的第三方jar包，<strong>系统类加载器的父类加载器 是扩展类加载器，同时它也是自定义类加载器的默认父加载器，</strong>  系统类加载器的加载路径一般通过 -classpath 或者 -cp指定，同样的也可以通过系统属性 java.class.path进行获取，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">        System.out.println(ApplicationClassLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line">    D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\charsets.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\deploy.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\access-bridge-<span class="number">64.</span>jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\cldrdata.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\dnsns.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\jaccess.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\jfxrt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\localedata.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\nashorn.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunec.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunjce_provider.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunmscapi.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\sunpkcs11.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\ext\zipfs.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\javaws.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jce.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfr.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jfxswt.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\jsse.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\management-agent.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\plugin.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\resources.jar;D:\Java\Java8\jdk1.<span class="number">8.0</span>\jre\lib\rt.jar;H:\pdf\java-concurrency-master\java-concurrency-master\book\target\classes;C:\Users\yinshi\.m2\repository\mysql\mysql-connector-java\<span class="number">6.0</span>.<span class="number">6</span>\mysql-connector-java-<span class="number">6.0</span>.<span class="number">6.</span>jar;D:\Program Files\JetBrains\IntelliJ IDEA <span class="number">2020.1</span>.<span class="number">3</span>\lib\idea_rt.jar</span><br><span class="line"></span><br><span class="line">        sun.misc.Launcher$AppClassLoader@<span class="number">14d</span>ad5dc</span><br></pre></td></tr></table></figure>

<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p>用程序实现自定义的类加载器，所有的自定义类加载都是ClassLoader的直接子类或者间接子类，java.lang.ClassLoader是一个抽象类，它里面并没有抽象方法，但是又findClass 方法，务必实现该方法，否则将会抛出 Class找不到的异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义类加载器必须是ClassLoader 的直接或者间接子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义默认的class 存放路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Path DEFAULT_CLASS_DIR = Paths.get(<span class="string">&quot;H:\\pdf\\java-concurrency-master\\java-concurrency-master\\book\\target\\classes\\com\\wangwenjun\\concurrent\\chapter10&quot;</span></span><br><span class="line">            , <span class="string">&quot;classloader1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path classDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认的class路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = DEFAULT_CLASS_DIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许传入指定的class路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定class路径的同时，指定父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classDir, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写父类的findClass 方法，这个是至关重要的step</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 读取class 的二进制数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">this</span>.readClassBytes(name);</span><br><span class="line">        <span class="comment">//如果数据为null，或者没有读到任何信息，则抛出 ClassNotFoundException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Can not load the class &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用defineClass 方法定义class（）</span></span><br><span class="line">        <span class="comment">//name 定义类的名字</span></span><br><span class="line">        <span class="comment">// classBytes class文件的二进制字节数组</span></span><br><span class="line">        <span class="comment">// 字节数组的偏移量</span></span><br><span class="line">        <span class="comment">// 从偏移量开始读取多长的byte数据</span></span><br><span class="line">        <span class="comment">// 问题： 第一个 阶段的加载主要是获取class的字节流信息，那么我们将整个字节流信息交给defineClass不就行 了吗，为什么还要指定偏移量和读取长度呢：</span></span><br><span class="line">        <span class="comment">// 因为class字节数组不一定是从一个class文件中获得的，有可能是来自网络的，也有可能是来自网络或者其他途径。</span></span><br><span class="line">        <span class="comment">//由此可见一个字节数组中很有可能存储多个class的字节信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将class文件读入内存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClassBytes(String name)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 将包名分隔符 转换为分拣路径分隔符</span></span><br><span class="line">        String classPath = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Path classFullPath = classDir.resolve(Paths.get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!classFullPath.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Files.copy(classFullPath, baos);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;load the class &quot;</span> + name + <span class="string">&quot; occur error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My ClassLoader&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个构造函数使用默认的文件路径</li>
<li>第二个构造函数允许外部指定一个特定的磁盘目录</li>
<li>第三个构造函数除了可以指定磁盘目录外，还可以指定该类加载的父加载器</li>
</ul>
<p>全路径格式有以下几种情况：</p>
<ul>
<li>java.lang.String:     包名.类名</li>
<li>javax.swing.JSpinner $DefaultEditor: 包名.类名 $内部类</li>
<li>java.security.KeyStor$Builder$FileBuilder$1 :包名.类名 $内部类 $内部类$匿名内部类</li>
<li>java.net.URLClassLoader$3$1: 包名.类名 $内部类$匿名内部类</li>
</ul>
<p>强调defineClass 方法，该方法的完整方法描述是  defineClass(String name, byte[] b, int off, int len) </p>
<ul>
<li>其中第一个是要定义类的名字，一般与findClass 方法中的类名保持一致即可</li>
<li>第二个是 class文件的二进制字节数组，</li>
<li>第三个是字节数组的偏移量</li>
<li>第4个是从偏移量开始读取多长的byte数据</li>
</ul>
<h2 id="双亲委托机制详细介绍"><a href="#双亲委托机制详细介绍" class="headerlink" title="双亲委托机制详细介绍"></a>双亲委托机制详细介绍</h2><ul>
<li>当一个类加载器被调用了loadClass之后，它并不会直接将其加载，而是先交给当前类加载器的 父加载器尝试加载直到最顶层的父加载器，然后一次向下进行加载。</li>
</ul>
<p><img src="/uploads/java-concurrency-master/classLoaderOfFather.png"></p>
<p>在解析loadClass 源码之前，思考一个问题，由于担心HelloWorld.class 被系统类加载器加载，所以删除了HelloWorld 的相关文件，那么有什么办法可以不用删除又可以使用 MyClassLoader对HelloWorld 进行加载的吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">     <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码片段是 java.lang.ClassLoader 的loadClass（name）和 loadClass（name，resolve）方法，由于loadClass （name）调用的是 loadClass（name，false），因此我们重点解释  loadClass（name，false）即可</p>
<ul>
<li>从当前类加载器的已加载类缓存中根据类的全路径名查询是否存在该类， 如果存在则直接返回 </li>
<li>如果当前类存在父类加载器，则 调用父类加载器的loadClass （name,false） 方法对其 进行加载</li>
<li>如果当前类加载不存在父类加载器，则直接调用根类加载器 对该类进行加载</li>
<li>如果 当前类的所有父类加载器都没有成功加载class ，则尝试 调用当前类加载器的 findClass 方法对其进行加载，该方法就是我们自定义加载器需要重写的方法</li>
<li>最后如果类被成功加载，则做一些性能数据的统计 </li>
<li>由于loadClass 指定了revolve 为false，所以不会 进行连接阶段的继续执行 ，这也就解释了  为什么通过类加载器 加载类并不会导致类的初始化</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如何在不删除HelloWorld.class 文件的情况下 使用MyClassLoader 而不是系统类加载器进行HelloWorld 的加载，有如下两种方法可以做到。</p>
<ol>
<li>第一种方式 是绕过系统类加载器，直接将扩展类加载器 作为MyClassLoader 的父加载器，示例 代码如下： </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader extClassloader = MyClassLoaderTest.class.getClassLoader().getParent();</span><br><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classLoader1&quot;</span>,extClassloader);</span><br><span class="line">Class&lt;?&gt; aclass=classLoader.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.HelloWorld&quot;</span>);</span><br><span class="line">System.out.println(aClass);</span><br><span class="line">System.out.println(aClass.getClassLoader());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>首先我们通过MyClassLoaderTest.class 获取系统类加载器，然后再获取系统类加载器的父类加载器 扩展类加载器，使其成为MyClassLoader的父类加载器，这样一来，根加载器和扩展类加载器都无法对 G:\ classloader 类文件进行加载，自然而然就交给了MyClassLoader 对 HelloWorld 进行加载了，这种方式充分利用了类加载器 父类委托机制的特性</li>
</ul>
<ol start="2">
<li> 第二种方式实在构造 MyClassLoader 的时候指定其父类加载器为null ，示例代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader classLoader=<span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">Class&lt;?&gt; aclass=classLoader.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.HelloWorld&quot;</span>);</span><br><span class="line">System.out.println(aClass);</span><br><span class="line">System.out.println(aClass.getClassLoader());</span><br><span class="line"></span><br><span class="line">根据对 loadClass方法的源码分析，当前类在没有父类加载器的情况下，会直接使用根加载器对该类进行加载 ，很显然，HelloWorld 在根加载器的加载路径下 是无法找到的，那么它 自然而然地就交给当前类加载器进行加载了</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="破坏双亲委托机制"><a href="#破坏双亲委托机制" class="headerlink" title="破坏双亲委托机制"></a>破坏双亲委托机制</h2><ul>
<li>我们发现类加载器的父委托机制的逻辑 主要是由loadClass来控制的，有些时候我们需要打破这种双亲委托的机制，比如 HelloWorld 这个类就是不希望通过系统类加载器对其进行加载。</li>
<li>JDk 提供的双亲委托机制并非一个强制性的模型，程序开发人员是可以对其进行 灵活发挥破坏这种委托机制的 </li>
</ul>
<p>比如： 如果我们想要在程序运行时进行某个模块功能的升级，甚至是 在不停止服务的前提下增加新的功能，这就是我们常说的热部署。</p>
<ul>
<li>热部署首先要卸载掉加载该模块所有Class的类加载器，卸载类加载器会导致所有类的卸载，</li>
<li>很显然我们无法对JVM 三大内置加载器进行卸载，我们只有通过控制 自定义类加载器才能做到这一点 </li>
</ul>
<p>我们可以通过破坏父委托机制的方式 来实现对HelloWorld类的加载，而不需要在工程中删除该文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerDelegateClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Path DEFAULT_CLASS_DIR = Paths.get(<span class="string">&quot;G:&quot;</span>, <span class="string">&quot;classloader1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path classDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = DEFAULT_CLASS_DIR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">(String classDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrokerDelegateClassLoader</span><span class="params">(String classDir, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classBytes = <span class="keyword">this</span>.readClassBytes(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == classBytes || classBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Can not load the class &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1. 根据类的全路径名称进行加锁，确保每一个类在多线程 的情况下制备加载一次 </span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">//2. 到已加载类的缓存中查看该类是否已经被加载，如果已加载则直接返回</span></span><br><span class="line">            Class&lt;?&gt; klass = findLoadedClass(name);</span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">if</span> (klass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4. 假如缓存中没有被加载的类，则需要对其进行首次加载，如果类的全路径以java和javax开头，则直接委托给 系统类加载器对其进行加载 </span></span><br><span class="line">                <span class="keyword">if</span> (name.startsWith(<span class="string">&quot;java.&quot;</span>) || name.startsWith(<span class="string">&quot;javax&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        klass = getSystemClassLoader().loadClass(name);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 5. 如果类不是以java 和javax 开头，则尝试用我们自定义的类加载进行加载 </span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        klass = <span class="keyword">this</span>.findClass(name);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 6. 如果 自定义类加载仍旧 没有完成对类的加载，则委托 给其父类加载器进行加载或者系统类加载器进行加载 </span></span><br><span class="line">                    <span class="keyword">if</span> (klass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getParent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            klass = getParent().loadClass(name);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            klass = getSystemClassLoader().loadClass(name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7. 经过诺干次的尝试后，如果还是无法对类进行加载，则抛出无法找到类的异常 </span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == klass) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(klass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> klass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] readClassBytes(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String classPath = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Path classFullPath = classDir.resolve(Paths.get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!classFullPath.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">            Files.copy(classFullPath, baos);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;load the class &quot;</span> + name + <span class="string">&quot; occur error.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Broker Delegate ClassLoader&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类加载器命名空间、运行时包、类的卸载等"><a href="#类加载器命名空间、运行时包、类的卸载等" class="headerlink" title="类加载器命名空间、运行时包、类的卸载等"></a>类加载器命名空间、运行时包、类的卸载等</h2><h3 id="1-类的命名空间"><a href="#1-类的命名空间" class="headerlink" title="1.类的命名空间"></a>1.类的命名空间</h3><p>每一个类加载器都有各自的命名空间，命名空间时由该加载器及其所有父加载器所构成的，因此在每一个类加载器中同一个class 都是独一无二的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">       MyClassLoader classLoader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">       MyClassLoader classLoader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">&quot;G:\\classloader1&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">       Class&lt;?&gt; aClass = classLoader1.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.Test&quot;</span>);</span><br><span class="line">       Class&lt;?&gt; bClass = classLoader2.loadClass(<span class="string">&quot;com.wangwenjun.concurrent.chapter10.Test&quot;</span>);</span><br><span class="line">       System.out.println(aClass.getClassLoader());</span><br><span class="line">       System.out.println(bClass.getClassLoader());</span><br><span class="line">       System.out.println(aClass.hashCode());</span><br><span class="line">       System.out.println(bClass.hashCode());</span><br><span class="line">       System.out.println(aClass == bClass);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的代码，不论load多少次Test，都会发现他们始终时同一份class对象，这也完全符合我们在本书9.1节中的描述。 类被加载后的内存情况如图所示：</p>
<p><img src="/uploads/java-concurrency-master/classAfterLoader.png"></p>
<ul>
<li>但是，使用不同的类加载器，或者同一个类加载器的不同示例，去加载同一个class，则会在堆内存和方法区产生多个class对象 </li>
</ul>
<p>（1） 不同类加载器加载同一个class，输出的结果显示aclass 和 bclass不是同一个class示例 </p>
<p>（2）相同类加载器加载同一个class,输出的结果显示aclass 和 bclass不是同一个class示例 </p>
<p>分析JDK 中关于ClassLoader 的相关源代码，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            。。。</span><br><span class="line">                </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在类加载器进行类加载的时候，首先会到  加载记录表也就是缓存中，查看该类是否已经被加载过了，如果已经被加载过了，就不会重复加载，否则就会认为其是 首次加载， 下图就是同一个class 被不同类加载器加载之后的内存i情况 。</p>
<p><img src="/uploads/java-concurrency-master/differentClassLoaderLoadClass.png"></p>
<p>同一个class示例在同一个类加载器命名空间之下是唯一的。</p>
<h3 id="2-运行时包"><a href="#2-运行时包" class="headerlink" title="2. 运行时包"></a>2. 运行时包</h3><ul>
<li>我们在编写代码的时候，通常会给一个类指定一个包名，包的作用是为了组织类，防止不同包下同样名称的class 引起冲突，还能起到封装的作用，包名和类名构成了类的全限定名称。</li>
<li>在JVM运行时，class会由一个运行时包，<strong>运行时的包是类加载器的命名空间和类的全限定名称共同组成的</strong>。 例如:BootstrapClassLoader.ExtClassLoader.AppClassLoader.MyClassLoader.com.wangwenjun.concurrent.chapter10.Test</li>
<li>这样做的好处同样是 处于安全和封装的考虑，在java.lang.String中存在仅包可见的方法 void getChars（char[] var1,int var2），java.lang包以外的class 是无法直接对其访问的。  假设用户想自己定义一个类 java.lang.HackString。并且由自定义的类加载器进行加载，尝试访问getChars方法，由于 java.lang.HackString 和 java.lang.String是由不同的类加载器进行加载的，它们拥有各自不同的运行时包，因此 HackString 是无法访问java.lang.String 的包可见方法以及成员变量的 </li>
</ul>
<h3 id="3-初始化类加载器"><a href="#3-初始化类加载器" class="headerlink" title="3.初始化类加载器"></a>3.初始化类加载器</h3><p>由于运行时包的存在，JVM 规定了不同的运行时包下的类 彼此之间是不可以进行访问的。那么问题来了，为什么我们在开发的程序中可以访问java.lang包下的类呢。 我们直到java.lang包 是由根加载器进行加载的，而我们开发的程序或者第三方类库一般是 由系统类加载器进行加载的。</p>
<h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>每一个类在经过ClassLoader 的加载之后，在虚拟机中都会 有对应的Class 实例，如果某个类C 被类加载器CL 加载，那么CL 就被成为C的初始类加载器。 </p>
<p>JVM 为每一个类加载器维护了一个列表，该列表中记录了 将该类加载器作为初始类加载器的所有class ，在加载一个类时，JVM 使用这些列表来判断该类是否已经被加载过了，是否需要首次加载 。</p>
<ul>
<li>根据JVM规范的规定，在类的加载过程中，所有 参与的类加载器，即使没有亲自记载过该类，也会被标识为该类的初始类加载器，比如 java.lang.String首先经过了 BrokerDelegateClassLoader类加载器，一次又经过了 系统类加载器、扩展类加载器、根类加载器，这些类加载器都是java.lang.String 的初始类加载器，JVM会在每一个类加载器维护的列表中添加该 class 类型，如下图所示。</li>
</ul>
<p><img src="/uploads/java-concurrency-master/InitClassLoaderWithClassList.png"></p>
<p>虽然SimpleClass 和 java.lang.String 由不同的类加载器加载，但是 在BrokerDelegate-Class Loader的class列表中维护了 SimpleClass.class  和String.class ，因此在SimpleClass中 是可以正常访问 rt.jar 中的class 的</p>
<h3 id="4-类的卸载"><a href="#4-类的卸载" class="headerlink" title="4.类的卸载"></a>4.类的卸载</h3><ul>
<li>在jvm启动的过程中，jvm会加载很多的类，在运行期间同样会加载很多的类，比如用自定义的类加载器进行类的加载，或者像Apache Drools框架一样会在每一个DSL 文件解析成功之后生成相应的类文件。</li>
<li>关于JVM在运行期间到底加载了多少class，可以在启动JVM时 指定 -verbose：class 参数观察到，我们直到某个对象在堆内存中如果没有其他地方引用则会在垃圾回收器 线程进程GC的时候被回收掉，那么该对象在堆内存中的Class 对象以及Class 在方法区中的数据结构何时被回收呢?</li>
<li>JVM规定一个Class只有在满足下面三个条件的时候才会被GC回收，也就是类被卸载<ol>
<li>该类所有的实例都已经被GC ，比如SImple.class 的所有Simple实例都被回收掉</li>
<li>加载该类的ClassLoader实例被回收</li>
<li>该类的class实例 没有在其他地方被引用</li>
</ol>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>唉，为情所困，脑子都要炸了，这篇记录拖得太久了，<ol>
<li>介绍了JVM 内置的3大类加载器（根类加载器，扩展类加载器，系统类加载器）</li>
<li>通过继承ClassLoader重写findClass方法自定义了MyClassLoader，</li>
<li>通过堆loadClass方法的源码剖析详细分析了双亲委托机制的原理，双亲委托机制时一种包含关系，而并非继承关系。</li>
<li> 自定义一个与java.lang.String 同名的String类 ，但是JVM不允许这样做，会在JVM 的defineClass的时候做安全性检查。</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">java高并发详解-09-类的加载过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-25 22:29:27" itemprop="dateCreated datePublished" datetime="2021-02-25T22:29:27+08:00">2021-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/25/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-09-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>ClassLoader的主要职责是负责加载各种class文件到JVM中</li>
<li>ClassLoader是一个抽象的class ，给定一个class 的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存区域中</li>
</ul>
<h1 id="类的加载过程简介"><a href="#类的加载过程简介" class="headerlink" title="类的加载过程简介"></a>类的加载过程简介</h1><p>类的加载过程一般分为3个比较大的阶段，分别是 <strong>加载阶段、连接阶段、初始化阶段，</strong></p>
<p><img src="/uploads/java-concurrency-master/loadClassStep.png"></p>
<ul>
<li>加载阶段： 主要负责查找并加载类的二进制数据文件，其实就是class文件</li>
<li>连接阶段： 这个阶段所做的工作比较多，细分的话还可以分为以下3个阶段<ul>
<li>验证： 主要是确保类文件的正确性，比如class的版本，class文件的魔术因子是否正确</li>
<li>准备： 为类的静态变量分配内存，并且为其初始化默认值</li>
<li>解析： 把类中的符号引用转换为 直接引用</li>
</ul>
</li>
<li>初始化阶段： 为类的静态变量赋予正确的初始值 （代码编写阶段给定的值，也就是程序员的代码赋的值）</li>
</ul>
<p>当一个JVM在我们通过执行Java 命令启动后，其中可能包含的类非常多，并不是每个类都会被初始化。</p>
<ul>
<li>JVM对类的初始化时一个延迟的机制，即 ：使用的时 lazy的方式，当一个类在首次使用的时候才会被 初始化，同一个运行时包下，一个Class 只会被初始化一次 （运行时包和类的包是有区别的）</li>
</ul>
<h1 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h1><p>jvm虚拟机规范规定了，每个类或者接口被Java程序首次主动使用时，才会对其进行初始化。</p>
<h2 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h2><p>(下面的例子有问题，main方法应该写在别的类里面，因为main方法会导致类初始化)</p>
<p>jvm同时规范了以下6种主动使用类的场景，具体如下</p>
<ol>
<li><p>通过new 关键字会导致类的初始化： 这种是我们经常采用的初始化一个类的方式，它肯定会导致类的加载并且最终初始化。</p>
</li>
<li><p><strong>访问类的静态变量</strong>，包括读取和更新会导致类的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    I will be initialized</span><br><span class="line">	<span class="number">10</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>访问类的静态方法</strong>，会导致类的初始化 </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">       <span class="comment">// System.out.println(x);</span></span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    I will be initialized</span><br><span class="line">test execute</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>对某个类进行反射操作，会导致类的初始化 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// Simple[] simples = new Simple[10];</span></span><br><span class="line">       <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//        test();</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">I will be initialized</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>初始化子类会导致父类的初始化 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The parent is initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The child will be initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line">        System.out.println(Child.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    ActiveLoadTest test</span><br><span class="line">The parent is initialized</span><br><span class="line">The child will be initialized</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在测试类中调用了Child的静态变量，会使得Child被初始化，Child又是 Parent的子类， 子类的初始化会导致父类的初始化</p>
</li>
<li><p>需要注意的一点是，如果<strong>通过子类使用父类的 静态变量（输出Child.y）只会导致父类的初始化，子类则不会被初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line">        System.out.println(Child.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    </span><br><span class="line">ActiveLoadTest test</span><br><span class="line">The parent is initialized</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>启动类： 也就是执行main函数所在的类会导致该类的初始化， 比如使用java命令运行上文中的ActiveLoadTest类</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h2><p>除了上面的6种情况，其余的都称为被动使用，不会导致类的加载和初始化</p>
<ol>
<li><p>构造某个类的数组时，并不会导致该类的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ActiveLoadTest test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.MAX);</span></span><br><span class="line"><span class="comment">//        System.out.println(GlobalConstants.RANDOM);</span></span><br><span class="line"><span class="comment">//        System.out.println(Child.y);</span></span><br><span class="line"></span><br><span class="line">        Simple[] simples = <span class="keyword">new</span> Simple[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//        System.out.println(simples);</span></span><br><span class="line">        <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//            test();</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li> 引用<strong>类的静态常量</strong>不会导致类的初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The GlobalConstants will be initialized.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在其他类中使用 MAX 不会导致 GlobalConstants的初始化，静态代码块不会输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 虽然 RANDOM 是静态常量，但是由于计算复杂，只有初始化之后才能得到记过，因此在其他类中使用 RANDOM 会导致 GlobalConstants的初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RANDOM = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">        System.out.println(simples.length);*/</span></span><br><span class="line"></span><br><span class="line">        System.out.println(GlobalConstants.MAX);</span><br><span class="line">        System.out.println(GlobalConstants.RANDOM);</span><br><span class="line"><span class="comment">//        System.out.println(Child.y);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Simple[] simples = new Simple[10];</span></span><br><span class="line"><span class="comment">//        System.out.println(simples);</span></span><br><span class="line">        <span class="comment">// System.out.println(x);</span></span><br><span class="line"><span class="comment">//            test();</span></span><br><span class="line"><span class="comment">//        Class.forName(&quot;com.wangwenjun.concurrent.chapter09.Simple&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    ActiveLoadTest test</span><br><span class="line"><span class="number">100</span></span><br><span class="line">The GlobalConstants will be initialized.</span><br><span class="line"><span class="number">1357034692</span></span><br></pre></td></tr></table></figure>



<h1 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h1><h2 id="类的加载阶段"><a href="#类的加载阶段" class="headerlink" title="类的加载阶段"></a>类的加载阶段</h2><p>类的加载就是将class文件中的二进制数据读取到内存之中，然后将该字节流所代表的静态存储结构转换为方法区中 运行的数据结构，并且在堆内存中生成一个该类的 java.lang.Class 对象，作为访问方法区数据结构的入口。</p>
<p><img src="/uploads/java-concurrency-master/afterCLassLoader.png"></p>
<ul>
<li>类加载的最终产物就是堆内存中的class对象，对同一个ClassLoader来讲，不管某个类被加载了多少次，对应到堆内存中的class对象始终是同一个。</li>
<li>虚拟机规范中指出了类的加载是通过一个<strong>全限定名（包名+类名）</strong>来获取二进制数据流，</li>
<li>但是并没有限定必须通过某种方式去获得，例如常见的是  <strong>class二进制文件的形式</strong><ul>
<li>运行时动态生成，比如通过动态代理 java.lang.Proxy也可以生成代理类的二进制字节流</li>
<li>通过网络获取</li>
<li>通过读取zip文件获得类的二进制字节流，比如jar 、war</li>
<li>将类的二进制数据存储在数据库的BLOB字段类型中</li>
<li>运行时生成class文件，并且动态加载</li>
</ul>
</li>
<li>在某个类完成加载阶段之后，虚拟机会<strong>将这些二进制字节流按照虚拟机所需的格式存储在<em>方法区</em>中</strong>，然后形成特定的数据结构，随之<strong>又在堆内存中实例化一个 java.lang.Class类对象，</strong>在类加载的整个生命周期中，加载过程还没有结束，连接阶段是可以交叉工作的，比如连接阶段验证字节流信息的合法性。</li>
</ul>
<h2 id="类的连接阶段"><a href="#类的连接阶段" class="headerlink" title="类的连接阶段"></a>类的连接阶段</h2><p>类的连接阶段可以细分为3个小的过程，分别是<strong>验证、准备和解析</strong></p>
<h3 id="1-验证"><a href="#1-验证" class="headerlink" title="1.验证"></a>1.验证</h3><p>验证在连接阶段的主要目的是：  <strong>确保class文件的字节流所包含的内存符合当前JVM的规范要求，并且不会危害JVM 自身安全的代码</strong>，当字节流信息不符合要求时，则会抛出 VerifyError 这样的异常或者时子异常。</p>
<ul>
<li>验证文件格式（例如魔术因子 0xCAFEBABE, 主次版本号）</li>
<li>元数据的验证<ul>
<li>元数据的验证其实是对class的字节流进行语义分析的过程，确保class字节流符合JVM规范的要求</li>
<li>检查当前类是否存在父类，是否继承了某个接口，这些父类和接口是否合法</li>
<li>检查该类是否继承了被final修饰的类，被final修饰的类是不允许被继承并且其中的方法是不允许被 override的</li>
<li>检查该类是否为抽象类，如果不是抽象类，是否实现了父类的抽象方法或者接口中的所有方法</li>
<li>检查方法重载的合法性，比如相同的方法名称、相同的参数，但是返回类型不同，这都是不被允许的</li>
</ul>
</li>
<li>字节码验证<ul>
<li>主要是验证程序的控制流程，比如循环、分支。比如： 类型转换是否合法 ，程序计数器的指令不会跳转到不合法的字节码指令中去</li>
</ul>
</li>
<li>符号引用的验证<ul>
<li>验证符号引用转换为直接引用时的合法性</li>
<li>通过符号引用描述的字符串全限定名称是否能够顺利的找到相关的类</li>
<li>符号引用的类、字段、方法，是否能对当前类可见，比如不能访问引用类的私有方法</li>
<li>符号引用验证的目的是： 为了保证解析动作的顺利进行，比如某个类的字段不存在，则会抛出NoSuchFieldError ，若方法不存在 则抛出 NoSuchMethodError等，我们在使用反射的时候，会遇到这样的异常信息</li>
</ul>
</li>
</ul>
<h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h3><p>当一个class字节流通过了所有的验证过程后，就开始为该对象的类变量（静态变量）分配内存并设置初始值了。 </p>
<p>注意： <strong>类变量的内存会被分配到方法区中，</strong> 不同于实例变量会被分配到对内存中 。</p>
<ul>
<li>所谓的设置初始值，其实就是为相应的类变量 给定一个相关类型在没有设置值时的默认值，不同的数据类型以及其 初始值为：</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>（byte）0</td>
</tr>
<tr>
<td>Char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>Short</td>
<td>(short)0</td>
</tr>
<tr>
<td>Int</td>
<td>0</td>
</tr>
<tr>
<td>Float</td>
<td>0.0F</td>
</tr>
<tr>
<td>Double</td>
<td>0.0D</td>
</tr>
<tr>
<td>Long</td>
<td>0L</td>
</tr>
<tr>
<td>Boolean</td>
<td>False</td>
</tr>
<tr>
<td>引用类型</td>
<td>null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedPrepate</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> b=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>static int a=10,在准备阶段值为 初始值0，</li>
<li>final static int b则为10 ，因为在类的编译阶段javac 会将其Value 生成一个 ConstantValue属性，直接赋予10.</li>
</ul>
<h3 id="3-解析（TODO）"><a href="#3-解析（TODO）" class="headerlink" title="3.解析（TODO）"></a>3.解析（TODO）</h3><p>在连接阶段中经历了验证、准备之后，就可以顺利进入到解析过程了，当然在解析的过程中照样会交叉一些验证的过程，</p>
<ul>
<li>比如符号引用的验证，</li>
</ul>
<p>所谓解析就是在常量池中寻找类、接口、字段和方法的符号引用，并且将这些符号引用替换为直接引用的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassResolve</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Simple simple=<span class="keyword">new</span> Simple();</span><br><span class="line">    <span class="function">pulbic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(simple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机规范规定了，在anewarray，checkcast、getfield、getstatic，instanceof，invokeinterface，invokespecial、invokevirtual，multianewarray、new、putfiled、putstatic 这13个 操作符号引用的字节码指令之前，必须要对所有的符号提前进行解析 。</p>
<p>解析过程主要是 针对类接口、字段、类方法和接口方法这4类进行的，分别对应到常量池中的CONSTANT_Class_info、 Constant_Filldref_info、Constant_Methodref_info 和 Constant_InterfaceMethodref_info 这4中类型常量 。</p>
<h4 id="类接口解析"><a href="#类接口解析" class="headerlink" title="类接口解析"></a>类接口解析</h4><ul>
<li>假设前文代码中的Simple ，不是一个数组类型，则在加载的过程中，需要先完成对SImple 类的加载，同样需要经历所有的类加载阶段</li>
<li>如果SImple是一个数组类型，则虚拟机不需要完成对 SImple 的加载，只需要在虚拟机中生成一个能够代表该类型的数组对象，并且在堆内存中开辟一片连续的地址空间即可</li>
<li>在类接口的解析完成之后，还需要进行符号引用的验证</li>
</ul>
<h4 id="字段的解析"><a href="#字段的解析" class="headerlink" title="字段的解析"></a>字段的解析</h4><p>所谓字段的解析，就是解析你所访问类或者接口中的字段，在解析类或者变量的时候，如果该字段不存在，或者出现错误，则会抛出异常，不再进行下面的解析。</p>
<ul>
<li>如果Simple类本身就包含某个字段，则直接返回这个字段的引用，当然也要对该字段所属的类提前进行类加载</li>
<li>如果Simple 类中不存在该字段，则会根据继承关系自下而上，查找父类或者接口的字段，找到即可返回，同样需要提前对找到的字段进行类的加载过程 。</li>
<li>如果SImple类中没有字段，一直找到了最上层的java.lang.Object 还是没有，则表示 查找失败，也就不再进行任何解析，直接抛出了NoSuchFieldError 异常</li>
</ul>
<h4 id="类方法的解析"><a href="#类方法的解析" class="headerlink" title="类方法的解析"></a>类方法的解析</h4><p>类方法和接口方法有所不同，类方法可以直接使用该类进行调用，而接口方法必须要有相应的实现类继承才能够进行调用 。</p>
<ul>
<li>若在类方法表中发现class_index 中索引的Simple 是一个接口而不是一个类，则 直接返回错误</li>
<li>在SImple类中查找是否有方法描述和目标方法完全一致的方法，如果有，则直接返回这个方法的引用，否则直接继续向上查找。</li>
<li>如果父类中仍然没有找到，则意味着查找失败，程序会抛出NoSuchMethodError 异常</li>
<li>如果在当前类或者父类中找到了和目标方法一致的方法，但是它是一个抽象类，则会抛出AbstractMethodError 这个异常</li>
</ul>
<h4 id="接口方法的解析"><a href="#接口方法的解析" class="headerlink" title="接口方法的解析"></a>接口方法的解析</h4><p>接口不仅可以定义方法，还可以继承其他接口</p>
<ul>
<li>在接口方法表中发现 class_index 中索引的Simple是一个类而不是一个接口，则会直接 返回错误，因为方法接口表 和类接口表 所容纳的类型应该是 不一样的，所以常量池 中有 Constant_Methodref_info 和 Constant_InterfaceMethodref_info 两个不同的类型 </li>
<li>接下来的查找 和类方法的解析就比较类似了，自下而上的查找，直到找到为止，或者没找到 抛出NoSuchMethodError 异常 。</li>
</ul>
<h3 id="类的初始化阶段"><a href="#类的初始化阶段" class="headerlink" title="类的初始化阶段"></a>类的初始化阶段</h3><p>类的初始化阶段是整个类加载过程的最后一个阶段</p>
<ul>
<li>在初始化阶段做的最主要的一件事情就是执行 <clinit> () 方法中所有的类变量都会被 赋予正确的值，也就是在程序编写的时候指定的值 </li>
<li> <clinit> () 方法 实在编译阶段生成的，也就是说它 已经包含在 class文件中了，<clinit>中包含了所有类变量的赋值动作和静态语句块的执行代码 ，</li>
<li>编译器收集的顺序是 由执行语句在源文件中的出现顺序所决定的 （<clinit> 是能够保证顺序性）</li>
<li>静态 语句块只能对后面的静态变量进行赋值，但是 不能对其进行访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">static</span>&#123;</span><br><span class="line">         <span class="comment">// 静态代码块 只能对后面的静态变量进行赋值，但是不能对其访问 </span></span><br><span class="line">        System.out.println(x);<span class="comment">// 报错，Illegal forward reference </span></span><br><span class="line">        <span class="comment">//  </span></span><br><span class="line">        x=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外<clinit> 方法与类的构造函数有所不同，它不需要显示的调用父类的 构造器，虚拟机会保证父类的 <clinit>方法最先执行，因此父类的静态变量总是能够得到优先赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            value = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类使用父类的静态变量为自己的静态变量赋值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出的是： <span class="number">20</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟机会保证父类的 <clinit>方法最先执行，因此父类的静态变量总是 能够得到优先赋值  </li>
<li><clinit>() 方法虽然是真实存在的，但是它 只能被虚拟机执行，在主动使用触发了类的初始化之后就会调用这个方法  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInit</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The ClassInit static code block will be invoke.&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">                .forEach(i -&gt; <span class="keyword">new</span> Thread(ClassInit::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在同一时间，只能有一个线程执行到静态代码块中的内容，并且静态代码块仅仅只会被执行一次，JVM保证了 <clinit> 方法在多线程的执行环境下的同步语义，因此在单例设计模式下，采用 Holder的方式是一种最佳的设计方法 </li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li>类的加载过程 还是会围绕 二进制文件的加载，二进制数据的连接以及类的初始化这样的过程区进行 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">   <span class="comment">//1. </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton(); <span class="comment">// 2.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y+;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Singleton singleton=Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton.x);</span><br><span class="line">        System.out.println(singleton.y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    com.wangwenjun.concurrent.chapter09.Singleton@<span class="number">4554617</span>c</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先在连接阶段的准备过程中，每一个类变量都被赋予了相应的初始值  x=0，y=0， instance=null</p>
</li>
<li><p>类的初始化阶段，初始化阶段会为每一个类变量赋予正确的值，也就是执行 <clinit> 方法的过程 </p>
<p>x=0, y=0, instance =new Singleton()</p>
</li>
<li><p>然后在 new SIngleton 的时候，会执行类的构造函数，而在构造函数中 分别对 x和y 进行自增，结果为：</p>
<p>x=1，  y=1</p>
</li>
</ol>
<p>再看调换 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); <span class="comment">// 调换Singleton顺序之后， </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton);</span><br><span class="line">        System.out.println(singleton.x);</span><br><span class="line">        System.out.println(singleton.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">    </span><br><span class="line">    com.wangwenjun.concurrent.chapter09.Singleton@<span class="number">4554617</span>c</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">java高并发详解-08-线程池原理以及自定义线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-24 20:33:31" itemprop="dateCreated datePublished" datetime="2021-02-24T20:33:31+08:00">2021-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>线程池主要是为了重复利用线程，提高效率</li>
<li>因为线程是一个重量级的资源，创建、启动以及销毁都是比较耗费资源的，因此对线程重复利用是一种好的程序设计习惯</li>
<li>系统中可创建的线程数量是有限的，线程数量和系统性能是一种抛物线的关系</li>
<li>本章主要从原理入手，设计一个线程池，理解一个线程池应该具有哪些功能，需要注意哪些细节</li>
</ul>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p>一个完整的线程池应该具备如下要素</p>
<ul>
<li><p>任务队列： 用户缓存提交的任务</p>
</li>
<li><p>线程数量管理功能： 一个线程池必须能够很好的管理 和控制线程的数量，可以通过3个参数来实现：</p>
<ul>
<li>创建线程池时 初始的线程数量init</li>
<li>线程池自动扩充的最大线程数量max</li>
<li>在线程池空闲的时候需要释放线程，但是也要维护一定数量的活跃数量或者核心数量 core</li>
</ul>
<p>有了这3个参数，就能够很好的控制线程池中的线程数量，将其维护在一个合理的范围之内，三者关系是  init&lt;=core&lt;=max</p>
</li>
<li><p>任务拒绝策略： 如果线程数量已达到上限且任务队列已满，则需要有相应的拒绝策略来通知任务提交者。</p>
</li>
<li><p>线程工厂： 用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等</p>
</li>
<li><p>QueueSize： 任务队列主要存放 提交的Runnable，但是为了防止内存溢出，需要有limit 数量对其进行控制</p>
</li>
<li><p>KeepedAlive时间： 该时间主要决定线程各个重要参数自动维护的时间间隔</p>
</li>
</ul>
<p><img src="/uploads/java-concurrency-master/ThreadPoolPrinciple.png"></p>
<h1 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h1><p><img src="/uploads/java-concurrency-master/ThreadPoolImpl.png"></p>
<h2 id="线程池接口定义"><a href="#线程池接口定义" class="headerlink" title="线程池接口定义"></a>线程池接口定义</h2><ol>
<li><p>ThreadPool</p>
<p>ThreadPool主要顶一个了一个线程池应该具备的基本操作和方法，</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池大小,返回初始线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getInitSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池最大线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池的核心线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCoreSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中用户缓存任务队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中活跃线程的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//查看线程池是否已经被shutdown</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>RunnableQueue</p>
<p>RunnableQueue 用于存放提交的Runnable，该Runnable是一个BlockedQueue，并且有limit的限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务队列，用户缓存提交到线程池中的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当有新任务进来时候，首先会offer 到队列中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程通过take方法 获取Runnable</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Runnable <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务队列中任务的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>ThreadFactory</p>
<p>THreadFactory 提供创建线程的接口，以便于个性化的定制 Thread，比如应该被加入到哪个 group中，优先级，线程名字以及是否为守护线程等</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">createThread</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>DenyPolicy</p>
<p>DenyPolicy主要用于 当Queue中的runnable 达到了limit上限的时候， 决定采用何种策略通知提交者。该接口中默认定义了3中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现1： 直接将任务丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DiscardDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现2： 像任务提交者抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AbortDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RunnableDenyException(<span class="string">&quot;The runnable &quot;</span> + runnable + <span class="string">&quot; will be abort.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现3： 在提交者所在的线程中执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RunnerDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!threadPool.isShutdown()) &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>RunnableDenyException</p>
<p>RunnableDenyException 是RuntimeException的子类，主要用于通知 任务提交者，任务队列已无法再接受新的任务</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDenyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableDenyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>InternalTask</p>
<p>InternalTask 是 Runnable的一个实现，主要用于线程池内部，该类会使用到 RunnableQueue，然后不断地从queue中取出某个runnable ，并且运行runnable的 run方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RunnableQueue runnableQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalTask</span><span class="params">(RunnableQueue runnableQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runnableQueue = runnableQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前任务为 running ，并且没有被中断，</span></span><br><span class="line">        <span class="keyword">while</span> (running &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 则其将不断地 从queue中获取 runnable，然后执行run方法</span></span><br><span class="line">                Runnable task = runnableQueue.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                running = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止当前任务，主要会在 线程池的shutdown 方法中使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程池的详细实现"><a href="#线程池的详细实现" class="headerlink" title="线程池的详细实现"></a>线程池的详细实现</h2><ol>
<li><p>LinkedRunnableQueue (将runnableList 作为同步锁 对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedRunnableQueue</span> <span class="keyword">implements</span> <span class="title">RunnableQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务队列的最大容量，在构造时候传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="comment">// 假如任务队列中的任务满了，则需要执行拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DenyPolicy denyPolicy;</span><br><span class="line">    <span class="comment">// 用于存放任务的队列（双向循环列表）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; runnableList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPool threadPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedRunnableQueue</span><span class="params">(<span class="keyword">int</span> limit, DenyPolicy denyPolicy, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        <span class="keyword">this</span>.denyPolicy = denyPolicy;</span><br><span class="line">        <span class="keyword">this</span>.threadPool = threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runnableList.size() &gt;= limit) &#123;</span><br><span class="line">                <span class="comment">// 无法容纳新的任务时，执行拒绝策略</span></span><br><span class="line">                denyPolicy.reject(runnable, threadPool);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将任务假如到队尾，并且唤醒阻塞中的线程</span></span><br><span class="line">                runnableList.addLast(runnable);</span><br><span class="line">                runnableList.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="comment">// 如果任务队列中没有可执行的任务，则将当前线程挂起，进入 runnablelist 关联的wait set中等待唤醒</span></span><br><span class="line">            <span class="comment">// （有新任务假如时，会被唤醒）</span></span><br><span class="line">            <span class="keyword">while</span> (runnableList.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runnableList.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 被中断时，需要将该异常抛出，通知上游 InternalTask</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从任务队列头部移除一个任务</span></span><br><span class="line">            <span class="keyword">return</span> runnableList.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回当前任务队列中的任务数量</span></span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="keyword">return</span> runnableList.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>2.初始化线程池 (线程池本身也是一个线程)</p>
<p>线程池需要有数量控制属性（）、创建线程工厂（ThreadFactory）、任务队列策略（DenyPolicy） 等功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池本身自己也是一个线程，需要keepAlive，更新容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThreadPool</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initSize;</span><br><span class="line">    <span class="comment">//线程池最大线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//线程池核心线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 当前活跃的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> activeCount;</span><br><span class="line">    <span class="comment">// 创建线程工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RunnableQueue runnableQueue;</span><br><span class="line">    <span class="comment">// 线程池是否已经被shutdown</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isShutdown = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 工作线程队列（存放活跃线程）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;ThreadTask&gt; threadQueue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DenyPolicy DEFAULT_DENY_POLICY = <span class="keyword">new</span> DenyPolicy.DiscardDenyPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadFactory DEFAULT_THREAD_FACTORY = <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initSize  初始的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize   最大的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize  核心线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueSize 任务队列的最大数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicThreadPool</span><span class="params">(<span class="keyword">int</span> initSize, <span class="keyword">int</span> maxSize, <span class="keyword">int</span> coreSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> queueSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initSize, maxSize, coreSize, DEFAULT_THREAD_FACTORY,</span><br><span class="line">                queueSize, DEFAULT_DENY_POLICY, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造线程池需要传入的参数，更多</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initSize      初始的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize       最大的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize      核心线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 创建线程工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueSize     任务队列的最大数量（最大任务数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> denyPolicy    任务队列满后的拒绝策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicThreadPool</span><span class="params">(<span class="keyword">int</span> initSize, <span class="keyword">int</span> maxSize, <span class="keyword">int</span> coreSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory, <span class="keyword">int</span> queueSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           DenyPolicy denyPolicy, <span class="keyword">long</span> keepAliveTime, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initSize = initSize;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.runnableQueue = <span class="keyword">new</span> LinkedRunnableQueue(queueSize, denyPolicy, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时，先创建initSize 个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initSize; i++) &#123;</span><br><span class="line">            newThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务，只需要将 runnable插入任务队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">this</span>.runnableQueue.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的自动维护，具体逻辑看 InternalTask的run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalTask internalTask = <span class="keyword">new</span> InternalTask(runnableQueue);</span><br><span class="line">        Thread thread = <span class="keyword">this</span>.threadFactory.createThread(internalTask);</span><br><span class="line">        ThreadTask threadTask = <span class="keyword">new</span> ThreadTask(thread, internalTask);</span><br><span class="line">        threadQueue.offer(threadTask);</span><br><span class="line">        <span class="keyword">this</span>.activeCount++;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从线程池中 remove 某个线程</span></span><br><span class="line">        ThreadTask threadTask = threadQueue.remove();</span><br><span class="line">        threadTask.internalTask.stop();</span><br><span class="line">        <span class="keyword">this</span>.activeCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 主要用于维护线程数量，比如 扩容、回收等工作</span></span><br><span class="line">        <span class="keyword">while</span> (!isShutdown &amp;&amp; !isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                timeUnit.sleep(keepAliveTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                isShutdown = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShutdown)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(runnableQueue.size() + <span class="string">&quot;==&quot;</span> + activeCount);</span><br><span class="line">                <span class="comment">// 当前队列中 有任务尚未处理，并且 activeCount&lt; coreSize 则继续扩容</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() &gt; <span class="number">0</span> &amp;&amp; activeCount &lt; coreSize) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = initSize; i &lt; coreSize; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;--create&quot;</span>);</span><br><span class="line">                        newThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前队列中 有任务尚未处理，并且 activeCount&lt; maxSize 则继续扩容</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() &gt; <span class="number">0</span> &amp;&amp; activeCount &lt; maxSize) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = coreSize; i &lt; maxSize; i++) &#123;</span><br><span class="line">                        newThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果任务队列中 没有任务，则需要回收，回收至 coreSize 即可</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() == <span class="number">0</span> &amp;&amp; activeCount &gt; maxSize) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;remove...&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = coreSize; i &lt; maxSize; i++) &#123;</span><br><span class="line">                        removeThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShutdown) <span class="keyword">return</span>;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">            threadQueue.forEach(threadTask -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                threadTask.internalTask.stop();</span><br><span class="line">                threadTask.thread.interrupt();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">this</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInitSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.initSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCoreSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.coreSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> runnableQueue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.activeCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isShutdown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger GROUP_COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadGroup group = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;MyThreadPool-&quot;</span> + GROUP_COUNTER.getAndDecrement());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">createThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(group, runnable, <span class="string">&quot;thread-pool-&quot;</span> + COUNTER.getAndDecrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadTask 只是 InternalTask和Thread的一个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(Thread thread, InternalTask internalTask)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">            <span class="keyword">this</span>.internalTask = internalTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread;</span><br><span class="line"></span><br><span class="line">        InternalTask internalTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BasicThreadPool 同时也是Thread的子类，它在初始化的时候启动，在keepalive时间到了之后，再自动维护活动线程数量</li>
<li>TODO： BasicThreadPool 采用继承Thread的方式，不好的方式，会暴露Thread的方法，建议 改为组合关系，TODO 后面我这边会自行修改 </li>
</ul>
<h3 id="线程自动维护"><a href="#线程自动维护" class="headerlink" title="线程自动维护"></a>线程自动维护</h3><ul>
<li>自动维护线程的代码块（run方法） 是同步代码块，主要是为了阻止在线程维护过程中 线程池销毁引起的数据不一致的问题</li>
<li>任务队列中若存在积压任务，并且当前活动线程少于核心线程数，则新建 （CoreSize-initSize）数量的线程，并且将其假如到活动线程队列中，为了防止马上进行 （maxSize-coreSize）数量的扩充，建议使用 continue 终止本次循环</li>
<li>任务队列中有 积压任务，并且当前活动线程少于 最大线程数，则新建（maxSIze-coreSIze）数量的扩充，建议使用 continue 终止本次循环</li>
<li>当线程池不够繁忙时，则需要回收部分线程，回收到coreSize 数量即可，回收时调用removeThread（）方法，在该方法中需要考虑的一点是，如果被回收的线程恰巧从Runnable任务取出了某个任务，则会继续保持该线程的运行，知道完成了任务的运行为止 。详情见 InterTask 的run方法</li>
</ul>
<h3 id="线程池销毁shutdown"><a href="#线程池销毁shutdown" class="headerlink" title="线程池销毁shutdown"></a>线程池销毁shutdown</h3><ul>
<li>线程池的销毁同样需要同步机制的保护，主要是 为了防止与线程池本身的维护线程引起数据冲突</li>
</ul>
<h1 id="线程池的应用"><a href="#线程池的应用" class="headerlink" title="线程池的应用"></a>线程池的应用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadPool threadPool = <span class="keyword">new</span> BasicThreadPool(<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            threadPool.execute(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running and done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (; ; )</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getActiveCount:&quot; + threadPool.getActiveCount());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getQueueSize:&quot; + threadPool.getQueueSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getCoreSize:&quot; + threadPool.getCoreSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getMaxSize:&quot; + threadPool.getMaxSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;======================================&quot;);</span></span><br><span class="line"><span class="comment">//            TimeUnit.SECONDS.sleep(5);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">12</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>TODO： 看看 JDK 的 ExecutorService的原理和源码，据说是类似的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">java高并发详解-07-Hook线程以及捕获线程执行异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-23 21:30:24" itemprop="dateCreated datePublished" datetime="2021-02-23T21:30:24+08:00">2021-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>学习如何获取线程在运行时期的异常信息</li>
<li>学习如何向Java程序注入 Hook线程</li>
</ul>
<h1 id="获取线程运行时异常"><a href="#获取线程运行时异常" class="headerlink" title="获取线程运行时异常"></a>获取线程运行时异常</h1><p>在Thread类中，关于处理运行时异常的API总共有4个，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.  为某个特定线程 指定 UncaughtExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(</span><br><span class="line">                <span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setDefaultUncaughtExceptionHandler&quot;</span>)</span><br><span class="line">                    );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         defaultUncaughtExceptionHandler = eh;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//2. 设置全局的 UncaughtExceptionHandler</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//3.  获取特定线程的 UncaughtExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">            uncaughtExceptionHandler : group;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4.  获取全局的 UncaughtExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        uncaughtExceptionHandler = eh;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="UncaughtExceptionHandler的介绍"><a href="#UncaughtExceptionHandler的介绍" class="headerlink" title="UncaughtExceptionHandler的介绍"></a>UncaughtExceptionHandler的介绍</h2><ul>
<li>线程在执行单元中时不允许抛出checked异常的</li>
<li>线程运行在自己的上下文中，派生它的线程将无法直接获得它运行中出现的异常信息</li>
</ul>
<p>所以Java为我们提供了一个 UncaughtExceptionHandler 接口，</p>
<ul>
<li>当线程在运行过程中出现了异常时，会回调UncaughtExceptionHandler 接口，从而我们得知 哪个线程在运行时出错，以及错误类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Interface for handlers invoked when a &lt;tt&gt;Thread&lt;/tt&gt; abruptly</span></span><br><span class="line"><span class="comment">     * terminates due to an uncaught exception.</span></span><br><span class="line"><span class="comment">     （当一个线程突然的终结了由于一个未被捕获的异常，这个时候这个handler会被调用 ）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;When a thread is about to terminate due to an uncaught exception</span></span><br><span class="line"><span class="comment">     * the Java Virtual Machine will query the thread for its</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt; using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #getUncaughtExceptionHandler&#125; and will invoke the handler&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;uncaughtException&lt;/tt&gt; method, passing the thread and the</span></span><br><span class="line"><span class="comment">     * exception as arguments.</span></span><br><span class="line"><span class="comment">     （当线程由于未捕获的异常即将终止时，Java虚拟机将查询它的线程 为了给 UncaughtExceptionHandler做参数，JVM 传递线程和</span></span><br><span class="line"><span class="comment">*异常作为参数给 uncaughtException方法）</span></span><br><span class="line"><span class="comment">     * If a thread has not had its &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * explicitly set, then its &lt;tt&gt;ThreadGroup&lt;/tt&gt; object acts as its</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;. If the &lt;tt&gt;ThreadGroup&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment">     * has no</span></span><br><span class="line"><span class="comment">     * special requirements for dealing with the exception, it can forward</span></span><br><span class="line"><span class="comment">     * the invocation to the &#123;<span class="doctag">@linkplain</span> #getDefaultUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * default uncaught exception handler&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setDefaultUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ThreadGroup#uncaughtException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked when the given thread terminates due to the</span></span><br><span class="line"><span class="comment">         * given uncaught exception.</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Any exception thrown by this method will be ignored by the</span></span><br><span class="line"><span class="comment">         * Java Virtual Machine.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该回调接口会被Thread 中的dispatchUncaughtException方法调用，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 当线程在运行过程中出现异常时，JVM会调用dispatchUncaughtException方法，该方法会将对应的线程实例以及异常信息传递给回调接口</li>
</ul>
<h2 id="UncaughtExceptionHandler-实例"><a href="#UncaughtExceptionHandler-实例" class="headerlink" title="UncaughtExceptionHandler 实例"></a>UncaughtExceptionHandler 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureThreadException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler((t, e) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot; occur exception&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//here will throw unchecked exception.</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Test-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    Test-Thread occur exception</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.CaptureThreadException.lambda$main$<span class="number">1</span>(CaptureThreadException.java:<span class="number">22</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.CaptureThreadException$$Lambda$<span class="number">2</span>/<span class="number">1078694789.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这种设计方式是比较常见的，（在后面的设计模式也会讲到），尤其是那种异步执行方法，</li>
<li>比如Google 的guava toolkit就提供了 EventBus ，在EventBus 中事件源和实践的subscriber两者 借助EventBus 实现了完全的解耦合，但是在subscriber执行任务时有可能会出现异常i情况，EventBus也是借助于一个ExceptionHandler进行回调处理的 </li>
</ul>
<h2 id="UncaughtExceptionHandler-源码分析"><a href="#UncaughtExceptionHandler-源码分析" class="headerlink" title="UncaughtExceptionHandler 源码分析"></a>UncaughtExceptionHandler 源码分析</h2><p>当 没有主动的 向线程 注入UncaughtExceptionHandler 回调接口的情况下，线程加入出现了异常 又将如何处理呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the handler invoked when this thread abruptly terminates</span></span><br><span class="line"><span class="comment">  * due to an uncaught exception. If this thread has not had an</span></span><br><span class="line"><span class="comment">  * uncaught exception handler explicitly set then this thread&#x27;s</span></span><br><span class="line"><span class="comment">  * &lt;tt&gt;ThreadGroup&lt;/tt&gt; object is returned, unless this thread</span></span><br><span class="line"><span class="comment">  * has terminated, in which case &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the uncaught exception handler for this thread</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">         uncaughtExceptionHandler : group;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getUncaughtExceptionHandler 方法首先会判断当前线程是否设置了handler，</p>
<ul>
<li>如果有则执行线程自己的uncaughtException方法 ，</li>
<li>否则就到所在的ThreadGroup中获取</li>
</ul>
</li>
<li><p>ThreadGroup同样也实现了UncaughtExceptionHandler接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">            <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ueh.uncaughtException(t, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">                System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span></span><br><span class="line">                                 + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 ThreadGroup实现了  Thread.UncaughtExceptionHandler  接口</p>
<ol>
<li>该 ThreadGroup如果有父 ThreadGroup，则直接调用 父group的 uncaughtException方法</li>
<li>如果 设置了全局默认的 UncaughtExceptionHandler  ，则调用全局的 uncaughtException方法</li>
<li>如果既没有父 ThreadGroup，也没有全局默认的 UncaughtExceptionHandler  ， 则直接 将异常的堆栈信息定向到 System.err中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// get current thread&#x27;s thread group</span></span><br><span class="line">        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();</span><br><span class="line">        System.out.println(mainGroup.getName());</span><br><span class="line">        System.out.println(mainGroup.getParent());</span><br><span class="line">        System.out.println(mainGroup.getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//here will throw unchecked exception.</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Test-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果： </span><br><span class="line">    main</span><br><span class="line">java.lang.ThreadGroup[name=system,maxpri=<span class="number">10</span>]</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">Exception in thread <span class="string">&quot;Test-Thread&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.EmptyExceptionHandler.lambda$main$<span class="number">0</span>(EmptyExceptionHandler.java:<span class="number">21</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.EmptyExceptionHandler$$Lambda$<span class="number">1</span>/<span class="number">295530567.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码 既没有设置默认的Handler ,也没有对thread指定Handler，因此当thread出现异常时，会向上寻找 Group的 uncaughtException方法</li>
</ul>
<pre class="mermaid">graph LR
线程出现异常 -->MainGroup -->SystemGroup -->System.err</pre>

<pre class="mermaid">graph TD
线程出现异常 -->getUncaughtExceptionHandler{当前线程是否设置了异常处理器}
getUncaughtExceptionHandler -->|uncaughtExceptionHandler不为空| CurrThread[当前线程异常处理器处理]
getUncaughtExceptionHandler -->|uncaughtExceptionHandler为空| group[找所在 group]

group --> 父group{是否存在父group}
父group -->|父group存在| parent.uncaughtException[父group去处理]
父group -->|父group不存在| getDefaultUncaughtExceptionHandler[找全局默认的UncaughtExceptionHandler]

getDefaultUncaughtExceptionHandler -->DefaultUncaughtExceptionHandler{是否设置全局DefaultUncaughtExceptionHandler}
DefaultUncaughtExceptionHandler -->|DefaultUncaughtExceptionHandler不为空|Defaultueh.uncaughtException[DefaultUncaughtExceptionHandler处理]
DefaultUncaughtExceptionHandler -->|DefaultUncaughtExceptionHandler为空|System.err.print[输出异常堆栈]</pre>

<h1 id="注入钩子函数"><a href="#注入钩子函数" class="headerlink" title="注入钩子函数"></a>注入钩子函数</h1><h2 id="Hook线程介绍"><a href="#Hook线程介绍" class="headerlink" title="Hook线程介绍"></a>Hook线程介绍</h2><p>JVM进程的退出是由于： <strong>JVM进程中没有活跃的非守护线程，或者收到了系统中断信号</strong>，向JVM程序注入一个 Hook线程，在JVM进程退出的时候，Hook 线程会启动执行，<strong>通过Runtime可以为JVM注入多个Hook线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadHook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Hook线程1</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The hook thread 2 is running.&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;The program will exit.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// Hook线程2 </span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The hook thread 2 is running.&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;The hook thread 2 will exit.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// JVM 退出信号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;The program will is stopping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    The program will is stopping.</span><br><span class="line">The hook thread <span class="number">2</span> is running.</span><br><span class="line">The hook thread <span class="number">2</span> is running.</span><br><span class="line">The program will exit.</span><br><span class="line">The hook thread <span class="number">2</span> will exit.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>给Java程序注入了两个Hook线程，在main线程中结束，也就是JVM中没有了活动的非守护线程</li>
<li>jvm进程即将退出时，两个Hook线程会被启动并且运行 </li>
</ul>
<h2 id="Hook线程实战"><a href="#Hook线程实战" class="headerlink" title="Hook线程实战"></a>Hook线程实战</h2><p>我们在开发中经常会遇到Hook线程，比如：</p>
<ul>
<li>为了防止某个程序被重复启动，在启动时会创建一个lock文件，进程收到中断信号时候会删除lock文件，我们在mysql 服务器、zookeeper、kafka等系统都能看到lock文件的存在</li>
</ul>
<p>本代码利用hook线程的特点，模拟一个防止重复启动的程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreventDuplicated</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_PATH = <span class="string">&quot;/home/yinshi/locks/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_FILE = <span class="string">&quot;.lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PERMISSIONS = <span class="string">&quot;rw-------&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.注入hook线程，在程序退出时删除lock文件</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The program received kill SIGNAL.&quot;</span>);</span><br><span class="line">            getLockFile().toFile().delete();</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">// 2.检查是否存在 .lock文件</span></span><br><span class="line">        checkRunning();</span><br><span class="line">		<span class="comment">//3.简单模拟程序running</span></span><br><span class="line">        <span class="comment">//simulate the program is running.</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;program is running.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkRunning</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = getLockFile();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;The program already running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString(PERMISSIONS);</span><br><span class="line">        Files.createFile(path, PosixFilePermissions.asFileAttribute(perms));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Path <span class="title">getLockFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Paths.get(LOCK_PATH, LOCK_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行kill pid 或者 kill -1 pid 命令后，JVM进程会收到中断信号，并且启动hook线程 删除.lock文件</li>
</ul>
<h2 id="Hook线程应用场景以及注意事项"><a href="#Hook线程应用场景以及注意事项" class="headerlink" title="Hook线程应用场景以及注意事项"></a>Hook线程应用场景以及注意事项</h2><ul>
<li>hook线程只有在收到退出信号的时候会被执行，如果 是 kill -9 ，那么Hook线程不会得到执行，进程将会退出，因此 .lock文件将得不到清理</li>
<li>hook线程中也可以执行 一些资源释放的工作，比如 关闭文件句柄、socket链接、数据库connection等</li>
<li>尽量不要在 Hook线程中执行一些耗时非常长的操作，因为其会导致程序迟迟不能退出</li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li>知道了如何通过Handler回调的方式获取线程运行期间的异常信息， </li>
<li>分析了Thread的源码 和 ThreadGroup的源码，追踪uncaughtException的执行顺序</li>
<li>了解了Hook的执行时机，帮助程序获得进程中断的信号，有机会在进程退出之前做一些资源释放或者告警通知</li>
<li>如果强制杀死进程，（比如kill -9） 那么进程将不会收到任何中断信号</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java高并发详解-06-ThreadGroup详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-23 00:08:17" itemprop="dateCreated datePublished" datetime="2021-02-23T00:08:17+08:00">2021-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>创建线程的时候如果没有显示得指定ThreadGroup，那么新的线程会被加入到父线程相同的ThreadGroup中</li>
<li>其实这里主要就是看ThreadGroup的源码，以及Thread的源码，就可以知道关于Thread的一些规则，比如 Thread的优先级 的范围，以及不能超过ThreadGroup的MAX</li>
</ul>
<h1 id="ThreadGroup-与Thread"><a href="#ThreadGroup-与Thread" class="headerlink" title="ThreadGroup 与Thread"></a>ThreadGroup 与Thread</h1><h2 id="创建ThreadGroup"><a href="#创建ThreadGroup" class="headerlink" title="创建ThreadGroup"></a>创建ThreadGroup</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是private ，不对外暴露</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.daemon;</span><br><span class="line">        <span class="keyword">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        parent.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个构造函数为 ThreadGroup赋予了名字，它的默认父 ThreadGroup是创建它的线程所在的ThreadGroup</li>
<li>第二构造函数赋予group名字的同时，显示指定了父ThreadGroup</li>
</ul>
<h2 id="复制Thread数组和ThreadGroup数组"><a href="#复制Thread数组和ThreadGroup数组" class="headerlink" title="复制Thread数组和ThreadGroup数组"></a>复制Thread数组和ThreadGroup数组</h2><h3 id="复制Thread数组"><a href="#复制Thread数组" class="headerlink" title="复制Thread数组"></a>复制Thread数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies into the specified array every active thread in this</span></span><br><span class="line"><span class="comment">     * thread group and its subgroups.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment">     * way as the invocation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> #enumerate(Thread[], boolean) enumerate&#125;&#123;<span class="doctag">@code</span> (list, true)&#125;</span></span><br><span class="line"><span class="comment">     * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  list</span></span><br><span class="line"><span class="comment">     *         an array into which to put the list of threads</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the number of threads put into the array</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">     *          if &#123;<span class="doctag">@linkplain</span> #checkAccess checkAccess&#125; determines that</span></span><br><span class="line"><span class="comment">     *          the current thread cannot access this thread group</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[])</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies into the specified array every active thread in this</span></span><br><span class="line"><span class="comment">     * thread group. If &#123;<span class="doctag">@code</span> recurse&#125; is &#123;<span class="doctag">@code</span> true&#125;,</span></span><br><span class="line"><span class="comment">     * this method recursively enumerates all subgroups of this</span></span><br><span class="line"><span class="comment">     * thread group and references to every active thread in these</span></span><br><span class="line"><span class="comment">     * subgroups are also included. If the array is too short to</span></span><br><span class="line"><span class="comment">     * hold all the threads, the extra threads are silently ignored.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; An application might use the &#123;<span class="doctag">@linkplain</span> #activeCount activeCount&#125;</span></span><br><span class="line"><span class="comment">     * method to get an estimate of how big the array should be, however</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;if the array is too short to hold all the threads, the extra threads</span></span><br><span class="line"><span class="comment">     * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active</span></span><br><span class="line"><span class="comment">     * thread in this thread group, the caller should verify that the returned</span></span><br><span class="line"><span class="comment">     * int value is strictly less than the length of &#123;<span class="doctag">@code</span> list&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Due to the inherent race condition in this method, it is recommended</span></span><br><span class="line"><span class="comment">     * that the method only be used for debugging and monitoring purposes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层私有逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">int</span> n, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ngroupsSnapshot = <span class="number">0</span>;</span><br><span class="line">        ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nt = nthreads;</span><br><span class="line">            <span class="keyword">if</span> (nt &gt; list.length - n) &#123;</span><br><span class="line">                nt = list.length - n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (threads[i].isAlive()) &#123;</span><br><span class="line">                    list[n++] = threads[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">                ngroupsSnapshot = ngroups;</span><br><span class="line">                <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">                n = groupsSnapshot[i].enumerate(list, n, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的public 的2个方法，会将ThreadGroup 中active线程全部复制到Thread数组中，</li>
<li>其中recurse参数如果为True，则方法会将所有子 group的active线程全部递归到Thread数组中，</li>
<li>enumerate（list ）实际上等价于 enumerate（list，true）</li>
</ul>
<h3 id="复制ThreadGroup数组"><a href="#复制ThreadGroup数组" class="headerlink" title="复制ThreadGroup数组"></a>复制ThreadGroup数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[])</span> </span>&#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和复制Thread数组类似，上面方法用于复制当前ThreadGroup的子 Group，同样recurse会决定是否以递归的方式复制</li>
</ul>
<h2 id="ThreadGroup操作"><a href="#ThreadGroup操作" class="headerlink" title="ThreadGroup操作"></a>ThreadGroup操作</h2><p>Threadgroup 并不能提供对线程的管理，主要功能是对线程提供组织</p>
<h3 id="ThreadGroup基本操作"><a href="#ThreadGroup基本操作" class="headerlink" title="ThreadGroup基本操作"></a>ThreadGroup基本操作</h3><ul>
<li>activeCount（）： 用于获取group中活跃的线程，只是一个估计值，该方法会递归获取其他子group中的活跃线程</li>
<li>activeGroupCount（）： 用于获取group中活跃的子group，只是一个估计值，该方法也会递归获取所有的子 group</li>
<li>getMaxPriority() 用于获取group的优先级，默认情况下，Group的优先级为10，在该group中，所有线程的优先级不能大于group的优先级</li>
<li>getName() 用于获取group的名字</li>
<li>getParent（）用于获取group的父 group，如果父group不存在，则会返回null ，比如system group的父group就是 null</li>
<li>list（）该方法没有返回值，执行该方法会将group中所有的活跃线程信息全部输出到控制台，也就是 System.out</li>
<li>parentOf（ThreadGroup g）会判断当前group是不是给定的group的父group ，另外如果给定的group就是本身，那么也返回true</li>
<li>setMaxPriority(int pri)会指定group的最大优先级 ，最大优先级不能超过父 group的最大优先级。执行该方法不仅仅会改变当前group的最大优先级，还会改变所有子goup的最大优先级</li>
</ul>
<p>ThreadGroup的interrupt</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Interrupts all threads in this thread group.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is</span></span><br><span class="line"><span class="comment">   * called with no arguments; this may result in a security exception.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * This method then calls the &lt;code&gt;interrupt&lt;/code&gt; method on all the</span></span><br><span class="line"><span class="comment">   * threads in this thread group and in all of its subgroups.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span>  SecurityException  if the current thread is not allowed</span></span><br><span class="line"><span class="comment">   *               to access this thread group or any of the threads in</span></span><br><span class="line"><span class="comment">   *               the thread group.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.SecurityException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.ThreadGroup#checkAccess()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span>      1.2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">      ThreadGroup[] groupsSnapshot;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          checkAccess();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">              threads[i].interrupt();</span><br><span class="line">          &#125;</span><br><span class="line">          ngroupsSnapshot = ngroups;</span><br><span class="line">          <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">              groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">          groupsSnapshot[i].interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>interrupt一个thread group会导致 该group中所有的active 线程都被interrupt ，</li>
<li>也就说该 group中的每一个interrupt 标识都被设置了 </li>
<li>通过源码分析，可以看出interrupt内部会执行所有thread 的interrupt方法，并且会递归获取子 group，然后执行他们各自的interrupt方法</li>
</ul>
<h3 id="ThreadGroup的destory"><a href="#ThreadGroup的destory" class="headerlink" title="ThreadGroup的destory"></a>ThreadGroup的destory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroys this thread group and all of its subgroups. This thread</span></span><br><span class="line"><span class="comment"> * group must be empty, indicating that all threads that had been in</span></span><br><span class="line"><span class="comment"> * this thread group have since stopped.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is</span></span><br><span class="line"><span class="comment"> * called with no arguments; this may result in a security exception.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread group is not</span></span><br><span class="line"><span class="comment"> *               empty or if the thread group has already been destroyed.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  SecurityException  if the current thread cannot modify this</span></span><br><span class="line"><span class="comment"> *               thread group.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.ThreadGroup#checkAccess()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>      JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (destroyed || (nthreads &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            destroyed = <span class="keyword">true</span>;</span><br><span class="line">            ngroups = <span class="number">0</span>;</span><br><span class="line">            groups = <span class="keyword">null</span>;</span><br><span class="line">            nthreads = <span class="number">0</span>;</span><br><span class="line">            threads = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i += <span class="number">1</span>) &#123;</span><br><span class="line">        groupsSnapshot[i].destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>destory 用于销毁 ThreadGroup ，该方法只是针对一个没有任何active线程的group 进行一个 destory标记，调用该方法的结果是在父 group中将自己移除</li>
</ul>
<h3 id="守护ThreadGroup"><a href="#守护ThreadGroup" class="headerlink" title="守护ThreadGroup"></a>守护ThreadGroup</h3><ul>
<li>线程可以设置为守护线程，ThreadGroup也可以设置为 守护ThreadGroup，</li>
<li>但是将一个THreadGroup 设置为 daemon ，也并不会影响线程的daemon属性</li>
<li>如果一个 ThreadGroup 的daemon被设置为  true，那么在group中没有任何active线程的时候，该group将自动destory </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">java高并发详解-05-线程间通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-21 14:50:38" itemprop="dateCreated datePublished" datetime="2021-02-21T14:50:38+08:00">2021-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><p>线程间通信又称为 进程内通信，多个线程实现互斥访问共享资源时 会互相发送信号或等待信号</p>
</li>
<li><p>主要是 线程之间 wait，notify，notifyAll ，以及背后的原理内幕</p>
</li>
<li><p>wait 和 notify 方法必须拥有该对象的monitor ，也就是wait方法必须在同步方法中使用**</p>
</li>
</ul>
<h1 id="同步阻塞与异步非阻塞"><a href="#同步阻塞与异步非阻塞" class="headerlink" title="同步阻塞与异步非阻塞"></a>同步阻塞与异步非阻塞</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Event&gt; eventQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_EVENT = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_MAX_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventQueue.size() &gt;= max) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is full.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            console(<span class="string">&quot; the new event is submitted&quot;</span>);</span><br><span class="line">            eventQueue.addLast(event);</span><br><span class="line">            <span class="comment">// 只能唤醒一个 线程</span></span><br><span class="line">            eventQueue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is empty.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Event event = eventQueue.removeFirst();</span><br><span class="line">            <span class="keyword">this</span>.eventQueue.notify();</span><br><span class="line">            console(<span class="string">&quot; the event &quot;</span> + event + <span class="string">&quot; is handled.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">console</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s:%s\n&quot;</span>, currentThread().getName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="同步阻塞消息处理"><a href="#同步阻塞消息处理" class="headerlink" title="同步阻塞消息处理"></a>同步阻塞消息处理</h2><ul>
<li>同步Event 提交，客户端等待时间过长 会陷入阻塞，导致二次提交 Event耗时过长</li>
<li>由于客户端提交的Event数量不多，导致系统同时受理业务数量有限，也就是系统的整理的吞吐量不高</li>
<li>这种一个线程处理一个Event的方式，会导致出现频繁的创建开启和销毁，从而增加系统额外开销</li>
<li>在业务达到峰值的时候，大量的业务处理线程阻塞会导致频繁的CPU切换上下文，从而降低系统性能</li>
</ul>
<h2 id="异步非阻塞消息处理"><a href="#异步非阻塞消息处理" class="headerlink" title="异步非阻塞消息处理"></a>异步非阻塞消息处理</h2><ul>
<li>客户端不用等到结果处理结束之后才能返回，从而提高了系统的吞吐量和并发量</li>
<li>服务端的线程数量在一个可控的范围之内是不会导致太多的CPU上下文切换，从而带来额外的开销</li>
<li>服务端线程可以重复利用，这样可以减少不断创建线程带来的资源浪费</li>
</ul>
<h1 id="单线程间通信"><a href="#单线程间通信" class="headerlink" title="单线程间通信"></a>单线程间通信</h1><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><ul>
<li><p>wait 和 notify是 Object中的方法，也就是说 JDK中的每一个类都拥有这2个方法</p>
</li>
<li><p>下面是 wait的 3个重载方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2. </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>wait 方法的3个重载方法都将调用wait（long timeout）这个方法，</li>
<li>wait（）等价于 wait（0），其中0代表永不超时 </li>
<li>Object的wait（long timeout）方法会导致当前线程进入阻塞，直到 有其他线程调用了 Object的notify 或者 notifyAll方法才能将其唤醒，或者 阻塞时间到达了 timeout时间而自动唤醒</li>
<li><strong>wait方法必须拥有该对象的monitor ，也就是wait方法必须在同步方法中使用</strong></li>
<li><strong>当前线程执行了该对象的wait方法之后，将会放弃对该 monitor的所有权并且进入与该对象关联的waitset中，也就说一旦线程执行了某个object 的wait方法之后，他就会释放对该对象 monitor的所有权，</strong>其他线程也会有机会继续争抢该 monitor的所有权 </li>
<li>（这个就是 Thread:: join的背后的逻辑，thread.join就是调用了wait 方法，所以父线程会 等到子线程执行完毕，才继续执行）</li>
</ul>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Wakes up a single thread that is waiting on this object&#x27;s</span></span><br><span class="line"><span class="comment">    * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment">    * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment">    * the discretion of the implementation. A thread waits on an object&#x27;s</span></span><br><span class="line"><span class="comment">    * monitor by calling one of the &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The awakened thread will not be able to proceed until the current</span></span><br><span class="line"><span class="comment">    * thread relinquishes the lock on this object. The awakened thread will</span></span><br><span class="line"><span class="comment">    * compete in the usual manner with any other threads that might be</span></span><br><span class="line"><span class="comment">    * actively competing to synchronize on this object; for example, the</span></span><br><span class="line"><span class="comment">    * awakened thread enjoys no reliable privilege or disadvantage in being</span></span><br><span class="line"><span class="comment">    * the next thread to lock this object.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment">    * of this object&#x27;s monitor. A thread becomes the owner of the</span></span><br><span class="line"><span class="comment">    * object&#x27;s monitor in one of three ways:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;By executing a synchronized instance method of that object.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;By executing the body of a &#123;<span class="doctag">@code</span> synchronized&#125; statement</span></span><br><span class="line"><span class="comment">    *     that synchronizes on the object.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;For objects of type &#123;<span class="doctag">@code</span> Class,&#125; by executing a</span></span><br><span class="line"><span class="comment">    *     synchronized static method of that class.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Only one thread at a time can own an object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">    *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        java.lang.Object#notifyAll()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        java.lang.Object#wait()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>看一下方法说明注释-</p>
<ul>
<li><p>唤醒<strong>单个</strong>正在等待执行该对象wait 方法的线程</p>
</li>
<li><p>如果有很多线程都在等待，其中之一会被选中唤醒， 选择是任意的</p>
</li>
<li><p>被唤醒的线程需要重新获取对该对象所关联 monitor的lock 才能继续执行</p>
</li>
<li><p>被唤醒的线程将不能继续，直到当前线程放弃对该对象的锁。被唤醒的线程将以通常的方式与任何其他可能正在主动竞争同步这个对象的线程竞争;例如，被唤醒的线程在成为下一个锁定该对象的线程时没有任何可靠的特权或劣势</p>
</li>
</ul>
<h3 id="关于wait-和notify的注意事项"><a href="#关于wait-和notify的注意事项" class="headerlink" title="关于wait 和notify的注意事项"></a>关于wait 和notify的注意事项</h3><ul>
<li><p><strong>wait 是可中断方法</strong>，所以： 当前线程一旦调用了wait方法 进入阻塞状态，其他线程是可以使用 interrupt 方法将其打断的； 可中断方法被打断后，会收到 中断异常 InterruptedException ，同时 interrupt flag 也会被擦除 </p>
</li>
<li><p>线程执行了某个对象的wait 方法之后，会加入与之 对应的wait set中，<strong>每一个对象的 monitor 都有一个与之关联的 wait set</strong></p>
</li>
<li><p><strong>当线程进入wait set之后，notify 方法可以将其唤醒</strong>，也就是 从 wait set中弹出，<strong>同时中断 wait 中的线程也会将其唤醒</strong></p>
</li>
<li><p><strong>必须在同步方法中 使用 wait 和 notify 方法，</strong> 因为执行wait 和 notify 的前提条件是  必须持有同步方法的monitor 的所有权， 运行下面任何一个方法 都会抛出 非法的 monitor 状态异常  InllegalMonitorStateException: </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，因为 **必须在同步方法中 使用 wait 和 notify 方法，**</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testwait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.wait();  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，**必须在同步方法中 使用 wait 和 notify 方法，**</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testwait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步代码的monitor 必须与执行  wait  notify方法的对象一致，简单来说就是 <strong>用哪个对象的 monitor 进行同步，就只能用哪个对象 进行wait 和 notify操作。</strong></li>
</ul>
<p>运行下面代码的任何一个方法会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object MUTEX = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错，如果非要用 MUTEx ，可以使用同步代码块的形式 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            MUTEX.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 报错，报错，如果非要用 MUTEx ，可以使用同步代码块的形式 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testNotify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MUTEX.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify();</span><br><span class="line">        waitNotify.testNotify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.lang.Object.notifyAll(Native Method)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.WaitNotify.testNotify(WaitNotify.java:<span class="number">21</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.WaitNotify.main(WaitNotify.java:<span class="number">27</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面同步方法中 monitor 引用的是 this，而wait notify 使用的确实  MUTEX，<strong>虽然是在 同步方法中执行 wait  notify方法，但是 wait 和 notify方法的执行并未 获取 MUTEX 的monitor 为前提</strong></p>
<h2 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait 和sleep"></a>wait 和sleep</h2><ul>
<li>都可以使线程进入 阻塞状态</li>
<li>都是可中断方法，被中断后会收到中断异常</li>
<li>wait 时 Object方法， sleep 是 THread  方法</li>
<li>wait 执行需要在 synchronized 方法中进行，而sleep 不需要</li>
<li><strong>线程在同步方法中执行sleep 方法时，不会释放 monitor锁 ， 而 wait 方法则会释放monitor 锁</strong></li>
<li>sleep 方法短暂休眠后会主动退出阻塞 ，而 wait方法（没有指定时间） 则需要被其他线程中断才能退出阻塞 </li>
</ul>
<h1 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h1><ul>
<li>前面之所以 把 notify划到  单线程通信，我觉得是 因为 notify 只能唤醒一个线程，所以叫单线程通信</li>
<li>而 notifyAll 可以唤醒所以 waitset中的线程，所以称为 多线程通信</li>
</ul>
<h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><h3 id="1-notifyAll-方法"><a href="#1-notifyAll-方法" class="headerlink" title="1.notifyAll 方法"></a>1.notifyAll 方法</h3><ul>
<li>多线程之间通信需要用到Object 的notifyAll 方法，该方法与notify类似，都可以唤醒 由于调用wait方法而阻塞的线程，</li>
<li>但是 notify方法只能唤醒其中的一个线程，而notifyALL方法则可以同时唤醒全部的阻塞线程，同样被唤醒的线程仍需要继续争抢monitor的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up all threads that are waiting on this object&#x27;s monitor. A</span></span><br><span class="line"><span class="comment"> * thread waits on an object&#x27;s monitor by calling one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The awakened threads will not be able to proceed until the current</span></span><br><span class="line"><span class="comment"> * thread relinquishes the lock on this object. The awakened threads</span></span><br><span class="line"><span class="comment"> * will compete in the usual manner with any other threads that might</span></span><br><span class="line"><span class="comment"> * be actively competing to synchronize on this object; for example,</span></span><br><span class="line"><span class="comment"> * the awakened threads enjoy no reliable privilege or disadvantage in</span></span><br><span class="line"><span class="comment"> * being the next thread to lock this object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment"> * of this object&#x27;s monitor. See the &#123;<span class="doctag">@code</span> notify&#125; method for a</span></span><br><span class="line"><span class="comment"> * description of the ways in which a thread can become the owner of</span></span><br><span class="line"><span class="comment"> * a monitor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment"> *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#notify()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#wait()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-生产者消费者"><a href="#2-生产者消费者" class="headerlink" title="2.生产者消费者"></a>2.生产者消费者</h3><p>前面的EventQueue 队列在多个线程同时并发的情况下会出现数据不一致的情况。当线程的数量增加的时候，会出现数据不一致的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EventQueue eventQueue = <span class="keyword">new</span> EventQueue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    eventQueue.offer(<span class="keyword">new</span> EventQueue.Event());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    eventQueue.take();</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer: the queue is empty.</span><br><span class="line">Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> java.util.NoSuchElementException</span><br><span class="line">	at java.util.LinkedList.removeFirst(LinkedList.java:<span class="number">270</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventQueue.take(EventQueue.java:<span class="number">48</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventClient.lambda$main$<span class="number">1</span>(EventClient.java:<span class="number">25</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventClient$$Lambda$<span class="number">2</span>/<span class="number">1324119927.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>

<p>数据不一致的情况大致分为2类，</p>
<ul>
<li>其一是 LinLinkedList 中没有元素的时候，依旧调用了 removeFirst方法，</li>
<li>其二是 当LinkedList中的元素超过了10个的时候 仍旧执行了addLast方法</li>
</ul>
<p>分析现象：</p>
<h4 id="LinLinkedList-为空时，执行removeFirst方法"><a href="#LinLinkedList-为空时，执行removeFirst方法" class="headerlink" title="LinLinkedList 为空时，执行removeFirst方法"></a>LinLinkedList 为空时，执行removeFirst方法</h4><p>假设EventQueue中元素为空，</p>
<ul>
<li>两个线程在执行take方法时分别调用wait 进入阻塞，另外一个offer线程执行addLast方法之后唤醒了其中一个阻塞的take线程，</li>
<li>该take线程顺利消费了一个元素之后，因为是 使用notify方法，只能唤醒一个线程，而此时恰巧再次唤醒了一个take线程，此时就会导致执行empty LinkedList的 removeFirst方法，过程如下：</li>
</ul>
<pre class="mermaid">sequenceDiagram
autonumber
note over take线程1,take线程2:queue size=0
take线程1 ->>take线程1: 执行wait,进入wait set中释放monitor lock
take线程2 ->>take线程2: 执行wait,进入wait set中释放monitor lock
offer线程1 ->>offer线程1: Offer线程addLast，queue size=1
offer线程1 ->>offer线程1: notify方法
offer线程1->>take线程2: 唤醒
take线程2 ->>take线程2: remove first,Queue size=0
take线程2 ->>take线程2: Notify
take线程2->>take线程1: 唤醒
take线程1 ->>take线程1: remove first,报错</pre>

<h4 id="LinLinkedList-元素为10时执行addLast方法"><a href="#LinLinkedList-元素为10时执行addLast方法" class="headerlink" title="LinLinkedList 元素为10时执行addLast方法"></a>LinLinkedList 元素为10时执行addLast方法</h4><pre class="mermaid">sequenceDiagram
autonumber
note over offer线程1,offer线程2:queue size=10
offer线程1 ->>offer线程1: 执行wait,进入wait set中释放monitor lock
offer线程2 ->>offer线程2: 执行wait,进入wait set中释放monitor lock
take线程1 ->>take线程1: Take线程removeFirst，queue size=9
take线程1 ->>take线程1: notify方法
take线程1->>offer线程2: 唤醒
offer线程2 ->>offer线程2: addLast,Queue size=10
offer线程2 ->>offer线程2: Notify
offer线程2->>offer线程1: 唤醒
offer线程1 ->>offer线程1: addLast,Queue size=10</pre>



<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p><strong>只需要将临界值的if判断更改为while ，将 notify更改为 notifyAll即可</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Event&gt; eventQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_EVENT = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_MAX_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (eventQueue.size() &gt;= max) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is full.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            console(<span class="string">&quot; the new event is submitted&quot;</span>);</span><br><span class="line">            eventQueue.addLast(event);</span><br><span class="line">            <span class="comment">// 唤醒所有线程，让他们再去争抢 monitor</span></span><br><span class="line">            eventQueue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is empty.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Event event = eventQueue.removeFirst();</span><br><span class="line">            <span class="comment">// 唤醒所有线程，让他们再去争抢 monitor</span></span><br><span class="line">            <span class="keyword">this</span>.eventQueue.notifyAll();</span><br><span class="line">            console(<span class="string">&quot; the event &quot;</span> + event + <span class="string">&quot; is handled.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">console</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s:%s\n&quot;</span>, currentThread().getName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程休息室wait-set"><a href="#线程休息室wait-set" class="headerlink" title="线程休息室wait set"></a>线程休息室wait set</h3><ul>
<li>在虚拟机规范中存在一个 wait set（线程休息室）的概念，至于 wait set时怎么样的数据结构，JDK官网并没有给出明确的定义，不同厂家的JDK有着不同的实现方式。</li>
<li>不管怎样，线程调用了某个对象的wait方法之后，都会加入与该对象monitor关联的wait set中，并且释放 monitor的所有权</li>
</ul>
<p>下图演示了 ： 若干个线程调用了 wait方法之后被加入与 monitor关联的wait set中，待 另外一个线程（当前monitor持有者）调用该monitor的 notify方法之后，其中一个线程会从 wait set中弹出 。至于时随机弹出 还是先进先出的方式弹出，虚拟机同样没有给出强制要求 </p>
<p><img src="/uploads/java-concurrency-master/notify-waitset.png"></p>
<p>而执行notifyAll 则不需要考虑哪个线程会被弹出，因为wait set中的所有wait线程都会被弹出，如下图5-6 所示</p>
<p><img src="/uploads/java-concurrency-master/notifyAll-waitset.png"></p>
<h2 id="自定义显示锁BooleanLock"><a href="#自定义显示锁BooleanLock" class="headerlink" title="自定义显示锁BooleanLock"></a>自定义显示锁BooleanLock</h2><h3 id="synchronized关键字的缺陷"><a href="#synchronized关键字的缺陷" class="headerlink" title="synchronized关键字的缺陷"></a>synchronized关键字的缺陷</h3><p>synchronized关键字 提供了一种排他式的数据同步机制，某个线程在获取 monitor lock的时候可能会被阻塞，而这种阻塞有2个很明显的缺陷：</p>
<ul>
<li>无法控制阻塞时长</li>
<li>阻塞不可被中断</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDefect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronizedDefect defect = <span class="keyword">new</span> SynchronizedDefect();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(defect::syncMethod, <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        <span class="comment">//make sure the t1 started.</span></span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(defect::syncMethod, <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//make sure the t2 started.</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(t2.isInterrupted());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/T1_TIME_WAITTING.png"></p>
<p><img src="/uploads/java-concurrency-master/T2_BLOCKED.png"></p>
<ul>
<li>被 synchronized 同步的线程不可被中断</li>
</ul>
<h3 id="自定义显示锁BooleanLock-1"><a href="#自定义显示锁BooleanLock-1" class="headerlink" title="自定义显示锁BooleanLock"></a>自定义显示锁BooleanLock</h3><p>利用前面所学的知识，构造一个显示的BooleanLock，使其</p>
<ul>
<li>具备synchronized关键字所有功能的同时，</li>
<li>又具备<strong>可中断 和lock超时的功能</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 永远阻塞，除非获取到了锁，这一点与synchronized类似，</span></span><br><span class="line"><span class="comment">     * 但是该方法可以被中断，中断时会抛出 InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 除了被中断外，还增加了 对应的超时功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mills</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行锁的释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前有哪些线程被 阻塞，类是与 wait set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Thread&gt; <span class="title">getBlockedThreads</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true； 锁空闲</span></span><br><span class="line"><span class="comment">     * false：当前锁不可用，（锁被其他线程占领 &amp;&amp; 或者自己已经拥有锁（这次就不让锁重入了） ）</span></span><br><span class="line"><span class="comment">     * 该方式 只是去判断锁的状态，不会真正的去 lock 或者 unlock，也就是不会修改锁状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现BooleanLock"><a href="#实现BooleanLock" class="headerlink" title="实现BooleanLock"></a>实现BooleanLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前拥有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread currentThread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * false ：当前锁没有被任何线程 获得，或者已经释放</span></span><br><span class="line"><span class="comment">     * true： 该锁已经被某个线程获得，该线程就是 currThread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储因为获取锁 而阻塞的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thread&gt; blockedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (locked) &#123;</span><br><span class="line">                <span class="comment">//暂存当前线程</span></span><br><span class="line">                <span class="keyword">final</span> Thread tempThread = currentThread();</span><br><span class="line">                <span class="comment">// 装载 因获取锁而阻塞的 其他线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!blockedList.contains(currentThread()))</span><br><span class="line">                        blockedList.add(currentThread());</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前线程在wait时候被中断，则从blockedList中删除，避免内存泄漏</span></span><br><span class="line">                    blockedList.remove(tempThread);</span><br><span class="line">                    <span class="comment">//继续抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放自己</span></span><br><span class="line">            blockedList.remove(currentThread());</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            <span class="keyword">this</span>.locked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//更新当前拥有锁的对象</span></span><br><span class="line">            <span class="keyword">this</span>.currentThread = currentThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 如果 mills（超时时间）不合法，抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidParameterException(<span class="string">&quot;非法的mills参数&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mills == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> remainingMills = mills;</span><br><span class="line">                <span class="keyword">long</span> endMills = currentTimeMillis() + remainingMills;</span><br><span class="line">                <span class="keyword">while</span> (locked) &#123;</span><br><span class="line">                    <span class="comment">//2. 如果剩余等待时间（remainingMills），小于等于0，意味着已经超时了，应该抛出 超时的异常</span></span><br><span class="line">                    <span class="keyword">if</span> (remainingMills &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">&quot;can not get the lock during &quot;</span> + mills + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!blockedList.contains(currentThread()))</span><br><span class="line">                        blockedList.add(currentThread());</span><br><span class="line">                    <span class="comment">// 3. 多次wait的过程中，剩余等待时间（remainingMills）也会不断地更新</span></span><br><span class="line">                    <span class="keyword">this</span>.wait(remainingMills);</span><br><span class="line">                    <span class="comment">// 4. 刷新 remainingMills</span></span><br><span class="line">                    remainingMills = endMills - currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5. 获得 monitor lock，从blockList中删除当前线程，修改locked 标识，且更新当前线程为 锁地拥有者</span></span><br><span class="line">                blockedList.remove(currentThread());</span><br><span class="line">                <span class="keyword">this</span>.locked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.currentThread = currentThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//1.只有锁地拥有者，才有资格释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (currentThread == currentThread()) &#123;</span><br><span class="line">                <span class="comment">// 2. 更新lock 标识为 未锁定</span></span><br><span class="line">                <span class="keyword">this</span>.locked = <span class="keyword">false</span>;</span><br><span class="line">                Optional.of(currentThread().getName() + <span class="string">&quot; release the lock monitor.&quot;</span>).ifPresent(System.out::println);</span><br><span class="line">                <span class="comment">//3. 清空wait set,通知wait set中所有线程，可以尝试抢锁了</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Thread&gt; <span class="title">getBlockedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(blockedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">//            // 如果当前 lock 标识为已锁定 并且 自己不是锁的拥有者</span></span><br><span class="line"><span class="comment">//            if (locked &amp;&amp; !this.currentThread.equals(currentThread())) &#123;</span></span><br><span class="line"><span class="comment">//                //直接返回，也不 加入blockList</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;tryLock fail，当前Lock拥有者是:&quot; + this.currentThread.getName());</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //说明当前锁 空闲或者自己已经是锁的拥有者，</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;说明当前锁 空闲或者自己已经是锁的拥有者&quot;);</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line">            <span class="comment">//如果当前锁空闲，则返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">                <span class="comment">//直接返回false，也不 加入blockList</span></span><br><span class="line">                System.out.println(<span class="string">&quot;tryLock succ,当前锁空闲&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;tryLock fail，当前Lock拥有者是:&quot;</span> + <span class="keyword">this</span>.currentThread.getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试类：-tryLock是自己加上的，也可以去除"><a href="#测试类：-tryLock是自己加上的，也可以去除" class="headerlink" title="测试类：(tryLock是自己加上的，也可以去除)"></a>测试类：(tryLock是自己加上的，也可以去除)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLockTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> BooleanLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁失败，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(!lock.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程tryLock失败,退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(currentThread() + <span class="string">&quot; get the lock.&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> randomInt = current().nextInt(<span class="number">10</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(randomInt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethodTimeoutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁失败，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(!lock.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程tryLock失败,退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(currentThread() + <span class="string">&quot; get the lock.&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> randomInt = current().nextInt(<span class="number">10</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(randomInt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BooleanLockTest blt = <span class="keyword">new</span> BooleanLockTest();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(blt::syncMethod, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(blt::syncMethodTimeoutable, <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*(BooleanLockTest blt = new BooleanLockTest();</span></span><br><span class="line"><span class="comment">        IntStream.range(0, 2)</span></span><br><span class="line"><span class="comment">                .mapToObj(i -&gt; new Thread(blt::syncMethod,&quot;Thread&quot;+i))</span></span><br><span class="line"><span class="comment">                .forEach(Thread::start);*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li><p>介绍了wait 和notify方法的使用，以及注意事项，比如：</p>
<ul>
<li>wait 和notify方法必须在同步方法中使用，且当前线程必须拥有锁，才可以</li>
<li>同步代码的monitor 必须与执行  wait  notify方法的对象一致，简单来说就是 <strong>用哪个对象的 monitor 进行同步，就只能用哪个对象 进行wait 和 notify操作。</strong></li>
<li>不能使用空对象（null）作为 monitor</li>
</ul>
</li>
<li><p>生产者与消费者模型是多线程开发最常用的模型之一，也是多线程间 通信的最好范例</p>
</li>
<li><p>讲诉了wait set线程休息室的概念，以及调用notify 和 notifyAll 对wait set的影响</p>
</li>
<li><p>synchronized同步方法的缺点：</p>
<ul>
<li>不可以中断</li>
<li>无法超时</li>
</ul>
</li>
<li><p>通过synchronized的缺点，只定义开发了一个BooleanLock锁，其功能包括：</p>
<ul>
<li>synchronized关键字的互斥访问 共享资源</li>
<li>增加了可中断功能</li>
<li>增加了 可超时功能</li>
<li>增加了 tryLock功能</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">java高并发详解-04-线程安全与数据同步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-18 23:56:02" itemprop="dateCreated datePublished" datetime="2021-02-18T23:56:02+08:00">2021-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>从字节码指令维度掌握 synchronized 关键字的原理,以及互斥同步的 流程</li>
<li>还有一点很重要的是,通过画时序图 分析数据不一致的场景 和原因</li>
</ul>
<h1 id="4-1数据同步-Todo"><a href="#4-1数据同步-Todo" class="headerlink" title="4.1数据同步(Todo)"></a>4.1数据同步(Todo)</h1><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源:"></a>共享资源:</h3><p>多个线程同时对同一份资源进行访问(读写操作),被多个线程访问的资源,<strong>就称为共享资源</strong></p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>如何保证多个线程访问到的数据是一致的,则被称为<strong>数据同步或者资源同步</strong></p>
<h3 id="4-1-1-数据不一致问题的引入"><a href="#4-1-1-数据不一致问题的引入" class="headerlink" title="4.1.1 数据不一致问题的引入"></a>4.1.1 数据不一致问题的引入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindownRunnableError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;的号码是：&quot;</span> + (index++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TicketWindownRunnableError task = <span class="keyword">new</span> TicketWindownRunnableError();</span><br><span class="line">        Thread 一号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;一号窗口&quot;</span>);</span><br><span class="line">        Thread 二号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;二号窗口&quot;</span>);</span><br><span class="line">        Thread 三号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;三号窗口&quot;</span>);</span><br><span class="line">        Thread 四号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;四号窗口&quot;</span>);</span><br><span class="line">        一号窗口.start();</span><br><span class="line">        二号窗口.start();</span><br><span class="line">        三号窗口.start();</span><br><span class="line">        四号窗口.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h4><p>多次运行上面程序，会大致出现3类问题，具体如下：</p>
<ul>
<li>某个号码被略过，没有出现</li>
<li>某个号码被多次显示</li>
<li>号码超过了最大值500</li>
</ul>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;的号码是：&quot;</span> + (index++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-号码被掠过"><a href="#1-号码被掠过" class="headerlink" title="1. 号码被掠过"></a>1. 号码被掠过</h5><p>线程的执行是由CPU时间片轮询调度的，假设此时线程1.线程2 都执行到了index =65 的位置，其中线程2 将index 修改为66后未输出前，cpu调度将执行权力交给了线程1，线程1 将其累加到了 67， 那么66就被忽略了</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=65
Thread1 ->> Thread1 :thread 停顿
Thread2 ->> Thread2 : index+1 =65+1
Thread2 ->> Thread2 : index=66
Thread2 ->> Thread2 : thread停顿,问题点，此处忽略了print66，
Thread1 ->> Thread1 :index+1=66+1
Thread1 ->> Thread1 :index=67
Thread1 ->> Thread1 :print 67
Thread1 ->> Thread1 : index+1=67+1
Thread1 ->> Thread1 :index=68
Thread1 ->> Thread1 : print 68</pre>



<h5 id="2-号码重复出现"><a href="#2-号码重复出现" class="headerlink" title="2. 号码重复出现"></a>2. 号码重复出现</h5><p>线程1 执行index+1，然后cpu 执行权落入线程2手里，由于线程1 并没有给index 赋值301， 所以线程2 执行index+1的 结果也是 301，</p>
<p>所以出现了 重复号码的情况</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=300
Thread1 ->> Thread1 :index +1=300+1
Thread1 ->> Thread1 : 线程停顿
Thread2 ->> Thread2 : index+1 =300+1
Thread2 ->> Thread2 : index=301
Thread1 ->> Thread1 : index=301
Thread1 ->> Thread1 : print 301
Thread2 ->> Thread2 : 问题点-print 301</pre>

<h5 id="3-号码超过了最大值"><a href="#3-号码超过了最大值" class="headerlink" title="3. 号码超过了最大值"></a>3. 号码超过了最大值</h5><p>当 index=499 的时候，线程1 和线程2 都看到条件满足。线程2短暂停顿，线程1 将index增加到了500，线程2恢复运行后，又将 500+1 ，此时就出现了超过MAX 的情况。</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=499
Thread1 ->> Thread1 :进入while 循环条件满足
Thread2 ->> Thread2 :进入while 循环条件满足
Thread1 ->> Thread1 : index+1 =499+1
Thread2 ->> Thread2 : 线程停顿
Thread1 ->> Thread1 : index=500
Thread1 ->> Thread1 : print 500
Thread2 ->> Thread2 : index+1=500+1
Thread2 ->> Thread2 : index =501
Thread2 ->> Thread2 : 问题点-print 501</pre>

<h1 id="4-2-初始synchronized关键字"><a href="#4-2-初始synchronized关键字" class="headerlink" title="4.2 初始synchronized关键字"></a>4.2 初始synchronized关键字</h1><h2 id="4-2-1-什么是synchronized"><a href="#4-2-1-什么是synchronized" class="headerlink" title="4.2.1 什么是synchronized"></a>4.2.1 什么是synchronized</h2><p>JDK官网对synchronized关键字的权威解释：</p>
<p>Synchronized keyword enable a simple strategy for preventing thread interference and memory consistency errors:  if an object is visible to more than one thread,all reads or writes to that object’s  variables are done through synchronized methods.</p>
<p>Synchronized关键字启用了一种简单的策略来防止线程干扰和内存一致性错误:如果一个对象对多个线程可见，那么对该对象变量的所有读或写操作都通过Synchronized同步的方法完成。 </p>
<p>同步互斥： 互斥是方式，同步是结果</p>
<p>具体表现为：</p>
<ul>
<li>synchronized 关键字提供了一种锁机制，能够确保共享变量的互斥访问，从而防止数据不一致问题的出现</li>
<li>synchronized 关键字包括 monitor enter 和 monitor exit 两个JVM 指令，它能够保证在任何时候任何线程执行到 monitor enter成功之前都必须从主内存获取数据，而不是从缓存中， 在monitor exit运行成功之后，共享变量被更新后的值 必须刷入回之内存 （简单来说，就是 执行 monitor enter之前，从主内存中获取共享变量的值，在执行 monitor exit之后，将更新后的共享变量的值 同步回主内存，解决缓存一致性的问题）</li>
<li>synchronized 的指令严格遵守 java 的先行发生原则（happens-before），一个monitor exit 指令之前 一定由一个 monitor enter 指令，成对出现 。</li>
</ul>
<h2 id="4-2-2-synchronized-关键字的用法"><a href="#4-2-2-synchronized-关键字的用法" class="headerlink" title="4.2.2 synchronized 关键字的用法"></a>4.2.2 synchronized 关键字的用法</h2><p>synchronized 可以用于对 方法块 或者方法进行修饰， 不能够用于对class 或者变量进行修饰</p>
<h3 id="1-同步方法"><a href="#1-同步方法" class="headerlink" title="1. 同步方法"></a>1. 同步方法</h3><p>同步方法的语法  ： [default | public | private | protected] <strong>synchronized</strong> [static ] type methods().</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticSync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2. 同步代码块"></a>2. 同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object MUTEX=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(MUTEX)&#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-深入理解synchronized关键字"><a href="#4-3-深入理解synchronized关键字" class="headerlink" title="4.3 深入理解synchronized关键字"></a>4.3 深入理解synchronized关键字</h2><ul>
<li>synchronized 提供了一种互斥机制，在同一时刻，只能由一个线程访问同步资源</li>
<li>不应该将MUTEX称为锁，严谨的说法，应该是 某线程 获取到了 MUTEX关联的 monitor锁</li>
</ul>
<h3 id="Monitor-enter"><a href="#Monitor-enter" class="headerlink" title="Monitor enter"></a>Monitor enter</h3><p>每个对象都与一个monitor 相关联，一个monitor的lock的锁 只能被一个线程在同一时间获得，在一个线程尝试获得与 对象关联monitor的所有权时候回发生如下几件事情。</p>
<ul>
<li>如果monitor 的计数器为0，则意味着 该monitor的lock 还没有被获得，某个线程获得之后 将立即对该计数器加一 ，从此该线程就是这个monitor 的所有者了</li>
<li>如果一个已经拥有该monitor所有权的线程重入 ，则会导致 monitor计数器再次累加</li>
<li>如果monitor已经被其他线程 所拥有，则 其他线程尝试获取该monitor 的所有权时，会被陷入阻塞状态知道monitor计数器 变为0，才能再次尝试 获取对 monitor的所有权 。</li>
</ul>
<h3 id="Monitor-exit"><a href="#Monitor-exit" class="headerlink" title="Monitor exit"></a>Monitor exit</h3><ul>
<li>释放对 monitor的所有权，想要释放对 某个对象关联的 monitor的所有权的前提是 ，你曾经获得了所有权。</li>
<li>释放monitor锁的过程比较简单，就是将 monitor的计数器减一， </li>
<li>如果monitor的计数器 结果为0，那就意味着 该线程不再拥有对 该monitor的所有权，通俗的讲 就是解锁。</li>
<li>与此同时，被该 monitor block的线程将再次尝试 获得对该monitor的所有权</li>
</ul>
<h3 id="使用-synchronized需要注意的问题"><a href="#使用-synchronized需要注意的问题" class="headerlink" title="使用 synchronized需要注意的问题"></a>使用 synchronized需要注意的问题</h3><ul>
<li>与monitor关联的对象不能为空,  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mutex=<span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">        、、、</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">每一个对象和一个 monitor 关联，对象都为<span class="keyword">null</span>了，monitor 肯定无从谈起</span><br></pre></td></tr></table></figure>

<ul>
<li>synchronized作用域太大，synchronized 应该尽可能地只作用于  <strong>共享资源地读写作用域</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">由于<span class="keyword">synchronized</span> 关键字存在排他性，也就是所有线程必须串行的经过<span class="keyword">synchronized</span>保护的共享区域，</span><br><span class="line">    如果<span class="keyword">synchronized</span> 作用域越大，则代表其效率越低，甚至丧失并发的优势</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不同的monitor 企图锁相同的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mutex=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">         <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">        、、、</span><br><span class="line">   	 &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(Task::<span class="keyword">new</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造了5个线程，同时也构造了5个 Runnable实例， Runnable作为逻辑单元传递给Thread，然后将发现：</span></span><br><span class="line"><span class="keyword">synchronized</span> 无法同步互斥， 因为 线程之间的monitor lock争抢只能发生在 monitor 关联的同一个引用上。</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>多个锁的交叉导致死锁</li>
</ul>
<h3 id="4-4-This-Monitor和Class-Monitor"><a href="#4-4-This-Monitor和Class-Monitor" class="headerlink" title="4.4 This Monitor和Class Monitor"></a>4.4 This Monitor和Class Monitor</h3><p>synchronized 的用法可以从两个维度上面分类：</p>
<h3 id="1-根据修饰对象分类"><a href="#1-根据修饰对象分类" class="headerlink" title="1.根据修饰对象分类"></a>1.根据修饰对象分类</h3><p>synchronized 可以修饰方法和代码块</p>
<ul>
<li>修饰代码块<ul>
<li>synchronized(this|object) {}</li>
<li>synchronized(类.class) {}</li>
</ul>
</li>
<li>修饰方法<ul>
<li>修饰非静态方法</li>
<li>修饰静态方法</li>
</ul>
</li>
</ul>
<h2 id="2-根据获取的锁分类"><a href="#2-根据获取的锁分类" class="headerlink" title="2. 根据获取的锁分类"></a>2. 根据获取的锁分类</h2><ul>
<li><p>获取对象锁</p>
<ul>
<li>synchronized(this|object) {}</li>
<li>修饰非静态方法</li>
</ul>
</li>
<li><p>获取类锁</p>
<ul>
<li>synchronized(类.class) {}</li>
<li>修饰静态方法，非静态方法</li>
</ul>
</li>
</ul>
<h4 id="This-Monitor（-对象锁）"><a href="#This-Monitor（-对象锁）" class="headerlink" title="This Monitor（ 对象锁）:"></a>This Monitor（ 对象锁）:</h4><ul>
<li>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，<strong>通常会被称为“内置锁”或“对象锁”</strong>。<strong>类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</strong></li>
</ul>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>synchronized 关键字修饰了同一个实例对象的两个不同方法，那么与之对应的monitor 是什么？ 两个 monitor是否一致呢。</p>
<p>实例锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisMonitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getName() + <span class="string">&quot; enter to method1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(currentThread().getName() + <span class="string">&quot; enter to method2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThisMonitor thisMonitor = <span class="keyword">new</span> ThisMonitor();</span><br><span class="line">        <span class="keyword">new</span> Thread(thisMonitor::method1, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thisMonitor::method2, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/thread-thisMonitor.png"></p>
<p><img src="/uploads/java-concurrency-master/thread-thisMonitor2.png"></p>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul>
<li>由上图可以看出 T1获取了 monitor lock  并处于休眠状态，而 T2 线程企图获取 monitor 的lock时陷入了 BLOCKED 状态，可见 使用synchronized 关键字同步类的不同实例方法，争抢的时 同一个monitor的lock ，而 与之关联的引用则是 ThisMonitor 的实例引用</li>
<li>其中 method1 保持方法同步的方式，method2 则采用了同步代码块 的方式，并且使用的是 this的monitor</li>
</ul>
<p>when a thread invokes a synchronized method, it automatically acquires the intrinsic lock  for that method’s object and releases it when the method returns .  The lock release occurs even if the return was caused by an uncaught exception .</p>
<h4 id="Class-Monitor（类锁）"><a href="#Class-Monitor（类锁）" class="headerlink" title="Class Monitor（类锁）:"></a>Class Monitor（类锁）:</h4><ul>
<li>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</li>
</ul>
<p>对象锁，static修饰 ,有两个类方法（静态方法）分别使用 synchronized对其进行同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassMonitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getName() + <span class="string">&quot; enter to method1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ClassMonitor.class)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(currentThread().getName() + <span class="string">&quot; enter to method2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(ClassMonitor::method1, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ClassMonitor::method2, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/thread-classMonitor.png"></p>
<p><img src="/uploads/java-concurrency-master/thread-classMonitor2.png"></p>
<ul>
<li> 从上图可以看出 用synchronized 同步某个类的不同静态方法争抢的也是 同一个 monitor的lock ，</li>
<li>与 This monitor 信息不一样的地方在于 （a java.lang.Class for ……..）</li>
<li>由此推断与 该 monitor关联的引用是 ClassMonitor.class  实例</li>
</ul>
<p>since  a static method is associated with a class, not an object  . In this case, the thread acquires the intrinstic lock for the Class  object associated with the class . Thus access to class’s static fields is controlled by a lock that’s distinct from the lock for any instance of the class .</p>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><ul>
<li><strong>对于非静态方法，同一个实例的线程访问会被拦截，非同一实例可以同时访问。 即此时是默认对象锁（this）。</strong></li>
<li><strong>静态方法默认类锁。</strong></li>
<li><strong>对于静态方法，由于此时对象还未生成，所以只能采用类锁；</strong></li>
<li><strong>只要采用类锁，就会拦截所有线程，只能让一个线程访问。</strong></li>
<li><strong>对于对象锁（this），如果是同一个实例，就会按顺序访问，但是如果是不同实例，就可以同时访问。</strong></li>
<li><strong>如果对象锁跟访问的对象没有关系，那么就会都同时访问。</strong></li>
</ul>
<h3 id="4-5-程序死锁的原因以及如何诊断"><a href="#4-5-程序死锁的原因以及如何诊断" class="headerlink" title="4.5 程序死锁的原因以及如何诊断"></a>4.5 程序死锁的原因以及如何诊断</h3><ol>
<li><p>交叉锁可导致程序出现死锁</p>
<p>典型的哲学家吃面问题，</p>
</li>
<li><p>内存不足</p>
<p>当并发请求系统可用内存时，如果此时系统内存不足，则可能会出现死锁的情况，举个例子，两个线程 T1 和 T2，执行某个任务，其中T1 已经获取了10MB内存， T2 获取了20MB内存，如果每个线程都需要30MB的内存，但是剩余可用内存刚好为20MB，那么两个线程 有可能都在等待彼此能够释放内存资源。</p>
</li>
<li><p>一问一答式的数据交换</p>
</li>
<li><p>数据库锁</p>
<p>无论是数据库表级别的锁，还是行级别的锁， 比如 某个线程执行 for update语句退出了事务，其他线程访问该数据库时 都将陷入死锁。</p>
</li>
<li><p>文件锁</p>
<p>某线程获得了文件锁意外退出，其他读取该文件的线程也将会 进入死锁知道系统释放文件句柄资源</p>
</li>
<li><p>死循环引起的死锁</p>
</li>
</ol>
<h4 id="死锁诊断"><a href="#死锁诊断" class="headerlink" title="死锁诊断"></a>死锁诊断</h4><ol>
<li>交叉锁引起的死锁</li>
</ol>
<ul>
<li>打开jstack 工具或者 jconsole工具，一般交叉锁引起的死锁线程都会进入 BLOCKED状态，CPU资源占用不高，很容易借助工具来发现</li>
</ul>
<p><img src="/uploads/java-concurrency-master/deadLock_read.png"></p>
<p><img src="/uploads/java-concurrency-master/deadLock_write.png"></p>
<ol start="2">
<li>死循环引起的死锁（假死）</li>
</ol>
<ul>
<li>工作的线程并未BLOCKED ,而是始终处于 RUNNABLE状态，CPU使用率高居不下，</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><p>synchronized 关键字在Java 中提供了同步语义，它可以保证在同一时间 只允许一个线程访问 共享数据资源。</p>
</li>
<li><p>本章介绍了synchronized的详细用法，修饰 方法，或者修饰代码块，</p>
<ul>
<li>如果修饰的是  static 方法或者static 方法快，那么 使用的就是 CLASS monitor，是 class 实例的monitor</li>
<li>如果修饰的不带static ，那就是 this monitor，使用的是某个对象的 monitor</li>
</ul>
</li>
<li><p>介绍死锁场景，以及定位死锁问题</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java高并发详解-03-ThreadAPI详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-18 13:25:17" itemprop="dateCreated datePublished" datetime="2021-02-18T13:25:17+08:00">2021-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程sleep"><a href="#线程sleep" class="headerlink" title="线程sleep"></a>线程sleep</h2><p>sleep是一个静态方法，其中有两个重载方法，其中一个需要传入毫秒数，另外一个既需要毫秒数也需要纳秒数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">     * execution) for the specified number of milliseconds, subject to</span></span><br><span class="line"><span class="comment">     * the precision and accuracy of system timers and schedulers. The thread</span></span><br><span class="line"><span class="comment">     * does not lose ownership of any monitors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">     * execution) for the specified number of milliseconds plus the specified</span></span><br><span class="line"><span class="comment">     * number of nanoseconds, subject to the precision and accuracy of system</span></span><br><span class="line"><span class="comment">     * timers and schedulers. The thread does not lose ownership of any</span></span><br><span class="line"><span class="comment">     * monitors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  nanos</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> 0-999999&#125; additional nanoseconds to sleep</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative, or the value of</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@code</span> nanos&#125; is not in the range &#123;<span class="doctag">@code</span> 0-999999&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">            millis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(millis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>sleep方法会使得当前线程进入指定毫秒数的休眠，暂停执行，虽然给定一个休眠时间，但是最终要以系统的定时器和调度器的精度为准。</strong></p>
</li>
<li><p><strong>sleep 期间不会放弃 monitor 锁的所有权</strong> </p>
</li>
</ul>
<h3 id="使用TimeUnit-替代-Thread-sleep"><a href="#使用TimeUnit-替代-Thread-sleep" class="headerlink" title="使用TimeUnit 替代 Thread.sleep"></a>使用TimeUnit 替代 Thread.sleep</h3><ul>
<li>在JDK引入了一个枚举 TimeUnit，其对 sleep 方法提供了很好的封装。</li>
<li>强烈建议，使用TimeUnit代替 直接使用Thread.sleep()</li>
</ul>
<h2 id="线程yield"><a href="#线程yield" class="headerlink" title="线程yield"></a>线程yield</h2><ul>
<li>Thread.yeild 线程礼让，当前线程暂时不跑了，让其他线程先跑。类似于你去银行排队办事情，你跑到最后去重新拿个号重新排队。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A hint to the scheduler that the current thread is willing to yield</span></span><br><span class="line"><span class="comment">   * its current use of a processor. The scheduler is free to ignore this</span></span><br><span class="line"><span class="comment">   * hint.</span></span><br><span class="line"><span class="comment">   * // 意思是，给了调度器scheduler一个提示，我愿意让出当前的处理器processor给其他人，但是人家processor未必搭理你这个暗示。</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span></span><br><span class="line"><span class="comment">   * between threads that would otherwise over-utilise a CPU. Its use</span></span><br><span class="line"><span class="comment">   * should be combined with detailed profiling and benchmarking to</span></span><br><span class="line"><span class="comment">   * ensure that it actually has the desired effect.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   这个例子就是通过yield方法来实现两个线程的交替执行。</span></span><br><span class="line"><span class="comment"> 		不过请注意：这种交替并不一定能得到保证，源码中也对这个问题进行说明：</span></span><br><span class="line"><span class="comment"> 		主要说明了三个问题：</span></span><br><span class="line"><span class="comment"> 　　调度器可能会忽略该方法。</span></span><br><span class="line"><span class="comment"> 　　使用的时候要仔细分析和测试，确保能达到预期的效果。</span></span><br><span class="line"><span class="comment"> 　　很少有场景要用到该方法，主要使用的地方是调试和测试。　　</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span></span><br><span class="line"><span class="comment">   * for debugging or testing purposes, where it may help to reproduce</span></span><br><span class="line"><span class="comment">   * bugs due to race conditions. It may also be useful when designing</span></span><br><span class="line"><span class="comment">   * concurrency control constructs such as the ones in the</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> java.util.concurrent.locks&#125; package.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>yield方法属于一种<strong>启发式的方法</strong>，会提醒调度器 我愿意放弃当前CPU资源，如果CPU资源不紧张，则会忽略这种提醒</p>
</li>
<li><p>调用 yield 方法 会使当前线程从 ＲＵＮＮＩＮＧ　状态切换到　ＲＵＮＮＡＢＬＥ</p>
</li>
<li><p>yield 只是一个提示(hint),cpu 调度器并不会担保每次都能满足 yield提示.</p>
<h3 id="yield-和-sleep"><a href="#yield-和-sleep" class="headerlink" title="yield 和 sleep"></a>yield 和 sleep</h3><ul>
<li>sleep 会导致当前线程暂停指定的时间,没有CPU时间片的消耗</li>
<li>yield 只是对CPU调度器的一个提示,如果CPU调度器没有忽略这个提示, 他会导致线程上下文的切换.(因为当前线程愿意让出自己的资源)</li>
<li>sleep会使 线程短暂block ,会在给定的时间内释放 CPU资源 </li>
<li>yield 会使 RUNNING状态的Ｔｈｒｅａｄ　进入　ＲＵＮＮＡＢＬＥ状态(如果CPU调度器没有忽略这个提示的话)</li>
<li>sleep几乎百分百地完成了给定时间的休眠,而 yield 的提示并不能一定担保</li>
<li>一个线程sleep 另一个线程调用interrupt 会捕获到中断信号,而 yield 则不会</li>
<li><strong>yield 方法和同步没关系，也就是和ObjectMonitor没关系，你硬上锁就是在唱独角戏 ( _05_03_YieldTest）</strong></li>
</ul>
</li>
</ul>
<h2 id="设置线程的优先级"><a href="#设置线程的优先级" class="headerlink" title="设置线程的优先级"></a>设置线程的优先级</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Changes the priority of this thread.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called</span></span><br><span class="line"><span class="comment">  * with no arguments. This may result in throwing a</span></span><br><span class="line"><span class="comment">  * &lt;code&gt;SecurityException&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Otherwise, the priority of this thread is set to the smaller of</span></span><br><span class="line"><span class="comment">  * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted</span></span><br><span class="line"><span class="comment">  * priority of the thread&#x27;s thread group.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">     ThreadGroup g;</span><br><span class="line">     checkAccess();</span><br><span class="line">     <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">             newPriority = g.getMaxPriority();</span><br><span class="line">         &#125;</span><br><span class="line">         setPriority0(priority = newPriority);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns this thread&#x27;s priority.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  this thread&#x27;s priority.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #setPriority</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> priority;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>理论上优先级高的线程会优先获取到  被cpu调度的机会,但是<strong>这个优先级 和yield一样,同样只是一个  hint(提示)</strong></p>
</li>
<li><p>对于root用户,他会 hint  系统你想要设置的优先级别, 否则他会被忽略</p>
</li>
<li><p>如果CPU比较忙,设置优先级可能会获得更多的CPU时间片,但是 在闲时优先级的高低几乎不会有任何作用</p>
</li>
<li><p><strong>不要在程序设计当中企图使用线程优先级绑定某些特定的业务,或者让业务严重依赖线程优先级</strong></p>
</li>
<li><p>线程优先级 区间范围为 [1,10],如果不在该区间 则 抛出异常</p>
</li>
<li><p>如果set设置的优先级大于 ThreadGroup的优先级, 则以 ThreadGroup为准 .</p>
</li>
<li><p>线程默认的优先级与父类保持一致, 一般情况下是 5,因为main线程的优先级就是5,所以它派生出来的线程都是5.</p>
</li>
</ul>
<h2 id="获取线程唯一ID"><a href="#获取线程唯一ID" class="headerlink" title="获取线程唯一ID"></a>获取线程唯一ID</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the identifier of this Thread.  The thread ID is a positive</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;long&lt;/tt&gt; number generated when this thread was created.</span></span><br><span class="line"><span class="comment">   * The thread ID is unique and remains unchanged during its lifetime.</span></span><br><span class="line"><span class="comment">   * When a thread is terminated, this thread ID may be reused.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> this thread&#x27;s ID.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> tid;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程的ID在整个JVM进程中都会是唯一的,并且是从 0开始逐次递增.</li>
<li>如果在main方法(main线程)中创建了一个唯一的线程,并且调用getid方法 后发现返回结果并不等于0 ,不必惊讶,因为一个JVM启动时候,实际上已经开辟了很多个线程.自增序列已经有所增加了,所以我们创建的并非是第0号线程</li>
</ul>
<h2 id="获取当前线程"><a href="#获取当前线程" class="headerlink" title="获取当前线程"></a>获取当前线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a reference to the currently executing thread object.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  the currently executing thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>currentThread() 用于返回当前执行线程的引用,这个方法虽然很简单,但是使用非常广泛,</li>
</ul>
<h2 id="设置线程上下文类加载器"><a href="#设置线程上下文类加载器" class="headerlink" title="设置线程上下文类加载器"></a>设置线程上下文类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/* The context ClassLoader for this thread */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader contextClassLoader;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        contextClassLoader = cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (contextClassLoader == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                                   Reflection.getCallerClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contextClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>getContextClassLoader ()<ul>
<li>获取线程上下文的类加载器, 简单来说就是这个线程是由哪个类加载器加载的.</li>
<li>如果在没有修改线程上下文类加载器的情况下,则保持与父类同样的类加载器</li>
</ul>
</li>
<li>setContextClassLoader(ClassLoader cl) 设置该线程的类加载器,<ul>
<li>该方法可以打破java类加载的双亲加载(父委托机制),有时候也称为 <strong>Java类加载器的后门</strong></li>
<li>后续会有专门的讲解</li>
</ul>
</li>
</ul>
<h2 id="线程interrupt"><a href="#线程interrupt" class="headerlink" title="线程interrupt"></a>线程interrupt</h2><p><strong>中断线程阻塞</strong></p>
<p><strong>这是一个 非常重要的API</strong>,也是经常使用的方法,与线程中断的API有如下几个,我们通过源码详解解析</p>
<ul>
<li>public void interrupt() </li>
<li>public static boolean interrupted()</li>
<li>public boolean isInterrupted()</li>
</ul>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Interrupts this thread.(打断这个线程)   </span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Unless the current thread is interrupting itself, which is</span></span><br><span class="line"><span class="comment">     * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     * of this thread is invoked, which may cause a &#123;@link</span></span><br><span class="line"><span class="comment">     * SecurityException&#125; to be thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link</span></span><br><span class="line"><span class="comment">     * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link</span></span><br><span class="line"><span class="comment">     * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;</span></span><br><span class="line"><span class="comment">     * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link</span></span><br><span class="line"><span class="comment">     * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,</span></span><br><span class="line"><span class="comment">     * methods of this class, then its interrupt status will be cleared and it</span></span><br><span class="line"><span class="comment">     * will receive an &#123;@link InterruptedException&#125;.</span></span><br><span class="line"><span class="comment">     // 如果当前线程被阻塞了由于调用下面这些什么Object的wait或者Thread的 sleep .join方法,</span></span><br><span class="line"><span class="comment">     然后它的中断状态将被清除 会收到&#123;@link InterruptedException&#125;。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span></span><br><span class="line"><span class="comment">     * then the channel will be closed, the thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">     * status will be set, and the thread will receive a &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.ClosedByInterruptException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125;</span></span><br><span class="line"><span class="comment">     * then the thread&#x27;s interrupt status will be set and it will return</span></span><br><span class="line"><span class="comment">     * immediately from the selection operation, possibly with a non-zero</span></span><br><span class="line"><span class="comment">     * value, just as if the selector&#x27;s &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">     * status will be set. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果 当前线程正处于 阻塞状态,调用 interrupt方法,则可以 <strong>中断打断这个阻塞</strong></p>
</li>
<li><p>是线程进入阻塞的方法有:</p>
<ul>
<li><p>Object的 wait 方法 以及变形的 重载的方法:wait (long)    和wait (long,int)</p>
</li>
<li><p>Thread 的sleep(long)方法,以及 重载的方法</p>
</li>
<li><p>Thread的join方法 以及重载的方法</p>
</li>
<li><p>InterruptibleChannel 的io操作</p>
</li>
<li><p>Selector 的wakeup方法</p>
</li>
<li><p>其他方法</p>
<ul>
<li>以上的方法都会使得当前线程进入阻塞状态.如果另外一个线程调用被阻塞线程的 interrupt 方法,则会打破这种阻塞 .</li>
<li>打断一个线程并不等于该线程的生命周期结束,仅仅是 打断了当前线程的阻塞状态</li>
<li>一个线程在阻塞的情况下被打断,会抛出一个 InterruptedException 的异常,这个异常就像一个 signal 一样通知当前线程被打断了 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="interrupt源码解析"><a href="#interrupt源码解析" class="headerlink" title="interrupt源码解析"></a>interrupt源码解析</h3><ul>
<li>一个线程内存存在着名为 interrupt flag的标识,如果一个 线程被interrupt ,那么它的 flag 将被设置</li>
<li>通过源码可以看到Thread中存在一个私有方法: <strong>interrupt0();           // Just to set the interrupt flag</strong>“,该方法作用是  修改interrupt flag</li>
<li>如果一个线程已经是 死亡Terminated 状态,那么尝试对其的interrupt 会直接被忽略\</li>
</ul>
<h3 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted"></a>isInterrupted</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">    * status&lt;/i&gt; of the thread is unaffected by this method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment">    * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment">    * returning false.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span></span><br><span class="line"><span class="comment">    *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #interrupted()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">    * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">    * passed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要判断当前线程是否被中断,该方法仅仅是对 interrupt flag 的一个判断,并不会影响改变 interrupt flag的值</li>
<li>可中断方法捕获到了中断信号(signal) 之后,也就是捕获了InterruptedException 异常之后,会擦除interrupt的标识.</li>
<li>可中断方法捕获到了中断信号后,为了不影响线程中的其他方法的执行,将线程的interrupt flag标识复位 ,很合理的 设计</li>
</ul>
<h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted"></a>interrupted</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests whether the current thread has been interrupted.  The</span></span><br><span class="line"><span class="comment">    * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In</span></span><br><span class="line"><span class="comment">    * other words, if this method were to be called twice in succession, the</span></span><br><span class="line"><span class="comment">    * second call would return false (unless the current thread were</span></span><br><span class="line"><span class="comment">    * interrupted again, after the first call had cleared its interrupted</span></span><br><span class="line"><span class="comment">    * status and before the second call had examined it).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    测试当前线程是否已被中断的 . 这个线程的 &lt;中断状态&gt;被这个方法清除。</span></span><br><span class="line"><span class="comment">*换句话说，如果这个方法被连续调用两次，则第二个调用将返回false(</span></span><br><span class="line"><span class="comment">   除非当前线程被再一次 interrupted,在第一次调用后 已经清除了它自身 的interrupted status后再次被中断状态和第二次调用之前检查它</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment">    * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment">    * returning false.</span></span><br><span class="line"><span class="comment">    线程中断被忽略，因为线程不是活的中断的时间会被这个方法反映出来*返回false。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span></span><br><span class="line"><span class="comment">    *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isInterrupted()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">    * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">    * passed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用该方法会直接擦除掉线程的interrupt flag,</p>
</li>
<li><p>需要注意的是: 第一次调用interrupted方法会返回true ,并且立即擦除了interrupt flag;</p>
</li>
<li><p>第二次包括以后的调用永远都是返回false,除非在此期间又一次地被打断了 .</p>
</li>
</ul>
<h3 id="interrupted源码分析"><a href="#interrupted源码分析" class="headerlink" title="interrupted源码分析"></a>interrupted源码分析</h3><ul>
<li>isInterrupted() 方法和   interrupted()方法都调用了同一个 native方法 :isInterrupted(boolean ClearInterrupted);,                                                                 ClearInterrupted用来控制是否擦除线程的 interrupt flag</li>
<li>isInterrupted()的 参数为 false,表示 不想擦除</li>
<li>interrupt 静态方法中该参数为 true,表示想擦除 </li>
</ul>
<p>如果一个线程在没有执行可中断方法之前就被打断了,那么其接下来执行可中断方法,比如sleep 会发生什么情况呢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrupt</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//  1.判断当前线程是否被中断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread is interrupted? &quot;</span> + Thread.interrupted());</span><br><span class="line">        <span class="comment">// 2.中断当前线程</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="comment">//  3.判断当前线程是否被中断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread is interrupted? &quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//4. 当前线程执行可中断方法</span></span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 5.捕获中断信号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;I will be interrupted still.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果: </span><br><span class="line">Main thread is interrupted? <span class="keyword">false</span></span><br><span class="line">Main thread is interrupted? <span class="keyword">true</span></span><br><span class="line">I will be interrupted still.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明: 如果一个线程设置了 interrupt flag,那么接下来可中断方法 会立即中断,因此 注释5的信号捕获部分会被执行.</p>
<h2 id="线程Join"><a href="#线程Join" class="headerlink" title="线程Join"></a>线程Join</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment"> * way as the invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #join(long) join&#125;&#123;<span class="doctag">@code</span> (0)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment"> * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment"> * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment"> * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>join某个线程A(),会使当前线程B进入等待,直到线程A结束生命周期,或者到达给定的时间,</p>
<p>那么在此期间B线程是处于BLOCKED的,而不是A线程,</p>
<ul>
<li>join方法会使得当前线程永远的等待下去,知道期间被另外的线程中断,或者join的线程执行结束.</li>
<li>join的另外2个重载方法,指定毫秒数,在指定的时间到达之后,当前线程也会退出阻塞.</li>
</ul>
<h4 id="问题-如果一个线程已经结束了生命周期-那么调用它的join方法的当前线程会被阻塞吗"><a href="#问题-如果一个线程已经结束了生命周期-那么调用它的join方法的当前线程会被阻塞吗" class="headerlink" title="问题: 如果一个线程已经结束了生命周期,那么调用它的join方法的当前线程会被阻塞吗?"></a>问题: 如果一个线程已经结束了生命周期,那么调用它的join方法的当前线程会被阻塞吗?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">不会被阻塞</span><br></pre></td></tr></table></figure>

<ul>
<li><p> join() 和 sleep() 一样，可以被中断（被中断时，会抛出 InterrupptedException 异常）；</p>
</li>
<li><p>不同的是，join() 内部调用了 wait()，会出让锁，</p>
</li>
<li><p>而 sleep() 会一直保持锁。</p>
</li>
</ul>
<h3 id="join-的示例和作用"><a href="#join-的示例和作用" class="headerlink" title="join() 的示例和作用"></a>join() 的示例和作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建child对象，此时child表示的线程处于NEW状态</span></span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        <span class="comment">// child表示的线程转换为RUNNABLE状态</span></span><br><span class="line">        child.start();</span><br><span class="line">        <span class="comment">// 等待child线程运行完再继续运行</span></span><br><span class="line">        child.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码展示了两个类：Parent（父线程类），Child（子线程类）。</p>
<p>Parent.main()方法是程序的入口，通过 Child child = new Child(); 新建child子线程（此时 child子线程处于NEW状态）；</p>
<p>然后调用child.start()（child子线程状态转换为RUNNABLE）；</p>
<p>再调用child.join()，此时，Parent父线程会等待child子线程运行完再继续运行。</p>
<p>下图是我总结的 Java 线程状态转换图：</p>
<p><img src="/uploads/java-concurrency-master/thread-join.png"></p>
<h3 id="join-的作用"><a href="#join-的作用" class="headerlink" title="join() 的作用"></a>join() 的作用</h3><p>让父线程等待子线程结束之后才能继续运行</p>
<p>Waiting for the finalization of a thread</p>
<p>In some situations, we will have to wait for the finalization of a thread. For example, we may have a program that will begin initializing the resources it needs before proceeding with the rest of the execution. We can run the initialization tasks as threads and wait for its finalization before continuing with the rest of the program. For this purpose, we can use the join() method of the Thread class.   <strong><em>When we call this method using a thread object, it suspends the execution of the calling thread until the object called finishes its execution.</em></strong></p>
<p> 当我们调用某个线程的这个方法时，这个方法会挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。</p>
<h3 id="join源码分析"><a href="#join源码分析" class="headerlink" title="join源码分析:"></a>join源码分析:</h3><p>join() 一共有三个重载版本，分别是无参、一个参数、两个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptedException;</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">public final synchronized void join(long millis, int nanos) throws InterruptedException;</span><br></pre></td></tr></table></figure>



<p>其中</p>
<p>(1) 三个方法都被final修饰，无法被子类重写。</p>
<p>(2) join(long), join(long, long) 是synchronized method，同步的对象是当前线程实例。</p>
<p>(2) 无参版本和两个参数版本最终都调用了一个参数的版本。</p>
<p>(3) join() 和 join(0) 是等价的，表示一直等下去；join(非0)表示等待一段时间。</p>
<p><strong>从源码可以看到 join(0) 调用了Object.wait(0)，其中Object.wait(0) 会一直等待，直到被notify/中断才返回。</strong></p>
<p><strong>while(isAlive())是为了防止子线程伪唤醒(spurious wakeup)，只要子线程没有TERMINATED的，父线程就需要继续等下去。</strong></p>
<p>(4) join() 和 sleep() 一样，可以被中断（被中断时，会抛出 InterrupptedException 异常）；不同的是，join() 内部调用了 wait()，会出让锁，而 sleep() 会一直保持锁。</p>
<p><strong>以本文开头的代码为例，我们分析一下代码逻辑：</strong></p>
<ul>
<li><p>调用链：Parent.main() -&gt; child.join() -&gt; child.join(0) -&gt; child.wait(0)（此时 Parent线程会获得 child 实例作为锁，其他线程可以进入 child.join() ，但不可以进入 child.join(0)， 因为child.join(0)是同步方法）。</p>
</li>
<li><p>如果 child 线程是 Active，则调用 child.wait(0)（为了防止子线程 spurious wakeup, 需要将 wait(0) 放入 while(isAlive()) 循环中。</p>
</li>
<li><p>一旦 child 线程不为 Active （状态为 TERMINATED）, child.notifyAll() 会被调用-&gt; child.wait(0)返回 -&gt; child.join(0)返回 -&gt; child.join()返回 -&gt; Parent.main()继续执行, 子线程会调用this.notify()，child.wait(0)会返回到child.join(0) ，child.join(0)会返回到 child.join(), child.join() 会返回到 Parent 父线程，Parent 父线程就可以继续运行下去了。</p>
</li>
</ul>
<ul>
<li>子线程结束后，子线程的this.notifyAll()会被调用，join()返回，父线程只要获取到锁和CPU，就可以继续运行下去了</li>
<li>在调用 join() 方法的程序中，原来的多个线程仍然多个线程，<strong>并没有发生“合并为一个单线程”</strong>。真正发生的是调用 join() 的线程进入 TIMED_WAITING 状态，等待 join() 所属线程运行结束后再继续运行。</li>
</ul>
<h2 id="如何关闭一个线程"><a href="#如何关闭一个线程" class="headerlink" title="如何关闭一个线程"></a>如何关闭一个线程</h2><h3 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h3><ol>
<li><p>线程结束生命周期,正常结束</p>
</li>
<li><p>捕获中断信号 关闭线程</p>
<ul>
<li><p>通过new Thread的方式创建线程,这种方式看似简单,但是其实 派生成本是比较高的,因此在一个线程中往往会循环地执行某个任务,比如心跳检查,不断接收网络消息报文,系统决定退出地时候,可以借助中断线程地方式使其退出,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I will start work&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//working.</span></span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;I will be exiting.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;System will be shutdown.&quot;</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">线程中执行某个可中断方法,可以通过捕获中断信号来决定是否退出</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用volatile开关控制</p>
<p>由于线程的interrupt 标识 很有可能被擦除,或者逻辑单元不会调用任何可中断方法,</p>
<p>所以使用volatile修饰的开关 flag关闭线程也是一种常见做法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlagThreadExit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I will start work&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!closed &amp;&amp; !isInterrupted())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;i am working.&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;I will be exiting.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.closed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyTask t = <span class="keyword">new</span> MyTask();</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;System will be shutdown.&quot;</span>);</span><br><span class="line">        t.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="异常退出"><a href="#异常退出" class="headerlink" title="异常退出"></a>异常退出</h3><p>在一个线程的执行单元中,是不允许抛出 checked异常的, 如果线程在运行过程中,需要捕获checked 异常并且判断是否继续运行,</p>
<p>那么此时可以将checked异常封装成unchecked异常(RuntimeException) 抛出,进而 结束线程的生命周期</p>
<h3 id="系统假死"><a href="#系统假死" class="headerlink" title="系统假死"></a>系统假死</h3><p>绝大部分原因是因为某个线程阻塞了,或者线程出现了死锁 .</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>学习了Thread 的大多数API,主要分为2类,</li>
<li>一类是 获取线程的信息,如 getID,getName,getPriority,currThread</li>
<li>一类是阻塞以及中断阻塞 方法, sleep,join,  interrupt </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinshi</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"4oBiQGiWDHdACABLWjT7ouaV-gzGzoHsz","appKey":"fr4vMSPUjcHLtIrF2hmRF6UE","serverURLs":"https://4obiqgiw.lc-cn-n1-shared.com","placeholder":"国王不动，手下怎么跟随? --反叛的鲁鲁修","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"cdh":"https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"}, {
      el: '#valine-comments',
      path: "/page/2/",
      serverURLs: "https://4obiqgiw.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>


</body>
</html>
