<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="HCj467TtuvFkAzzdCvYvbniAeNiUy7TUwp2hG1qGWQE">
  <meta name="baidu-site-verification" content="LppFIbSdZO">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limingzhang666.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","width":320,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="拨开云雾见青天">
<meta property="og:type" content="website">
<meta property="og:title" content="Yinshi&#39;s Blog">
<meta property="og:url" content="https://limingzhang666.github.io/page/4/index.html">
<meta property="og:site_name" content="Yinshi&#39;s Blog">
<meta property="og:description" content="拨开云雾见青天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yinshi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://limingzhang666.github.io/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yinshi's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yinshi's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yinshi"
      src="/images/yinshi01_avatar.jpg">
  <p class="site-author-name" itemprop="name">Yinshi</p>
  <div class="site-description" itemprop="description">拨开云雾见青天</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/limingzhang666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limingzhang666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:laimingcham@163.com" title="E-Mail → mailto:laimingcham@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/limingzhang666" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">深入理解jvm-06-类文件结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-11 22:03:21" itemprop="dateCreated datePublished" datetime="2021-01-11T22:03:21+08:00">2021-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><h3 id="平台无关性："><a href="#平台无关性：" class="headerlink" title="平台无关性："></a>平台无关性：</h3><ul>
<li>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石</li>
</ul>
<h3 id="语言无关性："><a href="#语言无关性：" class="headerlink" title="语言无关性："></a>语言无关性：</h3><ul>
<li>Java技术发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，</li>
<li>他们在发布规范文档的时候，也刻意把Java的规范拆分成了：</li>
<li><strong><em>《Java语言规范》（The Java Language Specification）</em></strong></li>
<li><strong><em>及《Java虚拟机规范》（The Java Virtual Machine Specification）</em></strong></li>
</ul>
<p><strong><em>在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上”</em></strong><br><strong><em>（In the future，we will consider bounded extensions to the Java virtual machine to provide better support for other languages）</em></strong></p>
<ul>
<li><strong><em>作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，以Class文件作为他们产品的交付媒介。</em></strong></li>
</ul>
<p>例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把它们的源程序代码编译成Class文件。虚拟机丝毫不关心Class的来源是什么语言</p>
<ul>
<li>Java语言中的各种语法、关键字、常量变量和运算符号的语义 最终都会由多条字节码指令组合来表达 ，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。（类似于 java语言的功能只是 字节码功能的一个子集）</li>
<li>因此有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于java的语言特性提供了发挥空间</li>
</ul>
<p><img src="/uploads/jvm/08-JVM-nobindLanguage.png"></p>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>注意：</p>
<ul>
<li>任何一个Class文件都对应着唯一的一个类或接口的定义信息</li>
<li>类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）</li>
</ul>
<ul>
<li>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在</li>
<li>当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割成若干个8个字节进行存储。</li>
</ul>
<p><strong><em>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”</em></strong></p>
<ul>
<li>无符号数： 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表：  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</li>
</ul>
<p><img src="/uploads/jvm/09-jvm-wufahao-info.png"></p>
<ul>
<li>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</li>
</ul>
<h3 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h3><p>Class的结构不像XML等描述语言，由于它没有任何分隔符号，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>魔数：</p>
<ul>
<li><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件</p>
</li>
<li><p>使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动</p>
</li>
<li><p>Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE（咖啡宝贝？）</p>
</li>
<li><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，</p>
</li>
<li><p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul>
<li>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</li>
</ul>
<h4 id="常量池容量计数值"><a href="#常量池容量计数值" class="headerlink" title="常量池容量计数值"></a>常量池容量计数值</h4><ul>
<li><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）</p>
</li>
<li><p>与Java语言习惯不同，这个容量计数器从1开始，而不是从0开始。</p>
</li>
<li><p>之所以从1开始是因为 ：  在Class文件格式规范制定之时，设计者将第0项常量控出来是有特殊考虑，目的在于 <strong><em>当某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义 ，可以把索引值设置为0</em></strong>来表示。 </p>
</li>
<li><p>如下 图所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。</p>
<p><img src="/uploads/jvm/10-jvm-constantPool.png"></p>
</li>
</ul>
<h4 id="常量类型："><a href="#常量类型：" class="headerlink" title="常量类型："></a>常量类型：</h4><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p>
<ul>
<li><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p>
</li>
<li><p>符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
<h4 id="JVM动态连接"><a href="#JVM动态连接" class="headerlink" title="JVM动态连接"></a>JVM动态连接</h4><ul>
<li>在Class文件中不会保存各个方法、字段最终在内存中的布局信息</li>
<li>这些字段、方法的符号引用不经过虚拟机在运行期转换的话 是无法得到真正的内存入口地址，也就无法直接被虚拟机直接使用</li>
<li>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</li>
</ul>
<h4 id="常量池的项目类型"><a href="#常量池的项目类型" class="headerlink" title="常量池的项目类型"></a>常量池的项目类型</h4><ul>
<li>常量池中每一项常量都是一个表，</li>
<li>最初常量表中共有11种结构 各不相同的表结构数据，后来为了更好的支持动态语言调用，额外增加了4种动态语言相关的常量（）<ul>
<li>JDK 7时增加了前三种：<strong>CONSTANT_MethodHandle_info</strong>、<strong>CONSTANT_MethodType_info</strong>和<strong>CONSTANT_InvokeDynamic_info</strong>。出于性能和易用性的考虑（JDK 7设计时已经考虑到，预留了17个常量标志位），在JDK 11中又增加了第四种常量<strong>CONSTANT_Dynamic_info</strong>。</li>
</ul>
</li>
<li>为了支持Java模块化系统（Jigsaw），又加入了<strong>CONSTANT_Module_info</strong>和<strong>CONSTANT_Package_info</strong>两个常量</li>
<li>截至JDK13，常量表中分别有17种不同类型的常量。</li>
</ul>
<p><img src="/uploads/jvm/12-jvm-constantPool-projectType.png"></p>
<h4 id="常量结构："><a href="#常量结构：" class="headerlink" title="常量结构："></a>常量结构：</h4><ul>
<li>之所以说常量池时最烦琐的数据，是因为这<strong>17种常量类型各自有着完全独立的数据结构</strong>，两两之间被没有什么共性和联系</li>
</ul>
<h5 id="CONSTANT-Class-info"><a href="#CONSTANT-Class-info" class="headerlink" title="CONSTANT_Class_info"></a>CONSTANT_Class_info</h5><ul>
<li><p>回头看看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，</p>
</li>
<li><p>查表6-3的标志列可知这个常量属于<strong>CONSTANT_Class_info</strong>类型，此类型的常量代表一个<strong>类或者接口的符号引用</strong>。</p>
</li>
<li><p>CONSTANT_Class_info的结构比较简单，如表6-4所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>其中 tag 是标志位，它用于区分常量类型；</li>
<li>name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了整个类（或者接口）的全限定名。</li>
<li>本例中的 name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量。</li>
<li>继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个<strong>CONSTANT_Utf8_info</strong>类型的常量。</li>
</ul>
<h5 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a>CONSTANT_Utf8_info</h5><p> CONSTANT_Utf8_info 类型的结构如表6-5所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody></table>
<ul>
<li>length值说明了这个UTF-8编码的字符串长度是多少字节，</li>
<li>它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串</li>
<li>UTF-8缩略编码与普通UTF-8编码的区别是：<br>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，<br>从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符<br>的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</li>
<li>由于Class文件中方法、字段等都需要引用 CONSTANT_Utf8_info 型常量来描述名称，所以 CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度（length的最大值），即u2类型能表达的最大值65535。</li>
<li><strong><em>所以Java程序中如果定义了超过64KB</em></strong> 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</li>
</ul>
<h4 id="javap-工具"><a href="#javap-工具" class="headerlink" title="javap 工具"></a>javap 工具</h4><p>在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。</p>
<p>代码清单6-2中列出了使用javap工具的-verbose参数输出的TestClass.class文件字节码内容（为节省篇幅，此清单中省略了常量池以外的信息）。</p>
<p><strong><em>代码清单6-2　使用javap命令输出常量表</em></strong></p>
<p><img src="/uploads/jvm/13-jvm-constantPool-javap.png"></p>
<ul>
<li>从代码清单6-2中可以看到，计算机已经帮我们把整个常量池的21项常量都计算了出来</li>
<li>其中有些常量似乎从来没有在代码中出现过，如“I”“V”“<init>”“LineNumberTable”“LocalVariableTable”等，这些看起来在源代码中不存在的常量是哪里来的？</li>
<li>这部分常量的确不来源于Java源代码，它们都是编译器自动生成的。会被字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用，它们将会被用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么</li>
<li>因为Java中的“类”是无穷无尽的，无法通过简单的无符号数来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达</li>
</ul>
<h4 id="常量池中的17种数据类型的结构总表"><a href="#常量池中的17种数据类型的结构总表" class="headerlink" title="常量池中的17种数据类型的结构总表"></a>常量池中的17种数据类型的结构总表</h4><p><img src="/uploads/jvm/14-jvm-constantPool-01.png"></p>
<p><img src="/uploads/jvm/14-jvm-constantPool-02.png"></p>
<p><img src="/uploads/jvm/14-jvm-constantPool-03.png"></p>
<h3 id="访问标志（access-flags）"><a href="#访问标志（access-flags）" class="headerlink" title="访问标志（access flags）"></a>访问标志（access flags）</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access flags），这个标志用于识别一些类或者接口层次的访问信息。包括：</p>
<ul>
<li>这个Class是类还是接口</li>
<li>是否定义为public</li>
<li>是否定义为abstract类型</li>
<li>如果是类，是否被声明为final</li>
<li>等等，具体的标志位以及标志的含义见下：</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令的新语义，<br>invokespecial指令的语义在JDK1.0.2发生过改变，为了区别这条指令使用哪种语义，<br>JDK1.0.2之后编译出来的类 这个标志都必须为 真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口和抽象类来说，此标志为真，其他类型都是 假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识 这个类并非由用户代码产生的</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这是一个枚举</td>
</tr>
<tr>
<td>ACC_MODULE</td>
<td>0x8000</td>
<td>标识这是一个模块</td>
</tr>
</tbody></table>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><ul>
<li>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，</li>
<li>而接口索引集合（interfaces）是一组u2类型的数据的集合</li>
<li>Class文件中由这三项数据来确定该类型的继承关系</li>
</ul>
<h4 id="类索引："><a href="#类索引：" class="headerlink" title="类索引："></a>类索引：</h4><p>用于确定这个类的全限定名</p>
<h4 id="父类索引："><a href="#父类索引：" class="headerlink" title="父类索引："></a>父类索引：</h4><p>用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了<br>java.lang.Object外，所有Java类的父类索引都不为0</p>
<h4 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h4><p>用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>
<ul>
<li><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型CONSTANT_Class_info的类描述符常量，</p>
</li>
<li><p>通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</p>
</li>
</ul>
<p><img src="/uploads/jvm/15-jvm-class-index.png"></p>
<h3 id="字段表-field-info-集合"><a href="#字段表-field-info-集合" class="headerlink" title="字段表(field_info)集合"></a>字段表(field_info)集合</h3><ul>
<li>字段表（field_info）用于描述接口或者类中声明的变量。</li>
<li>Java语言中的“字段”（Field）包括**<em>类级变量以及实例级变量**</em>，</li>
<li>但**<em>不包括在方法内部声明的局部变量**</em></li>
</ul>
<h4 id="字段可以包括的修饰符有"><a href="#字段可以包括的修饰符有" class="headerlink" title="字段可以包括的修饰符有:"></a>字段可以包括的修饰符有:</h4><p>字段的作用域（public、private、protected修饰符）、是<strong>实例变量还是类变量（static修饰符）</strong>、可变性（final）、</p>
<p><strong>并发可见性（volatile修饰符，是否强制从主内存读写</strong>）、<strong>可否被序列化（transient修饰符</strong>）、字段数据类型（基本类型、对象、数组）、字段名称。</p>
<ul>
<li>字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li>
</ul>
<h4 id="字段表的最终格式"><a href="#字段表的最终格式" class="headerlink" title="字段表的最终格式:"></a>字段表的最终格式:</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如表6-9所示。</p>
<p>表6-9　字段访问标志<br><img src="/uploads/jvm/16-jvm-attribute-accessFlags.png"></p>
<p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符</p>
<h4 id="全限定名："><a href="#全限定名：" class="headerlink" title="全限定名："></a>全限定名：</h4><p>以代码清单6-1中的代码为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”号表示全限定名结束。</p>
<h4 id="简单名称："><a href="#简单名称：" class="headerlink" title="简单名称："></a>简单名称：</h4><p>简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</p>
<h4 id="描述符："><a href="#描述符：" class="headerlink" title="描述符："></a>描述符：</h4><ul>
<li><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p>
</li>
<li><p>根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，</p>
</li>
<li><p>而对象类型则用字符L加对象的全限定名来表示</p>
</li>
</ul>
<p><img src="/uploads/jvm/17-jvm-attribute-desc.png"></p>
<ul>
<li>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。</li>
<li>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，</li>
<li>方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</li>
</ul>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h4><ul>
<li><p><strong>字段表集合中不会列出从父类或者父接口中继承而来的字段</strong></p>
</li>
<li><p>但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</p>
</li>
<li><p>另外，在<strong>Java语言中字段是无法重载的</strong>，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，</p>
</li>
<li><p>但是<strong>对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法</strong>的</p>
</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul>
<li><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，</p>
</li>
<li><p>依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项</p>
</li>
</ul>
<p>表6-11　方法表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<ul>
<li>因为<strong>volatile关键字和transient关键字不能修饰方法</strong>，所以<strong>方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志</strong>。</li>
<li>与之相对，<strong>synchronized、native、strictfp和abstract关键字可以修饰方法</strong>，<strong>方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、</strong><br><strong>ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志</strong>。</li>
<li>对于方法表，所有标志位及其取值可参见表6-12。</li>
</ul>
<p><img src="/uploads/jvm/18-jvm-method_access_flag.png"></p>
<h4 id="方法里的代码去哪了"><a href="#方法里的代码去哪了" class="headerlink" title="方法里的代码去哪了"></a>方法里的代码去哪了</h4><ul>
<li>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了</li>
<li>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，</li>
<li>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器“<clinit>()”方法和实例构造器“<init>()”方法 </li>
</ul>
<h4 id="重载（-Java语言）"><a href="#重载（-Java语言）" class="headerlink" title="重载（ Java语言）"></a>重载（ Java语言）</h4><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名 。</p>
<h5 id="特征签名："><a href="#特征签名：" class="headerlink" title="特征签名："></a>特征签名：</h5><ul>
<li><p>指 一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名中，所以java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</p>
</li>
<li><p>但是 在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</p>
</li>
<li><p>Java代码的方法特征签名只包括方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表，</p>
</li>
</ul>
<h3 id="属性表（attribute-info）集合"><a href="#属性表（attribute-info）集合" class="headerlink" title="属性表（attribute_info）集合"></a>属性表（attribute_info）集合</h3><p>后续各类属性表中 都会包含xx_index，那是代表对 常量池的引用，例如：</p>
<p>跟随access_flags标志的是两项索引值：<strong>name_index</strong> 和 <strong>descriptor_index</strong>。它们都是对<strong>常量池项的引用</strong>，分别代表着<strong>字段的简单名称以及字段和方法的描述符</strong></p>
<ul>
<li>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</li>
<li>为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项，这些属性具体见表6-13。</li>
</ul>
<p>表6-13　虚拟机规范预定义的属性</p>
<p><img src="/uploads/jvm/19-jvm-attributeinfo-01.png"></p>
<p><img src="/uploads/jvm/19-jvm-attributeinfo-02.png"></p>
<h4 id="Code属性（重点）："><a href="#Code属性（重点）：" class="headerlink" title="Code属性（重点）："></a>Code属性（重点）：</h4><p>理解Code属性是学习后面字节码执行引擎的必要基础，能直接阅读字节码也是工作中分析java代码语义问题的必要工具和基本技能</p>
<p>Code属性是Class文件中最重要的一个属性</p>
<ul>
<li><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。</p>
</li>
<li><p>Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，</p>
</li>
<li><p>譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。</p>
</li>
</ul>
<p>表6-15　Code属性表的结构</p>
<p><img src="/uploads/jvm/20-jvm-attributeinfo-Code.png"></p>
<ul>
<li><strong>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称，</strong></li>
<li><strong>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节</strong>。</li>
<li>max_stack代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度</li>
<li>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</li>
<li>方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理程序的参数（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</li>
<li>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那顾名思义每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令。</li>
<li><strong><em>ps:</em></strong>   关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了*<strong>一个方法不允许超过65535条字节码指令**<em>，即它实际只使用了u2的长度，</em></strong>如果超过这个限制，Javac编译器就会拒绝编译***。一般来讲，编写Java代码时只要不是刻意去编写一个超级长的方法来为难编译器，是不太可能超过这个最大值的限制的。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就有可能因为方法生成字节码超长的原因而导致编译失败。</li>
</ul>
<p>如果**<em>把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分**</em>，那么在整<br>个Class文件里，<strong>Code属性用于描述代码</strong>，<strong>所有的其他数据项目都用于描述元数据</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 原始Java代码</span><br><span class="line">public class TestClass &#123;</span><br><span class="line">    private int m;</span><br><span class="line">    public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">    	<span class="built_in">return</span> m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////编译后</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\&gt;javap -verbose TestClass</span><br><span class="line">// 常量表部分的输出见代码清单6-1，因版面原因这里省略掉</span><br><span class="line">&#123;</span><br><span class="line">public org.fenixsoft.clazz.TestClass();</span><br><span class="line">//构造方法</span><br><span class="line">    Code:</span><br><span class="line">        Stack=1, Locals=1, Args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial <span class="comment">#10; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        4: <span class="built_in">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">    	line 3: 0</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start Length Slot Name Signature</span><br><span class="line">        0 5 0 this Lorg/fenixsoft/clazz/TestClass;</span><br><span class="line"></span><br><span class="line">// 方法 2</span><br><span class="line">public int inc();</span><br><span class="line">Code:</span><br><span class="line">    Stack=2, Locals=1, Args_size=1</span><br><span class="line">    0: aload_0</span><br><span class="line">    1: getfield <span class="comment">#18; //Field m:I</span></span><br><span class="line">    4: iconst_1</span><br><span class="line">    5: iadd</span><br><span class="line">    6: ireturn</span><br><span class="line">LineNumberTable:</span><br><span class="line">	line 8: 0</span><br><span class="line">LocalVariableTable:</span><br><span class="line">    Start Length Slot Name Signature</span><br><span class="line">    0 7 0 this Lorg/fenixsoft/clazz/TestClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问:"></a>疑问:</h4><ul>
<li>这个类有两个方法——实例构造器<init>()和inc()，这两个方法很明显都是没有参数的，为什么Args_size会为1？</li>
<li>而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么会等于1？</li>
</ul>
<h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><ul>
<li><p>一条Java语言里面的潜规则：在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，</p>
</li>
<li><p>而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。</p>
</li>
<li><p>因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。</p>
</li>
<li><p>这个处理只对实例方法有效，如果代码清单6-1中的inc()方法被声明为static，那Args_size就不会等于1而是等于0了。</p>
</li>
<li></li>
</ul>
<h4 id="异常表："><a href="#异常表：" class="headerlink" title="异常表："></a>异常表：</h4><p>如果存在异常表，那它的格式应如表6-16所示，包含四个字段，这些字段的含义为：如果当字节码从第start_pc行[1]到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。</p>
<p>表6-16　属性表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>start_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>end_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>handler_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>catch_pc</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>异常表实际上是Java代码的一部分，尽管字节码中有最初为处理异常而设计的跳转指令，</li>
<li>但《Java虚拟机规范》中明确要求Java语言的编译器<strong>应当选择使用异常表</strong>而不是通过跳转指令来实现Java异常及finally处理机制[2]。</li>
</ul>
<p>代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了<strong>在字节码层面try-catchfinally是如何体现的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Java源码</span><br><span class="line">public int inc() &#123;</span><br><span class="line">    int x;</span><br><span class="line">    try &#123;</span><br><span class="line">        x &#x3D; 1;</span><br><span class="line">    	return x;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    	x &#x3D; 2;</span><br><span class="line">   	 	return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	x &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 编译后的ByteCode字节码及异常表</span><br><span class="line">public int inc();</span><br><span class="line">    Code:</span><br><span class="line">        Stack&#x3D;1, Locals&#x3D;5, Args_size&#x3D;1</span><br><span class="line">            0: iconst_1 &#x2F;&#x2F; try块中的x&#x3D;1</span><br><span class="line">            1: istore_1</span><br><span class="line">            2: iload_1 &#x2F;&#x2F; 保存x到returnValue中，此时x&#x3D;1</span><br><span class="line">            3: istore   4</span><br><span class="line">            5: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            6: istore_1</span><br><span class="line">            7: iload     4 &#x2F;&#x2F; 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            9: ireturn</span><br><span class="line">            10: astore_2 &#x2F;&#x2F; 给catch中定义的Exception e赋值，存储在变量槽 2中</span><br><span class="line">            11: iconst_2 &#x2F;&#x2F; catch块中的x&#x3D;2</span><br><span class="line">            12: istore_1</span><br><span class="line">            13: iload_1 &#x2F;&#x2F; 保存x到returnValue中，此时x&#x3D;2</span><br><span class="line">            14: istore    4</span><br><span class="line">            16: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            17: istore_1</span><br><span class="line">            18: iload      4 &#x2F;&#x2F; 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            20: ireturn</span><br><span class="line">            21: astore_3 &#x2F;&#x2F; 如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</span><br><span class="line">            22: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            23: istore_1</span><br><span class="line">            24: aload_3 &#x2F;&#x2F; 将异常放置到栈顶，并抛出</span><br><span class="line">            25: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">    from to target type</span><br><span class="line">        0 5 10 Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">        0 5 21 any</span><br><span class="line">        10 16 21 any</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>编译器为这段Java源码生成了三条异常表记录，对应三条可能出现的代码执行路径。从Java代码的语义上讲，这三条执行路径分别为：</p>
<ul>
<li>如果try语句块中出现属于Exception或其子类的异常，转到catch语句块处理；</li>
<li>如果try语句块中出现不属于Exception或其子类的异常，转到finally语句块处理；</li>
<li>如果catch语句块中出现任何异常，转到finally语句块处理。</li>
</ul>
<p>返回到我们上面提出的问题，这段代码的返回值应该是多少？熟悉Java语言的读者应该很容易说出答案：</p>
<ul>
<li>如果没有出现异常，返回值是1；</li>
<li>如果出现了Exception异常，返回值是2；</li>
<li>如果出现了Exception以外的异常，方法非正常退出，没有返回值。</li>
</ul>
<p>我们一起来分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。</p>
<ol>
<li>字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且*<strong>将此时x的值复制一份副本到最后一***<br>*</strong>个本地变量表的变量槽中*<strong>（**<em>这个变量槽里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为</em></strong><br><strong><em>方法返回值使用</em></strong>。为了讲解方便，给这个变量槽起个名字：returnValue）。</li>
<li>如果这时候没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后*<strong>将之前保存在returnValue中的整数1***  读入到 *</strong>操作栈***<br><strong><em>顶</em></strong>，**<em>最后ireturn指令会以int形式返回操作栈顶中的值**</em>，方法结束。</li>
<li>如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是<strong>将2赋值给变量x</strong>，然后将变量*<strong>x此时的值赋给returnValue*<strong>，最后</strong>再**<br><strong>将变量x的值改为3</strong>。*</strong>方法返回前同样将returnValue中保留的整数2读到了操作栈顶***。</li>
<li>从第21行开始的代码，作用是<strong>将变量x的值赋为3</strong>，并<strong>将栈顶的异常抛出</strong>，方法结束。</li>
</ol>
<p><strong><em>总结一下：</em></strong></p>
<ul>
<li>如果先给x赋值，再将x值 复制一个副本到本地变量表的 变量槽中，该变量槽中的值在ireturn指令执行时 会被读到操作栈顶，就是最终要 return的值，而不是 x的变量值</li>
<li>如果没有异常，还是会走finally的方法块给x进行赋值，但是最终返回的是 之前本地变量表的变量槽中的值，并不是走完finally块的时候 x的值 </li>
<li>如果发生了异常，且异常属于 catch方法的异常或者其异常子类，则 进catch方法块，给x赋值为2，然后将x=2 的值赋给returnValue，然后执行finally 的x=3,最后将 returnValue的值读到栈顶，输出</li>
<li>如果发生了catch块之外的异常，则 先执行finally 的x=3，再将异常堆栈信息读到栈顶，抛出去，最终不会return x，而是以异常堆栈的形式结束</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    // Java源码</span><br><span class="line">    public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">        int x;</span><br><span class="line">        try &#123;</span><br><span class="line">            x = 1;</span><br><span class="line">            List&lt;Object&gt; list = Arrays.asList();</span><br><span class="line">//            list.get(1);</span><br><span class="line">            System.out.println(1 / 0);</span><br><span class="line">            System.out.println(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">//            ClassCastException(<span class="string">&quot;异常外&quot;</span>)</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">            x = 2;</span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            x = 3;</span><br><span class="line">//            <span class="built_in">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test2 test2 = new Test2();</span><br><span class="line">        int inc = test2.inc();</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><ul>
<li><p>这里的Exceptions属性是在方法表中与Code属性平级的一项属性，不要与前面刚刚讲解完的异常表产生混淆。</p>
</li>
<li><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。</p>
<p>它的结构见表6-17。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_exceptions</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>exception_index_table</td>
<td>number_of_exceptons</td>
</tr>
</tbody></table>
<p>此属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示；exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p>
<h4 id="LocalVariableTable及LocalVariableTypeTable属性"><a href="#LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTable及LocalVariableTypeTable属性"></a>LocalVariableTable及LocalVariableTypeTable属性</h4><ul>
<li><p>LocalVariableTable属性用于描述**<em>栈帧中局部变量表的变量与Java源码中定义的变量之间的关系**</em>，</p>
</li>
<li><p>它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p>
</li>
<li><p>如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
</li>
<li><p>LocalVariableTable属性的结构如表6-19所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>local_variable_table_length</td>
<td>1</td>
</tr>
<tr>
<td>loca_variable_info</td>
<td>loca_variable_table</td>
<td>local_variable_table_length</td>
</tr>
</tbody></table>
<p>其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构如表6-20所示。<br>| 类型               | 名称                       | 数量                |<br>| —————— | ————————– | ——————- |<br>| u2                 |start_pc       | 1                   |<br>| u2                 | length           | 1                   |<br>| u2                 |name_index | 1                   |<br>| u2                 | descriptor_index                     |1 |<br>| u2                 | index | 1                   |</p>
<ul>
<li>start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围</li>
<li>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</li>
<li>index是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时（double和long），它占用的变量槽为index和index+1两个</li>
</ul>
<h4 id="LocalVariableTypeTable（用于支持泛型）"><a href="#LocalVariableTypeTable（用于支持泛型）" class="headerlink" title="LocalVariableTypeTable（用于支持泛型）"></a>LocalVariableTypeTable（用于支持泛型）</h4><ul>
<li><p>在JDK 5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”——LocalVariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。</p>
</li>
<li><p>对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[3]，描述符就不能准确描述泛型类型了。因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。</p>
</li>
</ul>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><ul>
<li><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。</p>
</li>
<li><p>类似“int x=123”和“static int x=123”这样的变量定义在Java程序里面是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。</p>
</li>
<li><p>对**<em>非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>()方法中进行的**</em>；</p>
</li>
<li><p>而对于**<em>类变量**</em>，则有两种方式可以选择：</p>
</li>
<li><ul>
<li>在类构造器<clinit>()方法中</li>
<li>或者使用ConstantValue属性。</li>
</ul>
</li>
<li><p>目前Oracle公司实现的Javac编译器的选择是，如果**<em>同时使用final和static来修饰一个变量**</em>（按照习惯，这里称“常量”更贴切），并且这个变量的<strong>数据类型是基本类型或者java.lang.String</strong>的话，就将会<strong>生成ConstantValue属性</strong>来进行初始化；</p>
</li>
<li><p>如果这个变量<strong>没有被final修饰</strong>，或者<strong>并非基本类型及字符串</strong>，则将会选择在<clinit>()方法中进行初始化。</p>
</li>
<li><p>虽然有final关键字才更符合“ConstantValue”的语义，但<strong>《Java虚拟机规范》中并没有强制要求字段必须设置ACC_FINAL标志，只要求有ConstantValue属性的字段必须设置ACC_STATIC标志而已，</strong></p>
</li>
<li><p><strong>对final关键字的要求是Javac编译器自己加入的限制</strong>。而对ConstantValue的属性值只能限于基本类型和String这点，其实并不能算是什么限制，这是理所当然的结果。</p>
</li>
</ul>
<p>因为此属性的属性值只是一个常量池的索引号，**<em>由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量**</em>，所以就算<br>ConstantValue属性想支持别的类型也无能为力。</p>
<p>ConstantValue属性的结构如表6-23所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_value_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>从数据结构中可以看出ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。</li>
<li>constantvalue_index数据项代表了常量池中一个字面量常量的引用，</li>
<li>根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</li>
</ul>
<h4 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h4><ul>
<li>InnerClasses属性用于记录<strong>内部类与宿主类之间的关联</strong>。</li>
<li>如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</li>
<li>InnerClasses属性的结构如表6-24所示。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_classes</td>
<td>1</td>
</tr>
<tr>
<td>loca_classes_info</td>
<td>inner_classes</td>
<td>number_of_classes</td>
</tr>
</tbody></table>
<p>数据项number_of_classes代表需要记录多少个内部类信息，</p>
<p>每一个内部类的信息都由一个inner_classes_info表进行描述。</p>
<p>inner_classes_info表的结构如表6-25所示。<br>| 类型               | 名称                       | 数量                |<br>| —————— | ————————– | ——————- |<br>| u2                 |inner_class_of_index     | 1                   |<br>| u4                 | outer_class_of_index          | 1                   |<br>| u2                 | inner_name_index | 1                   |<br>| loca_classes_info |      inner_classes_access_flag                     |1 |</p>
<ul>
<li>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</li>
<li>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为0。</li>
<li>inner_class_access_flags是内部类的访问标志，类似于类的access_flags，</li>
</ul>
<h4 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h4><ul>
<li>Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</li>
<li>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</li>
<li>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，</li>
<li>在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位。</li>
<li>编译器通过生成一些在源代码中不存在的Synthetic方法、字段甚至是整个类的方式，实现了越权访问（越过private修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法（Bridge Method）。</li>
<li>所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位中的一项，</li>
<li>唯一的例外是实例构造器“<init>()”方法和类构造器“<clinit>()”方法。</li>
</ul>
<h4 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h4><ul>
<li><p>StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code属性的属性表中。</p>
</li>
<li><p>这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（TypeChecker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
</li>
<li><p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。</p>
</li>
<li><p>类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p>
</li>
<li><p>StackMapTable属性的结构如表6-28所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_entries</td>
<td>1</td>
</tr>
<tr>
<td>stack_map_frame</td>
<td>stack_map_frame_entries</td>
<td>number_of_entries</td>
</tr>
</tbody></table>
<ul>
<li>在Java SE 7版之后的《Java虚拟机规范》中，明确规定对于版本号大于或等于50.0的Class文件，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性，这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。</li>
<li>一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</li>
</ul>
<h4 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h4><ul>
<li>Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。</li>
<li>在JDK 5里面大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（ParameterizedType），则Signature属性会为它记录泛型签名信息。</li>
<li>之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</li>
<li>使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。</li>
<li>但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，</li>
<li>现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。<br>Signature属性的结构如表6-29所示</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>signature_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>其中signature_index项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名或方法类型签名或字段类型签名。</li>
<li>如果当前的Signature属性是类文件的属性，则这个结构表示类签名，</li>
<li>如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，</li>
<li>如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。</li>
</ul>
<h4 id="MethodParameters属性"><a href="#MethodParameters属性" class="headerlink" title="MethodParameters属性"></a>MethodParameters属性</h4><ul>
<li>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。</li>
<li>MethodParameters的作用是记录方法的各个形参名称和信息。</li>
</ul>
<h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><ul>
<li>最初，基于存储空间的考虑，Class文件默认是不储存方法参数名称的，因为给参数起什么名字对计算机执行程序来说是没有任何区别的，所以只要在源码中妥当命名就可以了。</li>
<li>随着Java的流行，这点确实为程序的传播和二次复用带来了诸多不便，由于Class文件中没有参数的名称，如果只有单独的程序包而不附加JavaDoc的话，在IDE中编辑使用包里面的方法时是无法获得方法调用的智能提示的，这就阻碍了JAR包的传播。</li>
<li>后来，“-g：var”就成为了Javac以及许多IDE编译Class时采用的默认值，这样会将方法参数的名称生成到LocalVariableTable属性之中。</li>
<li>不过此时问题仍然没有全部解决，LocalVariableTable属性是Code属性的子属性——没有方法体存在，自然就不会有局部变量表，</li>
<li>但是对于其他情况，譬如抽象方法和接口方法，是理所当然地可以不存在方法体的，对于方法签名来说，还是没有找到一个统一完整的保留方法参数名称的地方。</li>
<li>所以JDK 8中新增的这个属性，使得编译器可以（编译时加上-parameters参数）将方法名称也写进Class文件中，而且MethodParameters是方法表的属性，与Code属性平级的，可以运行时通过反射API获取</li>
</ul>
<p>MethodParameters的结构如表6-32所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>parameters_count</td>
<td>1</td>
</tr>
<tr>
<td>parameter</td>
<td>parameters</td>
<td>parameters_count</td>
</tr>
</tbody></table>
<p>其中，引用到的parameter结构如表6-33所示。<br>表6-33　parameter属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
</tbody></table>
<h4 id="模块化相关属性"><a href="#模块化相关属性" class="headerlink" title="模块化相关属性"></a>模块化相关属性</h4><ul>
<li>JDK 9的一个重量级功能是Java的模块化功能，</li>
<li>因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，</li>
<li>所以，Class文件格式也扩展了**<em>Module、ModulePackages和ModuleMainClas**</em>s三个属性用于支持Java模块化相关功能</li>
</ul>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module:"></a>Module:</h5><p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块*<strong>requires、exports、opens、uses**<em>和</em></strong>provides***定义的全部内容</p>
<p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储<br>了这个模块requires、exports、opens、uses和provides定义的全部内容，其结构如表6-34所示。</p>
<p>表6-34　Module属性结构</p>
<p><img src="/uploads/jvm/22-jvm-Module.png"></p>
<p><strong><em>TODO： 暂时用不到，就先不了解了</em></strong></p>
<h5 id="ModulePackages"><a href="#ModulePackages" class="headerlink" title="ModulePackages"></a>ModulePackages</h5><p>ModulePackages是另一个用于支持Java模块化的变长属性，它用于描述该模块中所有的包，不论是<br>不是被export或者open的。</p>
<h5 id="ModuleMainClass"><a href="#ModuleMainClass" class="headerlink" title="ModuleMainClass"></a>ModuleMainClass</h5><p>ModuleMainClass属性是一个定长属性，用于确定该模块的主类（Main Class），其结构</p>
<h4 id="运行时注解相关属性"><a href="#运行时注解相关属性" class="headerlink" title="运行时注解相关属性"></a>运行时注解相关属性</h4><h5 id="背景：-1"><a href="#背景：-1" class="headerlink" title="背景："></a>背景：</h5><ul>
<li>早在JDK 5时期，Java语言的语法进行了多项增强，其中之一是提供了对注解（Annotation）的支持。</li>
<li>为了存储源码中注解信息，Class文件同步增加了 <strong><em>RuntimeVisibleAnnotations</em></strong>  、*<strong>RuntimeInvisibleAnnotations**<em>、</em></strong>RuntimeVisibleParameterAnnotations*** 和 <strong><em>RuntimeInvisibleParameterAnnotations</em></strong>四个属性。</li>
<li>到了JDK 8时期，进一步加强了Java语言的注解使用范围，又新增类型注解（JSR 308），所以Class文件中也同步增加了 <strong><em>RuntimeVisibleTypeAnnotations</em></strong> 和<br>**<em>RuntimeInvisibleTypeAnnotations**</em> 两个属性。</li>
<li>由于这六个属性不论结构还是功能都比较雷同，因此我们把它们合并到一起，以**<em>RuntimeVisibleAnnotations**</em>为代表进行介绍。</li>
<li><strong>RuntimeVisibleAnnotations</strong>是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，</li>
<li>当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</li>
<li></li>
<li>RuntimeVisibleAnnotations属性的结构如表6-38所示。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_annotations</td>
<td>1</td>
</tr>
<tr>
<td>annotation</td>
<td>annotations</td>
<td>num_annotations</td>
</tr>
</tbody></table>
<p>num_annotations是annotations数组的计数器，annotations中每个元素都代表了一个运行时可见的注解，注解在Class文件中以annotation结构来存储，</p>
<p>具体如表6-39所示<br>表6-39　annotation属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>type_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_element_value_pairs</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>element_value_pairs</td>
<td>num_element_value_pair</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">RocketMQ-02-RocketMQ快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-06 20:59:26" itemprop="dateCreated datePublished" datetime="2021-01-06T20:59:26+08:00">2021-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RocketMQ入门"><a href="#RocketMQ入门" class="headerlink" title="RocketMQ入门"></a>RocketMQ入门</h1><h2 id="核心概念说明"><a href="#核心概念说明" class="headerlink" title="核心概念说明"></a>核心概念说明</h2><p><img src="/uploads/RocketMQ/RocketMQ01.png" alt="image-20210106210340592"></p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ul>
<li>消息生产者，负责产生消息，一般由业务系统负责产生消息。</li>
</ul>
<h4 id="Producer-Group"><a href="#Producer-Group" class="headerlink" title="Producer Group"></a>Producer Group</h4><ul>
<li>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul>
<li>消息费者，负责消费消息，一般是后台系统负责异步消费。</li>
</ul>
<h4 id="Push-Consumer"><a href="#Push-Consumer" class="headerlink" title="Push Consumer"></a>Push Consumer</h4><ul>
<li>服务端向消费者端推送消息</li>
</ul>
<h4 id="Pull-Consumer"><a href="#Pull-Consumer" class="headerlink" title="Pull Consumer"></a>Pull Consumer</h4><ul>
<li>消费者端向服务定时拉取消息</li>
</ul>
<h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><ul>
<li> 一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</li>
</ul>
<h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><ul>
<li><p>集群架构中的组织协调员</p>
</li>
<li><p>收集broker的工作情况</p>
</li>
<li><p>不负责消息的处理</p>
</li>
</ul>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><ul>
<li>是RocketMQ的核心负责消息的发送、接收、高可用等（真正干活的）</li>
<li>需要定时发送自身情况到NameServer，默认10秒发送一次，超时2分钟会认为该broker失效。</li>
</ul>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><ul>
<li><p>不同类型的消息以不同的Topic名称进行区分，如User、Order等</p>
</li>
<li><p>是逻辑概念</p>
</li>
</ul>
<h3 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h3><ul>
<li>消息队列，用于存储消息</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;zlm-mqProducer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置nameserver的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建topic，参数分别是：broker的名称，topic的名称，queue的数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        producer.createTopic(<span class="string">&quot;broker-zhangliming&quot;</span>, <span class="string">&quot;zhangliming-test-topic&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;topic创建成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="发送消息（同步）"><a href="#发送消息（同步）" class="headerlink" title="发送消息（同步）"></a>发送消息（同步）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;我的第一个消息-add!&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;add&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消息id：C0A800693F5814DAD5DC1E4E22F20000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">3</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A800693F5814DAD5DC1E4E22F20000, offsetMsgId=C0A83E5A00002A9F00000000000000BA, messageQueue=MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">3</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Message数据结构"><a href="#Message数据结构" class="headerlink" title="Message数据结构"></a>Message数据结构</h3><table>
<thead>
<tr>
<th>字段名</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Topic</td>
<td>null</td>
<td>必填，线下环境不需要申请，线上环境需要申请后才能使用</td>
</tr>
<tr>
<td>Body</td>
<td>null</td>
<td>必填，二进制形式，序列化由应用决定，Producer 与 Consumer 要协商好序列化形式。</td>
</tr>
<tr>
<td>Tags</td>
<td>null</td>
<td>选填，类似于 Gmail 为每封邮件设置的标签，方便服务器过滤使用。<br/>目前只支持每个消息设置一个 tag，所以也可以类比为 Notify 的 MessageType 概念</td>
</tr>
<tr>
<td>Keys</td>
<td>null</td>
<td>选填，代表这条消息的业务关键词，服务器会根据 keys 创建哈希索引，<br>设置后，可以在 Console 系统根据 Topic、Keys 来查询消息，<br>由于是哈希索引，请尽可能保证 key 唯一，例如订单号，商品 Id 等。</td>
</tr>
<tr>
<td>Flag</td>
<td>0</td>
<td>选填，完全由应用来设置，RocketMQ 不做干预</td>
</tr>
<tr>
<td>DelayTimeLevel</td>
<td>0</td>
<td>选填，消息延时级别，0 表示不延时，大于 0 会延时特定的时间才会被消费</td>
</tr>
<tr>
<td>WaitStoreMsgOK</td>
<td>True</td>
<td>选填，表示消息是否在服务器落盘后才返回应答。</td>
</tr>
</tbody></table>
<h3 id="发送消息（异步）"><a href="#发送消息（异步）" class="headerlink" title="发送消息（异步）"></a>发送消息（异步）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;我的第一个异步发送消息!&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        producer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送成功了!&quot;</span> + sendResult);</span><br><span class="line">                System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送失败!&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">发送成功了!SendResult [sendStatus=SEND_OK, msgId=C0A8006943E014DAD5DC1E5694380000, offsetMsgId=C0A83E5A00002A9F0000000000000174, messageQueue=MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">1</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line">消息id：C0A8006943E014DAD5DC1E5694380000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">1</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;haoke-consumer&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅消息，接收的是所有消息</span></span><br><span class="line"><span class="comment">//        consumer.subscribe(&quot;my-topic&quot;, &quot;*&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;add || update&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;消息:&quot;</span> + <span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息 -&gt; &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消息:我的第一个消息-add!</span><br><span class="line">消息:我的第一个消息-add!</span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">186</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609938835416</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">8951</span>, storeTimestamp=<span class="number">1609938835430</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000000, commitLogOffset=<span class="number">0</span>, bodyCRC=<span class="number">2131316890</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, CONSUME_START_TIME=<span class="number">1609939507601</span>, UNIQ_KEY=C0A8006920E814DAD5DC1E4E1BD80000, WAIT=<span class="keyword">true</span>, TAGS=add&#125;, body=[-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">102</span>, -<span class="number">124</span>, -<span class="number">25</span>, -<span class="number">84</span>, -<span class="number">84</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">128</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">86</span>, -<span class="number">26</span>, -<span class="number">74</span>, -<span class="number">120</span>, -<span class="number">26</span>, -<span class="number">127</span>, -<span class="number">81</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">33</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">3</span>, storeSize=<span class="number">186</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609938837234</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">8964</span>, storeTimestamp=<span class="number">1609938837241</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F00000000000000BA, commitLogOffset=<span class="number">186</span>, bodyCRC=<span class="number">2131316890</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, CONSUME_START_TIME=<span class="number">1609939507601</span>, UNIQ_KEY=C0A800693F5814DAD5DC1E4E22F20000, WAIT=<span class="keyword">true</span>, TAGS=add&#125;, body=[-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">102</span>, -<span class="number">124</span>, -<span class="number">25</span>, -<span class="number">84</span>, -<span class="number">84</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">128</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">86</span>, -<span class="number">26</span>, -<span class="number">74</span>, -<span class="number">120</span>, -<span class="number">26</span>, -<span class="number">127</span>, -<span class="number">81</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">33</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="消息过滤器"><a href="#消息过滤器" class="headerlink" title="消息过滤器"></a>消息过滤器</h2><ul>
<li><p>RocketMQ支持根据用户自定义属性进行过滤，过滤表达式类似于SQL的where，如：a&gt; 5 AND b =’abc’</p>
</li>
<li><p>原因是默认配置下，不支持自定义属性，需要设置开启 broker.conf中配置,见第一章可以看见配置<br>enablePropertyFilter=true</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.MessageSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅消息，接收的是所有消息</span></span><br><span class="line"><span class="comment">//        consumer.subscribe(&quot;my-topic&quot;, &quot;*&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;my-topic-filter&quot;</span>, MessageSelector.bySql(<span class="string">&quot;sex=&#x27;女&#x27; AND age&gt;=18&quot;</span>));</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;消息:&quot;</span> + <span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息 -&gt; &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">2</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940231764</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9804</span>, storeTimestamp=<span class="number">1609940231769</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F00000000000003CE, commitLogOffset=<span class="number">974</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">3</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940231776</span>, UNIQ_KEY=C0A800692B3C14DAD5DC1E636A540000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">21</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">1</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940241237</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9818</span>, storeTimestamp=<span class="number">1609940241243</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000490, commitLogOffset=<span class="number">1168</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940241244</span>, UNIQ_KEY=C0A8006908F014DAD5DC1E638F550000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">22</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">3</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940251652</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9836</span>, storeTimestamp=<span class="number">1609940251657</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000552, commitLogOffset=<span class="number">1362</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">4</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940251658</span>, UNIQ_KEY=C0A8006934D414DAD5DC1E63B8030000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">23</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;这是一个用户的消息, id = 1003&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic-filter&quot;</span>, <span class="string">&quot;delete&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        message.putUserProperty(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        message.putUserProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    消息id：C0A80069251814DAD5DC1E63D08D0000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic-filter, brokerName=broker-zhangliming, queueId=<span class="number">0</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A80069251814DAD5DC1E63D08D0000, offsetMsgId=C0A83E5A00002A9F0000000000000614, messageQueue=MessageQueue [topic=my-topic-filter, brokerName=broker-zhangliming, queueId=<span class="number">0</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="producer详解"><a href="#producer详解" class="headerlink" title="producer详解"></a>producer详解</h2><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>在某些业务中，consumer在消费消息时，是需要按照生产者发送消息的顺序进行消费的，比如在电商系统中，订单的消息，会有创建订单、订单支付、订单完成，如果消息的顺序发生改变，那么这样的消息就没有意义了。</p>
<p><img src="/uploads/RocketMQ/RocketMQ02.png" alt="image-20210106210340592"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;HAOKE_ORDER_PRODUCER&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> orderId = i % <span class="number">10</span>; <span class="comment">// 模拟生成订单id</span></span><br><span class="line">            String msgStr = <span class="string">&quot;order --&gt; &quot;</span> + i +<span class="string">&quot;, id = &quot;</span>+ orderId;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;haoke_order_topic&quot;</span>, <span class="string">&quot;ORDER_MSG&quot;</span>,</span><br><span class="line">                    msgStr.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(message, (mqs, msg, arg) -&gt; &#123;</span><br><span class="line">                Integer id = (Integer) arg;</span><br><span class="line">                <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">            &#125;, orderId);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">                DefaultMQPushConsumer(<span class="string">&quot;HAOKE_ORDER_CONSUMER&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;haoke_order_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                                + msg.getQueueId() + <span class="string">&quot; &quot;</span></span><br><span class="line">                                + <span class="keyword">new</span> String(msg.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                System.out.println(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs);</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：相同订单id的消息会落到同一个queue中，一个消费者线程会顺序消费queue，从而实现顺序消费消<br>息。</p>
<h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><h3 id="回顾是什么事务"><a href="#回顾是什么事务" class="headerlink" title="回顾是什么事务"></a>回顾是什么事务</h3><p>聊什么是事务，最经典的例子就是转账操作，用户A转账给用户B1000元的过程如下：<br>用户A发起转账请求，用户A账户减去1000元<br>用户B的账户增加1000元<br>如果，用户A账户减去1000元后，出现了故障（如网络故障），那么需要将该操作回滚，用户A账户增加1000元。<br>这就是事务。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>随着项目越来越复杂，越来越服务化，就会导致系统间的事务问题，这个就是分布式事务问题。<br>分布式事务分类有这几种：</p>
<ul>
<li>基于单个JVM，数据库分库分表了（跨多个数据库）。</li>
<li>基于多JVM，服务拆分了（不跨数据库）。</li>
<li>基于多JVM，服务拆分了 并且数据库分库分表了。</li>
</ul>
<p>解决分布式事务问题的方案有很多，使用消息实现只是其中的一种。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Half-Prepare-Message"><a href="#Half-Prepare-Message" class="headerlink" title="Half(Prepare) Message"></a>Half(Prepare) Message</h4><p>指的是暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次<br>确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息。</p>
<h4 id="Message-Status-Check"><a href="#Message-Status-Check" class="headerlink" title="Message Status Check"></a>Message Status Check</h4><p>由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长<br>期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回<br>查。</p>
<p><img src="/uploads/RocketMQ/RocketMQ03.png" alt="image-20210106210340592"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/uploads/RocketMQ/RocketMQ04.png" alt="image-20210106210340592"></p>
<ol>
<li>发送方向 MQ 服务端发送消息。</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后MQ Server 将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, LocalTransactionState&gt; STATE_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行具体的业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 发送的消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户A账户减500元.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">//模拟调用服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             System.out.println(1/0);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户B账户加500元.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            STATE_MAP.put(msg.getTransactionId(), LocalTransactionState.COMMIT_MESSAGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二次提交确认</span></span><br><span class="line"><span class="comment">//            return LocalTransactionState.UNKNOW;</span></span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        STATE_MAP.put(msg.getTransactionId(), LocalTransactionState.ROLLBACK_MESSAGE);</span><br><span class="line">        <span class="comment">// 回滚</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息回查</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;状态回查 ---&gt; &quot;</span> + msg.getTransactionId() +<span class="string">&quot; &quot;</span> +STATE_MAP.get(msg.getTransactionId()) );</span><br><span class="line">        <span class="keyword">return</span> STATE_MAP.get(msg.getTransactionId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;transaction_producer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> TransactionListenerImpl());</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;pay_topic&quot;</span>, <span class="string">&quot;用户A给用户B转账500元&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        producer.sendMessageInTransaction(message, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">99999</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;HAOKE_CONSUMER&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅topic，接收此Topic下的所有消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;pay_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h4><p>返回commit状态时，消费者能够接收到消息，返回rollback状态时，消费者接受不到消息。</p>
<h2 id="consumer详解"><a href="#consumer详解" class="headerlink" title="consumer详解"></a>consumer详解</h2><h3 id="push和pull模式"><a href="#push和pull模式" class="headerlink" title="push和pull模式"></a>push和pull模式</h3><p>在RocketMQ中，消费者有两种模式，一种是push模式，另一种是pull模式。</p>
<ul>
<li>(常用)push模式：客户端与服务端建立连接后，当服务端有消息时，将消息推送到客户端。</li>
<li>pull模式：客户端不断的轮询请求服务端，来获取新的消息。<br>但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式，即consumer轮询从broker拉取消息。<br>区别：</li>
<li> Push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。</li>
<li>Pull方式里，取消息的过程需要用户自己写，首先通过打算消费的Topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取的开始offset，直到取完了，再换另一个MessageQueue。</li>
<li>疑问：既然是采用pull方式实现，RocketMQ如何保证消息的实时性呢？</li>
</ul>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的<br>数据，再返回，然后进入循环周期。<br>客户端像传统轮询一样从服务端请求数据，服务端会阻塞请求不会立刻返回，直到有数据或超时才返回给客<br>户端，然后关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p>
<p><img src="/uploads/RocketMQ/RocketMQ05.png" alt="image-20210106210340592"></p>
<h2 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h2><p>DefaultMQPushConsumer实现了自动保存offset值以及实现多个consumer的负载均衡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置组名</span></span><br><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;HAOKE_IM&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过groupname将多个consumer组合在一起，那么就会存在一个问题，消息发送到这个组后，消息怎么分配呢？<br>这个时候，就需要指定消息模式，分别有集群和广播模式。</p>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>同一个 ConsumerGroup(GroupName相同) 里的每 个 Consumer 只消费所订阅消息的一部分内容， 同<br>一个 ConsumerGroup 里所有的 Consumer消费的内容合起来才是所订阅 Topic 内容的整体， 从而达到<br>负载均衡的目的 。</p>
<h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p>同一个 ConsumerGroup里的每个 Consumer都 能消费到所订阅 Topic 的全部消息，也就是一个消息会<br>被多次分发，被多个 Consumer消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集群模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"><span class="comment">// 广播模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure>

<h3 id="重复消息的解决方案"><a href="#重复消息的解决方案" class="headerlink" title="重复消息的解决方案"></a>重复消息的解决方案</h3><p>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办<br>法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<ol>
<li>消费端处理消息的业务逻辑保持幂等性</li>
<li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li>
</ol>
<ul>
<li>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</li>
<li>第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</li>
<li>第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。</li>
<li>第2条可以消息系统实现，也可以业务端实现。</li>
<li>正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以</li>
<li>最好还是**<em>由业务端自己处理消息重复的问题**</em>，这也是RocketMQ不解决消息重复的问题的原因。</li>
<li>  RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</li>
</ul>
<h2 id="RocketMQ存储"><a href="#RocketMQ存储" class="headerlink" title="RocketMQ存储"></a>RocketMQ存储</h2><p>RocketMQ中的消息数据存储，采用了零拷贝技术（使用 mmap + write 方式），文件系统采用 Linux Ext4 文件系<br>统进行存储。</p>
<h3 id="消息数据的存储"><a href="#消息数据的存储" class="headerlink" title="消息数据的存储"></a>消息数据的存储</h3><p>在RocketMQ中，消息数据是保存在磁盘文件中，为了保证写入的性能，RocketMQ尽可能保证顺序写入，顺序写<br>入的效率比随机写入的效率高很多。<br>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的，CommitLog是真正存储数据的文件，<br>ConsumeQueue是索引文件，存储数据指向到物理文件的配置。</p>
<p><img src="/uploads/RocketMQ/RocketMQ06.png" alt="image-20210106210340592"></p>
<p>如上图所示：</p>
<ul>
<li>消息主体以及元数据都存储在CommitLog当中</li>
<li>Consume Queue相当于kafka中的partition，是一个逻辑队列，存储了这个Queue在CommiLog中的起始<br>offset，log大小和MessageTag的hashCode。</li>
<li>每次读取消息队列先读取consumerQueue,然后再通过consumerQueue去commitLog中拿到消息主体。</li>
</ul>
<p>文件位置：</p>
<p><img src="/uploads/RocketMQ/RocketMQ07.png" alt="image-20210106210340592"></p>
<h2 id="同步刷盘与异步刷盘"><a href="#同步刷盘与异步刷盘" class="headerlink" title="同步刷盘与异步刷盘"></a>同步刷盘与异步刷盘</h2><p>RocketMQ 为了提高性能，会尽可能地保证 磁盘的顺序写。消息在通过 Producer 写入 RocketMQ 的时候，有两<br>种写磁盘方式，分别是同步刷盘与异步刷盘。</p>
<ul>
<li><p>同步刷盘</p>
<ul>
<li>在返回写成功状态时，消息已经被写入磁盘 。</li>
<li>具体流程是：消息写入内存的 PAGECACHE 后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程<br>执行完成后唤醒等待的线程，返回消息写成功的状态 。</li>
</ul>
</li>
<li><p>异步刷盘</p>
</li>
<li><p>在返回写成功状态时，消息可能只是被写入了内存的 PAGECACHE，写操作的返回快，吞吐量大</p>
<ul>
<li>当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</li>
</ul>
</li>
<li><p>broker配置文件中指定刷盘方式</p>
<ul>
<li>flushDiskType=ASYNC_FLUSH – 异步</li>
<li>flushDiskType=SYNC_FLUSH – 同步</li>
</ul>
</li>
</ul>
<p><img src="/uploads/RocketMQ/RocketMQ08.png" alt="image-20210106210340592"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/" class="post-title-link" itemprop="url">RocketMQ-01-使用DockerCompose安装RocketMQ</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-05 23:08:19" itemprop="dateCreated datePublished" datetime="2021-01-05T23:08:19+08:00">2021-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="使用DockerCompose安装RocketMQ"><a href="#使用DockerCompose安装RocketMQ" class="headerlink" title="使用DockerCompose安装RocketMQ"></a>使用DockerCompose安装RocketMQ</h1><p>安装Docker 和 Docker-Compose 过程略</p>
<h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若没有目录，自行创建</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ  </span><br><span class="line">vi docker-compose.yml </span><br><span class="line"></span><br><span class="line">内容如下：</span><br><span class="line"></span><br><span class="line">version: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  rmqnamesrv:</span><br><span class="line">    image: foxiswho/rocketmq:server</span><br><span class="line">    container_name: rmqnamesrv</span><br><span class="line">    ports:</span><br><span class="line">      - 9876:9876</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/logs:/opt/logs</span><br><span class="line">      - ./data/store:/opt/store</span><br><span class="line">    networks:</span><br><span class="line">        rmq:</span><br><span class="line">          aliases:</span><br><span class="line">            - rmqnamesrv</span><br><span class="line"></span><br><span class="line">  rmqbroker:</span><br><span class="line">    image: foxiswho/rocketmq:broker</span><br><span class="line">    container_name: rmqbroker</span><br><span class="line">    ports:</span><br><span class="line">      - 10909:10909</span><br><span class="line">      - 10911:10911</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/logs:/opt/logs</span><br><span class="line">      - ./data/store:/opt/store</span><br><span class="line">      - ./data/brokerconf/broker.conf:/etc/rocketmq/broker.conf</span><br><span class="line">    environment:</span><br><span class="line">        NAMESRV_ADDR: <span class="string">&quot;rmqnamesrv:9876&quot;</span></span><br><span class="line">        JAVA_OPTS: <span class="string">&quot; -Duser.home=/opt&quot;</span></span><br><span class="line">        JAVA_OPT_EXT: <span class="string">&quot;-server -Xms128m -Xmx128m -Xmn128m&quot;</span></span><br><span class="line">    <span class="built_in">command</span>: mqbroker -c /etc/rocketmq/broker.conf</span><br><span class="line">    depends_on:</span><br><span class="line">      - rmqnamesrv</span><br><span class="line">    networks:</span><br><span class="line">      rmq:</span><br><span class="line">        aliases:</span><br><span class="line">          - rmqbroker</span><br><span class="line"></span><br><span class="line">  rmqconsole:</span><br><span class="line">    image: styletang/rocketmq-console-ng</span><br><span class="line">    container_name: rmqconsole</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    environment:</span><br><span class="line">        JAVA_OPTS: <span class="string">&quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - rmqnamesrv</span><br><span class="line">    networks:</span><br><span class="line">      rmq:</span><br><span class="line">        aliases:</span><br><span class="line">          - rmqconsole</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  rmq:</span><br><span class="line">    name: rmq</span><br><span class="line">    driver: bridge</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自行创建 目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ/data/brokerconf</span><br><span class="line"></span><br><span class="line">vi broker.conf</span><br><span class="line"><span class="comment"># 内容如下：</span></span><br><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">#  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">#  limitations under the License.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所属集群名字</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"><span class="comment"># 原因是默认配置下，不支持自定义属性，需要设置开启</span></span><br><span class="line">enablePropertyFilter=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker 名字，注意此处不同的配置文件填写的不一样，如果在 broker-a.properties 使用: broker-a,</span></span><br><span class="line"><span class="comment"># 在 broker-b.properties 使用: broker-b</span></span><br><span class="line">brokerName=broker-zhangliming</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 表示 Master，&gt; 0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># nameServer地址，分号分割</span></span><br><span class="line"><span class="comment"># namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动IP,如果 docker 报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;192.168.0.120:10909&gt; failed</span></span><br><span class="line"><span class="comment"># 解决方式1 加上一句 producer.setVipChannelEnabled(false);，解决方式2 brokerIP1 设置宿主机IP，不要使用docker 内部IP</span></span><br><span class="line">brokerIP1=192.168.62.90</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭 ！！！这里仔细看是 false，false，false</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件时间点，默认凌晨4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"></span><br><span class="line"><span class="comment"># commitLog 每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"></span><br><span class="line"><span class="comment"># ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"></span><br><span class="line"><span class="comment"># destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment"># redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment"># 检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line"><span class="comment"># storePathRootDir=/home/yinshi/rocketmq-all-4.1.0-incubating/store</span></span><br><span class="line"><span class="comment"># commitLog 存储路径</span></span><br><span class="line"><span class="comment"># storePathCommitLog=/home/yinshi/rocketmq-all-4.1.0-incubating/store/commitlog</span></span><br><span class="line"><span class="comment"># 消费队列存储</span></span><br><span class="line"><span class="comment"># storePathConsumeQueue=/home/yinshi/rocketmq-all-4.1.0-incubating/store/consumequeue</span></span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line"><span class="comment"># storePathIndex=/home/yinshi/rocketmq-all-4.1.0-incubating/store/index</span></span><br><span class="line"><span class="comment"># checkpoint 文件存储路径</span></span><br><span class="line"><span class="comment"># storeCheckpoint=/home/yinshi/rocketmq-all-4.1.0-incubating/store/checkpoint</span></span><br><span class="line"><span class="comment"># abort 文件存储路径</span></span><br><span class="line"><span class="comment"># abortFile=/home/yinshi/rocketmq-all-4.1.0-incubating/store/abort</span></span><br><span class="line"><span class="comment"># 限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"></span><br><span class="line"><span class="comment"># flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment"># flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment"># flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment"># flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker 的角色</span></span><br><span class="line"><span class="comment"># - ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment"># - SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment"># - SLAVE</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷盘方式</span></span><br><span class="line"><span class="comment"># - ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment"># - SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发消息线程池数量</span></span><br><span class="line"><span class="comment"># sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment"># 拉消息线程池数量</span></span><br><span class="line"><span class="comment"># pullMessageThreadPoolNums=128</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ </span><br><span class="line"></span><br><span class="line"><span class="comment"># pull 镜像太慢</span></span><br><span class="line">vi /etc/docker/daemon.json </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>,<span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,<span class="string">&quot;https://registry.docker-cn.com&quot;</span>],</span><br><span class="line">	<span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.62.90:5000&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 重启docker ，然后</span></span><br><span class="line">systemctl restart docker </span><br><span class="line">docker-compose up</span><br><span class="line">docker images</span><br><span class="line">docker  ps</span><br></pre></td></tr></table></figure>



<h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><p>访问控制台 RocketMQ 控制台</p>
<h3 id="访问-http-192-168-62-90-8080-登入控制台"><a href="#访问-http-192-168-62-90-8080-登入控制台" class="headerlink" title="访问 http://192.168.62.90:8080 登入控制台"></a>访问 <a target="_blank" rel="noopener" href="http://192.168.62.90:8080/">http://192.168.62.90:8080</a> 登入控制台</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">深入理解jvm-05-调优案例分析与实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-28 23:12:21" itemprop="dateCreated datePublished" datetime="2020-12-28T23:12:21+08:00">2020-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><h2 id="大内存硬件上的程序部署策略"><a href="#大内存硬件上的程序部署策略" class="headerlink" title="大内存硬件上的程序部署策略"></a>大内存硬件上的程序部署策略</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>服务器的硬件为四路志强处理器、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的文档网站使用。软件版本选用的是64位的JDK 5，管理员启用了一个虚拟机实例，使用-Xmx和-Xms参数将Java堆大小固定在12GB。使用一段时间后发现服务器的运行效果十分不理想，网站经常不定期出现长时间失去响应。</p>
<p>监控服务器运行状况后发现网站失去响应是由垃圾收集停顿所导致的，在该系统软硬件条件下，HotSpot虚拟机是以服务端模式运行，默认使用的是吞吐量优先收集器，回收12GB的Java堆，一次FullGC的停顿时间就高达14秒。由于程序设计的原因，访问文档时会把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象大多在分配时就直接进入了老年代，没有在Minor GC中被清理掉。这种情况下即使有12GB的堆，内存也很快会被消耗殆尽，由此导致每隔几分钟出现十几秒的停顿，令网站开发、管理员都对使用Java技术开发网站感到很失望</p>
<ul>
<li><strong><em>回收大块堆内存而导致的长时间停顿</em></strong></li>
</ul>
<h3 id="解决方案（单体）："><a href="#解决方案（单体）：" class="headerlink" title="解决方案（单体）："></a>解决方案（单体）：</h3><p><strong><em>程序部署上的主要问题显然是过大的堆内存进行回收时带来的长时间的停顿</em></strong></p>
<ul>
<li><p>将Java堆分配的内存重新缩小到1.5GB或者2GB ，在深夜执行定时任务的方式触发Full GC甚至是自动重启应用服务器来保持内存可用空间在一个稳定的水平。</p>
</li>
<li><p>这样的确可以避免长时间停顿，</p>
</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>在硬件上的投资就显得非常浪费。</li>
</ul>
<h3 id="解决方案（集群）："><a href="#解决方案（集群）：" class="headerlink" title="解决方案（集群）："></a>解决方案（集群）：</h3><ul>
<li>建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了10GB内存。</li>
<li>另外建立一个Apache服务作为前端均衡代理作为访问门户。</li>
<li>考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问，处理器资源敏感度较低，</li>
<li>因此改为CMS收集器进行垃圾回收。</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致I/O异常。</li>
<li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点的连接池已经满了，而另外一些节点仍有较多空余</li>
</ul>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><p><strong><em>控制Full GC频率的关键是老年代的相对稳定</em></strong></p>
<p>这主要取决于应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。</p>
<p>目前单体应用在较大内存的硬件上主要的部署方式有两种：</p>
<ul>
<li>通过一个单独的Java虚拟机实例来管理大量的Java堆内存。</li>
<li>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源。</li>
</ul>
<h2 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h2><h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><p>这是一个学校的小型项目：基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据，系统使用了逆向AJAX技术（也称为Comet或者Server Side Push），选用CometD 1.1.1作为服务端推送框架，服务器是Jetty 7.1.4，硬件为一台很普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统。</p>
<ul>
<li><p>测试期间发现服务端不定时抛出内存溢出异常，服务不一定每次都出现异常</p>
</li>
<li><p>尝试过把堆内存调到最大，32位系统最多到1.6GB基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁</p>
</li>
<li><p>加入-XX：+HeapDumpOnOutOfMemoryError参数，居然也没有任何反应，抛出内存溢出异常时什么文件都没有产生</p>
</li>
<li><p>无奈之下只好挂着jstat紧盯屏幕，发现垃圾收集并不频繁，Eden区、Survivor区、老年代以及方法区的内存全部都很稳定，压力并不大，但就是照样不停抛出内存溢出异常</p>
</li>
<li><p>在内存溢出后从系统日志中找到异常堆栈如代码清单5-1所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 异常堆栈</span><br><span class="line"></span><br><span class="line">[org.eclipse.jetty.util.log] handle failed java.lang.OutOfMemoryError: null</span><br><span class="line">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:99)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)</span><br><span class="line">at org.eclipse.jetty.io.nio.DirectNIOBuffer.&lt;init&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul>
<li>操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位Windows平台的限制是2GB，其中划了1.6GB给Java堆，</li>
<li>而Direct Memory耗用的内存并不算入这1.6GB的堆之内，因此它最大也只能在剩余的0.4GB空间中再分出一部分而已</li>
<li> 直接内存（Direct Memory）空间不足之后，不会主动触发GC ，只能等待老年代满了之后Full GC，顺便帮忙清理 直接内存的废弃对象 </li>
<li>否则就不得不一直等到抛出内存溢出异常时，先捕获到异常，再在Catch块里面通过System.gc()命令来触发垃圾收集</li>
<li>如果Java虚拟机再打开了-XX：+DisableExplicitGC开关，禁止了人工触发垃圾收集的话，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常</li>
</ul>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul>
<li>直接内存：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出OutOf-MemoryError或者OutOfMemoryError：Direct buffer memory。</li>
<li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（如果线程请求的栈深度大于虚拟机所允许的深度）或者OutOfMemoryError</li>
<li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，可能会抛出IOException：Too many open files异常。</li>
<li>JNI代码：如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中，而是占用Java虚拟机的本地方法栈和本地内存的。</li>
<li>虚拟机和垃圾收集器：虚拟机、垃圾收集器的工作也是要消耗一定数量的内存的。</li>
</ul>
<h2 id="外部命令导致系统缓慢："><a href="#外部命令导致系统缓慢：" class="headerlink" title="外部命令导致系统缓慢："></a>外部命令导致系统缓慢：</h2><h3 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h3><p>一个数字校园应用系统，运行在一台四路处理器的Solaris 10操作系统上，中间件为GlassFish服务器。系统在做大并发压力测试的时候，发现请求响应时间比较慢，通过操作系统的mpstat工具发现处理器使用率很高，但是系统中占用绝大多数处理器资源的程序并不是该应用本身。这是个不正常的现象，通常情况下用户应用的处理器占用率应该占主要地位，才能说明系统是在正常工作。</p>
<p>通过Solaris 10的dtrace脚本可以查看当前情况下哪些系统调用花费了最多的处理器资源，dtrace运行后发现最消耗处理器资源的竟然是“fork”系统调用。众所周知，“fork”系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生，这又是个相当不正常的现象。</p>
<p><strong><em>最终找到了答案：</em></strong> </p>
<ul>
<li>每个用户请求的处理都需要执行一个外部Shell脚本来获得系统的一些信息。</li>
<li>执行这个Shell脚本是通过 <strong><em>Java的Runtime.getRuntime().exec()</em></strong> 方法来调用的。</li>
<li>这种调用方式可以达到执行Shell脚本的目的，但是它在Java虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。</li>
<li>Java虚拟机执行这个命令的过程是首先**<em>复制一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程**</em>。</li>
<li>如果频繁执行这个操作，系统的消耗必然会很大，而且不仅是处理器消耗，内存负担也很重。</li>
</ul>
<h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>建议去掉这个Shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快恢复了正常。</p>
<h2 id="服务器虚拟机进程崩溃"><a href="#服务器虚拟机进程崩溃" class="headerlink" title="服务器虚拟机进程崩溃"></a>服务器虚拟机进程崩溃</h2><h3 id="问题：-3"><a href="#问题：-3" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>一个基于B/S的MIS系统，硬件为两台双路处理器、8GB内存的HP系统，服务器是WebLogic9.2</p>
</li>
<li><p>正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid###.log文件后，虚拟机进程就消失了</p>
</li>
<li><p>两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日志中注意到，每个节点的虚拟机进程在崩溃之前，都发生过大量相同的异常，</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//异常堆栈2</span><br><span class="line"></span><br><span class="line">java.net.SocketException: Connection reset</span><br><span class="line">at java.net.SocketInputStream.read(SocketInputStream.java:168)</span><br><span class="line">at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)</span><br><span class="line">at java.io.BufferedInputStream.read(BufferedInputStream.java:235)</span><br><span class="line">at org.apache.axis.transport.http.HTTPSender.readHeadersFromSocket(HTTPSender.java:583)</span><br><span class="line">at org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:143)</span><br><span class="line">... 99 more</span><br></pre></td></tr></table></figure>

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li>这是一个远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的待办事项变化时，要通过Web服务通知OA门户系统，把待办事项的变化同步到OA门户之中。</li>
<li>通过SoapUI测试了一下同步待办事项的几个Web服务，发现调用后竟然需要长达3分钟才能返回，并且返回结果都是超时导致的连接中断。</li>
<li>由于MIS系统的用户多，待办事项变化很快，为了不被OA系统速度拖累，使用了异步的方式调用Web服务</li>
<li>但由于**<em>两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃**</em></li>
</ul>
<h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><p>通知OA门户方修复无法使用的集成接口，并**<em>将异步调用改为生产者/消费者模式的消息队列实现**</em>后，系统恢复正常。</p>
<h2 id="不恰当数据结构导致内存占用过大"><a href="#不恰当数据结构导致内存占用过大" class="headerlink" title="不恰当数据结构导致内存占用过大"></a>不恰当数据结构导致内存占用过大</h2><h3 id="问题：-4"><a href="#问题：-4" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>一个后台RPC服务器，使用64位Java虚拟机，内存配置为-Xms4g-Xmx8g-Xmn1g，使用ParNew加CMS的收集器组合。</p>
</li>
<li><p>平时对外服务的Minor GC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap&lt;Long，Long&gt;Entry，</p>
</li>
<li><p>在这段时间里面Minor GC就会造成超过500毫秒的停顿</p>
</li>
<li><p>，对于这种长度的停顿时间就接受不了了，具体情况如下面的收集器日志所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=95 (full 4):</span><br><span class="line">par new generation total 903168K, used 803142K [0x00002aaaae770000, 0x00002aaaebb70000, 0x00002aaaebb70000)</span><br><span class="line">eden space 802816K, 100% used [0x00002aaaae770000, 0x00002aaadf770000, 0x00002aaadf770000)</span><br><span class="line">from space 100352K, 0% used [0x00002aaae5970000, 0x00002aaae59c1910, 0x00002aaaebb70000)</span><br><span class="line">to space 100352K, 0% used [0x00002aaadf770000, 0x00002aaadf770000, 0x00002aaae5970000)</span><br><span class="line">concurrent mark-sweep generation total 5845540K, used 3898978K [0x00002aaaebb70000, 0x00002aac507f9000, 0x00002aacae770000)</span><br><span class="line">concurrent-mark-sweep perm gen total 65536K, used 40333K [0x00002aacae770000, 0x00002aacb2770000, 0x00002aacb2770000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2011-10-28T11:40:45.162+0800: 226.504: [GC 226.504: [ParNew: 803142K-&gt; 100352K(903168K), 0.5995670 secs] 4702120K-&gt;Heap after GC invocations=96 (full 4):</span><br><span class="line">par new generation total 903168K, used 100352K [0x00002aaaae770000, 0x00002-aaaebb70000, 0x00002aaaebb70000)</span><br><span class="line">eden space 802816K, 0% used [0x00002aaaae770000, 0x00002aaaae770000, 0x00002aaadf770000)</span><br><span class="line">from space 100352K, 100% used [0x00002aaadf770000, 0x00002aaae5970000, 0x00002aaae5970000)</span><br><span class="line">to space 100352K, 0% used [0x00002aaae5970000, 0x00002aaae5970000, 0x00002aaaebb70000)</span><br><span class="line">concurrent mark-sweep generation total 5845540K, used 3955980K [0x00002aaaebb70000, 0x00002aac507f9000, 0x00002aacae770000)</span><br><span class="line">concurrent-mark-sweep perm gen total 65536K, used 40333K [0x00002aacae770000, 0x00002aacb2770000, 0x00002aacb2770000)</span><br><span class="line">&#125;T</span><br><span class="line">otal time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 0.6070570 seconds</span><br></pre></td></tr></table></figure>



<h3 id="分析-："><a href="#分析-：" class="headerlink" title="分析 ："></a>分析 ：</h3><ul>
<li>观察这个案例的日志，平时Minor GC时间很短，原因是新生代的绝大部分对象都是可清除的，在Minor GC之后Eden和Survivor基本上处于完全空闲的状态。</li>
<li>但是在分析数据文件期间，800MB的Eden空间很快被填满引发垃圾收集</li>
<li>但Minor GC之后，新生代中绝大部分对象依然是存活的</li>
<li>ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，</li>
<li>如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确性就成为一个沉重的负担，因此导致垃圾收集的暂停时间明显变长。</li>
</ul>
<h3 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h3><p>如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑直接将Survivor空间去掉（加入参数-XX：SurvivorRatio=65536、</p>
<p>-XX ：MaxTenuringThreshold=0或者-XX：+Always-Tenure），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再去清理它们。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>这种措施可以治标，但也有很大副作用</p>
<h3 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h3><p>治本的方案必须要修改程序，因为这里产生问题的根本原因是用HashMap&lt;Long，Long&gt;结构来存储数据文件空间效率太低了。</p>
<ul>
<li>我们具体分析一下HashMap空间效率，在HashMap&lt;Long，Long&gt;结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16字节（2×8字节）。</li>
<li>这两个长整型数据包装成java.lang.Long对象之后，就分别具有8字节的Mark Word、8字节的Klass指针，再加8字节存储数据的long值。</li>
<li>然后这2个Long对象组成Map.Entry之后，又多了16字节的对象头，然后一个8字节的next字段和4字节的int型的hash字段，为了对齐，还必须添加4字节的空白填充，</li>
<li>最后还有HashMap中对这个Entry的8字节的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24byte)×2)+Entry(32byte)+HashMapRef(8byte)=88byte，空间效率为有效数据除以全部内存空间，即16字节/88字节=18%，这确实太低了。</li>
</ul>
<ul>
<li>如果是写入数据库，是否可以采用 ，边读边写，200条commit 一次</li>
</ul>
<h2 id="由安全点导致长时间停顿"><a href="#由安全点导致长时间停顿" class="headerlink" title="　由安全点导致长时间停顿"></a>　由安全点导致长时间停顿</h2><h3 id="问题：-5"><a href="#问题：-5" class="headerlink" title="问题："></a>问题：</h3><p>有一个比较大的承担公共计算任务的离线HBase集群，运行在JDK 8上，使用G1收集器。每天都有大量的MapReduce或Spark离线分析任务对其进行访问，同时有很多其他在线集群Replication过来的数据写入，因为集群读写压力较大，而离线分析任务对延迟又不会特别敏感，所以将-XX：MaxGCPauseMillis参数设置到了500毫秒。</p>
<ul>
<li><p>不过运行一段时间后发现垃圾收集的停顿经常达到3秒以上，</p>
</li>
<li><p>而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒，现象如以下日志所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Times: user=1.51 sys=0.67, real=0.14 secs]</span><br><span class="line">2019-06-25T 12:12:43.376+0800: 3448319.277: Total time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 2.2645818</span><br></pre></td></tr></table></figure>



<h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>在垃圾收集调优时，我们主要依据real时间为目标来优化程序，因为最终用户只关心发出请求到得到响应所花费的时间，也就是响应速度，而不太关心程序到底使用了多少个线程或者处理器来完成任务。</p>
<p>日志显示这次垃圾收集一共花费了0.14秒，但其中用户线程却足足停顿了有2.26秒，两者差距已经远远超出了正常的TTSP（Time To Safepoint）耗时的范畴。</p>
<ul>
<li>所以先加入参数-XX：+PrintSafepointStatistics和-XX：PrintSafepointStatisticsCount=1去查看安全点日志，具体如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmop [threads: total initially_running wait_to_block]</span><br><span class="line">65968.203: ForceAsyncSafepoint [931 1 2]</span><br><span class="line">[time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line">[2255 0 2255 11 0] 1</span><br></pre></td></tr></table></figure>

<ul>
<li>日志显示当前虚拟机的操作（VM Operation，VMOP）是等待所有用户线程进入到安全点，</li>
<li>但是有两个线程特别慢，导致发生了很长时间的自旋等待。</li>
<li>日志中的2255毫秒自旋（Spin）时间就是指由于部分线程已经走到了安全点，但还有一些特别慢的线程并没有到，</li>
<li>所以垃圾收集线程无法开始工作，只能空转（自旋）等待。</li>
</ul>
<ul>
<li>解决问题的第一步是把这两个特别慢的线程给找出来，这个倒不困难，添加-XX：+SafepointTimeout和-XX：SafepointTimeoutDelay=2000两个参数，</li>
<li>让虚拟机在等到线程进入安全点的时间超过2000毫秒时就认定为超时，这样就会输出导致问题的线程名称，得到的日志如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SafepointSynchronize::begin: Timeout detected:</span></span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: Timed out while spinning to reach a safepoint.</span></span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: Threads which did not reach the safepoint:</span></span><br><span class="line"><span class="comment"># &quot;RpcServer.listener,port=24600&quot; #32 daemon prio=5 os_prio=0 tid=0x00007f4c14b22840</span></span><br><span class="line">nid=0xa621 runnable [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: (End of list)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从错误日志中顺利得到了导致问题的线程名称为“RpcServer.listener，port=24600”</li>
<li>有什么因素可以阻止线程进入安全点？</li>
<li>安全点是以“是否具有让程序长时间执行的特征”为原则进行选定的，</li>
<li>所以方法调用、循环跳转、异常跳转这些位置都可能会设置有安全点，</li>
<li>但是HotSpot虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用int类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环（CountedLoop），相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为不可数循环（Uncounted Loop），将会被放置安全点。</li>
<li>通常情况下这个优化措施是可行的，但循环执行的时间不单单是由其次数决定，如果循环体单次执行就特别慢，那即使是可数循环也可能会耗费很多的时间。</li>
</ul>
<h3 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h3><p>最终查明导致这个问题是HBase中一个连接超时清理的函数，由于集群会有多个MapReduce或Spark任务进行访问，而每个任务又会同时起多个Mapper/Reducer/Executer，其每一个都会作为一个HBase的客户端，这就导致了同时连接的数量会非常多。更为关键的是，清理连接的索引值就是int类型，所以这是一个可数循环，HotSpot不会在循环中插入安全点。当垃圾收集发生时，如果RpcServer的Listener线程刚好执行到该函数里的可数循环时，则必须等待循环全部跑完才能进入安全点，此时其他线程也必须一起等着，所以从现象上看就是长时间的停顿。找到了问题，解决起来就非常简单了，</p>
<p><strong><em>把循环索引的数据类型从int改为long即可，</em></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">深入理解jvm-04-垃圾收集算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-27 12:01:23" itemprop="dateCreated datePublished" datetime="2020-12-27T12:01:23+08:00">2020-12-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>两个分代假说：</p>
<h4 id="弱分代假说（Weak-Generational-Hypothesis）："><a href="#弱分代假说（Weak-Generational-Hypothesis）：" class="headerlink" title="弱分代假说（Weak Generational Hypothesis）："></a>弱分代假说（Weak Generational Hypothesis）：</h4><ul>
<li> 绝大多数对象都是朝生夕灭的 </li>
</ul>
<h4 id="强分代假说（Strong-Generaional-Hypothesis）："><a href="#强分代假说（Strong-Generaional-Hypothesis）：" class="headerlink" title="强分代假说（Strong Generaional Hypothesis）："></a>强分代假说（Strong Generaional Hypothesis）：</h4><ul>
<li> 熬过越多次GC过程的对象 就越难以消亡</li>
</ul>
<p>这两个分代假说共同奠定了多款常用GC器一致的设计原则：</p>
<ul>
<li>GC器应该将Java 堆Heap 划分出不同的区域，然后将回收对象依据其 年龄（对象熬过GC收集的次数） 分配到不同的区域进行存储 。</li>
<li>而不同的区域 因为其对象的不同特性，可以采用不同的垃圾收集算法 。</li>
<li>如果区域对象 大多数对象都是朝生夕灭 的，难以熬过GC过程的 ，那把他们放在一起，每次回收只标记那些少量存活的对象实例，这样就可以用少量代价回收大量空间</li>
<li>如果剩下的都是难以消亡的对象，就把这个年龄大的对象 集中放在一起，jvm使用低频率区回收这个区域。  </li>
<li>这样就兼顾了GC的时间开销 和内存空间的有效利用</li>
</ul>
<p>将java堆进行划分成 不同区域后，gc器 才可以每次只收集其中某一个 或某些部分的区域， 因此 出现了  MInor GC , Major GC, Full GC</p>
<p>这样的回收类型划分，</p>
<p>针对不同区域的，安排与里面存储对象存亡特征相匹配的 GC 算法，如 标记删除，标记复制，标记整理 </p>
<p>因为存在 跨代引用的场景，老年代与新生代 可能存在互相引用的情况，这样 纪要通过GCRoot的可达性分析 ，也要额外遍历整个老年代的对象 来确保可达性分析结果的正确性， 这样由很大的性能负担</p>
<p> 所以出行第三条经验法则</p>
<h4 id="跨代引用假说（Intergenerational-Reference-Hypothesis）："><a href="#跨代引用假说（Intergenerational-Reference-Hypothesis）：" class="headerlink" title="跨代引用假说（Intergenerational Reference Hypothesis）："></a>跨代引用假说（Intergenerational Reference Hypothesis）：</h4><ul>
<li><p>跨代引用相对于同代引用来说 仅仅占极少数</p>
</li>
<li><p>这其实是通过强分代假说和 弱分代假说逻辑推理得出的推论： </p>
</li>
<li><p>存在互相引用关系的2个对象，应该是倾向于同时生存和同时消亡的，</p>
</li>
<li><p>如果某个新生代对象存在跨代引用，那么由于老年代对象难以消亡，所以 新生代对象在GC过程的时候也难以消亡，从而得以存活。慢慢的随着 之前新生代对象的年龄的增长，它也会被 晋升到老年代之中，这时候就不存在 跨代引用了</p>
</li>
<li><p>ps:  依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描</p>
</li>
</ul>
<h2 id="GC-名词字典"><a href="#GC-名词字典" class="headerlink" title="GC 名词字典"></a>GC 名词字典</h2><ul>
<li><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li><p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p>
</li>
</ul>
<h2 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark-Sweep）算法"></a>标记-清除（Mark-Sweep）算法</h2><p>算法分为“标记”和“清除”两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，</li>
<li>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li>
<li>标记过程就是对象是否属于垃圾的判定过程，</li>
<li>后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过<br>程的执行效率都随对象数量增长而降低</li>
<li>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ul>
<p><img src="/uploads/jvm/05-mark-sweep.png"></p>
<h2 id="标记-复制（Mark-Copy）算法"><a href="#标记-复制（Mark-Copy）算法" class="headerlink" title="标记-复制（Mark-Copy）算法"></a>标记-复制（Mark-Copy）算法</h2><h3 id="半区复制-（Semispace-Copying）"><a href="#半区复制-（Semispace-Copying）" class="headerlink" title="半区复制 （Semispace Copying）"></a>半区复制 （Semispace Copying）</h3><ul>
<li><p>将可用内存按容量分为大小相等的2块 ，每次只使用其中1块 。 </p>
</li>
<li><p>当这一块的内存用完了，就将还存活的对象复制到另一块上面 ，</p>
</li>
<li><p>然后就将还存活的对象复制到另一块上面，</p>
</li>
<li><p>然后再把已经使用过的内存空间一次清理掉。 </p>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>如果内存中多数对象都是存活的，这种算法会产生大量的内存间的复制 开销</p>
</li>
<li><p><strong><em>但是</em></strong>   在新生代这个 内存区域，98%的对象实例都熬不过第一轮收集，所以 不是算法有问题，是将算法 没有用到对的区域</p>
</li>
<li><p> 因为多数对象都是可回收的状态，所以算法复制的就是占少数的存活对象 </p>
</li>
<li><p>而且因为每次都是针对整个半区进行回收，分配内存时候也不用考虑 空间碎片整理的情况，只需要移动堆顶指针，按顺序分配即可，简单 高效</p>
</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>复制回收算法的代价是 将内存缩小一半，空间浪费未免太多了一点</li>
</ul>
<p><img src="/uploads/jvm/06-mark_copy.png"></p>
<h3 id="优化半区复制-（Appel式回收）"><a href="#优化半区复制-（Appel式回收）" class="headerlink" title="优化半区复制 （Appel式回收）"></a>优化半区复制 （Appel式回收）</h3><p>因为IBM 对 对象的朝生夕灭 特点做了调研，新生代中的对象 98% 熬不过第一轮收集，所以 提出了优化版的半区复制算法，即： </p>
<p>Appel 式回收：</p>
<h4 id="具体做法："><a href="#具体做法：" class="headerlink" title="具体做法："></a>具体做法：</h4><ul>
<li>将新生代  分为一块较大的Eden区（80%）  + Survivor_1（10%）+Survivor_2（10%）</li>
<li>每次分配内存时候，只使用 Eden（80%） 和 Survivor_1（10%），而 Survivor_2（10%）就暂时浪费掉</li>
<li>当 发生 GC的时候，就将 Eden（80%） 和 Survivor_1（10%）中的存活对象 复制到 Survivor_2（10%） 中</li>
<li>然后直接清理掉Eden（80%） 和 Survivor_1（10%）</li>
</ul>
<h4 id="逃生门”的安全设计（分配担保）："><a href="#逃生门”的安全设计（分配担保）：" class="headerlink" title="逃生门”的安全设计（分配担保）："></a>逃生门”的安全设计（分配担保）：</h4><p>98%的对象都熬不过第一轮GC 这个是 普通场景， 没有人能保证 每一次 GC后 ，继续存活的对象 不超过10% ，所以 Survivor_2（10%） 有可能装不下了。</p>
<p>这个时候 Appel 有一个 “逃生门”的安全设计 ：</p>
<ul>
<li>当 Survivor_2（10%）容纳不了一次  Minor GC （新生代GC，Young GC）存活对象， </li>
<li>就需要 依赖其他内存区域（实际上大多数是老年代） 进行分配担保，就将一部分 存活对象移入 老年代</li>
</ul>
<h4 id="分配担保-（Todo）"><a href="#分配担保-（Todo）" class="headerlink" title="分配担保 （Todo）"></a>分配担保 （Todo）</h4><ul>
<li>内存的分配担保好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有什么风险了。</li>
<li>内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代，这对虚拟机来说就是安全的</li>
</ul>
<h2 id="标记整理（Mark-Compact）算法"><a href="#标记整理（Mark-Compact）算法" class="headerlink" title="标记整理（Mark-Compact）算法"></a>标记整理（Mark-Compact）算法</h2><ul>
<li><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种标记-复制算法 .</p>
</li>
<li><p>针对老年代对象的存亡特征，提出了 有针对性的 “标记-整理”（Mark-Compact）算法</p>
</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li>首先标记出所有需要回收的对象，</li>
<li>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如图3-4所示。</li>
</ul>
<p><img src="/uploads/jvm/07-mark-compact.png"></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p>如果移动存活对象，尤其是在老年代 这种每次回收都有大量对象存活区域 ，移动存活对象并更新所有 引用这些对象的地方将会是一种极为负重的操作 ，</p>
<p>而且这种对象移动操作必须全程暂停用户应用程序才能进行。 Stop The World</p>
</li>
<li><p>如果不考虑移动和整理存活对象的话，，存活对象倒置 的空间碎片化问题就 只能依赖更为复杂的内存分配器和内存访问器来解决。</p>
</li>
<li><p>内存的访问 是用户程序最频繁的操作，如果这个环节上增加了额外的负担，势必影响用户程序的吞吐量</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p>
</li>
<li><p>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿</p>
</li>
<li><p>但是从整个程序的吞吐量来看，移动对象会更划算。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的</p>
</li>
<li><p>HotSpot虚拟机里面关注吞吐量的ParallelScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的</p>
</li>
<li><p>还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p>
</li>
</ul>
<h2 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h2><ul>
<li><p>枚举根节点的时候，用户线程必须要停顿。</p>
</li>
<li><p>根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</p>
</li>
<li><p>这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因</p>
</li>
</ul>
<ul>
<li>虚拟机应当是有办法直接得到哪些地方存放着对象引用的。</li>
<li>在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，</li>
<li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</li>
</ul>
<h3 id="安全点（SafePoint）"><a href="#安全点（SafePoint）" class="headerlink" title="安全点（SafePoint）"></a>安全点（SafePoint）</h3><ul>
<li>实际上HotSpot也的确没有为每条指令都生成OopMap,只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）</li>
<li>安全点的设定，决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停</li>
<li>安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。</li>
</ul>
<h4 id="抢先式中断（Preemptive-Suspension）："><a href="#抢先式中断（Preemptive-Suspension）：" class="headerlink" title="抢先式中断（Preemptive Suspension）："></a>抢先式中断（Preemptive Suspension）：</h4><p>抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>
<p>现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</p>
<h4 id="主动式中断（Voluntary-Suspension）"><a href="#主动式中断（Voluntary-Suspension）" class="headerlink" title="主动式中断（Voluntary Suspension）:"></a>主动式中断（Voluntary Suspension）:</h4><ul>
<li>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</li>
<li>轮询标志的地方和安全点是重合的，</li>
<li>另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li>
</ul>
<h3 id="安全区域（Safe-Region）："><a href="#安全区域（Safe-Region）：" class="headerlink" title="安全区域（Safe Region）："></a>安全区域（Safe Region）：</h3><ul>
<li><p>用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p>
</li>
<li><p>对于这种情况，就必须引入安全区域（Safe Region）来解决。</p>
</li>
<li><p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
</li>
<li><p>我们也可以把安全区域看作被扩展拉伸了的安全点 </p>
</li>
</ul>
<p>当用户线程执行到安全区域里面的代码时，</p>
<ul>
<li>首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li>
<li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），</li>
<li>如果完成了，那线程就当作没事发生过，继续执行；</li>
<li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li>
</ul>
<h3 id="记忆集与卡表（Remembered-Set）："><a href="#记忆集与卡表（Remembered-Set）：" class="headerlink" title="记忆集与卡表（Remembered Set）："></a>记忆集与卡表（Remembered Set）：</h3><ul>
<li><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围</p>
</li>
<li><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</p>
</li>
<li><p>在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节</p>
</li>
</ul>
<h4 id="卡精度："><a href="#卡精度：" class="headerlink" title="卡精度："></a>卡精度：</h4><p>  每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-03-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-03-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" class="post-title-link" itemprop="url">深入理解jvm-03-垃圾收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-26 23:59:09" itemprop="dateCreated datePublished" datetime="2020-12-26T23:59:09+08:00">2020-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-03-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-03-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="垃圾收集需要完成的3件事情"><a href="#垃圾收集需要完成的3件事情" class="headerlink" title="垃圾收集需要完成的3件事情"></a>垃圾收集需要完成的3件事情</h2><ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如果回收</li>
</ul>
<h2 id="为什么要了解gc-和内存分配："><a href="#为什么要了解gc-和内存分配：" class="headerlink" title="为什么要了解gc 和内存分配："></a>为什么要了解gc 和内存分配：</h2><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="运行时数据区域："><a href="#运行时数据区域：" class="headerlink" title="运行时数据区域："></a>运行时数据区域：</h2><h3 id="线程隔离区域"><a href="#线程隔离区域" class="headerlink" title="线程隔离区域"></a>线程隔离区域</h3><ul>
<li><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。</p>
</li>
<li><p>每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，</p>
</li>
<li><p>当方法结束或者线程结束时，内存自然就跟随着回收了。</p>
</li>
</ul>
<h3 id="线程共享区域"><a href="#线程共享区域" class="headerlink" title="线程共享区域"></a>线程共享区域</h3><ul>
<li><p>Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，</p>
</li>
<li><p>只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的</p>
</li>
<li><p>所以 GC 关注的就是这部分区域的内存管理 （分配和回收）</p>
</li>
</ul>
<h2 id="判断对象“死亡”"><a href="#判断对象“死亡”" class="headerlink" title="判断对象“死亡”"></a>判断对象“死亡”</h2><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul>
<li>在对象中添加一个**<em>引用计数器**</em>，</li>
<li>每当有一个地方引用它时，计数器值就加一；</li>
<li>当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的</li>
</ul>
<p>主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p>
<p>举个简单的例子，请看代码中的testGC()方法：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * testGC()方法执行后，objA和objB会不会被GC呢？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testGC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line">[GC (System.gc()) [PSYoungGen: <span class="number">14622</span>K-&gt;<span class="number">1008</span>K(<span class="number">153088</span>K)] <span class="number">14622</span>K-&gt;<span class="number">1016</span>K(<span class="number">502784</span>K), <span class="number">0.0007592</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap after GC invocations=<span class="number">1</span> (full <span class="number">0</span>):</span><br><span class="line"> PSYoungGen      total <span class="number">153088</span>K, used <span class="number">1008</span>K [<span class="number">0x0000000715980000</span>, <span class="number">0x0000000720400000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space <span class="number">131584</span>K, <span class="number">0</span>% used [<span class="number">0x0000000715980000</span>,<span class="number">0x0000000715980000</span>,<span class="number">0x000000071da00000</span>)</span><br><span class="line">  from space <span class="number">21504</span>K, <span class="number">4</span>% used [<span class="number">0x000000071da00000</span>,<span class="number">0x000000071dafc040</span>,<span class="number">0x000000071ef00000</span>)</span><br><span class="line">  to   space <span class="number">21504</span>K, <span class="number">0</span>% used [<span class="number">0x000000071ef00000</span>,<span class="number">0x000000071ef00000</span>,<span class="number">0x0000000720400000</span>)</span><br><span class="line"> ParOldGen       total <span class="number">349696</span>K, used <span class="number">8</span>K [<span class="number">0x00000005c0c00000</span>, <span class="number">0x00000005d6180000</span>, <span class="number">0x0000000715980000</span>)</span><br><span class="line">  object space <span class="number">349696</span>K, <span class="number">0</span>% used [<span class="number">0x00000005c0c00000</span>,<span class="number">0x00000005c0c02000</span>,<span class="number">0x00000005d6180000</span>)</span><br><span class="line"> Metaspace       used <span class="number">3118</span>K, capacity <span class="number">4496</span>K, committed <span class="number">4864</span>K, reserved <span class="number">1056768</span>K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 338<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p>从运行结果中可以清楚看到内存回收日志，意味着虚拟机并没有因为这两个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><ul>
<li><p>基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为<strong>“引用链”（Reference Chain）</strong></p>
</li>
<li><p><strong>如果某个对象到GC Roots间没有任何引用链相连</strong>，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
</li>
</ul>
<p><img src="/uploads/jvm/04-gcRoot.png"></p>
<p>在Java技术体系里面，固定可作为**<em>GC Roots**</em>的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p>ps:  当只针对 java堆中的某一块区域发起GC的时候，  使用局部回收 或者 分代回收 ，需要想到 各个区域并不是孤立封闭的，某个区域里 的对象很有可能被 堆中的其他区域对象引用，所以 这些关联区域的对象也要一起 加入到 GC Roots集合中 去，才能保证 可达性分析的正确性</p>
<h2 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用 reference"></a>引用 reference</h2><ul>
<li><p>无论是通过计数器法 判断对象的引用数量，还是通过可达性分析算法 判断对象是否引用链可达。 判断对象是否存活 都和 “引用” 离不开关系 。</p>
</li>
<li><p>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用</p>
</li>
</ul>
<h3 id="强引用（Strongly-Re-ference）"><a href="#强引用（Strongly-Re-ference）" class="headerlink" title="强引用（Strongly Re-ference）"></a>强引用（Strongly Re-ference）</h3><ul>
<li><p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Objectobj=new Object()”这种引用关系。</p>
</li>
<li><p>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
</li>
</ul>
<h3 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h3><ul>
<li><p>用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，</p>
</li>
<li><p>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，</p>
</li>
<li><p>如果这次回收还没有足够的内存，才会抛出内存溢出异常</p>
</li>
</ul>
<h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h3><ul>
<li>用来描述那些非必须对象，但是它的强度比软引用更弱一些，</li>
<li>被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</li>
<li>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li>
</ul>
<h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h3><h2 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h2><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，</p>
<p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ul>
<li><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，</p>
</li>
<li><p>随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。</p>
</li>
<li><p>假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
</li>
</ul>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。</p>
<p>原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> * 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, i am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">    finalize method executed!</span><br><span class="line">yes, i am still alive :)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure>

<p>运行结果可以看到，</p>
<ul>
<li>SAVE_HOOK对象的finalize()方法确实被垃圾收集器触发过，并且在被收集前成功逃脱了。</li>
<li>另外一个值得注意的地方就是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。</li>
<li>这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><ul>
<li>方法区垃圾收集的“性价比”通常也是比较低的：</li>
</ul>
<p>在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p>
<ul>
<li>方法区的垃圾收集主要回收两部分内容：<strong>废弃的常量</strong> 和<strong>不再使用的类型</strong></li>
</ul>
<p>关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClass-Loading、</p>
<p>-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，</p>
<ul>
<li>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压<br>力。</li>
</ul>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>对于线程私有的 本地方法栈、虚拟机栈、程序计数器 跟随线程的生命周期 ，每个方法的调用和退出对应着一个栈帧的入栈和出栈，栈帧的大小在类结构确定的时候，分配内存的大小就已经确认了，此处的内存回收是已知的，不用过多考虑</li>
<li>对于线程公有的区域： 方法区，java堆。 因为一个接口可能存在多个实现类，方法的不同分支产生的对象数量不等 ，所需的内存大小也不同。 这些都是动态的，只有在运行时期，我们才能确认这部分的数据。所以GC 主要管理的就是这部分的 内存（分配和回收）</li>
<li>判断对象是否死亡2种算法： 引用计数器，GCRoots可达性分析</li>
<li>引用：狭隘的引用概念： 如果reference类型的数据中存储的数值代表着  另一块内存的起始地址，就称 该 reference数据是 某块内存，某个对象的引用 。 后面又分 强引用，软引用，弱引用，虚引用 。</li>
<li>分代收集理论： 弱分代假说，</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-02-OOM%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-02-OOM%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">深入理解jvm-02-OOM异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-26 22:04:23" itemprop="dateCreated datePublished" datetime="2020-12-26T22:04:23+08:00">2020-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-02-OOM%E5%BC%82%E5%B8%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-02-OOM%E5%BC%82%E5%B8%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OOM实战"><a href="#OOM实战" class="headerlink" title="OOM实战"></a>OOM实战</h1><p>《java虚拟机规范》的规定中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM 异常的可能</p>
<h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><ul>
<li>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证 <strong><em>GC Roots到对象之间有可达路径</em></strong> 来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。代码清单2-3中限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX：+HeapDumpOnOutOf-MemoryError可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid14844.hprof ...</span><br><span class="line">Heap dump file created [<span class="number">29587006</span> bytes in <span class="number">0.082</span> secs]</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.base/java.util.Arrays.copyOf(Arrays.java:<span class="number">3720</span>)</span><br><span class="line">	at java.base/java.util.Arrays.copyOf(Arrays.java:<span class="number">3689</span>)</span><br><span class="line">	at java.base/java.util.ArrayList.grow(ArrayList.java:<span class="number">237</span>)</span><br><span class="line">	at java.base/java.util.ArrayList.grow(ArrayList.java:<span class="number">242</span>)</span><br><span class="line">	at java.base/java.util.ArrayList.add(ArrayList.java:<span class="number">485</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>Java堆内存的OutOfMemoryError异常是实际应用中最常见的内存溢出异常情况。出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟随进一步提示“Java heap space”。</li>
</ul>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li>第一步首先应确认内存中导致OOM的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（MemoryOverflow）</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集无法回收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。</li>
<li>如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</li>
</ul>
<h2 id="虚拟机栈-和本地方法栈溢出"><a href="#虚拟机栈-和本地方法栈溢出" class="headerlink" title="虚拟机栈 和本地方法栈溢出"></a>虚拟机栈 和本地方法栈溢出</h2><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常：</p>
<p>1）如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>2）如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟机栈和本地方法栈测试</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackSOF_1 oom = <span class="keyword">new</span> JavaVMStackSOF_1();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length:&quot;</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    stack length:<span class="number">982</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">13</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">14</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">14</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">14</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_1.stackLeak(JavaVMStackSOF_1.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机栈和本地方法栈测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.fenixsoft.jvm.chapter2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM: JDK 1.0.2, Sun Classic VM</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF_3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> stackLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> unused1, unused2, unused3, unused4, unused5,</span><br><span class="line">                unused6, unused7, unused8, unused9, unused10,</span><br><span class="line">                unused11, unused12, unused13, unused14, unused15,</span><br><span class="line">                unused16, unused17, unused18, unused19, unused20,</span><br><span class="line">                unused21, unused22, unused23, unused24, unused25,</span><br><span class="line">                unused26, unused27, unused28, unused29, unused30,</span><br><span class="line">                unused31, unused32, unused33, unused34, unused35,</span><br><span class="line">                unused36, unused37, unused38, unused39, unused40,</span><br><span class="line">                unused41, unused42, unused43, unused44, unused45,</span><br><span class="line">                unused46, unused47, unused48, unused49, unused50,</span><br><span class="line">                unused51, unused52, unused53, unused54, unused55,</span><br><span class="line">                unused56, unused57, unused58, unused59, unused60,</span><br><span class="line">                unused61, unused62, unused63, unused64, unused65,</span><br><span class="line">                unused66, unused67, unused68, unused69, unused70,</span><br><span class="line">                unused71, unused72, unused73, unused74, unused75,</span><br><span class="line">                unused76, unused77, unused78, unused79, unused80,</span><br><span class="line">                unused81, unused82, unused83, unused84, unused85,</span><br><span class="line">                unused86, unused87, unused88, unused89, unused90,</span><br><span class="line">                unused91, unused92, unused93, unused94, unused95,</span><br><span class="line">                unused96, unused97, unused98, unused99, unused100;</span><br><span class="line"></span><br><span class="line">        stackLength ++;</span><br><span class="line">        test();</span><br><span class="line"></span><br><span class="line">        unused1 = unused2 = unused3 = unused4 = unused5 =</span><br><span class="line">                unused6 = unused7 = unused8 = unused9 = unused10 =</span><br><span class="line">                        unused11 = unused12 = unused13 = unused14 = unused15 =</span><br><span class="line">                                unused16 = unused17 = unused18 = unused19 = unused20 =</span><br><span class="line">                                        unused21 = unused22 = unused23 = unused24 = unused25 =</span><br><span class="line">                                                unused26 = unused27 = unused28 = unused29 = unused30 =</span><br><span class="line">                                                        unused31 = unused32 = unused33 = unused34 = unused35 =</span><br><span class="line">                                                                unused36 = unused37 = unused38 = unused39 = unused40 =</span><br><span class="line">                                                                        unused41 = unused42 = unused43 = unused44 = unused45 =</span><br><span class="line">                                                                                unused46 = unused47 = unused48 = unused49 = unused50 =</span><br><span class="line">                                                                                        unused51 = unused52 = unused53 = unused54 = unused55 =</span><br><span class="line">                                                                                                unused56 = unused57 = unused58 = unused59 = unused60 =</span><br><span class="line">                                                                                                        unused61 = unused62 = unused63 = unused64 = unused65 =</span><br><span class="line">                                                                                                                unused66 = unused67 = unused68 = unused69 = unused70 =</span><br><span class="line">                                                                                                                        unused71 = unused72 = unused73 = unused74 = unused75 =</span><br><span class="line">                                                                                                                                unused76 = unused77 = unused78 = unused79 = unused80 =</span><br><span class="line">                                                                                                                                        unused81 = unused82 = unused83 = unused84 = unused85 =</span><br><span class="line">                                                                                                                                                unused86 = unused87 = unused88 = unused89 = unused90 =</span><br><span class="line">                                                                                                                                                        unused91 = unused92 = unused93 = unused94 = unused95 =</span><br><span class="line">                                                                                                                                                                unused96 = unused97 = unused98 = unused99 = unused100 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;stack length:&quot;</span> + stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果： stack length:<span class="number">7550</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_3.test(JavaVMStackSOF_3.java:<span class="number">34</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.JavaVMStackSOF_3.test(JavaVMStackSOF_3.java:<span class="number">34</span>)</span><br></pre></td></tr></table></figure>



<p>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot虚拟机抛出的都是StackOverflowError异常。</p>
<p>可见相同的代码在Classic虚拟机中成功产生了OutOfMemoryError而不是StackOver-flowError异常。如果测试时不限于单线程，通过不断建立线程的方式，HotSpot上也是可以产生内存溢出异常的，具体如代码清单2-6所示。但是这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系，主要取决于操作系统本身的内存使用状态。甚至可以说，在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p>
<p>操作系统分配给每个进程的内存是有限制的，譬如32位Windows的单个进程最大内存限制为2GB。HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值，那剩余的内存即为2GB（操作系统限制）减去最大堆容量，再减去最大方法区容量，由于程序计数器消耗内存很小，可以忽略掉，如果把直接内存和虚拟机进程本身耗费的内存也去掉的话，剩下的内存就由虚拟机栈和本地方法栈来分配了。因此为每个线程分配到的栈内存越大，可以建立的线程数量自<br>然就越少，建立线程时就越容易把剩下的内存耗尽，代码清单2-6演示了这种情况。</p>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。</p>
<p>前面曾经提到HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代的背景故事，在此我们就以测试代码来观察一下，使用“永久代”还是“元空间”来实现方法区，</p>
<p>String::intern()是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过-XX：PermSize和-XX：MaxPermSize限制永久代的大小，即可间接限制其中常量池的容量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行时常量池导致的内存溢出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用Set保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 在short范围内足以让6MB的PermSize产生OOM了</span></span><br><span class="line">        <span class="keyword">short</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">at java.lang.String.intern(Native Method)</span><br><span class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>从运行结果中可以看到，运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是“PermGen space”，说明运行时常量池的确是属于方法区（即JDK 6的HotSpot虚拟机中的永久代）的一部分。</p>
<p>而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使用-XX：MaxPermSize参数或者在JDK 8及以上版本使用-XX：MaxMeta-spaceSize参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将一直进行下去，永不停歇[1]。出现这种变化，是因为自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中，所以在JDK 7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。这时候使用-Xmx参数限制最大堆到6MB就能够看到以下两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OOM异常一：</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.base/java.lang.Integer.toString(Integer.java:<span class="number">440</span>)</span><br><span class="line">at java.base/java.lang.String.valueOf(String.java:<span class="number">3058</span>)</span><br><span class="line">at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:<span class="number">12</span>)</span><br><span class="line"><span class="comment">// OOM异常二：</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.base/java.util.HashMap.resize(HashMap.java:<span class="number">699</span>)</span><br><span class="line">at java.base/java.util.HashMap.putVal(HashMap.java:<span class="number">658</span>)</span><br><span class="line">at java.base/java.util.HashMap.put(HashMap.java:<span class="number">607</span>)</span><br><span class="line">at java.base/java.util.HashSet.add(HashSet.java:<span class="number">220</span>)</span><br><span class="line">at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java from InputFile-Object:<span class="number">14</span>)</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： </span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>而JDK 7（以及部分其他虚拟机，例如JRockit）的intern()方法实现就不需要再拷贝字符串的实例到永久代了，既然字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可，因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。</p>
<p>而对str2比较返回false，这是因为“java”[2]这个字符串在执行String-Builder.toString()之前就已经出现过了，字符串常量池中已经有它的引用，不符合intern()方法要求“首次遇到”的原则，“计算机软件”这个字符串则是首次出现的，因此结果返回true。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>-XX：MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。<br>-XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值。<br>·-XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可<br>减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最<br>大的元空间剩余容量的百分比</p>
<h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>直接内存（Direct Memory）的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致，代码清单越过了DirectByteBuffer类直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例，体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能，在JDK 10时才将Unsafe的部分功能通过VarHandle开放给外部使用），因为虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常，真正申请分配内存的方法是Unsafe::allocateMemory()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError</span><br><span class="line">	at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">	at org.fenixsoft.jvm.chapter2.DirectMemoryOOM.main(DirectMemoryOOM.java:<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，如果读者发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-01-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-01-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">深入理解jvm-01-自动内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-26 15:02:06" itemprop="dateCreated datePublished" datetime="2020-12-26T15:02:06+08:00">2020-12-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-01-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-01-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h1><h2 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h2><p><img src="/uploads/jvm/01-runtimedatazone.png"></p>
<h3 id="程序计数器-（线程私有的）"><a href="#程序计数器-（线程私有的）" class="headerlink" title="程序计数器  （线程私有的）"></a>程序计数器  （线程私有的）</h3><p>Program Counter Register， 可以看作是当前线程执行字节码的行号指示器</p>
<ul>
<li><p><strong><em>字节码解释器</em></strong>  工作时 通过改变**<em>程序计数器**</em> 的值，来选取下一条需要执行的字节码指令 。</p>
<p>相当于时程序控制流的 指示器，告诉jvm 下一条要执行的命令是什么 。 分支、循环、跳转、异常处理、线程恢复等 都依赖 改变 程序计数器 值来完成  </p>
</li>
</ul>
<ul>
<li><p>jvm 的多线程是通过线程 轮流切换、分配处理器执行时间的方式实现的。 </p>
</li>
<li><p>在任何一个确定的时间，处理器只会处理某一个线程中的指令。为了确保线程切换回去后，能恢复到之前 线程的正确执行位置，</p>
<p>所以每条线程都有独立的 <strong><em>程序计数器</em></strong> ，各个线程之间的程序计数器 互相隔离，互不影响干扰，独立存储</p>
<p><strong>所以 说 程序计数器是 线程私有的</strong></p>
</li>
<li><p>如果A线程执行 的是java方法，计数器记录的是 字节码指令的地址 。</p>
</li>
<li><p>如果B线程执行的是 本地Native 方法，计数器记录的是 空 undefined</p>
</li>
</ul>
<h3 id="Java虚拟机栈（线程私有的）"><a href="#Java虚拟机栈（线程私有的）" class="headerlink" title="Java虚拟机栈（线程私有的）"></a>Java虚拟机栈（线程私有的）</h3><p>Java Virtual Machine Stack 也是线程私有的。所以它的生命周期 和线程相同</p>
<ul>
<li><p><strong>为 执行Java 方法 服务</strong></p>
</li>
<li><p><strong><em>java虚拟机栈</em></strong>  描述的是java方法执行的<strong>线程内存模型</strong> </p>
</li>
<li><p>每个方法被执行的时候，jvm都会同步创建一个<strong>栈帧 （stack frame）</strong>，用于存储 <strong>局部变量表</strong>、操作数栈、动态连接、方法出口等信息</p>
</li>
<li><p>一个方法从 被调用执行 到 执行完毕的过程，对应这一个 栈帧 从虚拟机栈从 入栈到 出栈的过程 </p>
</li>
<li><p>ps : 程序员口中 笼统的 将java 内存分为 堆内存（Heap）和 栈内存（Stack） 。栈内存指的就是  <strong><em>java虚拟机栈</em></strong>  ，再具体一点就是 其中的 <strong><em>局部变量表</em></strong></p>
</li>
<li><p><strong><em>栈帧（Stack Frame）是方法运行期很重要的 基本数据结构</em></strong></p>
</li>
</ul>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul>
<li><p>存放 了编译期可知的 各种java 基本数据类型 （boolean、byte、char、short、int、long、float、double）</p>
</li>
<li><p>存放了各类对象引用类型 （reference）（不是真的对象，是对象的地址 或者句柄）</p>
</li>
<li><p>存放了 returnAdress 类型 （指向了一条 字节码指令 的地址）</p>
</li>
</ul>
<ul>
<li>存储空间的单位 用 局部变量槽（Slot）来表示， 所以 局部变量表的大小，指的 就是 变量槽 的数量，比如 64位长度的long 和double占用2个 Slot，其他类型1个Slot </li>
</ul>
<ul>
<li>在该区域，存在2中异常情况<ul>
<li>如果线程请求的栈深度 大于jvm 允许的深度， 抛出 StackOverflowError</li>
<li>如果java虚拟机栈 允许 动态扩展，但是申请不到足够内存，抛出 OutofMemoryErrory </li>
</ul>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>Native Method Stack</p>
<ul>
<li><strong><em>为执行本地方法 (Native Method)服务</em></strong></li>
<li> 也会报 栈深度溢出 （Stack Overflow error）和 栈扩展异常 （OutOfMemoryError）</li>
</ul>
<h3 id="Java-堆（Heap）（线程共享）"><a href="#Java-堆（Heap）（线程共享）" class="headerlink" title="Java 堆（Heap）（线程共享）"></a>Java 堆（Heap）（线程共享）</h3><ul>
<li>java 堆是JVM 管理的内存中 <strong><em>最大的一块</em></strong> </li>
<li><strong><em>所有线程共享</em></strong>的 内存区域</li>
<li>用于存放对象实例，Java世界里 **“几乎” **所有的对象实例都在这里分配内存 </li>
<li>因为有可能未来出现 <strong><em>值类型</em></strong>，并且 因为**<em>逃逸分析**</em>技术的发展，栈上分配、标量替换优化手段 ，所以 不是全部java对象都在Heap上分配内存</li>
</ul>
<ul>
<li><p>java 堆是GC管理的内存区域，所以也称为 <strong><em>GC堆</em></strong></p>
</li>
<li><p>以前的GC 器 大部分使用的是 <strong>经典分代收集</strong> 理论设计的，所以 将java堆 化为为 新生代、老年代、永久代、Eden区，2个Survivor 。但是现在 也存在不使用 分代收集的 GC器 </p>
</li>
<li><p>所有线程共享的java堆 可以划分出 多个线程私有的  <strong><em>分配缓冲区******（Thread Local Allocation Buffer，TLAB）</em></strong>，用于  <strong>提高分配内存的效率</strong></p>
</li>
<li><p>不管如果将 java堆细分，java堆都是<strong>存储 对象的实例</strong>，更细的划分只是为了<strong>更好的回收内存或者更好的分配内存</strong>  </p>
</li>
<li><p>java堆 即可设计成固定大小的，也可以 设计成 可扩展的 ，</p>
</li>
<li><p>当前大部分 JVM都是设计成 可扩展的 ，通过 <strong>（-Xmx 和-Xms ）</strong>设定</p>
</li>
<li><p>如果堆 没有内存完成 实例分配，并且 堆也不可扩展时候，JVM 会抛出 OutOfMemoryError  (OOM)</p>
</li>
</ul>
<h3 id="方法区-非堆-Non-Heap-（线程共享）"><a href="#方法区-非堆-Non-Heap-（线程共享）" class="headerlink" title="方法区 (非堆 Non-Heap)（线程共享）"></a>方法区 (非堆 Non-Heap)（线程共享）</h3><p>Method Area</p>
<ul>
<li><p>用于存储已经被JVM加载的类型信息 、常量、静态变量、即时编译器编译后的代码缓存等数据  </p>
</li>
<li><p>《java虚拟机规范》将方法区描述为 堆的一个逻辑部分，别名为  <strong><em>“非堆”</em></strong>（**<em>Non-Heap）**</em>，用于和 java堆 区分开来</p>
</li>
<li><p>在Java8以前，把 方法区成为 “永久代（Permanent Generation）” ，但本质上2者 并不是等价的。   </p>
</li>
<li><p>因为当时 团队把GC的分代设计  扩展到了方法区， 使用了 永久代 来实现方法区的收集 。当时 希望像管理 java堆 一样的方式管理 方法区这一部分内存 。这样就可以 <strong><em>不用专门为 方法区 编写内存管理的代码</em></strong> ， </p>
</li>
<li><p>但是后面经过验证发现 永久代的实现更容易引起 OOM，永久代有 （-XX: MaxPermSize的上限 ，即使不设置也会有默认值）</p>
</li>
<li><p>所以java8的版本 完全废弃了 永久代的概念， 使用**<em>元空间**</em> （Meta-space） 来代替 。（使用本地内存管理的 方式 实现）</p>
</li>
<li><p>对方法区的内存回收目标：主要是针对 常量池的回收和类型的卸载 。回收效果不是很棒，但是又不能不管</p>
</li>
<li><p>GC 操作在该区域的频率是很少的 ，如同它的前称 “永久代”的名字一样 </p>
</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>runtime constant pool ，是方法区的一部分 。</p>
<ul>
<li>Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项信息是 <strong><em>常量池表（Constant Pool Table）</em></strong>，用于 存放编译期生成的各种字面量和 符号引用。</li>
<li>常量池表 就是放在 运行时常量池 中</li>
<li>运行时常量池  具备 动态性，java 语言并不要求常量一定在编译期才能产生，运行时也可以将新的常量放在池中 ，如： String的 intern()方法</li>
<li>因为  运行时常量池 是方法区的一部分，所以也受 方法区的内存现在，当申请不到内存的时候，也会报  OOM</li>
<li></li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>Direct Memory ,并不是JVM运行时数据区的一部分 ，也不是《java虚拟机规范》中定义的内存区域，但是这部分内存频繁被使用， 也可能抛出 OOM </p>
<ul>
<li><p>JDK 1.4中假如 NIO（new Input/Output）类，引入了一种基于通道（Channel）与缓冲区的 I/O方式 ，它可以使用Native 函数库 直接分配 堆外内存，然后</p>
<p>通过一个存储在java堆 里面的DirectByBuffer 对象作为 这块内存的引用进行操作，这样 避免java堆 和Native堆中 来回复制对象 。</p>
</li>
</ul>
<ul>
<li>直接内存的分配不会受 java堆大小的限制，但是 受到 计算机总内存 大小的限制 。</li>
<li>一般 服务器管理员管理虚拟机配置的时候 ，会更根据实际内存 设置 -Xmx的大小，但经常忽略掉 直接内存。  导致 各个内存区域 总和 大于 物理内存限制 。 从而动态扩展的时候出现  OOM</li>
</ul>
<h2 id="Java对象的创建"><a href="#Java对象的创建" class="headerlink" title="Java对象的创建"></a>Java对象的创建</h2><p>jvm 会进行类加载操作，类加载操作完成后，对象实例所需的内存大小就已经确定了 ，然后就需要对java对象实例 进行 内存分配了。 </p>
<h3 id="分配内存的方式"><a href="#分配内存的方式" class="headerlink" title="分配内存的方式"></a>分配内存的方式</h3><p>为对象分配内存任务的操作，就等同于 把一块确定大小的 内存 从java堆中分配出来 </p>
<h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><ul>
<li><p>如果 java堆中 内存时决定规整的，所有被使用的内存 都被放在 一边，空闲的内存被放在另一边，中间放着一个**<em>指针**</em>   为分界点的指示器 ，</p>
</li>
<li><p>那所分配内存就仅仅时把 指针 往空闲空间方向挪动一段与 对象大小相等的距离 ，这种分配称为 <strong><em>指针碰撞（Bump The Pointer）</em></strong></p>
</li>
</ul>
<h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><ul>
<li><p>如果java堆中的内存不是规整的 ，已经被使用的内存 和空闲的内存相互交错在一起， 那么虚拟机就需要 维护一个列表，记录那些内存块 时可用的。</p>
</li>
<li><p> 在分配内存 的时候，找到一块足够大的空间划分给 对象实例，并更新列表上的记录，这种方式称为 <strong><em>空闲列表（Free List）</em></strong></p>
</li>
</ul>
<p>java堆是否规整，取决于 GC器是否带有空间压缩整理（Compact）的能力决定，因此</p>
<p>因此，</p>
<ul>
<li>当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；</li>
<li>当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。</li>
</ul>
<h3 id="解决-分配内存空间的并发问题"><a href="#解决-分配内存空间的并发问题" class="headerlink" title="解决 分配内存空间的并发问题"></a>解决 分配内存空间的并发问题</h3><ul>
<li><p>对进行分配内存空间的操作进行同步处理，保证更新操作的原子性</p>
</li>
<li><p>把内存分配动作安装线程划分在不同的 空间中进行。即 每个线程在 java堆中预先分配一小块内存 ，称为 本地线程分配缓冲区（Thread Local Allocation Buffer, TLAB）。线程分配内存的时候，先在该线程的本地缓冲区 中分配。当本地缓冲区用完了，分配新的缓冲区时候，才需要同步锁定 。</p>
<p>使用 -XX: +/-UseTLAB 参数来设定</p>
</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在堆内存中的存储布局分为3部分</p>
<ul>
<li><p>对象头（Header）</p>
<p>对象头部分包含2类信息</p>
<ul>
<li>“Mark Word” ：用于存储对象自身的运行时数据 ，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li>
<li>类型指针： 即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例</li>
</ul>
</li>
<li><p>实例数据（Instance Data）</p>
<ul>
<li><p>实例数据是  对象真正存储的有效信息，即 程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
</li>
<li><p>这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。</p>
</li>
<li><p>HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs），</p>
</li>
<li><p>从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</p>
</li>
</ul>
</li>
<li><p>对齐填充（Padding）</p>
<ul>
<li><p>这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</p>
</li>
<li><p>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。</p>
</li>
<li><p>对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），</p>
</li>
<li><p>因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
</li>
</ul>
</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>创建对象自然是为了后续使用该对象，java通过栈上的reference数据来操作堆上的具体对象。 </p>
<p>主流的访问方式使用使用 句柄 和 直接指针 这两种：</p>
<h3 id="句柄的方式"><a href="#句柄的方式" class="headerlink" title="句柄的方式"></a>句柄的方式</h3><p>java堆中划出 一块内存作为句柄池，reference 中存储的就是对象的句柄地址 。而 句柄中包含对象的实例数据与类型数据各自的具体地址信息 </p>
<p><img src="/uploads/jvm/02-handlePool.png"></p>
<h3 id="直接使用指针的方式："><a href="#直接使用指针的方式：" class="headerlink" title="直接使用指针的方式："></a>直接使用指针的方式：</h3><p>java堆中的内存布局 必须考虑如何放置 类型数据的相关信息 。reference 存储的直接就是对象地址 。如果只是访问对象本身的话，不需要多一次间接访问的开销 。</p>
<p><img src="/uploads/jvm/03-redirectPointer.png"></p>
<h3 id="两种方式各有优势"><a href="#两种方式各有优势" class="headerlink" title="两种方式各有优势"></a>两种方式各有优势</h3><ul>
<li>使用句柄来访问的最大好处就是 reference 中存储的是稳定句柄地址，在对象被移动（GC时候移动对象是非常普遍的行为）时，只会改变句柄中的实例数据指针，而reference本身不需要被修改 </li>
<li>使用直接指针的好处就是 速度更快，节省了一次指针定位的时间开销，由于对象访问非常频繁，因为这类开销积少成多后是 非常可观的执行成本</li>
<li>hotspot 使用的就是  直接指针</li>
</ul>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>方法区和java堆 是线程共享的 ，虚拟机栈、本地方法栈、程序计数器都是线程私有的 </li>
<li>虚拟机栈描述了java 方法执行的 线程内存模型，一个java方法被调用，jvm就会创建一个对应的栈帧（stackFrame），方法的执行开始到结束对应这一个栈帧的入栈和出栈。</li>
<li>局部变量表是 虚拟机栈的一部分，里面存储了 编译期 可知的8种基本数据类型（short，int，long，double，float，byte，char，boolean）、引用类型reference（存储对象的地址 或者句柄），returnAdress返回地址类型（存储的是一个字节码的指令地址 ）</li>
<li>java 堆是gc管理的区域，将gc堆进行精细的划分区域是分了更高效的分配和回收内存 。</li>
<li>以前的GC 器 大部分使用的是 <strong>经典分代收集</strong> 理论设计的，所以 将java堆 化为为 新生代、老年代、永久代、Eden区，2个Survivor 。但是现在 也存在不使用 分代收集的 GC器 </li>
<li>java堆用于存储对象实例 </li>
<li>方法区用于存储类型信息、常量、静态变量， java8以前使用永久代的方式 收集该区域内存 ，后面使用<strong>本地内存方式实现的元空间</strong>代替永久代 , GC的行为在这个区域发生的频率很低，这个区域的回收目标主要是针对 常量池的回收和对类型的卸载 。所以称为 永久代一点不为过</li>
<li>分配内存的2种方式 ：指针碰撞（内存区域是否规整，GC器是否具有空间压缩功能）、空闲列表（）</li>
<li>分配内存时候如何防止并发：<ul>
<li>1种 是对分配内存空间的操作进行同步处理（cas配上失败重试的方式保证原子性）</li>
<li>本地线程分配缓冲（THread local allocation buffer），先预先给每个线程分配一小块内存，线程需要创建对象分配内存是否，先在线程的缓冲区分配，不够了再分配新的缓冲区 </li>
</ul>
</li>
<li>访问定位对象的2种方式： <ul>
<li>句柄，在java堆划出一个句柄池区域，java栈本地变量表 reference 存储句柄池的地址 ，句柄中存储 到对象实例数据和对象类型数据的  指针 。  这样的好处在于 当对象发生移动时候，java栈中存储的reference 不需要改变，只需要改变句柄的指针就可以 </li>
<li>直接指针 ：java方法栈 reference存储的就是 对象的地址 ，好处就是定位迅速 </li>
</ul>
</li>
<li>元空间的异常 有可能发生在 ：spring或者hirbernate 的动态增强，生成大量的 动态类的场景中。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-06-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-06-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">Spring源码解析-06-AOP动态代理源码解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-23 23:32:33" itemprop="dateCreated datePublished" datetime="2020-12-23T23:32:33+08:00">2020-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">Spring源码</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-06-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-06-AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="AOP动态代理"><a href="#AOP动态代理" class="headerlink" title="AOP动态代理"></a>AOP动态代理</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式；</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><p>导入aop模块；Spring AOP：(spring-aspects)</p>
</li>
<li><p>定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）</p>
</li>
<li><p>定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；</p>
<ul>
<li>前置通知(@Before)：logStart：在目标方法(div)运行之前运行</li>
<li>后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）</li>
<li>返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行</li>
<li>异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行</li>
<li>环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）</li>
</ul>
</li>
<li><p>给切面类的目标方法标注何时何地运行（通知注解）</p>
</li>
<li><p>将切面类和业务逻辑类（目标方法所在类）都加入到容器中;</p>
</li>
<li><p>必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)</p>
</li>
<li><p>给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】</p>
<p>ps:  在Spring中很多的 @EnableXXX;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 目标类 **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathCalculator</span> </span>&#123;</span><br><span class="line">	<span class="comment">//目标方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;MathCalculator...div...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> i/j;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 切面类**/</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// @Aspect 告诉Spring当前类是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspects</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//抽取公共的切入点表达式</span></span><br><span class="line">	<span class="comment">//1、本类引用</span></span><br><span class="line">	<span class="comment">//2、其他的切面引用</span></span><br><span class="line">	<span class="meta">@Pointcut(&quot;execution(public int com.atguigu.aop.MathCalculator.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）</span></span><br><span class="line">	<span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">		Object[] args = joinPoint.getArgs();</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;运行。。。@Before:参数列表是：&#123;&quot;</span>+Arrays.asList(args)+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@After(&quot;com.atguigu.aop.LogAspects.pointCut()&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logEnd</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;结束。。。@After&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//JoinPoint一定要出现在参数表的第一位</span></span><br><span class="line">	<span class="meta">@AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logReturn</span><span class="params">(JoinPoint joinPoint,Object result)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;正常返回。。。@AfterReturning:运行结果：&#123;&quot;</span>+result+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint,Exception exception)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;&quot;</span>+joinPoint.getSignature().getName()+<span class="string">&quot;异常。。。异常信息：&#123;&quot;</span>+exception+<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 配置类 **/</span> </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">//开启基于注解的aop模式</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAOP</span> </span>&#123;</span><br><span class="line">	 </span><br><span class="line">	<span class="comment">//业务逻辑类加入容器中</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MathCalculator <span class="title">calculator</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MathCalculator();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//切面类加入到容器中</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LogAspects <span class="title">logAspects</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LogAspects();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="分三步"><a href="#分三步" class="headerlink" title="分三步"></a>分三步</h3><ol>
<li>将业务逻辑组件和切面类都加入到容器中；告诉Spring哪个是切面类（@Aspect）</li>
<li>在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）</li>
<li>开启基于注解的aop模式；@EnableAspectJAutoProxy</li>
</ol>
<h3 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h3><ul>
<li>看给容器中注册了什么组件，</li>
<li>这个组件什么时候工作，</li>
<li>这个组件的功能是什么？</li>
</ul>
<h4 id="EnableAspectJAutoProxy-是什么？"><a href="#EnableAspectJAutoProxy-是什么？" class="headerlink" title="@EnableAspectJAutoProxy 是什么？"></a>@EnableAspectJAutoProxy 是什么？</h4><ul>
<li><p>@Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar</p>
</li>
<li><p>利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion</p>
<p>internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator </p>
</li>
<li><p>给容器中注册一个AnnotationAwareAspectJAutoProxyCreator；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">  <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line">  <span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	 * Indicate whether subclass-based (CGLIB) proxies are to be created as opposed</span></span><br><span class="line"><span class="comment">  	 * to standard Java interface-based proxies. The default is &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">  	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	 * Indicate that the proxy should be exposed by the AOP framework as a &#123;<span class="doctag">@code</span> ThreadLocal&#125;</span></span><br><span class="line"><span class="comment">  	 * for retrieval via the &#123;<span class="doctag">@link</span> org.springframework.aop.framework.AopContext&#125; class.</span></span><br><span class="line"><span class="comment">  	 * Off by default, i.e. no guarantees that &#123;<span class="doctag">@code</span> AopContext&#125; access will work.</span></span><br><span class="line"><span class="comment">  	 * <span class="doctag">@since</span> 4.3.1</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">  	<span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  * Registers an &#123;@link org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator</span><br><span class="line">  * AnnotationAwareAspectJAutoProxyCreator&#125; against the current &#123;@link BeanDefinitionRegistry&#125;</span><br><span class="line">  * as appropriate based on a given @&#123;@link EnableAspectJAutoProxy&#125; annotation.</span><br><span class="line">  *</span><br><span class="line"></span><br><span class="line">* @author Chris Beams</span><br><span class="line">  * @author Juergen Hoeller</span><br><span class="line">  * @since 3.1</span><br><span class="line">  * @see EnableAspectJAutoProxy</span><br><span class="line">  */</span><br><span class="line">   class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line"></span><br><span class="line"> 	/**</span><br><span class="line"> 	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span><br><span class="line">       	 * of the @&#123;@link EnableAspectJAutoProxy<span class="comment">#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line">               	 * &#123;@code @Configuration&#125; class.</span><br><span class="line">             </span><br><span class="line">               	    	 */</span><br><span class="line">               	@Override</span><br><span class="line">               	public void registerBeanDefinitions(</span><br><span class="line">               			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line"> 		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line"> 		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line"> 				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line"> 		<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line"> 			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line"> 			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="AnnotationAwareAspectJAutoProxyCreator："><a href="#AnnotationAwareAspectJAutoProxyCreator：" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator："></a>AnnotationAwareAspectJAutoProxyCreator：</h4><p>溯源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator ;</span><br><span class="line">AspectJAwareAdvisorAutoProxyCreator extends AbstractAdvisorAutoProxyCreator ;</span><br><span class="line">AbstractAdvisorAutoProxyCreator extends AbstractAutoProxyCreator ;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory</p>
<ul>
<li>AbstractAutoProxyCreator.setBeanFactory()</li>
<li>AbstractAutoProxyCreator.有后置处理器的逻辑；</li>
<li>AbstractAdvisorAutoProxyCreator.setBeanFactory()-》initBeanFactory()</li>
<li>AnnotationAwareAspectJAutoProxyCreator.initBeanFactory()</li>
</ul>
<h4 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h4><p>AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor，会调用postProcessBeforeInstantiation()</p>
<ul>
<li><p>先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；只要创建好的Bean都会被缓存起来  </p>
</li>
<li><p>AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例</p>
<p>【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】</p>
<p>【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象的】</p>
</li>
<li><p>resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation </p>
<p>希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续</p>
</li>
</ul>
<h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>AnnotationAwareAspectJAutoProxyCreator[InstantiationAwareBeanPostProcessor] </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】	的作用：</span><br><span class="line"> * 1）、每一个bean创建之前，调用postProcessBeforeInstantiation()；</span><br><span class="line"> * 		关心MathCalculator和LogAspect的创建</span><br><span class="line"> * 		1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class="line"> * 		2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，</span><br><span class="line"> * 			或者是否是切面（@Aspect）</span><br><span class="line"> * 		3）、是否需要跳过</span><br><span class="line"> * 			1）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】</span><br><span class="line"> * 				每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；</span><br><span class="line"> * 				判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回<span class="literal">true</span></span><br><span class="line"> * 			2）、永远返回<span class="literal">false</span></span><br><span class="line"> * </span><br><span class="line"> * 2）、创建对象</span><br><span class="line"> * postProcessAfterInitialization；</span><br><span class="line"> * 		<span class="built_in">return</span> wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下</span><br><span class="line"> * 		1）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors</span><br><span class="line"> * 			1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）</span><br><span class="line"> * 			2、获取到能在bean使用的增强器。</span><br><span class="line"> * 			3、给增强器排序</span><br><span class="line"> * 		2）、保存当前bean在advisedBeans中；</span><br><span class="line"> * 		3）、如果当前bean需要增强，创建当前bean的代理对象；</span><br><span class="line"> * 			1）、获取所有增强器（通知方法）</span><br><span class="line"> * 			2）、保存到proxyFactory</span><br><span class="line"> * 			3）、创建代理对象：Spring自动决定</span><br><span class="line"> * 				JdkDynamicAopProxy(config);jdk动态代理；</span><br><span class="line"> * 				ObjenesisCglibAopProxy(config);cglib的动态代理；</span><br><span class="line"> * 		4）、给容器中返回当前组件使用cglib增强了的代理对象；</span><br><span class="line"> * 		5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</span><br><span class="line"> * 		</span><br><span class="line"> * 	</span><br><span class="line"> * 	3）、目标方法执行	；</span><br><span class="line"> * 		容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）；</span><br><span class="line"> * 		1）、CglibAopProxy.intercept();拦截目标方法的执行</span><br><span class="line"> * 		2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；</span><br><span class="line"> * 			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"> * 			1）、List&lt;Object&gt; interceptorList保存所有拦截器 5</span><br><span class="line"> * 				一个默认的ExposeInvocationInterceptor 和 4个增强器；</span><br><span class="line"> * 			2）、遍历所有的增强器，将其转为Interceptor；</span><br><span class="line"> * 				registry.getInterceptors(advisor);</span><br><span class="line"> * 			3）、将增强器转为List&lt;MethodInterceptor&gt;；</span><br><span class="line"> * 				如果是MethodInterceptor，直接加入到集合中</span><br><span class="line"> * 				如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；</span><br><span class="line"> * 				转换完成返回MethodInterceptor数组；</span><br><span class="line"> * </span><br><span class="line"> * 		3）、如果没有拦截器链，直接执行目标方法;</span><br><span class="line"> * 			拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制）</span><br><span class="line"> * 		4）、如果有拦截器链，把需要执行的目标对象，目标方法，</span><br><span class="line"> * 			拦截器链等信息传入创建一个 CglibMethodInvocation 对象，</span><br><span class="line"> * 			并调用 Object retVal =  mi.proceed();</span><br><span class="line"> * 		5）、拦截器链的触发过程;</span><br><span class="line"> * 			1)、如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法；</span><br><span class="line"> * 			2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</span><br><span class="line"> * 				拦截器链的机制，保证通知方法与目标方法的执行顺序；</span><br><span class="line"> * 		</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>@EnableAspectJAutoProxy 开启AOP功能</li>
<li>@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</li>
<li>AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</li>
<li>容器的创建流程：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象</span><br><span class="line">2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean</span><br><span class="line">	1）、创建业务逻辑组件和切面组件</span><br><span class="line">	2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程</span><br><span class="line">	3）、组件创建完之后，判断组件是否需要增强</span><br><span class="line">		是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>执行目标方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）、代理对象执行目标方法</span><br><span class="line">2）、CglibAopProxy.intercept()；</span><br><span class="line">	1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）</span><br><span class="line">	2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；</span><br><span class="line">	3）、效果：</span><br><span class="line">		正常执行：前置通知-》目标方法-》后置通知-》返回通知</span><br><span class="line">		出现异常：前置通知-》目标方法-》后置通知-》异常通知</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-05-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-05-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" class="post-title-link" itemprop="url">Spring源码解析-05-自动装配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-23 23:32:33" itemprop="dateCreated datePublished" datetime="2020-12-23T23:32:33+08:00">2020-12-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">Spring源码</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-05-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/23/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-05-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring利用依赖注入（DI），完成对IOC容器中中各个组件的依赖关系赋值；</p>
<h3 id="Autowired：自动注入"><a href="#Autowired：自动注入" class="headerlink" title="@Autowired：自动注入"></a>@Autowired：自动注入</h3><ul>
<li>默认优先按照类型去容器中找对应的组件:applicationContext.getBean(BookDao.class);找到就赋值</li>
<li>如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找 applicationContext.getBean(“bookDao”)</li>
<li>@Qualifier(“bookDao”)：使用@Qualifier指定需要装配的组件的id，而不是使用属性名</li>
<li>自动装配默认一定要将属性赋值好，没有就会报错；可以使用@Autowired(required=false);</li>
<li>@Primary：让Spring进行自动装配的时候，默认使用首选的bean；也可以继续使用@Qualifier指定需要装配的bean的名字</li>
</ul>
<h3 id="Resource-JSR250"><a href="#Resource-JSR250" class="headerlink" title="@Resource(JSR250)"></a>@Resource(JSR250)</h3><p>@Resource:</p>
<ul>
<li><p>默认是按照组件名称进行装配的；</p>
</li>
<li><p>可以和@Autowired一样实现自动装配功能；</p>
</li>
<li><p>没有能支持@Primary功能</p>
</li>
<li><p>没有支持@Autowired（reqiured=false）;</p>
</li>
</ul>
<h3 id="Inject-JSR330-java规范的注解"><a href="#Inject-JSR330-java规范的注解" class="headerlink" title="@Inject(JSR330)[java规范的注解]"></a>@Inject(JSR330)[java规范的注解]</h3><ul>
<li><p>需要导入javax.inject的包，</p>
</li>
<li><p>和Autowired的功能一样。</p>
</li>
<li><p>没有required=false的功能；</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps:"></a>ps:</h3></li>
</ul>
<p>@Autowired:Spring定义的； </p>
<p>@Resource、@Inject都是java规范</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><ul>
<li>AutowiredAnnotationBeanPostProcessor:解析完成自动装配功能；</li>
</ul>
<h3 id="Autowired位置"><a href="#Autowired位置" class="headerlink" title="@Autowired位置"></a>@Autowired位置</h3><p>@Autowired:构造器，参数，方法，属性 ，都是从容器中获取参数组件的值</p>
<ul>
<li><p>标注在set方法位置： @Bean+方法参数；参数从容器中获取;默认不写@Autowired效果是一样的；都能自动装配</p>
</li>
<li><p>标在构造器上：如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取</p>
</li>
<li><p>放在参数位置： </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认加在ioc容器中的组件，容器启动会调用无参构造器创建对象，再进行初始化赋值等操作</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Car car;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器要用的组件，都是从容器中获取</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">		System.out.println(<span class="string">&quot;Boss...有参构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//@Autowired </span></span><br><span class="line">	<span class="comment">//标注在方法，Spring容器创建当前对象，就会调用方法，完成赋值；</span></span><br><span class="line">	<span class="comment">//方法使用的参数，自定义类型的值从ioc容器中获取</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(// <span class="meta">@Autowired</span></span></span></span><br><span class="line"><span class="function"><span class="params">        Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Boss [car=&quot;</span> + car + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.liming.service&quot;,&quot;com.liming.dao&quot;,</span></span><br><span class="line"><span class="meta">	&quot;com.liming.controller&quot;,&quot;com.liming.bean&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConifgOfAutowired</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Primary</span></span><br><span class="line">	<span class="meta">@Bean(&quot;bookDao2&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">		BookDao bookDao = <span class="keyword">new</span> BookDao();</span><br><span class="line">		bookDao.setLable(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> bookDao;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Bean</span>标注的方法创建对象的时候，方法参数的值从容器中获取</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> car</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Color <span class="title">color</span><span class="params">(Car car)</span></span>&#123;</span><br><span class="line">		Color color = <span class="keyword">new</span> Color();</span><br><span class="line">		color.setCar(car);</span><br><span class="line">		<span class="keyword">return</span> color;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="把Spring底层一些组件注入到自定义的Bean中"><a href="#把Spring底层一些组件注入到自定义的Bean中" class="headerlink" title="把Spring底层一些组件注入到自定义的Bean中"></a>把Spring底层一些组件注入到自定义的Bean中</h3><p>自定义组件想要使用Spring容器底层的一些组件（ApplicationContext，BeanFactory，xxx）；</p>
<ul>
<li><pre><code>    自定义组件实现xxxAware；在创建对象的时候，会调用接口规定的方法注入相关组件；Aware；</code></pre>
</li>
<li><pre><code>    把Spring底层一些组件注入到自定义的Bean中；</code></pre>
</li>
<li><pre><code>    xxxAware：功能使用xxxProcessor；</code></pre>
</li>
<li><pre><code>        ApplicationContextAware==》ApplicationContextAwareProcessor. invokeAwareInterfaces ；会帮忙把spring底层逐渐传入到当前bean </code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>,<span class="title">BeanNameAware</span>,<span class="title">EmbeddedValueResolverAware</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot;传入的ioc：&quot;</span>+applicationContext);</span><br><span class="line">      <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">&quot;当前bean的名字：&quot;</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver resolver)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      String resolveStringValue = resolver.resolveStringValue(<span class="string">&quot;你好 $&#123;os.name&#125; 我是 #&#123;20*18&#125;&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;解析的字符串：&quot;</span>+resolveStringValue);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinshi</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"4oBiQGiWDHdACABLWjT7ouaV-gzGzoHsz","appKey":"fr4vMSPUjcHLtIrF2hmRF6UE","serverURLs":"https://4obiqgiw.lc-cn-n1-shared.com","placeholder":"国王不动，手下怎么跟随? --反叛的鲁鲁修","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"cdh":"https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"}, {
      el: '#valine-comments',
      path: "/page/4/",
      serverURLs: "https://4obiqgiw.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>


</body>
</html>
