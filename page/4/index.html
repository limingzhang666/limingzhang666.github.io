<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="HCj467TtuvFkAzzdCvYvbniAeNiUy7TUwp2hG1qGWQE">
  <meta name="baidu-site-verification" content="LppFIbSdZO">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limingzhang666.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","width":320,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="拨开云雾见青天">
<meta property="og:type" content="website">
<meta property="og:title" content="Yinshi&#39;s Blog">
<meta property="og:url" content="https://limingzhang666.github.io/page/4/index.html">
<meta property="og:site_name" content="Yinshi&#39;s Blog">
<meta property="og:description" content="拨开云雾见青天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yinshi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://limingzhang666.github.io/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yinshi's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yinshi's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yinshi"
      src="/images/yinshi01_avatar.jpg">
  <p class="site-author-name" itemprop="name">Yinshi</p>
  <div class="site-description" itemprop="description">拨开云雾见青天</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">72</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/limingzhang666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limingzhang666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:laimingcham@163.com" title="E-Mail → mailto:laimingcham@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/limingzhang666" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">深入理解jvm-14-前端编译与优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-27 20:12:07" itemprop="dateCreated datePublished" datetime="2021-01-27T20:12:07+08:00">2021-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h1><p>在Java技术下谈“编译期”而没有具体上下文语境的话，其实是一句很含糊的表述，</p>
<ul>
<li><p>因为它可能是指一个前端编译器（叫“编译器的前端”更准确一些）把*.java文件转变成*.class文件的过程；</p>
</li>
<li><p>也可能是指Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程；</p>
</li>
<li><p>还可能是指使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程序编译成与目标机器指令集相关的二进制代码的过程</p>
</li>
</ul>
<p>列举了这3类编译过程里一些比较有代表性的编译器产品：</p>
<ul>
<li>前端编译器：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li>
<li>即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器。</li>
<li>提前编译器：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET</li>
</ul>
<p>因为Java虚拟机设计团队选择把<strong>对性能的优化全部集中到运行期的即时编译器中</strong>，这样可以让那些不是由Javac产生的Class文件（如JRuby、Groovy等语言的Class<br>文件）也同样能享受到编译器优化措施所带来的性能红利。</p>
<ul>
<li>前端编译器，开发优化程序员的编码过程，降低了编码复杂度，提高了编码效率，提高了程序员的幸福感，很多”<strong>语法糖</strong>（枚举、泛型、装箱拆箱）“就是依赖前端编译期实现的。</li>
<li>即时编译器 在运行期的优化过程，支撑了程序的执行效率不断的提升，</li>
</ul>
<h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><p>分析源码是了解一项技术的实现内幕最彻底的手段，Javac编译器不像HotSpot虚拟机那样使用C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序，这为纯Java的程序员了解它的编译过程带来了很大的便利。</p>
<h4 id="Javac编译过程"><a href="#Javac编译过程" class="headerlink" title="Javac编译过程"></a>Javac编译过程</h4><ol>
<li>准备过程： 初始化插入式注解处理器</li>
<li>解析与填充符号表过程，包括：<ul>
<li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树</li>
<li>填充符号表。产生符号地址和符号信息</li>
</ul>
</li>
<li>插入式注解处理器的注解处理过程：  插入式注解处理器的执行阶段</li>
<li>分析与字节码生成过程，包括：<ul>
<li>标注检查。对语法的静态信息进行检查。</li>
<li>数据流及控制流分析。对程序动态运行过程进行检查</li>
<li>解语法糖。将简化代码编写的语法糖还原为原有的形式</li>
<li>字节码生成。将前面各个步骤所生成的信息转换为字节码</li>
</ul>
</li>
</ol>
<p>上述3个处理过程，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中 重新处理这些新符号。从总体上来看，三者之间的关系与交互顺序如下图所示</p>
<p><img src="/uploads/jvm/13Compile/javac-compile.png"></p>
<ul>
<li>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法里</li>
</ul>
<p><img src="/uploads/jvm/13Compile/javac-compile2.png"></p>
<h4 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h4><p>解析过程由图10-5中的parseFiles()方法（图10-5中的过程1.1）来完成，解析过程包括了经典程序编译原理中的词法分析和语法分析两个步骤。</p>
<h5 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h5><p><strong>词法分析</strong>是将源代码的字符流转变为标记（Token）集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记，如“int a=b+2”这句代码中就包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个独立的标记，不可以再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p>
<p><strong>语法分析</strong>是根据标记序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</p>
<p>在Javac的源码中，<strong>语法分析过程由com.sun.tools.javac.parser.Parser</strong>类实现，这个阶段产出的<strong>抽象语法树是以com.sun.tools.javac.tree.JCTree类表示</strong>的。</p>
<h5 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h5><p>完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程，也就是图10-5中 enterTrees()方法（图10-5中注释的过程1.2）要做的事情</p>
<p>符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构，读者可以把它类比想象成哈希表中键值对的存储形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等各种形式）。符号表中所登记的信息在编译的不同阶段都要被用到。譬如在语义分析的过程中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的声明是否一致）和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</p>
<p>在Javac源代码中，<strong>填充符号表</strong>的过程由<strong>com.sun.tools.javac.comp.Enter类实现</strong>，该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p>
<h5 id="注解处理器（Lombok的实现原理）"><a href="#注解处理器（Lombok的实现原理）" class="headerlink" title="注解处理器（Lombok的实现原理）"></a>注解处理器（Lombok的实现原理）</h5><p>在JDK 6中又提出并通过了JSR-269提案[1]，该提案设计了一组被称为“<strong>插入式注解处理器</strong>”的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次（Round），这也就对应着图10-4的那个回环过程。</p>
<p>有了编译器注解处理的标准API后，<strong>程序员的代码才有可能干涉编译器的行为</strong>，<strong>由于语法树中的任意元素，甚至包括代码注释都可以在插件中被访问到</strong>，所以<strong>通过插入式注解处理器实现的插件在功能上有很大的发挥空间</strong>。只要有足够的创意，程序员能使用插入式注解处理器来实现许多原本只能在编码中由人工完成的事情。譬如Java著名的编码效率工具<strong>Lombok</strong>[2]，它可以通过注解来实现自动产生getter/setter方法、进行空置检查、生成受查异常表、产生equals()和hashCode()方法，等等，帮助开发人员消除Java的冗长代码，<strong>这些都是依赖插入式注解处理器</strong>来实现的，</p>
<p>在Javac源码中，插入式注解处理器的初始化过程是在<strong>initPorcessAnnotations</strong>()方法中完成的，而它的执行过程则是在<strong>processAnnotations</strong>()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</p>
<h5 id="语义分析与字节码生成（IDE工具提示报错原理）"><a href="#语义分析与字节码生成（IDE工具提示报错原理）" class="headerlink" title="语义分析与字节码生成（IDE工具提示报错原理）"></a>语义分析与字节码生成（IDE工具提示报错原理）</h5><p>经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的</p>
<p>而<strong>语义分析</strong>的主要任务则是对结构上正确的源程序<strong>进行上下文相关性质的检查</strong>，譬如进行<strong>类型检查、控制流检查、数据流检查</strong>。</p>
<p>我们编码时经常能在IDE中看到由红线标注的错误提示，其中绝大部分都是来源于语义分析阶段的检查结果。</p>
<h6 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h6><p>Javac在编译过程中，语义分析过程可分为标注检查和数据及控制流分析两个步骤，分别由图10-5的attribute()和flow()方法（分别对应图10-5中的过程3.1和过程3.2）完成。</p>
<p>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等</p>
<p>在标注检查中，还会顺便进行一个称为常量折叠（Constant Folding）的代码优化，这是Javac编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）</p>
<p>标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类。</p>
<h6 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h6><p>数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的，但校验范围会有所区别，有一些校验项只有在编译期或运行期才能进行。</p>
<p>下面举一个关于final修饰符的数据及控制流分析的例子，见代码清单10-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一带有final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二没有final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两个foo()方法中，一个方法的参数和局部变量定义使用了final修饰符，另外一个则没有，<strong>在代码编写时程序肯定会受到final修饰符的影响</strong>，<strong>不能再改变arg和var变量的值</strong>，</p>
<p>但是如果观察这<strong>两段代码编译出来的字节码</strong>，会发现<strong>它们是没有任何一点区别的</strong>，每条指令，甚至每个字节都一模一样。</p>
<p>通过第6章对Class文件结构的讲解我们已经知道，局部变量与类的字段（实例变量、类变量）的存储是有显著差别的，<strong>局部变量在常量池中并没有CONSTANT_Fieldref_info的符号引用</strong>，<strong>自然就不可能存储有访问标志（access_flags）的信息</strong>，甚至可能连变量名称都不一定会被保留下来（这取决于编译时的<br>编译器的参数选项），自然<strong>在Class文件中就不可能知道一个局部变量是不是被声明为final了</strong>。</p>
<p>因此，可以肯定地推断出把局部变量声明为final，对运行期是完全没有影响的，<strong>变量的不变性仅仅由Javac编译器在编译期间来保障</strong>，这就是一个只能在编译期而不能在运行期中检查的例子。</p>
<p>在Javac的源码中，数据及控制流分析的入口是图10-5中的flow()方法（图10-5中的过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p>
<h6 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h6><p>语法糖（Syntactic Sugar），也称糖衣语法，，是由英国计算机科学家Peter J.Landin发明的一种编程术语，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言。通常来说使用语法糖能够减少代码量、增加程序的可读性，从而减少程序代码出错的机会。</p>
<p>Java中最常见的语法糖包括了前面提到过的泛型（其他语言中泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱拆箱，等等，Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为解语法糖.</p>
<p>在Javac的源码中，解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类<br>和com.sun.tools.javac.comp.Lower类中完成。</p>
<h6 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h6><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作.</p>
<ul>
<li>前文多次登场的实例构造器<init>()方法和类构造器<clinit>()方法就是在这个阶段被添加到语法树之中的</li>
<li>请注意<strong>这里的实例构造器并不等同于默认构造函数</strong>，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性（public、protected、private或<package>）与当前类型一致的默认构造函数，<strong>这个工作在填充符号表阶段中就已经完成</strong></li>
<li><init>()和<clinit>()这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器，<clinit>()方法中无须调用父类的<clinit>()方法，Java虚拟机会自动保证父类构造器的正确执行，但在<clinit>()方法中经常会生成调用java.lang.Object的<init>()方法的代码）等操作收敛到<init>()和<br><clinit>()方法之中，并且<strong>保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行</strong>，上面所述的动作由**Gen::normalizeDefs()**方法来实现</li>
<li>还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式，如把字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK 5）的append()操作，等等。</li>
</ul>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到<strong>com.sun.tools.javac.jvm.ClassWriter</strong>类手上，由这个类的writeClass()方法输出字节码，<strong>生成最终的Class文件</strong>，到此，整个编译过程宣告结束。</p>
<h3 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h3><p>语法糖可以看作是前端编译器实现的一些“小把戏”，这些“小把戏”可能会使效率得到“大提升”，但我们也应该去了解这些“小把戏”背后的真实面貌，那样才能利用好它们，而不是被它们所迷惑。</p>
<p><strong>ps:  其实只需要在 反编译class文件后，就可以知道 使用了语法糖的java文件最后去语法糖后，变成了什么样子</strong></p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型的本质是 参数化类型（Parameterized Type）或者参数化多态（Parameteric Polymorphism）的应用， 即可以<strong>将操作的数据类型指定为方法签名中的一种参数</strong>，这种参数类型能够用在 类、接口和方法的创建中，分别构成 泛型类、泛型接口和泛型方法。 泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大的增强了编程语言的类型系统以及抽象能力。</p>
<p>Java的泛型直到今天依然作为Java语言不如C#语言好用的“铁证”被众人嘲讽</p>
<h5 id="Java与C-的泛型"><a href="#Java与C-的泛型" class="headerlink" title="Java与C#的泛型"></a>Java与C#的泛型</h5><ul>
<li><p>Java选择的泛型实现方式叫作“类型擦除式泛型”（Type Erasure Generics），</p>
</li>
<li><p>而C#选择的泛型实现方式是“具现化式泛型”（Reified Generics）。具现化和特化、偏特化这些名词最初都是源于C++模版语法中的概念</p>
</li>
<li><p>C#里面泛型无论在程序源码里面、编译后的中间语言表示（Intermediate Language，这时候泛型是一个占位符）里面，抑或是运行期的CLR里面都是切实存在的，List<int>与 List<string>就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。</p>
</li>
<li><p>而Java语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type),并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>其实是同一个类型，由此读者可以想象“类型擦除”这个名字的含义和来源</p>
</li>
</ul>
<p>代码清单10-2　Java中不支持的泛型用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeErasureGenerics</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123; <span class="comment">// 不合法，无法对泛型进行实例判断</span></span><br><span class="line">        	...</span><br><span class="line">        &#125;</span><br><span class="line">        E newItem = <span class="keyword">new</span> E(); <span class="comment">// 不合法，无法使用泛型创建对象</span></span><br><span class="line">        E[] itemArray = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 不合法，无法使用泛型创建数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>C#2.0引入了泛型之后，带来的显著优势之一便是对比起Java在执行性能上的提高，因为在<strong>使用平台提供的容器类型</strong>（如List<T>，Dictionary&lt;TKey，TValue&gt;）时，<strong>无须像Java里那样不厌其烦地拆箱和装箱</strong>[1]，如果在Java中要避免这种损失，就必须构造一个与数据类型相关的容器类（譬如IntFloatHashMap这样的容器）。显然，这除了引入更多代码造成复杂度提高、复用性降低之外，更是丧失了泛型本身的存在价值。</p>
</li>
<li><p>Java的类型擦除式泛型无论在使用效果上还是运行效率上，几乎是全面落后于C#的具现化式泛型，而它的<strong>唯一优势是在于实现这种泛型的影响范围上</strong>：擦除式泛型的<strong>实现几乎只需要在Javac编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机</strong>，也<strong>保证了以前没有使用泛型的库可以直接运行在Java 5.0之上</strong>。但这种听起来节省工作量甚至可以说是有偷工减料嫌疑的优势就显得非常短视</p>
</li>
</ul>
<p>在没有泛型的时代，由于Java中的数组是支持协变（Covariant）的[6]，对应的集合类也可以存入不同类型的元素，类似于代码清单10-3这样的代码尽管不提倡，但是完全可以正常编译成Class文件。</p>
<p>代码清单10-3　以下代码可正常编译为Class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 编译期不会有问题，运行时会报错</span></span><br><span class="line">ArrayList things = <span class="keyword">new</span> ArrayList();</span><br><span class="line">things.add(Integer.valueOf(<span class="number">10</span>)); <span class="comment">//编译、运行时都不会报错</span></span><br><span class="line">things.add(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>为了保证这些编译出来的Class文件可以在Java 5.0引入泛型之后继续运行，设计者面前大体上有两条路可以选择：<br>1）需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型。<br>2）直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</p>
<p>C# 选择了第一种方式，平行的加了一套泛型化版本的新类型 </p>
<p>Java选择了，第一要考虑到 保证“二进制向后兼容性”（Binary Backwards Compatibility）。二进制向后兼容性是明确写入《Java语言<br>规范》中的对Java使用者的严肃承诺，譬如一个在JDK 1.2中编译出来的Class文件，必须保证能够在JDK 12乃至以后的版本中也能够正常运行。</p>
<p>然后Java当时已经流行了10来年，存量老代码太多。</p>
<p>但<strong>第二条路也并不意味着一定只能使用类型擦除来实现</strong>，如果当时有足够的时间好好设计和实现，是完全有可能做出更好的泛型系统的，否则也不会有今天的<strong>Valhalla</strong>项目来<strong>还以前泛型偷懒留下的技术债</strong>了</p>
<h5 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h5><p>由于Java选择了第二条路，直接把已有的类型泛型化。要让所有需要泛型化的已有类型，譬如 ArrayList，原地泛型化后变成 ArrayList<T>,而且保证以前直接使用ArrayList的代码在泛型新版本里必须还能继续用这同一容器，这就必须让所有泛型化的实例，譬如 ArrayList<Integer>、ArrayList<String>这些全部自动成为<br>ArrayList的子类型才能可以，否则类型转换就是不安全的。由此 就引出了 <strong>“裸类型”（Raw Type）</strong>的概念，裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type），</p>
<p>代码清单10-4　裸类型赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ilist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; slist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list; <span class="comment">// 裸类型</span></span><br><span class="line">list = ilist;</span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure>

<p>接下来的问题是该如何实现裸类型。这里又有了两种选择：</p>
<ul>
<li>一种是在运行期由Java虚拟机来自动地、真实地构造出ArrayList<Integer>这样的类型，并且自动实现从ArrayList<Integer>派生自ArrayList的继承关系来满足裸类型的定义；</li>
<li>（<strong>被选择</strong>）另外一种是<strong>索性简单粗暴地直接在编译时把ArrayList<Integer>还原回ArrayList</strong>，只在<strong>元素访问、修改时自动插入一些强制类型转换和检查指令</strong>，这样看起来也是能满足需要，这两个选择的最终结果大家已经都知道了。</li>
</ul>
<p>代码清单10-5是一段简单的Java泛型例子，我们可以看一下它编译后的实际样子是怎样的。</p>
<p>代码清单10-5　泛型擦除前的例子</p>
<p>代码清单10-5　泛型擦除前的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;how are you?&quot;</span>, <span class="string">&quot;吃了没？&quot;</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;how are you?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，<strong>泛型类型都变回了裸类型</strong>，只在<strong>元素访问时插入了从Object到String的强制转型代码</strong>，如代码清单10-6所示。</p>
<p>代码清单10-6　泛型擦除后的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;how are you?&quot;</span>, <span class="string">&quot;吃了没？&quot;</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println((String) map.get(<span class="string">&quot;how are you?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，使用擦除法实现泛型直接导致了对原始类型（Primitive Types）数据的支持又成了新的麻烦，譬如将代码清单10-2稍微修改一下，变成代码清单10-7这个样子</li>
</ul>
<p>代码清单10-7　原始类型的泛型（目前的Java不支持）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; ilist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">long</span>&gt; llist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ilist;</span><br><span class="line">list = llist;</span><br></pre></td></tr></table></figure>

<p>这种情况下，一旦把泛型信息擦除后，到要插入强制转型的地方就没办法往下做了，因为 不支持 int、long 与 Object之间的强制类型转换。 当时Java给出的解决方案一如既往的简单粗暴：  既然没法转换，<strong>索性就不支持原生类型的泛型</strong>。都用ArrayList<Integer>、ArrayList<Long>，反正都做了<strong>自动的强制类型转换</strong>，遇到<strong>原生类型时把装箱、拆箱也自动做了</strong>.。这个决定也导致了无数构造包装类的装箱、拆箱的开销， 称为Java泛型慢的重要原因。</p>
<ul>
<li>第二，运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦，譬如代码清单10-2中罗列的几种Java不支持的泛型用法，都是由于运行期Java虚拟机无法取得泛型类型而导致的。像代码清单10-8这样，我们去写一个泛型版本的从List到数组的转换方法，由于不能从List中取得参数化类型T，所以不得不从一个额外参数中再传入一个数组的组件类型进去，实属无奈。</li>
</ul>
<p>代码清单10-8　不得不加入的类型参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123;</span><br><span class="line">    T[] array = (T[])Array.newInstance(componentType, list.size());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后，通过擦除法来实现泛型，还丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况，例如代码清单10-9的例子</li>
</ul>
<p>代码清单10-9　当泛型遇见重载1 (<strong>这段代码无法编译通过</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">   	 	System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是不能被编译的，因为参数List<Integer>和List<String>编译之后都被擦除了，变成了同一种的裸类型List，<br>类型擦除导致这两个方法的特征签名变得一模一样。（<strong>特征签名最重要的任务就是作为方法独一无二不可重复的ID，在Java代码中的方法特征签名只包括了方法名称、参数顺序及参数类型，而在字节码中的特征签名还包括方法返回值及受查异常表</strong>）</p>
<ul>
<li>由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响并带来新的需求，如在泛型类中如何获取传入的参数化类型等。</li>
<li>所以JCP组织对《Java虚拟机规范》做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，</li>
<li>Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[8]，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范[9]要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</li>
<li>另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</li>
</ul>
<h5 id="值类型与未来的泛型"><a href="#值类型与未来的泛型" class="headerlink" title="值类型与未来的泛型"></a>值类型与未来的泛型</h5><p>值类型，这点也是C#用户攻讦Java语言的常用武器之一，C#并没有Java意义上的原生数据类型，在C#中使用的int、bool、double关键字其实是对应了一系列在.NET框架中预定义好的结构体（Struct），如Int32、Boolean、Double等。在C#中开发人员也可以定义自己值类型，只要继承于ValueType类型即可，而ValueType也是统一基类Object的子类，所以并不会遇到Java那样int不自动装箱就无法转型为Object的尴尬。</p>
<p>值类型可以与引用类型一样，具有构造函数、方法或是属性字段，等等，而它与引用类型的区别在于它在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的。更为关键的是，值类型的实例很容易实现分配在方法的调用栈上的，这意味着值类型会随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</p>
<h5 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h5><p>代码清单10-11　自动装箱、拆箱与遍历循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">    	sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单10-12　自动装箱、拆箱与遍历循环编译之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = Arrays.asList( <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">    Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单10-11中一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖，代码<br>清单10-12则展示了它们在编译前后发生的变化。泛型就不必说了，</p>
<ul>
<li>自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法，如本例中的Integer.valueOf()与Integer.intValue()方法，</li>
<li>而遍历循环则是把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因。</li>
<li>最后再看看变长参数，它在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员的确也就是使用数组来完成类似功能的。</li>
</ul>
<p>这些语法糖虽然看起来很简单，但也不见得就没有任何值得我们特别关注的地方，代码清单10-13演示了自动装箱的一些错误用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoBoxing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">        System.out.println(c+<span class="string">&quot; &quot;</span>+d+<span class="string">&quot; &quot;</span>+System.identityHashCode(c)+<span class="string">&quot; &quot;</span>+System.identityHashCode(d));</span><br><span class="line">        System.out.println(e == f);</span><br><span class="line">        System.out.println(e+<span class="string">&quot; &quot;</span>+f+<span class="string">&quot; &quot;</span>+System.identityHashCode(e)+<span class="string">&quot; &quot;</span>+System.identityHashCode(f));</span><br><span class="line">        System.out.println(c == (a + b));</span><br><span class="line">        System.out.println(c.equals(a + b));</span><br><span class="line">        System.out.println(g == (a + b));</span><br><span class="line">        System.out.println(g.equals(a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Integer 源码（解释为什么  System.out.println(e == f);  //返回false）</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>鉴于<strong>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</strong>，以及<strong>它们equals()方法不处理数据转型的关系</strong>，</p>
<p>Integer::valueOf(int i),  当i的值 处于[-128,127]时，从缓存Cache中取， 否则 new Integer(i)，包装类==比较hash地址，所以  返回false</p>
<h5 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h5><p>在Java语言之中并没有使用预处理器，因为Java语言天然的编译方式（编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）就无须使用到预处理器。</p>
<p>Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。如代码清单10-14所示，该代码中的if语句不同于其他Java代码，它在编译阶段就会被“运行”，生成的字节码之中只包括“System.out.println(“block 1”)；”一条语句，并不会包含if语句及另外一个分子中的“System.out.println(“block 2”)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;block 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后的反编译结果：</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能力的语句搭配，则可能在控制流分析中提示错误，被拒绝编译，如代码清单10-15所示的代码就会被编译器拒绝编译。</p>
<p>代码清单10-15　不能使用其他条件语句来完成条件编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器将会提示“Unreachable code”</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">   	 System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了本节中介绍的泛型、自动装箱、自动拆箱、遍历循环、变长参数和条件编译之外，Java语言还有不少其他的语法糖，如<strong>内部类、枚举类、断言语句、数值字面量、对枚举和字符串的switch支持、try语句中定义和关闭资源（这3个从JDK 7开始支持）、Lambda表达式（</strong>从JDK 8开始支持，Lambda不能算是单纯的语法糖，但在前端编译器中做了大量的转换工作），等等，读者<strong>可以通过跟踪Javac源码、反编译Class文件等方式了解它们的本质实现</strong></p>
<h3 id="实战：插入式注解处理器-TODO"><a href="#实战：插入式注解处理器-TODO" class="headerlink" title="实战：插入式注解处理器(TODO)"></a>实战：插入式注解处理器(TODO)</h3><p>NameCheckProcessor的实战例子只演示了JSR-269嵌入式注解处理API其中的一部分功能，基于这组API支持的比较有名的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator AnnotationProcessor[1]（本质上与NameCheckProcessor所做的事情差不多）、自动为字段生成getter和setter方法等辅助内容的Lombok[2]（根据已有元素生成新的语法树元素）等，读者有兴趣的话可以参考它们官方站点的相关内容</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在本章中，我们从Javac编译器源码实现的层次上学习了Java源代码编译为字节码的过程，分析了Java语言中泛型、主动装箱拆箱、条件编译等多种语法糖的前因后果，并实战练习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。</p>
<p>如本章概述中所说的，在<strong>前端编译器中，“优化”手段主要用于提升程序的编码效率</strong>，之所以把Javac这类将Java代码转变为字节码的编译器称作“前端编译器”，是因为<strong>它只完成了从程序到抽象语法树或中间字节码的生成</strong>，而在此之后，还有一组<strong>内置于Java虚拟机内部的“后端编译器”来完成代码优化以及从字节码生成本地机器码的过程</strong>，即前面多次提到的即时编译器或提前编译器，这个<strong>后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">深入理解jvm-13-类加载及执行子系统的案例与实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-25 22:22:30" itemprop="dateCreated datePublished" datetime="2021-01-25T22:22:30+08:00">2021-01-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类加载及执行子系统的案例与实战"><a href="#类加载及执行子系统的案例与实战" class="headerlink" title="类加载及执行子系统的案例与实战"></a>类加载及执行子系统的案例与实战</h1><p>在Class文件格式与执行引擎这部分里，用户的程序能直接参与的内容并不太多，Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变.</p>
<p>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路，这些思路后来成为许多常用功能和程序实现的基础。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="Tomcat：正统的类加载器架构"><a href="#Tomcat：正统的类加载器架构" class="headerlink" title="Tomcat：正统的类加载器架构"></a>Tomcat：正统的类加载器架构</h3><p>主流的Java Web服务器，如Tomcat、Jetty、WebLogic、WebSphere或其他笔者没有列举的服务器，都实现了自己定义的类加载器，而且一般还都不止一个。因为一个功能健全的Web服务器，都要解决如下的这些问题：</p>
<ol>
<li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现<strong>相互隔离</strong>。这是最基本的需求，两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求每个类库在一个服务器中只能有一份，服务器应当能够<strong>保证两个独立应用程序的类库可以互相独立使用。</strong></li>
<li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。这个需求与前面一点正好相反，但是也很常见，例如用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费——这主要倒不是浪费磁盘空间的问题，而是指类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方 法区就会很容易出现过度膨胀的风险。</li>
<li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。目前，有许多主流的JavaWeb服务器自身也是使用Java语言来实现的。因此服务器本身也有类库依赖的问题，一般来说，基于安全考虑，服务器所使用的类库应该与应用程序的类库互相独立。</li>
<li>支持JSP应用的Web服务器，十有八九都需要支持HotSwap功能。我们知道JSP文件最终要被编译成Java的Class文件才能被虚拟机执行，但JSP文件由于其纯文本存储的特性，被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的“优势”来看待，因此“主流”的Web服务器都会支持JSP生成类的热替换，当然也有“非主流”的，如运行在生产模式（Production Mode）下的WebLogic服务器默认就不会处理JSP文件的变化。</li>
</ol>
<p>由于存在上述问题，在部署Web应用时，单独的一个ClassPath就不能满足需求了，所以各种Web服务器都不约而同地<strong>提供了好几个有着不同含义的ClassPath路径</strong>供用户存放第三方类库，这些路径一般会以“lib”或“classes”命名。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。现在就以Tomcat服务器[1]为例，与读者一同分析Tomcat具体是如何规划用户类库结构和类加载器的。</p>
<p>在Tomcat目录结构中，可以设置3组目录（/<strong>common</strong>/<em>、/<strong>server</strong>/<em>和/</em></em>shared**/<em>，但默认不一定是开放的，可能只有/lib/<em>目录存在）用于存放Java类库，另外还应该加上Web应用程序自身的“/</em></em>WEBINF**/*”目录，一共4组。把Java类库放置在这4组目录中，每一组都有独立的含义，分别是：</p>
<ul>
<li>放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</li>
<li>放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</li>
<li>放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li>
<li>放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li>
</ul>
<p>为了支持这套目录结构，并对目录里面的类库进行加载和隔离，<strong>Tomcat自定义了多个类加载器</strong>，这些类加载器按照经典的双亲委派模型来实现，其关系如图9-1所示。</p>
<p><img src="/uploads/jvm/23-tomcatClassLoader.png"></p>
<ul>
<li>灰色背景的3个类加载器是JDK（以JDK 9之前经典的三层类加载器为例）默认提供的类加载器，这3个加载器的作用在第7章中已经介绍过了。</li>
<li>而Common类加载器、Catalina类加载器（也称为Server类加载器）、Shared类加载器和Webapp类加载器则是Tomcat自己定义的类加载器，它们分别加<br>载/common/*、/server/*、/shared/*和/WebApp/WEB-INF/*中的Java类库。</li>
<li>其中WebApp类加载器和JSP类加载器通常还会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个JasperLoader类加载器。</li>
</ul>
<p>从图9-1的委派关系中可以看出，</p>
<ul>
<li>Common类加载器能加载的类都可以被Catalina类加载器和Shared类加载器使用，</li>
<li>而Catalina类加载器和Shared类加载器自己能加载的类则与对方相互隔离。</li>
<li>WebApp类加载器可以使用Shared类加载器加载到的类，但各个WebApp类加载器实例之间相互隔离。</li>
<li>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class文件，它存在的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的JSP类加载器来实现JSP文件的HotSwap功能。</li>
</ul>
<p>本例中的类加载结构在<strong>Tomcat 6以前</strong>是它默认的类加载器结构，在Tomcat 6及之后的版本简化了默认的目录结构，只有指定了<strong>tomcat/conf/catalina.properties</strong>配置文件的<strong>server.loader和share.loader</strong>项后才会真正建立Catalina类加载器和Shared类加载器的实例，否则会用到这两个类加载器的地方都会用Common类加载器的实例代替，</p>
<p>而默认的配置文件中并没有设置这两个loader项，所以Tomcat 6之后也顺理成章地把/common、/server和/shared这3个目录默认合并到一起变成1个/lib目录，这个目录里的类库相当于以前/common目录中类库的作用，是Tomcat的开发团队为了简化大多数的部署场景所做的一项易用性改进。</p>
<p>如果默认设置不能满足需要，用户可以通过修改配置文件指定server.loader和share.loader的方式重新启用原来完整的加载器架构。</p>
<h4 id="Tomcat类加载过程"><a href="#Tomcat类加载过程" class="headerlink" title="Tomcat类加载过程"></a>Tomcat类加载过程</h4><p>（1）在Tomcat启动时，会创建一系列的类加载器，在其主类Bootstrap的初始化过程中，会先初始化classloader，然后将其绑定到Thread中。 </p>
<p>（2）其中initClassLoaders方法，会根据catalina.properties的配置，创建相应的classloader。由于默认只配置了common.loader属性，所以其中只会创建一个出来</p>
<p>（3）然后，当一个应用启动的时候，会为其创建对应的WebappClassLoader。此时会将commonClassLoader设置为其parent</p>
<p>（4）在加载时，与java双亲委托机制不同，默认是子优先，也就是先用子加载器加载但是保证Java的基础类不允许其重新加载，以及servlet-api也不允许重新加载。</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>那么笔者不妨再提一个问题让各位读者思考一下：前面曾经提到过一个场景，如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring<br>放到Common或Shared目录下让这些程序共享。Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中的。那么被Common类加载器或Shared类加载器加载的Spring如何访问并不在其加载范围内的用户程序呢？</p>
<h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p><strong>当然就是前片所说的使用线程上下文类加载器，当我们在spring的配置文件中通过类来创建对象，spring都是使用线程上下文类加载器来加载了，默认设置为WebAppClassLoader，所以当在web应用程序内，spring通过线程上下文类加载器使用WebAppClassLoader来加载bean</strong></p>
<p>答案明显是使用线程上下文类加载器来实现的啊！仔细看源码你会发现，spring加载类所用的classloader都是通过Thread.currentThread().getContextClassLoader()来获取的，而当线程创建时会默认 setContextClassLoader(AppClassLoader)，即spring中始终可以获取到这个AppClassLoader(在tomcat里就是WebAppClassLoader)子类加载器来加载bean，以后任何一个线程都可以通过getContextClassLoader()获取到WebAppClassLoader来getbean了</p>
<h3 id="OSGi：灵活的类加载器架构"><a href="#OSGi：灵活的类加载器架构" class="headerlink" title="　OSGi：灵活的类加载器架构"></a>　OSGi：灵活的类加载器架构</h3><p>曾经在Java程序社区中流传着这么一个观点：“学习Java EE规范，推荐去看JBoss源码；学习类加载器的知识，就推荐去看OSGi源码。</p>
<ul>
<li><p>OSGi的Bundle类加载器之间只有规则，没有固定的委派关系。例如，某个Bundle声明了一个它依赖的Package，如果有其他Bundle声明了发布这个Package后，那么所有对这个Package的类加载动作都会委派给发布它的Bundle类加载器去完成。不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个Package和Class的时候，才会根据Package导入导出定义来构造Bundle间的委派和依赖。</p>
</li>
<li><p>另外，一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控制访问范围。如果一个类存在于Bundle的类库中但是没有被Export，那么这个Bundle的类加载器能找到这个类，但不会提供给其他Bundle使用，而且OSGi框架也不会把其他Bundle的类加载请求分配给这个Bundle来<br>处理。</p>
</li>
</ul>
<p>我们可以举一个更具体些的简单例子来解释上面的规则：</p>
<p>假设存在Bundle A、Bundle B、BundleC3个模块，并且这3个Bundle定义的依赖关系如下所示。</p>
<ul>
<li><p>Bundle A：声明发布了packageA，依赖了java.<em>的包；</em></p>
</li>
<li><p>*Bundle B：声明依赖了packageA和packageC，同时也依赖了java.*的包；</p>
</li>
<li><p>Bundle C：声明发布了packageC，依赖了packageA。</p>
</li>
</ul>
<p>那么，这3个Bundle之间的类加载器及父类加载器之间的关系如图9-2所示。</p>
<p><img src="/uploads/jvm/24-OSGiClassLoader.png"></p>
<p>由于没有涉及具体的OSGi实现，图9-2中的类加载器都没有指明具体的加载器实现，它只是一个<br>体现了加载器之间关系的概念模型，并且只是体现了OSGi中最简单的加载器委派关系。一般来说，在<br>OSGi里，加载一个类可能发生的查找行为和委派关系会远远比图9-2中显示的复杂，类加载时可能进<br>行的查找规则如下：</p>
<ul>
<li>以java.*开头的类，委派给父类加载器加载。</li>
<li>否则，委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的Classpath，使用自己的类加载器加载。</li>
<li>否则，查找是否在自己的Fragment Bundle中，如果是则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
<p>从图9-2中还可以看出，在OSGi中，加载器之间的关系不再是双亲委派模型的树形结构，而是已经进一步发展成一种更为复杂的、运行时才能确定的网状结构。这种网状的类加载器架构在带来更优秀的灵活性的同时，也可能会产生许多新的隐患</p>
<p>代码模块之间的依赖关系错综复杂，勉强分离出各个模块的Bundle后，发现在高并发环境下经常出现死锁。我们很容易就找到了死锁的原因：如果出现了Bundle A依赖Bundle B的Package B，而Bundle B又依赖了Bundle A的Package A，这两个Bundle进行类加载时就有很高的概率发生死锁。具体情况是当Bundle A加载Package B的类时，首先需要锁定当前类加载器的实例对象（java.lang.ClassLoader.loadClass()是一个同步方法），然后把请求委派给Bundle B的加载器处理，但如果这时Bundle B也正好想加载Package A的类，它会先锁定自己的加载器再去请求Bundle A的加载器处理，这样两个加载器都在等待对方处理自己的请求，而对方处理完之前自己又一直处于同步锁定的状态，因此它们就互相死锁，永远无法完成加载请求了。</p>
<p>在JDK 7时才终于出现了JDK层面的解决方案，类加载器架构进行了一次专门的升级，在ClassLoader中增加了registerAsParallelCapable方法对可并行的类加载进行注册声明，把锁的级别从ClassLoader对象本身，降低为要加载的类名这个级别，目的是从底层避免以上这类死锁出现的可能。</p>
<p>总体来说，OSGi描绘了一个很美好的模块化开发的目标，而且定义了实现这个目标所需的各种服务，同时也有成熟框架对其提供实现支持。对于单个虚拟机下的应用，从开发初期就建立在OSGi上是一个很不错的选择，这样便于约束依赖。但并非所有的应用都适合采用OSGi作为基础架构，OSGi在提供强大功能的同时，也引入了额外而且非常高的复杂度，带来了额外的风险。</p>
<h3 id="字节码生成技术与动态代理的实现"><a href="#字节码生成技术与动态代理的实现" class="headerlink" title="字节码生成技术与动态代理的实现"></a>字节码生成技术与动态代理的实现</h3><p>在Java世界里面除了Javac和字节码类库外，使用到字节码生成的例子比比皆是，如Web服务器中的JSP编译器，编译时织入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度。我们选择其中相对简单的动态代理技术来讲解字节码生成技术是如何影响程序运作的。</p>
<p>相信许多Java开发人员都使用过动态代理，即使没有直接使用过java.lang.reflect.Proxy或实现过java.lang.reflect.InvocationHandler接口，应该也用过Spring来做过Bean的组织管理。如果使用过Spring，那大多数情况应该已经不知不觉地用到动态代理了，因为如果Bean是面向接口编程，那么在Spring内部都是通过动态代理的方式来对Bean进行增强的。动态代理中所说的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的，它的优势不在于省去了编写代理类那一点编码工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。</p>
<p>代码清单9-1演示了一个最简单的动态代理的用法，原始的代码逻辑是打印一句“hello world”，代理类的逻辑是在原始类方法执行前打印一句“welcome”。我们先看一下代码，然后再分析JDK是如何做到的。</p>
<p>代码清单9-1　动态代理的简单示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">        System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">welcome</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>



<p>在上述代码里，唯一的“黑匣子”就是Proxy::newProxyInstance()方法，除此之外再没有任何特殊之处。这个方法返回一个实现了IHello的接口，并且代理了new Hello()实例行为的对象。跟踪这个方法的源码，可以看到程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作，前面的步骤并不是我们关注的重点，这里只分析它最后调用sun.misc.ProxyGenerator::generateProxyClass()方法来完成生成字节码的动作，这个方法会在运行时产生一个描述代理类的字节码byte[]数组.磁盘中将会产生一个名为“$Proxy0.class”的代理类Class文件，反编译后可以发现</p>
<p>这个代理类的实现代码也很简单，它为传入接口中的每一个方法，以及从java.lang.Object中继承来的equals()、hashCode()、toString()方法都生成了对应的实现，并且统一调用了InvocationHandler对象的invoke()方法（代码中的“this.h”就是父类Proxy中保存的InvocationHandler实例变量）来实现这些方法的内容，各个方法的区别不过是传入的参数和Method对象有所不同而已，所以无论调用动态代理的哪一个方法，实际上都是在执行InvocationHandler::invoke()中的代理逻辑。</p>
<h3 id="Backport工具：Java的时光机器"><a href="#Backport工具：Java的时光机器" class="headerlink" title="Backport工具：Java的时光机器"></a>Backport工具：Java的时光机器</h3><p>在Java世界里，每一次JDK大版本的发布，都会伴随着规模不等或大或小的技术革新，而对Java程序编写习惯改变最大的，肯定是那些对Java语法做出重大改变的版本，譬如JDK 5时加入的自动装箱、泛型、动态注解、枚举、变长参数、遍历循环（foreach循环）；譬如JDK 8时加入的Lambda表达式、Stream API、接口默认方法等。事实上在没有这些语法特性的年代，Java程序也照样能写，但是现在回头看来，上述每一种语法的改进几乎都是“必不可少”的，如同用惯了32寸液晶、4K分辨率显示器的程序员，就很难再在19寸显示器、1080P分辨率的显示器上编写代码了。</p>
<p>但假如公司“不幸”因为要保护现有投资、维持程序结构稳定等，必须使用JDK 5或者JDK 8以前的版本呢？幸好，我们没有办法把19寸显示器变成32寸的，但却可以跨越JDK版本之间的沟壑，把高版本JDK中编写的代码放到低版本JDK环境中去部署使用。为了解决这个问题，一种名为“Java逆向移植”的工具（Java Backporting Tools）应运而生，Retrotranslator[1]和Retrolambda是这类工具中的杰出代表。</p>
<p><strong>Retrotranslator</strong>的作用是将JDK 5编译出来的Class文件转变为可以在JDK 1.4或1.3上部署的版本，它能很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK 5中新增的集合改进、并发包及对泛型、注解等的反射操作。</p>
<p><strong>Retrolambda</strong>的作用与Retrotranslator是类似的，目标是将JDK 8的Lambda表达式和try-resources语法转变为可以在JDK5、JDK 6、JDK 7中使用的形式，同时也对接口默认方法提供了有限度的支持。</p>
<p>要想知道Backporting工具如何在旧版本JDK中模拟新版本JDK的功能，首先要搞清楚JDK升级中会提供哪些新的功能。JDK的每次升级新增的功能大致可以分为以下五类：</p>
<ol>
<li><p>对Java类库API的代码增强。譬如JDK 1.2时代引入的java.util.Collections等一系列集合类，在JDK 5时代引入的java.util.concurrent并发包、在JDK 7时引入的java.lang.invoke包，等等。</p>
</li>
<li><p>在前端编译器层面做的改进。这种改进被称作语法糖，如自动装箱拆箱，实际上就是Javac编译器在程序中使用到包装对象的地方自动插入了很Integer.valueOf()、Float.valueOf()之类的代码；变长参数在编译之后就被自动转化成了一个数组来完成参数传递；泛型的信息则在编译阶段就已经被擦<br>除掉了（但是在元数据中还保留着），相应的地方被编译器自动插入了类型转换代码。</p>
</li>
<li><p>需要在字节码中进行支持的改动。如JDK 7里面新加入的语法特性——动态语言支持，就需要在虚拟机中新增一条invokedynamic字节码指令来实现相关的调用功能。不过字节码指令集一直处于相对稳定的状态，这种要在字节码层面直接进行的改动是比较少见的。</p>
</li>
<li><p>需要在JDK整体结构层面进行支持的改进，典型的如JDK 9时引入的Java模块化系统，它就涉及了JDK结构、Java语法、类加载和连接过程、Java虚拟机等多个层面。</p>
</li>
<li><p>集中在虚拟机内部的改进。如JDK 5中实现的JSR-133[4]规范重新定义的Java内存模型（JavaMemory Model，JMM），以及在JDK 7、JDK 11、JDK 12中新增的G1、ZGC和Shenandoah收集器之类的改动，这种改动对于程序员编写代码基本是透明的，只会在程序运行时产生影响。</p>
</li>
</ol>
<p>上述的5类新功能中，逆向移植工具能比较完美地模拟了前两类，从第3类开始就逐步深入地涉及了直接在虚拟机内部实现的改进了，这些功能一般要么是逆向移植工具完全无能为力，要么是不能完整地或者在比较良好的运行效率上完成全部模拟。想想这也挺合理的，如果在语法糖和类库层面可以完美解决的问题，Java虚拟机设计团队也没有必要舍近求远地改动处于JDK底层的虚拟机嘛。</p>
<ul>
<li>在能够较好模拟的前两类功能中，第一类模拟相对更容易实现一些，如JDK 5引入的java.util.concurrent包，实际是由多线程编程的大师Doug Lea开发的一套并发包，在JDK 5出现之前就已经存在（那时候名字叫作dl.util.concurrent，引入JDK时由作者和JDK开发团队共同进行了一些改进），所以要在旧的JDK中支持这部分功能，以独立类库的方式便可实现。Retrotranslator中就附带了一个名叫“backport-util-concurrent.jar”的类库（由另一个名为“Backport to JSR166”的项目所提供）来代替JDK 5的并发包。</li>
<li>至于第二类JDK在编译阶段进行处理的那些改进，Retrotranslator则是使用ASM框架直接对字节码进行处理。由于组成Class文件的字节码指令数量并没有改变，所以无论是JDK 1.3、JDK 1.4还是JDK5，能用字节码表达的语义范围应该是一致的。当然，肯定不会是简单地把Class的文件版本号从49.0改回48.0就能解决问题了，虽然字节码指令的数量没有变化，但是元数据信息和一些语法支持的内容还是要做相应的修改。</li>
</ul>
<p>以枚举为例，尽管在JDK 5中增加了enum关键字，但是Class文件常量池的CONSTANT_Class_info类型常量并没有发生任何语义变化，仍然是代表一个类或接口的符号引用，没有加入枚举，也没有增加过“CONSTANT_Enum_info”之类的“枚举符号引用”常量。所以使用enum关键字定义常量，尽管从Java语法上看起来与使用class关键字定义类、使用interface关键字定义接口是同一层次的，但实际上这是由Javac编译器做出来的假象，从字节码的角度来看，枚举仅仅是一个继承于java.lang.Enum、自动生成了values()和valueOf()方法的普通Java类而已。</p>
<p>Retrotranslator对枚举所做的主要处理就是把枚举类的父类从“java.lang.Enum”替换为它运行时类库中包含的“net.sf.retrotranslator.runtime.java.lang.Enum_”，然后再在类和字段的访问标志中抹去ACC_ENUM标志位。当然，这只是处理的总体思路，具体的实现要比上面说的复杂得多。可以想象既然两个父类实现都不一样，values()和valueOf()的方法自然需要重写，常量池需要引入大量新的来自父类的符号引用，这些都是实现细节。</p>
<p>用Retrolambda模拟JDK 8的Lambda表达式属于涉及字节码改动的第三类情况，Java为支持Lambda会用到新的invokedynamic字节码指令，但幸好这并不是必须的，只是基于效率的考量。在JDK 8之前，Lambda表达式就已经被其他运行在Java虚拟机的编程语言（如Scala）广泛使用了，那时候是怎么生成字节码的现在照着做就是，不使用invokedynamic，除了牺牲一点效率外，可行性方面并没有太大的障碍。</p>
<p>Retrolambda的Backport过程实质上就是生成一组匿名内部类来代替Lambda，里面会做一些优化措施，譬如采用单例来保证无状态的Lambda表达式不会重复创建匿名类的对象。有一些Java IDE工具，如IntelliJ IDEA和Eclipse里会包含将此过程反过来使用的功能特性，在低版本Java里<strong>把匿名内部类显示成Lambda语法</strong>的样子，<strong>实际存在磁盘上的源码还是匿名内部类形式的</strong>，只是在IDE里可以把它显示为Lambda表达式的语法，让人阅读起来比较简洁而已。</p>
<h2 id="实战自己动手实现远程执行功能"><a href="#实战自己动手实现远程执行功能" class="headerlink" title="实战自己动手实现远程执行功能"></a>实战自己动手实现远程执行功能</h2><h3 id="痛点："><a href="#痛点：" class="headerlink" title="痛点："></a>痛点：</h3><p>在做程序维护的时候是否遇到过这类情形：排查问题的过程中，想查看内存中的一些参数值，却苦于没有方法把这些值输出到界面或日志中。又或者定位到某个缓存数据有问题，由于缺少缓存的统一管理界面，不得不重启服务才能清理掉这个缓存。类似的需求有一个共同的特点，那就是只要在服务中执行一小段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行临时代码的途径，让人恨不得在服务器上装个后门。这是项目运维中的常见问题，通常解决类问题有<br>以下几种途径：</p>
<h3 id="现存方案："><a href="#现存方案：" class="headerlink" title="现存方案："></a>现存方案：</h3><ol>
<li>可以使用BTrace[1]这类JVMTI工具去动态修改程序中某一部分的运行代码，这部分在第4章有简要的介绍，类似的JVMTI工具还有阿里巴巴的Arthas[2]等。</li>
<li>使用JDK 6之后提供了Compiler API，可以动态地编译Java程序，这样虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求是可以得到解决的。</li>
<li>也可以通过“曲线救国”的方式来做到，譬如写一个JSP文件上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个BeanShell Script、JavaScript等的执行引擎（如Mozilla Rhino[3]）去执行动态脚本。</li>
<li>在应用程序中内置动态执行的功能。</li>
</ol>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>首先，在实现“在服务端执行临时代码”这个需求之前，先来明确一下本次实战的具体目标，我们希望最终的产品是这样的：</p>
<ul>
<li>不依赖某个JDK版本才加入的特性（包括JVMTI），能在目前还被普遍使用的JDK中部署，只要是使用JDK 1.4以上的JDK都可以运行。</li>
<li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li>
<li>不侵入原有程序，即无须改动原程序的任何代码。也不会对原有程序的运行带来任何影响。</li>
<li>考虑到BeanShell Script或JavaScript等脚本与Java对象交互起来不太方便，“临时代码”应该直接支<br>持Java语言。</li>
<li>“临时代码”应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。这里写的是“不需要”而不是“不可以”，当“临时代码”需要引用其他类库时也没有限制，只要服务端程序能使用的类型和接口，临时代码都应当能直接引用。</li>
<li>“临时代码”的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在程序实现的过程中，我们需要解决以下3个问题：</p>
<ul>
<li>如何编译提交到服务器的Java代码？</li>
<li>如何执行编译之后的Java代码？</li>
<li>如何收集Java代码的执行结果？</li>
</ul>
<p>对于第一个问题，我们有两种方案可以选择。</p>
<ol>
<li><p>一种在服务器上编译，在JDK 6以后可以使用Compiler API，在JDK 6以前可以使用tools.jar包（在JAVA_HOME/lib目录下）中的com.sun.tools.Javac.Main类来编译Java文件，它们其实和直接使用Javac命令来编译是一样的。这种思路的缺点是引入了额外的依赖，而且把程序绑死在特定的JDK上了，要部署到其他公司的JDK中还得把tools.jar带上（虽然JRockit和J9虚拟机也有这个JAR包，但它总不是标准所规定必须存在的）。</p>
</li>
<li><p>另外一种思路是直接在客户端编译好，把字节码而不是Java代码传到服务端，这听起来好像有点投机取巧，一般来说确实不应该假定客户端一定具有编译代码的能力，也不能假定客户端就有编译出产品所需的依赖项。但是既然程序员会写Java代码去给服务端排查问题，那么很难想象他的机器上会连编译Java程序的环境都没有。</p>
</li>
</ol>
<p>对于第二个问题：</p>
<p>要执行编译后的Java代码，让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法就可以了（因为不实现任何接口，我们可以借用一下Java中约定俗成的“main()”方法）。但我们还应该考虑得更周全些：一段程序往往不是编写、运行一次就能达到效果，同一个类可能要被反复地修改、提交、执行。另外，提交上去的类要能访问到服务端的其他类库才行。还有就是既然提交的是临时代码，那提交的Java类在执行完后就应当能被卸载和回收掉。</p>
<p>最后一个问题，</p>
<p>我们想把程序往标准输出（System.out）和标准错误输出（System.err）中打印的信息收集起来。但标准输出设备是整个虚拟机进程全局共享的资源，如果使用<br>System.setOut()/System.setErr()方法把输出流重定向到自己定义的PrintStream对象上固然可以收集到输出信息，但也会对原有程序产生影响：会把其他线程向标准输出中打印的信息也收集了。虽然这些并不是不能解决的问题，不过为了达到完全不影响原程序的目的，我们可以采用另外一种办法：直接在执行的类中把对System.out的符号引用替换为我们准备的PrintStream的符号引用，依赖前面学习到的知识，做到这一点并不困难。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="HotSwapClassLoader"><a href="#HotSwapClassLoader" class="headerlink" title="HotSwapClassLoader"></a>HotSwapClassLoader</h4><p>第一个类用于实现“同一个类的代码可以被多次加载”这个需求，即用于解决9.2节列举的第二个问题的HotSwapClassLoader，具体程序如代码清单9-3所示。</p>
<p>HotSwapClassLoader所做的事情仅仅是公开父类（即java.lang.ClassLoader）中的protected方法defineClass()，我们将会使用这个方法把提交执行的Java类的byte[]数组转变为Class对象。HotSwapClassLoader中并没有重写loadClass()或findClass()方法，因此如果不算外部手工调用loadByte()方法的话，这个类加载器的类查找范围与它的父类加载器是完全一致的，在被虚拟机调用时，它会按照双亲委派模型交给父类加载。构造函数中指定为加载HotSwapClassLoader类的类加载器作为父类加载器，<strong>这一步是实现提交的执行代码可以访问服务端引用类库的关键</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 为了多次载入执行类而加入的加载器</span><br><span class="line"> * 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法</span><br><span class="line"> * 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载</span><br><span class="line"> *</span><br><span class="line"> * @author zzm</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HotSwapClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public HotSwapClassLoader() &#123;</span><br><span class="line">        super(HotSwapClassLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class loadByte(byte[] classByte) &#123;</span><br><span class="line">        return defineClass(null, classByte, 0, classByte.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClassModifier-、ByteUtils"><a href="#ClassModifier-、ByteUtils" class="headerlink" title="ClassModifier 、ByteUtils"></a>ClassModifier 、ByteUtils</h4><p>第二个类是实现将java.lang.System替换为我们自己定义的HackSystem类的过程，它直接修改符合Class文件格式的byte[]数组中的常量池部分，将常量池中指定内容的CONSTANT_Utf8_info常量替换为新的字符串，具体代码如下面的代码清单9-4所示。ClassModifier中涉及对byte[]数组操作的部分，主要是将byte[]与int和String互相转换，以及把对byte[]数据的替换操作封装在代码清单9-5所示的ByteUtils中。</p>
<p>经过ClassModifier处理后的byte[]数组才会传给HotSwapClassLoader.loadByte()方法进行类加载，byte[]数组在这里替换符号引用之后，与客户端直接在Java代码中引用HackSystem类再编译生成的Class是完全一样的。这样的实现既避免了客户端编写临时执行代码时要依赖特定的类（不然无法引入HackSystem），又避免了服务端修改标准输出后影响到其他程序的输出。下面我们来看看代码清单9-4和代码清单9-5。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改Class文件，暂时只提供修改常量池常量的功能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassModifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_Utf8_info = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] CONSTANT_ITEM_LENGTH = &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] classByte;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassModifier</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStr 修改前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStr 修改后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] modifyUTF8Constant(String oldStr, String newStr) &#123;</span><br><span class="line">        <span class="keyword">int</span> cpc = getConstantPoolCount();</span><br><span class="line">        <span class="keyword">int</span> offset = CONSTANT_POOL_COUNT_INDEX + u2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpc; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = ByteUtils.bytes2Int(classByte, offset, u1);</span><br><span class="line">            <span class="keyword">if</span> (tag == CONSTANT_Utf8_info) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = ByteUtils.bytes2Int(classByte, offset + u1, u2);</span><br><span class="line">                offset += (u1 + u2);</span><br><span class="line">                String str = ByteUtils.bytes2String(classByte, offset, len);</span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(oldStr)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);</span><br><span class="line">                    <span class="keyword">return</span> classByte;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offset += len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offset += CONSTANT_ITEM_LENGTH[tag];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 常量池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstantPoolCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bytes数组处理工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start + len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>) b[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            n &lt;&lt;= (--len) * <span class="number">8</span>;</span><br><span class="line">            sum = n + sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2Bytes(<span class="keyword">int</span> value, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((value &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b, start, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] string2Bytes(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bytesReplace(<span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)];</span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset);</span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes, offset, replaceBytes.length);</span><br><span class="line">        System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);</span><br><span class="line">        <span class="keyword">return</span> newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="HackSystem"><a href="#HackSystem" class="headerlink" title="HackSystem"></a>HackSystem</h4><p>最后一个类就是前面提到过的用来代替java.lang.System的HackSystem，这个类中的方法看起来不少，但其实除了把out和err两个静态变量改成使用ByteArrayOutputStream作为打印目标的同一个PrintStream对象，以及增加了读取、清理ByteArrayOutputStream中内容的getBufferString()和clearBuffer()方法外，就再没有其他新鲜的内容了。其余的方法全部都来自于System类的public方法，方法名字、参数、返回值都完全一样，并且实现也是直接转调了System类的对应方法而已。保留这些方法的目的，是为了在Sytem被替换成HackSystem之后，保证执行代码中调用的System的其余方法仍然可以继续使用，HackSystem的实现如代码清单9-6所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 为Javaclass劫持java.lang.System提供支持</span><br><span class="line"> * 除了out和err外，其余的都直接转发给System处理</span><br><span class="line"> *</span><br><span class="line"> * @author zzm</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HackSystem &#123;</span><br><span class="line"></span><br><span class="line">    public final static InputStream in &#x3D; System.in;</span><br><span class="line"></span><br><span class="line">    private static ByteArrayOutputStream buffer &#x3D; new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    public final static PrintStream out &#x3D; new PrintStream(buffer);</span><br><span class="line"></span><br><span class="line">    public final static PrintStream err &#x3D; out;</span><br><span class="line"></span><br><span class="line">    public static String getBufferString() &#123;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void clearBuffer() &#123;</span><br><span class="line">        buffer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setSecurityManager(final SecurityManager s) &#123;</span><br><span class="line">        System.setSecurityManager(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SecurityManager getSecurityManager() &#123;</span><br><span class="line">        return System.getSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static long currentTimeMillis() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) &#123;</span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int identityHashCode(Object x) &#123;</span><br><span class="line">        return System.identityHashCode(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面所有的方法都与java.lang.System的名称一样</span><br><span class="line">    &#x2F;&#x2F; 实现都是字节转调System的对应方法</span><br><span class="line">    &#x2F;&#x2F; 因版面原因，省略了其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JavaclassExecuter"><a href="#JavaclassExecuter" class="headerlink" title="JavaclassExecuter"></a>JavaclassExecuter</h4><p>我们来看看最后一个类JavaclassExecuter，它是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。JavaclassExecuter只有一个execute()方法，用输入的符合Class文件格式的byte[]数组替换掉java.lang.System的符号引用后，使用HotSwapClassLoader加载生成一个Class对象，由于每次执行execute()方法都会生成一个新的类加载器实例，因此同一个类可以实现重复加载。然后反射调用这个Class对象的main()方法，如果期间出现任何异常，将异常信息打印到HackSystem.out中，最后把缓冲区中的信息作为方法的结果来返回。JavaclassExecuter的实现代码<br>如代码清单9-7所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Javaclass执行工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaclassExecuter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类</span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classByte 代表一个Java类的Byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> ClassModifier(classByte);</span><br><span class="line">        <span class="keyword">byte</span>[] modiBytes = cm.modifyUTF8Constant(<span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;org/fenixsoft/classloading/execute/HackSystem&quot;</span>);</span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> HotSwapClassLoader();</span><br><span class="line">        Class clazz = loader.loadByte(modiBytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;);</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123;<span class="keyword">null</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证（TODO）"><a href="#验证（TODO）" class="headerlink" title="验证（TODO）"></a>验证（TODO）</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/" class="post-title-link" itemprop="url">深入理解jvm-12-动态类型语言支持</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-24 16:00:57" itemprop="dateCreated datePublished" datetime="2021-01-24T16:00:57+08:00">2021-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h1><p>在介绍Java虚拟机的动态类型语言支持之前，</p>
<ul>
<li>我们要先弄明白动态类型语言是什么？</li>
<li>它与Java语言、Java虚拟机有什么关系？</li>
</ul>
<p>了解Java虚拟机提供动态类型语言支持的技术背景，对理解这个语言特性是非常有必要的。</p>
<h2 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h2><ul>
<li><p>定义： 动态类型语言的关键特征是 它的<strong>类型检查的主体是在运行期而不是 编译期进行的</strong>，</p>
</li>
<li><p>满足这个特征的语言有很多，常用的包括： APL、Clojure、Erlang、Groovy、JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl，等等</p>
</li>
<li><p>那相对地，<strong>在编译期就进行类型检查过程的语言</strong>，譬如 C++ 和Java等就是最常用的<strong>静态类型语言</strong> </p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	int[][][] array = new int[1][0][-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这段Java代码能够正常编译，但运行的时候会出现NegativeArraySizeException异常。在《Java虚拟机规范》中明确规定了NegativeArraySizeException是一个运行时异常（Runtime Exception），通俗一点说，<strong>运行时异常就是指只要代码不执行到这一行就不会出现问题</strong>。</li>
<li>与运行时异常相对应的概念是<strong>连接时</strong>（<strong>类加载阶段的验证、准备和解析 称为连接阶</strong>段）<strong>异常</strong>，例如很常见的NoClassDefFoundError便属于连接时异常，即使导致连接时异常的代码放在一条根本无法被执行到的路径分支上，类加载时（第7章解释过Java的连接过程不在编译阶段，而在类加载阶段）也照样会抛出异常。</li>
</ul>
<p>不过在C语言中，语义相同的代码就会在编译期就直接出错，而不是等到运行时才出现异常：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">	int i[1][0][-1]; // GCC拒绝编译，报“size of array is negative”</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此看来，一门语言的哪一种检查行为 要在运行期进行，哪一种检查要在编译期进行并没有什么必然的因果逻辑关系，关键在于语言规范中人为设立的约定。</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>虽然正在阅读本书的每一位读者都能看懂这行代码要做什么，但对于计算机来讲，这一行“没头没尾”的代码是无法执行的，它需要一个具体的上下文中（譬如程序语言是什么、obj是什么类型）才有讨论的意义。</p>
<ul>
<li>现在先假设这行代码是在<strong>Java语言中</strong>，并且变量obj的静态类型为java.io.PrintStream，那变量obj的实际类型就必须是PrintStream的子类（实现了PrintStream接口的类）才是合法的。否则，哪怕obj属于一个确实包含有println(String)方法相同签名方法的类型，但只要它与PrintStream接口没有继承关系，代码依然不可能运行——因为**<em>类型检查不合法**</em></li>
<li>但是相同的代码在<strong>ECMAScript（JavaScript</strong>）中情况则不一样，无论obj具体是何种类型，无论其继承关系如何，只要这种类型的方法定义中确实包含有println(String)方法，能够找到相同签名的方法，调用便可成功。</li>
<li>产生这种差别产生的根本原因是Java语言在编译期间却已将println(String)方法完整的符号引用（本例中为一项CONSTANT_InterfaceMethodref_info常量）生成出来，并作为方法调用指令的参数存储到Class文件中，</li>
<li>例如下面这个样子：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual <span class="comment">#4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br></pre></td></tr></table></figure>

<ol>
<li>这个符号引用包含了该方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，Java虚拟机就可以翻译出该方法的直接引用。</li>
<li>而ECMAScript等动态类型语言与Java有一个核心的差异就是变量obj本身并没有类型，<strong>变量obj的值才具有类型</strong>，</li>
<li>所以编译器在编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型（即<strong>方法接收者不固定</strong>）。</li>
<li><strong><em>“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个核心特征。</em></strong></li>
</ol>
<h3 id="动态类型对比静态类型语言的优缺点："><a href="#动态类型对比静态类型语言的优缺点：" class="headerlink" title="动态类型对比静态类型语言的优缺点："></a>动态类型对比静态类型语言的优缺点：</h3><p>了解了动态类型和静态类型语言的区别后，也许读者的下一个问题就是动态、静态类型语言两者谁更好，或者谁更加先进呢？这种比较不会有确切答案，它们都有自己的优点，选择哪种语言是需要权衡的事情。</p>
<ul>
<li><p>静态类型语言能够<strong>在编译期确定变量类型</strong>，最显著的好处是<strong>编译器可以提供全面严谨的类型检查</strong>，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于<strong>稳定性</strong>及让项目容易达到更大的规模。</p>
</li>
<li><p>而动态类型语言在运行期才确定类型，这可以为开发人员提供极大的<strong>灵活性</strong>，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很<strong>清晰简洁</strong>，清晰简洁通常也就意味着<strong>开发效率的提升</strong>。</p>
</li>
<li><p>ps： <strong>动态类型语言与动态语言、弱类型语言并不是一个概念，需要区别对待。</strong></p>
</li>
</ul>
<h2 id="Java与动态类型"><a href="#Java与动态类型" class="headerlink" title="Java与动态类型"></a>Java与动态类型</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ol>
<li>Java语言、Java虚拟机与 动态类型语言之间有什么关系。</li>
</ol>
<ul>
<li><p>Java虚拟机毫无疑问是Java语言的运行平台，但它的使命并不限于此。</p>
</li>
<li><p>目前确实已经有许多动态类型语言运行于Java虚拟机之上了，如Clojure、Groovy、Jython和JRuby等，能够在同一个虚拟机之上可以实现静态类型语言的严谨与动态类型语言的灵活，这的确是一件很美妙的事情。</p>
</li>
<li><p>但遗憾的是Java虚拟机层面对动态类型语言的支持一直都还有所欠缺，主要表现在方法调用方面：</p>
<ul>
<li>JDK 7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是<strong>被调用的方法的符号引用</strong>（CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量）</li>
<li>前面已经提到过，方法的符号引用在编译时产生，而<strong>动态类型语言只有在运行期才能确定方法的接收者</strong>。这样，在Java虚拟机上实现的动态类型语言就不得不使用“曲线救国”的方式（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现</li>
<li>但这样势必会<strong>让动态类型语言实现的复杂度增加</strong>，也会带来额外的性能和内存开销。</li>
<li>内存开销是很显而易见的，方法调用产生的那一大堆的动态类就摆在那里。</li>
<li>而其中最严重的性能瓶颈是在于动态类型方法调用时，由于<strong>无法确定调用对象的静态类型</strong>，而导致的<strong>方法内联无法有效进行</strong>。</li>
<li>尽管也可以想一些办法（譬如调用点缓存）尽量缓解支持动态语言而导致的性能下降，但这种改善毕竟不是本质的</li>
</ul>
</li>
</ul>
<p>譬如有类似一下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arrays = &#123;<span class="string">&quot;abc&quot;</span>, new ObjectX(), 123, Dog, Cat, Car..&#125;</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> arrays)&#123;</span><br><span class="line">	item.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JVM动态字节码指令背景"><a href="#JVM动态字节码指令背景" class="headerlink" title="JVM动态字节码指令背景"></a>JVM动态字节码指令背景</h3><ul>
<li>在动态类型语言下这样的代码是没有问题，但由于在运行时arrays中的元素可以是任意类型，即使它们的类型中都有sayHello()方法，也肯定无法在编译优化的时候就确定具体sayHello()的代码在哪里，编译器只能不停编译它所遇见的每一个sayHello()方法，并缓存起来供执行时选择、调用和<strong>内联，</strong></li>
<li>如果arrays数组中不同类型的对象很多，就势必会对内联缓存产生很大的压力，缓存的大小总是有限的，类型信息的不确定性导致了缓存内容不断被失效和更新，先前优化过的方法也可能被不断替换而无法重复使用。</li>
<li>所以这种<strong>动态类型方法调用的底层问题</strong>终归是<strong>应当在Java虚拟机层次上去解决才最合适</strong>。</li>
<li>因此，在Java虚拟机层面上提供动态类型的直接支持就成为Java平台发展必须解决的问题，</li>
<li>这便是JDK 7时JSR-292提案中<strong>invokedynamic指令</strong>以及 <strong>java.lang.invoke</strong> 包出现的技术背景。</li>
</ul>
<h2 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h2><h3 id="方法句柄："><a href="#方法句柄：" class="headerlink" title="方法句柄："></a>方法句柄：</h3><p>JDK 7时新加入的java.lang.invoke包[1]是JSR 292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。</p>
<p>不妨把方法句柄与C/C++ 中的函数指针（Function Pointer），或者C# 里面的委派（Delegate）互相类比一下来理解。举个例子，，如果我们实现一个带谓词（谓词就是外部传入的排序时比较大小的动作）的排序函数，在C/C++ 中的常用做法时把谓词定义为函数，用函数指针来把谓词传递到排序方法，像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void sort(int list[], const int size, int (*compare)(int, int))</span><br></pre></td></tr></table></figure>

<p>但在Java语言中做不到这一点，没有办法单独把一个函数作为参数进行传递，普遍的做法是  涉及一个带有compare（）方法的Comparetor 接口，以实现这个接口的对象作为参数，例如 Java类库中的Collections：： sort 方法就是这样定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list,Comparator c)</span></span></span><br></pre></td></tr></table></figure>

<p>不过，在拥有方法句柄之后，Java 语言也可以拥有类似于 函数指针或者委托的方法别名这样的工具了，</p>
<p>以下代码演示了方法句柄的基本用法，无论obj 是何种类型（临时定义的ClassA 或者是实现PrintStream接口的实现类 System.out），都可以正确的调用到println（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">&quot;icyfenix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即是this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">&quot;println&quot;</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法getPrintlnMH()中实际上是模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。</p>
<p>而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。以此为基础，有了MethodHandle就可以写出类似于C/C++那样的函数声明了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, MethodHandle compare)</span></span></span><br></pre></td></tr></table></figure>

<p>从上面的例子看来，使用MethodHandle并没有多少困难，不过看完它的用法之后，读者大概就会产生疑问，相同的事情，用反射不是早就可以实现了吗？</p>
<p>确实，仅站在Java语言的角度看，MethodHandle在使用方法和效果上与Reflection有众多相似之处。不过，它们也有以下这些区别：</p>
<ol>
<li>Reflection和MethodHandle机制本质上都是在模拟方法调用，但是<strong>Reflection是在模拟Java代码层次的方法调用</strong>，而<strong>MethodHandle是在模拟字节码层次的方法调用</strong>。在MethodHandles.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual（以及<br>invokeinterface）和invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。</li>
<li>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是<strong>方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息</strong>。而后者仅包含<strong>执行该方法的相关信息</strong>。用开发人员通俗的话来讲，<strong>Reflection是重量级，而MethodHandle是轻量级。</strong></li>
<li>由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还在继续完善中），而通过<strong>反射去调用方法则几乎不可能直接去实施各类调用点优化措施</strong>。</li>
<li>MethodHandle与Reflection除了上面列举的区别外，最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度看”之后：<strong>Reflection API的设计目标是只为Java语言服务的</strong>，而<strong>MethodHandle则设计为可服务于所有Java虚拟机之上的语言，其中也包括了Java语言而已</strong>，而且Java在这里并不是主角。</li>
</ol>
<h2 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h2><p>了JDK 7为了更好地支持动态类型语言，引入了第五条方法调用的字节码指令invokedynamic，</p>
<ul>
<li>某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke<em>”指令方法（**</em>invokevirtual<strong>、</strong>invokespecial<strong>、**<em>invokestatic</em></strong>、**<em>invokeinterface**</em>））分派规则完全固化在虚拟机之中的问题，把<strong>如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中</strong>，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。</li>
<li>而且，它们两者的思路也是可类比的，都是为了达成同一个目的，只是一个用上层代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。因此，如果前面MethodHandle的例子看懂了，相信理解invokedynamic指令并不困难。</li>
</ul>
<ul>
<li>每一处含有invokedynamic指令的位置都被称作“<strong>动态调用点（Dynamically-Computed Call Site）</strong>”，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是<strong>变为JDK 7时新加入的CONSTANT_InvokeDynamic_info常量</strong>，从这个新常量中可以得到3项信息：<strong>引导方法</strong><br><strong>（Bootstrap Method，该方法存放在新增的BootstrapMethods属性中）、方法类型（MethodType）和名称。</strong></li>
<li>引导方法是有固定的参数，并且返回值规定是java.lang.invoke.CallSite对象，这个对象代表了真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用到要执行的目标方法上</li>
</ul>
<p>代码清单8-13所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeDynamicTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        INDY_BootstrapMethod().invokeExact(<span class="string">&quot;icyfenix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello String:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">BootstrapMethod</span><span class="params">(MethodHandles.Lookup lookup, String name, MethodType mt)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(lookup.findStatic(InvokeDynamicTest.class, name, mt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodType <span class="title">MT_BootstrapMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MethodType</span><br><span class="line">                .fromMethodDescriptorString(</span><br><span class="line">                        <span class="string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>,</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">MH_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookup().findStatic(InvokeDynamicTest.class, <span class="string">&quot;BootstrapMethod&quot;</span>, MT_BootstrapMethod());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">INDY_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        CallSite cs = (CallSite) MH_BootstrapMethod().invokeWithArguments(lookup(), <span class="string">&quot;testMethod&quot;</span>,</span><br><span class="line">                MethodType.fromMethodDescriptorString(<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> cs.dynamicInvoker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>前文提到过，由于**<em>invokedynamic**</em>指令面向的主要服务对象并非Java语言，而是<strong>其他Java虚拟机之上的其他动态类型语言</strong>，因此，光靠Java语言的<br>编译器Javac的话，在JDK 7时甚至还完全没有办法生成带有invokedynamic指令的字节码（曾经有一个java.dyn.InvokeDynamic的语法糖可以实现，但后来被取消了），</p>
</li>
<li><p>而到JDK 8引入了Lambda表达式和接口默认方法后，Java语言才算享受到了一点invokedynamic指令的好处，但用Lambda来解释invokedynamic指令运作就比较别扭，也无法与前面MethodHandle的例子对应类比，</p>
</li>
<li><p>所以笔者采用一些变通的办法：John Rose（JSR 292的负责人，以前Da Vinci Machine Project的Leader）编写过一个把程序的字节码转换为使用invokedynamic的简单工具<strong>INDY</strong>[1]来完成这件事，我们要使用这个工具来产生最终需要的字节码，</p>
</li>
<li><p>因此代码清单8-13中的方法名称不能随意改动，更不能把几个方法合并到一起写，因为它们是要被INDY工具读取的</p>
</li>
<li><p>把上面的代码编译，再使用INDY转换后重新生成的字节码如代码清单8-14所示,使用javap输出</p>
</li>
</ul>
<p>代码清单8-14　InvokeDynamic指令演示（2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    #121 = NameAndType #33:#30 // testMethod:(Ljava/lang/String;)V</span><br><span class="line">    #123 = InvokeDynamic #0:#121 // #0:testMethod:(Ljava/lang/String;)V</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span> <span class="keyword">throws</span> java.lang.Throwable</span>;</span><br><span class="line">	Code:</span><br><span class="line">		stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">            0: ldc #23 // String abc</span><br><span class="line">            2: invokedynamic #123, 0 // InvokeDynamic #0:testMethod: (Ljava/lang/String;)V   </span><br><span class="line">            <span class="number">7</span>: nop</span><br><span class="line">            <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.invoke.<span class="function">CallSite <span class="title">BootstrapMethod</span><span class="params">(java.lang.invoke.Method Handles$Lookup, java.lang.String, </span></span></span><br><span class="line"><span class="function"><span class="params">	Code:</span></span></span><br><span class="line"><span class="function"><span class="params">		stack=<span class="number">6</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">0</span>: new #<span class="number">63</span> // class java/lang/invoke/ConstantCallSite</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">3</span>: dup</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">4</span>: aload_0</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">5</span>: ldc #<span class="number">1</span> // class org/fenixsoft/InvokeDynamicTest</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">7</span>: aload_1</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">8</span>: aload_2</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">9</span>: invokevirtual #<span class="number">65</span> // Method java/lang/invoke/MethodHandles$ Lookup.findStatic:(Ljava/lang/Class;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">12</span>: invokespecial #<span class="number">71</span> // Method java/lang/invoke/ConstantCallSite. <span class="string">&quot;&lt;init&gt;&quot;</span>:(Ljava/lang/invoke/MethodHandle;)</span></span></span><br><span class="line"><span class="function">            15: areturn</span></span><br></pre></td></tr></table></figure>

<p>从main()方法的字节码中可见，原本的方法调用指令已经被替换为invokedynamic了，它的参数为第123项常量（第二个值为0的参数在虚拟机中不会直接用到，这与invokeinterface指令那个的值为0的参数一样是占位用的，目的都是为了给常量池缓存留出足够的空间）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2: invokedynamic #123, 0 // InvokeDynamic #0:testMethod:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>

<p>从常量池中可见，第123项常量显示“#123=InvokeDynamic#0：</p>
<ul>
<li>#121”说明它是一项CONSTANT_InvokeDynamic_info类型常量，常量值中前面“#0”代表引导方法取Bootstrap Methods属性表的第0项（javap没有列出属性表的具体内容，不过示例中仅有一个引导方法，即BootstrapMethod()），</li>
<li>而后面的“#121”代表引用第121项类型为CONSTANT_NameAndType_info的常量，从这个常量中可以获取到方法名称和描述符，即后面输出的“testMethod：<br>(Ljava/lang/String；)V”。</li>
</ul>
<p>再看BootstrapMethod()，这个方法在Java源码中并不存在，是由INDY产生的，但是它的字节码很容易读懂，</p>
<ul>
<li>所有逻辑都是调用MethodHandles$Lookup的findStatic()方法，产生testMethod()方法的MethodHandle，</li>
<li>然后用它创建一个ConstantCallSite对象。</li>
<li>最后，这个对象返回给invokedynamic指令实现对testMethod()方法的调用，invokedynamic指令的调用过程到此就宣告完成了。</li>
</ul>
<h2 id="实战：掌控方法分派规则"><a href="#实战：掌控方法分派规则" class="headerlink" title="实战：掌控方法分派规则"></a>实战：掌控方法分派规则</h2><p><strong>invokedynamic</strong>指令与此前4条传统的“invoke*”指令的最大区别就是它的<strong>分派逻辑不是由虚拟机决定的</strong>，而是<strong>由程序员决定</strong>。</p>
<p>在介绍Java虚拟机动态语言支持的最后一节中，笔者希望通过一个简单例子（如代码清单8-15所示），帮助读者理解程序员可以掌控方法分派规则之后，我们能做什么以前无法做到的事情。</p>
<p>代码清单8-15　方法调用问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 请读者在这里填入适当的代码（不能修改其他地方的代码）</span></span><br><span class="line">			<span class="comment">// 实现调用祖父类的thinking()方法，打印&quot;i am grandfather&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_1().<span class="function">new <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java程序中，可以通过“super”关键字很方便地调用到父类中的方法，但如果要访问祖类的方法呢？不妨自己思考一下，在JDK 7之前有没有办法解决这<br>个问题。</p>
<p>在拥有invokedynamic和java.lang.invoke包之前，使用纯粹的Java语言很难处理这个问题（使用ASM等字节码工具直接生成字节码当然还是可以处理的，但这已经是在字节码而不是Java语言层面来解决问题了），原因是在Son类的thinking()方法中根本无法获取到一个实际类型是GrandFather的对象引用，而invokevirtual指令的分派逻辑是固定的，只能按照方法接收者的实际类型进行分派，这个逻辑完全固化在虚拟机中，程序员无法改变。</p>
<p>如果是JDK 7 Update 9之前，使用代码清单8-16中的程序就可以直接解决该问题。</p>
<p>代码清单8-16　使用MethodHandle来解决问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">                MethodHandle mh = lookup().findSpecial(GrandFather.class,<span class="string">&quot;thinking&quot;</span>, mt, getClass());</span><br><span class="line">                mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_1().n<span class="function">ew <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<strong>JDK 7 Update 9之前</strong>的HotSpot虚拟机运行，会得到如下运行结果： i am grandfather</p>
<p>ps:  <strong>我试了一下用jdk 9</strong>，运行结果是： i am father，因为: </p>
<ul>
<li>这个逻辑在JDK 7 Update 9之后被视作一个潜在的安全性缺陷修正了，</li>
<li>原因是<strong>必须保证findSpecial()查找方法版本时受到的访问约束</strong>（譬如对访问控制的限制、对参数类型的限制）<strong>应与使用invokespecial指令一样</strong>，两者必须保持精确对等，包括在上面的场景中它只能访问到其直接父类中的方法版本。</li>
<li>所以在JDK 7 Update 10修正之后，运行以上代码只能得到如下结果 : i am father</li>
</ul>
<p>那在新版本的JDK中，上面的问题是否能够得到解决呢？</p>
<ul>
<li>答案是可以的，如果读者去查看MethodHandles.Lookup类的代码，将会发现需要进行哪些访问保护，在该API实现时是预留了后门的。</li>
<li>访问保护是通过一个<strong>allowedModes</strong>的参数来控制，而且这个参数可以被设置成“TRUSTED”来绕开所有的保护措施。尽管这个参数只是在Java类库本身使用，没有开放给外部设置，但我们<strong>通过反射可以轻易打破这种限制</strong>。</li>
<li>由此，我们可以把代码清单8-16中子类的thinking()方法修改为如下所示的代码来解决问题：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFatherTestCase_2</span>.<span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">GrandFatherTestCase_2</span>.<span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">                Field lookupImpl = MethodHandles.Lookup.class.getDeclaredField(<span class="string">&quot;IMPL_LOOKUP&quot;</span>);</span><br><span class="line">                lookupImpl.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                MethodHandle mh = ((MethodHandles.Lookup) lookupImpl.get(<span class="keyword">null</span>)).findSpecial(GrandFather.class,<span class="string">&quot;thinking&quot;</span>, mt, GrandFather.class);</span><br><span class="line">                mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_2().<span class="function">new <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码，在目前所有JDK版本中均可获得如下结果:   i am grandfather</p>
<h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><p>我们来探讨虚拟机是如何执行方法里面的字节码指令的。许多Java虚拟机的执行引擎在执行Java代码的时候都有<strong>解释执行（通过解释器执行）</strong>和 <strong>编译执行（通过即时编译器产生本地代码执行）</strong>两种选择，在本节中，我们将会分析在概念模型下的Java虚拟机解释执行字节码时，其执行引擎是如何工作的。</p>
<p>笔者在本章多次强调了“概念模型”，是因为实际的虚拟机实现，譬如HotSpot的模板解释器工作的时候，并不是按照下文中的动作一板一眼地进行机械式计算，而是动态产生每条字节码对应的汇编代码来运行，这与概念模型中执行过程的差异很大，但是结果却能保证是一致的。</p>
<h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><ul>
<li>Java语言经常被人们定位为“解释执行”的语言，在Java初生的JDK 1.0时代，这种定义还算是比较准确的，</li>
<li>但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事。</li>
<li>再后来，Java也发展出可以直接生成本地代码的编译器（如Jaotc、GCJ[1]，Excelsior JET），而C/C++语言也出现了通过解释器执行的版本（如<br>CINT[2]），</li>
<li>这时候再笼统地说“解释执行”，对于整个Java语言来说就成了几乎是没有意义的概念，</li>
<li>只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较合理确切。</li>
</ul>
<ul>
<li>无论是解释还是编译，也无论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅读、理解，然后获得执行能力。</li>
<li>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过图8-4中的各个步骤。</li>
<li>如果读者对大学编译原理的相关课程还有印象的话，很容易就会发现图8-4中下面的那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程；而中间的那条分支，自然就是解释执行的过程。</li>
</ul>
<p><img src="/uploads/jvm/11diapatch/compile.png"></p>
<p>如今，基于物理机、Java虚拟机，或者是非Java的其他高级语言虚拟机（HLLVM）的代码执行过程，大体上都会遵循这种符合现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树（Abstract Syntax Tree，AST）。</p>
<ul>
<li>对于一门具体语言的实现来说，词法、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。</li>
<li>也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的JavaScript执行引擎。</li>
</ul>
<p>在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p>
<h2 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h2><ul>
<li><p>Javac编译器输出的字节码指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作</p>
</li>
<li><p>与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，如果说得更通俗一些就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作</p>
</li>
</ul>
<h3 id="基于栈的指令集与基于寄存器的指令集区别："><a href="#基于栈的指令集与基于寄存器的指令集区别：" class="headerlink" title="基于栈的指令集与基于寄存器的指令集区别："></a>基于栈的指令集与基于寄存器的指令集区别：</h3><p>举个最简单的例子，分别使用这两种指令集去计算“1+1”的结果</p>
<h4 id="基于栈的指令集："><a href="#基于栈的指令集：" class="headerlink" title="基于栈的指令集："></a>基于栈的指令集：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>

<p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中。这种指令流中的指令通常都是不带参数的，使用操作数栈中的数据作为指令的运算输入，指令的运算结果也存储在操作数栈之中。</p>
<h4 id="基于寄存器的指令集"><a href="#基于寄存器的指令集" class="headerlink" title="基于寄存器的指令集:"></a>基于寄存器的指令集:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">add eax, 1</span><br></pre></td></tr></table></figure>

<p>mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。这种二地址指令是x86指令集中的主流，每个指令都包含两个单独的输入参数，依赖于寄存器来访问和存储数据。</p>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul>
<li><p>基于栈的指令集主要优点是可移植，</p>
</li>
<li><p>因为寄存器由硬件直接提供[2]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束，</p>
</li>
<li><p>栈架构的指令集还有一些其他的优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编<br>译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）等。</p>
</li>
<li><p>栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些，所有主流物理机的指令集都是寄存器架构[3]也从侧面印证了这点</p>
</li>
<li><p>在解释执行时，栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。因此由于指令数量和内存访问的原因，导致了栈架构指令集的执行速度会相对慢上一点。</p>
</li>
</ul>
<h2 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="　基于栈的解释器执行过程"></a>　基于栈的解释器执行过程</h2><p>代码清单8-17　一段简单的算术代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>;</span><br><span class="line">	Code:</span><br><span class="line">        Stack=<span class="number">2</span>, Locals=<span class="number">4</span>, Args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: bipush <span class="number">100</span></span><br><span class="line">        <span class="number">2</span>: istore_1</span><br><span class="line">        <span class="number">3</span>: sipush <span class="number">200</span></span><br><span class="line">        <span class="number">6</span>: istore_2</span><br><span class="line">        <span class="number">7</span>: sipush <span class="number">300</span></span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: iload_1</span><br><span class="line">        <span class="number">12</span>: iload_2</span><br><span class="line">        <span class="number">13</span>: iadd</span><br><span class="line">        <span class="number">14</span>: iload_3</span><br><span class="line">        <span class="number">15</span>: imul</span><br><span class="line">        <span class="number">16</span>: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javap提示这段代码需要<strong>深度为2的操作数栈</strong>和<strong>4个变量槽</strong>的局部变量空间，笔者就根据这些信息画了图8-5至图8-11共7张图片，来描述代码清单8-13执行过程中的代码、操作数栈和局部变量表的变化情况。</p>
<p><img src="/uploads/jvm/12bytecodeEngineer/01bipush.png"></p>
<ol>
<li>首先，执行偏移地址为0的指令，Bipush指令的作用是将单字节的整型常量值（-128～127）推入操作数栈顶，跟随有一个参数，指明推送的常量值，这里是100。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/02istore.png"></p>
<ol start="2">
<li>执行偏移地址为2的指令，<strong>istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量槽中</strong>。后续4条指令（直到偏移为11的指令为止）都是做一样的事情，也就是在对应代码中把变量a、b、c赋值为100、200、300。这4条指令的图示略过。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/03iload.png"></p>
<ol start="3">
<li>执行偏移地址为11的指令，<strong>iload_1指令的作用是将局部变量表第1个变量槽中的整型值复制到操作数栈顶</strong>。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/04iload2.png"></p>
<ol start="4">
<li>执行偏移地址为12的指令，iload_2指令的执行过程与iload_1类似，<strong>把第2个变量槽的整型值入栈</strong>。<br>画出这个指令的图示主要是为了显示下一条iadd指令执行前的堆栈状况。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/05iadd.png"></p>
<ol start="5">
<li>执行偏移地址为13的指令，<strong>iadd指令的作用是将操作数栈中头两个栈顶元素出栈，做整型加法，</strong><br><strong>然后把结果重新入栈。</strong>在iadd指令执行完毕后，栈中原有的100和200被出栈，<strong>它们的和300被重新入栈</strong>。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/06iload3.png"></p>
<ol start="6">
<li>执行偏移地址为14的指令，iload_3指令<strong>把存放在第3个局部变量槽中的300入栈到操作数栈中</strong>。这时操作数栈为两个整数300。下一条指令imul是将操作数栈中头两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，与iadd完全类似，所以笔者省略图示。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/07ireturn.png"></p>
<ol start="7">
<li>执行偏移地址为16的指令，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶<br>的整型值返回给该方法的调用者。到此为止，这段方法执行结束。</li>
</ol>
<p>再次强调上面的执行过程仅仅是一种<strong>概念模型</strong>，虚拟机最终会对执行过程做出<strong>一系列优化</strong>来提高性能，实际的运作过程并不会完全符合概念模型的描述。</p>
<p>更确切地说，实际情况会和上面描述的概念模型差距非常大，差距产生的根本原因是<strong>虚拟机中解析器和即时编译器都会对输入的字节码进行优化</strong>，即使解释器中也不是按照字节码指令去逐条执行的。例如在HotSpot虚拟机中，就有很多以“fast_”开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，即时编译器的优化手段则更是花样繁多</p>
<p>我们从这段程序的执行中也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径，符合我们在前面分析的特点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">深入理解jvm-11-虚拟机字节码执行引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-19 23:42:20" itemprop="dateCreated datePublished" datetime="2021-01-19T23:42:20+08:00">2021-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>执行引擎是Java虚拟机核心的组成部分之一。</p>
</li>
<li><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，</p>
</li>
<li><p>其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，</p>
</li>
<li><p>而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
</li>
</ul>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><h3 id="栈帧（Stack-Frame）"><a href="#栈帧（Stack-Frame）" class="headerlink" title="栈帧（Stack Frame）"></a>栈帧（Stack Frame）</h3><ul>
<li><p>Java虚拟机以方法作为最基本的执行单元，而 <strong>栈帧</strong> （Stack Frame）则是用于java虚拟机进行方法调用和方法执行背后的数据结构， 它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p>
</li>
<li><p>栈帧存储了方法的<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>和<strong>方法返回地址</strong> 等信息，</p>
</li>
<li><p>每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从<strong>入栈到出栈</strong>的过程</p>
</li>
<li><p>在编译Java程序源码的时候，栈帧需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。</p>
</li>
<li><p>一个栈帧需要分配多少内存，并不会收到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式</p>
</li>
</ul>
<ul>
<li>一个线程中的方法调用链 可能会很长，以java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。</li>
<li>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame）,与这个栈帧关联的方法 被称为 “当前方法”（Current Method）。</li>
<li>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，</li>
</ul>
<h3 id="栈帧的概念结构"><a href="#栈帧的概念结构" class="headerlink" title="栈帧的概念结构"></a>栈帧的概念结构</h3><p><img src="/uploads/jvm/10StackFrame/01-StackFrameConstruct.png"></p>
<h4 id="局部变量表（Local-Variables-Table）"><a href="#局部变量表（Local-Variables-Table）" class="headerlink" title="局部变量表（Local Variables Table）"></a>局部变量表（Local Variables Table）</h4><ul>
<li><p>局部变量表 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量表。 </p>
</li>
<li><p>在Java程序被编译成Class文件时，就在方法的Code属性中的<strong>max_locals</strong> 数据项中确定了该方法所需分配的局部变量表的最大容量</p>
</li>
<li><p>局部变量表的容量以 变量槽（Variable slot）为最小单位，</p>
</li>
<li><p>《Java虚拟机规范》被没有明确指出一个变量槽应占用的 内存空间大小，只有向导性的说每个变量槽 Variable Slot 都应该能存放一个  boolean 、 byte、 char、 short、 int、 float、 reference 或看return Address类型的数据</p>
</li>
</ul>
<h5 id="局部变量表中的数据类型"><a href="#局部变量表中的数据类型" class="headerlink" title="局部变量表中的数据类型"></a>局部变量表中的数据类型</h5><ul>
<li>一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference[1]和returnAddress这8种类型。</li>
<li>而第7种reference类型表示对一个对象实例的引用，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则将无法实现《Java语言规范》中定义的语法约定</li>
<li>第8种returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转，但现在也已经全部改为采用异常表来代替了</li>
<li>对于64位的数据类型，Java虚拟机会以 <strong>高位对齐</strong> 的方式为其分配 <strong>两个连续的变量槽空间</strong> 。Java语言中明确的64位的数据类型只有 long 和 double 两种。</li>
<li>这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中允许把一次long和double数据类型读写分割为两次32位读写的做法有些类<br>似。</li>
<li>由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。</li>
</ul>
<ul>
<li><p>Java虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会<strong>同时使用第N和N+1两个变量槽</strong>.</p>
</li>
<li><p>对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机<strong>不允许采用任何方式单独访问其中的某一个</strong>，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。</p>
</li>
<li><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<strong>参数值到参数列表</strong>的传递过程，即 <strong>实参到形参</strong>的传递。如果执行的时实例方法（没有被 static 修饰的方法），那局部变量表中的<strong>第0 位索引</strong>的变量槽 默认是 用于传递<strong>方法实例的引用</strong>，在方法中可以通过 关键字“this” 来访问到这个隐含的参数。 其余的参数 则是按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
</li>
</ul>
<h5 id="局部变量表的重用"><a href="#局部变量表的重用" class="headerlink" title="局部变量表的重用"></a>局部变量表的重用</h5><ul>
<li>为了尽可能的节省栈帧耗用的内存空间，<strong>局部变量表中的变量槽是可以重用</strong>的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体（就是一个方法体中的局部变量可能用到一半就不使用了，比如方法体有10行，而局部变量只在其中的3-4行被使用，那这个局部变量就没有覆盖整个方法体），如果当前字节码PC计数器的值 已经超过了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。</li>
<li>不过这样的设计除了节省栈帧空间外，还会伴随少量的<strong>副作用</strong></li>
<li>例如 在某些情况下变量槽的复用会直接影响到系统的GC 行为，如下如代码所示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M </span></span><br><span class="line"><span class="comment"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseVariableSlot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result: (我这里使用的JDK <span class="number">9</span>)</span><br><span class="line">[<span class="number">0.028</span>s][info][gc] Using G1</span><br><span class="line">[<span class="number">0.142</span>s][info][gc] GC(<span class="number">0</span>) <span class="function">Pause Initial <span class="title">Mark</span> <span class="params">(G1 Humongous Allocation)</span> 2M-&gt;1<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 1.368ms</span></span><br><span class="line"><span class="function">[0.142s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle</span></span><br><span class="line"><span class="function">[0.171s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Remark 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.724ms</span></span><br><span class="line"><span class="function">[0.171s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Cleanup 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.174ms</span></span><br><span class="line"><span class="function">[0.175s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">2</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 3.810ms</span></span><br><span class="line"><span class="function">[0.175s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle 33.128ms</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span></span><br></pre></td></tr></table></figure>

<p>代码中可以看到：</p>
<p>向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上“-verbose：gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收掉这64MB的内存。</p>
<p>代码没有回收掉 placeHolder所占的内存说的过去，因为执行system.gc()时，变量 placeholder 还处于作用域之内，虚拟机自然不敢回收掉placeholder 的内存。</p>
<p>我们修改一下代码，改成这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M</span></span><br><span class="line"><span class="comment"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseVariableSlot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result： 同上</span><br><span class="line">    [<span class="number">0.026</span>s][info][gc] Using G1</span><br><span class="line">[<span class="number">0.137</span>s][info][gc] GC(<span class="number">0</span>) <span class="function">Pause Initial <span class="title">Mark</span> <span class="params">(G1 Humongous Allocation)</span> 2M-&gt;1<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 1.593ms</span></span><br><span class="line"><span class="function">[0.137s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle</span></span><br><span class="line"><span class="function">[0.162s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Remark 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.727ms</span></span><br><span class="line"><span class="function">[0.165s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">2</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 3.594ms</span></span><br><span class="line"><span class="function">[0.166s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Cleanup 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.001ms</span></span><br><span class="line"><span class="function">[0.166s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle 28.351ms</span></span><br></pre></td></tr></table></figure>

<p>加入了花括号之后，placeholder的作用域被限制在了 花括号之内，从代码逻辑上讲，在执行 system.gc()的时候，placeholder 已经不可能再被访问了，但执行这段程序的时候，发现 64M的内存 还是没有被回收掉，</p>
<p>为什么呢，解释之前我们再修改一下代码,先对这段代码进行第二次修改，在调用System.gc()之前加入一行“int  a=0；”，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M</span><br><span class="line"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> */</span><br><span class="line">public class ReuseVariableSlot &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            byte[] placeholder = new byte[64 * 1024 * 1024];</span><br><span class="line">        &#125;</span><br><span class="line">         int a = 0;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> result: </span><br><span class="line"> [0.026s][info][gc] Using G1</span><br><span class="line">[0.145s][info][gc] GC(0) Pause Initial Mark (G1 Humongous Allocation) 2M-&gt;1M(80M) 1.527ms</span><br><span class="line">[0.145s][info][gc] GC(1) Concurrent Cycle</span><br><span class="line">[0.170s][info][gc] GC(1) Pause Remark 66M-&gt;66M(80M) 0.789ms</span><br><span class="line">[0.170s][info][gc] GC(1) Pause Cleanup 66M-&gt;66M(80M) 0.351ms</span><br><span class="line">[0.170s][info][gc] GC(1) Concurrent Cycle 25.457ms</span><br><span class="line">[0.174s][info][gc] GC(2) Pause Full (System.gc()) 66M-&gt;1M(80M) 3.362ms </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现加上 int a = 0; 之后，发现内存被回收了 （[info][gc] GC(2) Pause Full (System.gc()) 66M-&gt;1M(80M) 3.362ms ）</p>
<h5 id="代码总结："><a href="#代码总结：" class="headerlink" title="代码总结："></a>代码总结：</h5><p>上面的代码 ，<strong>placeholder 能否被回收</strong> 的根本原因是：  </p>
<ul>
<li>局部变量表的变量槽 是否还存有 关于placeholder数组对象的 <strong>引用</strong></li>
<li>第一次修改中（加花括号），代码虽然 已经离开了placeholder的作用域，但在之后，在没有发生过任何对局部变量表的读写 操作，placeholder 原本所占用的变量槽  还没有被其他变量所复用，所以作为 GC ROOTs 一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断。再绝大部分情况下影响很轻微。 但如果遇到 一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大部分内存但实际已经不会再使用的变量， 手动 将其设置为 null值 （用来代替 int a=0，把变量对应的局部变量槽清空）便不见得是一个绝对无意义的操作 。这是<strong>奇技淫巧</strong> ，并不是很认同。</li>
<li>这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到即时编译器的编译条件）下的“奇技”来使用。Java语言的一本非常著名的书籍《Practical Java》中将把“不使用的对象应手动赋值为null”作为一条推荐的编码规则（笔者并不认同这条规则），但是并没有解释具体原因</li>
<li>这是<strong>奇技淫巧</strong> ，并不是很认同。因为：<ul>
<li>从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法</li>
<li>更关键的是，从执行角度来讲，使用赋null操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，概念模型与实际执行过程是外部看起来等效，内部看上去则可以完全不同。当虚拟机使用解释器执行时，通常与概念模型还会比较接近，但经过即时编译器施加了各种编译优化措施以后，两者的差异就会非常大，只保证程序执行的结果与概念一致。在实际情况中，即时编译才是虚拟机执行代码的主要方式，赋null值的操作在经过即时编译优化后几乎是一定会被当作无效操作消除掉的，这时候将变量设置为null就是毫无意义的行为。字节码被即时编译为本地代码后，对GC Roots的枚举也与解释执行时期有显著差别，以前面的例子来看，经过第一次修改的代码（第二个方法）在经过即时编译后，System.gc()执行时就可以正确地回收内存，根本无须写成代码（第三个方法）的样子。</li>
</ul>
</li>
</ul>
<h5 id="局部变量表不存在准备阶段"><a href="#局部变量表不存在准备阶段" class="headerlink" title="局部变量表不存在准备阶段"></a>局部变量表不存在准备阶段</h5><ul>
<li><p>局部变量表不像类变量那样存在“准备阶段”，</p>
</li>
<li><p>之前我们在《虚拟机的类加载过程》学过，类的字段变量 有2次赋初始值的过程，  一次是在 准备阶段，赋予系统初始值；另外一次是在 初始化阶段，赋予程序员在代码中定义的初始值。 因此 即使在初始化阶段 程序员没有为类变量赋值也没有关系，类变量仍然具有一个决定的初始值（零值，默认值），不会产生歧义。</p>
</li>
<li><p>但是 局部变量就不一样 了，如果一个局部变量定义了，但没有赋初始值，那它是完全不能使用的。</p>
</li>
<li><p>所以不要认为 Java中任何情况都存在 诸如 整型变量默认为0、布尔型变量默认为 false 等这样的默认值规则。</p>
</li>
<li><p>如果局部变量不赋初始值，编译期在编译期间能检查到并提示出来，ide工具是会报错的。</p>
</li>
<li><p>即使编译能通过或者 通过手动的方式生成字节码，在《虚拟机的类加载过程》的字节码验证阶段，也会被虚拟机发现，从而导致 类加载失败。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a; <span class="comment">//</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result:  编译期报错：  可能尚未初始化变量a</span><br></pre></td></tr></table></figure>



<h3 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h3><ul>
<li><p>操作数栈 （Operand Stack）也常被称为操作栈，它是一个<strong>先入后出</strong> (Last In First Out,LIFO） 栈。 </p>
</li>
<li><p>同局部变量表一样， 操作数栈的最大深度也在编译的时候被写入到 Code 属性的 <strong>max_stacks</strong> 数据项之中。</p>
</li>
<li><p>操作数栈的每一个元素 都可以是包括long 和 double 在内的<strong>任意java数据类型</strong> 。32位 数据类型 所占的栈容量为 1，64 位数据类型所占的栈容量为  2。</p>
</li>
<li><p>javac 编译器的数据流分析工作保证了 在方法执行的任何时候，操作数栈的深度 都不会超过 在 max_stacks 数据项设定的最大值。</p>
</li>
</ul>
<h5 id="方法执行时的操作栈动作"><a href="#方法执行时的操作栈动作" class="headerlink" title="方法执行时的操作栈动作"></a>方法执行时的操作栈动作</h5><ul>
<li><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。  在方法的执行过程中，会有各种<strong>字节码指令</strong> 往  <strong>操作数栈</strong> 中写入和提取 内容， 也就是出栈和入栈操作。</p>
<p>譬如 在做算术运算的时候 ，通过将运算涉及的操作数栈 压入栈顶后 ，然后 调用运算指令来执行。</p>
</li>
</ul>
<p>又譬如 在调用其他方法的时候 ，通过操作数栈 来进行方法参数的传递。</p>
<p>举个例子， 例如整数加法 的字节码 iadd, 这条指令在运行的时候 ，要求操作数栈中最接近 栈顶的2个元素 已经存入了2个int 型的数值，当执行 iadd这个指令时候，会把这2 个int 值出栈 并相加，然后将 相加的结果重新入栈 。</p>
<h5 id="字节码指令严格匹配操作栈元素数据类型"><a href="#字节码指令严格匹配操作栈元素数据类型" class="headerlink" title="字节码指令严格匹配操作栈元素数据类型"></a>字节码指令严格匹配操作栈元素数据类型</h5><p>操作数栈中元素的数据类型必须 与字节码指令的序列严格匹配，在编译程序代码的时候，编译期必须严格保证这一点，在类校验阶段的数据流分析中还要 再次验证这一点。</p>
<p>例如： iadd指令只能 用于整型数据的加法，该指令在执行时，最接近栈顶的2个元素的数据类型 必须为int 型，不能出现一个long 和一个float 使用iadd指令相加的 情况。</p>
<h5 id="栈帧的优化"><a href="#栈帧的优化" class="headerlink" title="栈帧的优化"></a>栈帧的优化</h5><ul>
<li><p>Java虚拟机的<strong>解释执行引擎</strong> 被称为“<strong>基于栈的执行引擎</strong>”, 里面的栈 就是操作数栈。后续还会对基于栈的代码执行过程进行更详细的讲解。介绍它与更常见的<strong>基于寄存器的执行引擎</strong>有那些差别</p>
</li>
<li><p>在概念 模型中，两个不同栈帧（Stack Frame）作为不同方法的虚拟机栈 元素，是<strong>完全互相独立</strong>的。  但是在大多数虚拟机的实现中，会对这块进行一些<strong>优化处理</strong> ，令2个 不同方法的栈帧出现一部分 <strong>重叠</strong>。让下面的栈帧的部分操作数栈 与 上面栈帧的部分局部变量表 重叠在一起，这样做不仅节约了 一些空间，更重要的是 在进行方法调用的时候 就可以直接共用 一部分数据，无需进行<strong>额外的 参数 复制传递</strong>了 。重叠的过程如下图所示： </p>
</li>
</ul>
<p><img src="/uploads/jvm/10StackFrame/02-StackFrameOverlap.png"></p>
<h3 id="动态连接（Dynamic-Linking）"><a href="#动态连接（Dynamic-Linking）" class="headerlink" title="动态连接（Dynamic Linking）"></a>动态连接（Dynamic Linking）</h3><p>每个栈帧 都包含一个指向<strong>运行时常量池</strong> 中<strong>该栈帧所属方法的引用</strong>，持有这个引用 是为了支持方法调用过程中的<strong>动态连接</strong>。</p>
<p>通过之前文章，我们知道 Class文件 的常量池中存有 大量的符号引用，字节码中的<strong>方法调用指令</strong> 就以 常量池里<strong>指向方法的符号连接</strong> 作为参数。</p>
<ul>
<li>这些符号引用一部分将在 <strong>类加载阶段</strong>或者<strong>第一次使用的时候</strong>就被转化为<strong>直接引用</strong>，这种转化称为  <strong>静态解析</strong></li>
<li>另外一部分将在<strong>每一次运行期间</strong>都<strong>转化 为直接引用</strong>，这部分就称为 <strong>动态连接</strong>。后续后详细讲解</li>
</ul>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有 2种 方式退出这个方法。</p>
<ul>
<li>第一种退出方式是执行引擎遇到任意一个方法<strong>返回的字节码指令</strong>，这时候 可能会有返回值 传递给上层方法调用者 （调用当前方法的方法称为 <strong>主调方法</strong> 或者 “<strong>调用者</strong>”）， 方法是否有返回值 以及返回值的类型 将根据 何种方法返回指令来决定，这种退出方式 称为 “<strong>正常调用完成（Normal Method Invocation Completion）</strong>”</li>
<li>另外一种退出方式 就是方法执行过程中 遇到了异常，并且这个异常没有在方法体内得到妥善处理。  无论是Java虚拟机内部的异常，还是代码中<strong>athrow字指令</strong> 产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式 称为 “**异常调用完成(Abrupt Method Invocation Completion)**”  。一个方法使用异常完成出口的方式退出，是不会给他的上层调用者 提供任何返回值的。</li>
</ul>
<p>无论采用何种退出方式，在方法退出之后，都必须<strong>返回最初方法被调用的位置</strong>，程序才能继续执行。</p>
<p>方法返回时 可能需要在栈帧中 保存一些信息，用来帮助<strong>恢复它的上层主调方法的执行状态</strong> 。 </p>
<p>一般来说，方法正常退出时，<strong>主调方法的PC计数器的值 就可以作为返回地址</strong>，栈帧中很可能 会保存这个计数器值。</p>
<p>而异常退出的时候，返回地址就是 通过异常处理器 来确定的，栈帧中 一般不会保存这部分信息 （主调方法的PC计数器值）</p>
<h5 id="方法退出的过程"><a href="#方法退出的过程" class="headerlink" title="方法退出的过程"></a>方法退出的过程</h5><p>方法退出的过程实际上等同于<strong>把 当前栈帧出栈</strong>，因此退出时可能执行的操作有：</p>
<ul>
<li>恢复上层主调方法的局部变量表和操作数栈，</li>
<li>把返回值（如果有的话） 压入 调用者（主调方法对应的）栈帧的操作数栈中，</li>
<li>调整PC计数器值 以指向方法调用指令后面的 的一条指令等。</li>
</ul>
<p>这些都是 基于概念模型的讨论，只有具体到某一款 java虚拟机实现，会执行哪些操作才能确定下来</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>
<p>在讨论概念时候，一般会把 <strong>动态连接，方法返回地址 与 其他附加信息</strong>全部归为一类，称为<strong>栈帧信息</strong> 。</p>
<h2 id="方法调用详解（TODO）"><a href="#方法调用详解（TODO）" class="headerlink" title="方法调用详解（TODO）"></a>方法调用详解（TODO）</h2><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体执行过程。</p>
<p>在程序执行时，进行方法调用是最普遍最频繁的操作之一，Class文件的编译过程中 不包含传统程序语言编译的连接步骤，一切方法调用在Class文件 里面存储的都是 符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。 这个特性给了Java带来了更强大的动态扩展能力，也使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用的目标方法在Class 文件里面都是一个 常量池的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是:  方法在程序真正执行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。 换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<strong>解析</strong>（<strong>Resolution</strong>）</p>
<h4 id="编译期可知，运行期不可变"><a href="#编译期可知，运行期不可变" class="headerlink" title="编译期可知，运行期不可变"></a>编译期可知，运行期不可变</h4><p>在Java语言中，符合“编译期可知，运行期不可变”这个要求的方法，主要有 <strong>静态方法</strong> 和<strong>私有方法</strong>两大类，前者与类型直接关联，后者在外部不可访问，这两种方法各自的特点决定了他们都不可能通过继承或 别的方式重写出其他版本，因为它们都适合在类解析阶段进行解析。</p>
<h4 id="方法调用字节码指令"><a href="#方法调用字节码指令" class="headerlink" title="方法调用字节码指令"></a>方法调用字节码指令</h4><p>调用不同类型的方法，字节码指令集里面设计了不同的指令。在Java虚拟机支持 以下5条方法调用字节码指令，分别是：</p>
<ol>
<li>invokestatic ： 用于调用静态方法</li>
<li>invokespecial：  用于调用实例构造器<init>()方法、私有方法和父类中的方法</li>
<li>invokevirtual :  用于调用所有的虚方法</li>
<li>invokeinterface: 用于调用接口方法，会在运行时在确定一个实现该接口的对象</li>
<li>invokedynamic：  现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ol>
<h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><ul>
<li>前面的1-4条调用指令，分配逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</li>
<li>只要能被invokespecial 和 invokestatic指令调用的方法，都可以在解析阶段中确定唯一的调用版本 ，Java语言里符合这个条件的方法 有： </li>
</ul>
<p><strong>静态方法、私有方法、实例构造器、父类方法</strong>4种，再加上被 final修饰的方法（尽管它用invokevirtual）指令调用，这5种方法调用会再类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“<strong>非虚方法</strong>”（<strong>Non-Virtual Method</strong>），与之相反的，其他方法就被称为 <strong>虚方法（Virtual Method）</strong></p>
<p>方法静态解析演示：</p>
<p>演示了一种常见的解析调用的例子，该样例中，<strong>静态方法sayHello 只可能属于类型 StaticResolution ，没有任何途径可以覆盖或隐藏这个方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态解析演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticResolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticResolution.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 javap -verbose StaticResolution.class   得到下面结果：</p>
<p>使用javap命令查看这段程序对应的字节码，会发现的确是通过<strong>invokestatic</strong>命令来调用sayHello()方法，而且其调用的方法版本已经在编译时就明确以<strong>常量池项的形式</strong>固化在字节码指令的参数之中（ #5 = Methodref ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> Last modified <span class="number">2021</span>-<span class="number">1</span>-<span class="number">18</span>; size <span class="number">672</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">4041d</span>61106416a1bb60c338694bf8d00</span><br><span class="line">  Compiled from <span class="string">&quot;StaticResolution.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter8</span>.<span class="title">StaticResolution</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">53</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#22         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #25            // hello world</span><br><span class="line">   #4 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Methodref          #6.#28         // org/fenixsoft/jvm/chapter8/StaticResolution.sayHello:()V</span><br><span class="line">   #6 = Class              #29            // org/fenixsoft/jvm/chapter8/StaticResolution</span><br><span class="line">   #7 = Class              #30            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticResolution;</span><br><span class="line">  #15 = Utf8               sayHello</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               StaticResolution.java</span><br><span class="line">  #22 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #23 = Class              #31            // java/lang/System</span><br><span class="line">  #24 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;</span><br><span class="line">  #25 = Utf8               hello world</span><br><span class="line">  #26 = Class              #34            // java/io/PrintStream</span><br><span class="line">  #27 = NameAndType        #35:#36        // println:(Ljava/lang/String;)V</span><br><span class="line">  #28 = NameAndType        #15:#9         // sayHello:()V</span><br><span class="line">  #29 = Utf8               org/fenixsoft/jvm/chapter8/StaticResolution</span><br><span class="line">  #30 = Utf8               java/lang/Object</span><br><span class="line">  #31 = Utf8               java/lang/System</span><br><span class="line">  #32 = Utf8               out</span><br><span class="line">  #33 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #34 = Utf8               java/io/PrintStream</span><br><span class="line">  #35 = Utf8               println</span><br><span class="line">  #36 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.jvm.chapter8.StaticResolution();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticResolution;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: invokestatic  #5                  // Method sayHello:()V</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticResolution.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java中的非虚方法除了使用  <strong>invokespecial、invokestatic</strong> 调用的方法之外，还有一种就是 <strong>被final 修饰的实例方法</strong>。历史设计的原因，final 方法使用的是 <strong>invokevirtual</strong> 指令调用的，但是因为它无法被覆盖，没有其他版本的可能，所以也无须 对方法接收者 进行多态选择，又或者说 多态选择的结果肯定是唯一的。</p>
<p>再《Java语言规范》中明确定义了被 final修饰的方法是一种<strong>非虚方法</strong>.</p>
<h4 id="解析调用："><a href="#解析调用：" class="headerlink" title="解析调用："></a>解析调用：</h4><p>解析调用一定是一个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部 转变为 明确的直接引用，不必延迟到运行期再去完成。</p>
<h4 id="分派调用："><a href="#分派调用：" class="headerlink" title="分派调用："></a>分派调用：</h4><p>另一种主要的方法调用形式：  <strong>分派（Dispatch）</strong>调用则复杂许多，它可能是静态的也可能是动态的，按照分派依据 的宗量数可分为 <strong>单分派</strong> 和 <strong>多分派</strong>。 这两类分派两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派 4种分派组合情况 </p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>As we all know, Java 是一门面向对象的程序语言，因为java具备面向对象的 3个基本特征：  <strong>继承、封装 和多态。</strong></p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p> <strong>“分派”（Dispatch）</strong> 这个词本身就具有动态性，一般不应用在静态语境中。这部分原本在 英文原版的《Java虚拟机规范》和 《Java语言规范》里的说法都是:  </p>
<p>“Method Overload Resolution 方法重载解析” ,但部分外文资料和国内翻译的许多中文资料都将这种行为 称为 “静态分派”。</p>
<p>为了解释静态分派和重载（Overload），笔者准备了一段经常出现在面试题中的程序代码，读者不妨先看一遍，想一下程序的输出结果是什么。后面的话题将围绕这个类的方法来编写重载代码，以分析虚拟机和编译器确定方法版本的过程。程序如代码清单8-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    hello,guy!</span><br><span class="line">hello,guy!</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>为什么虚拟机会选择执行参数类型为Human的重载版本呢？在解决这个问题之前，我们先通过如下代码来定义两个关键概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

<ul>
<li>我们把上面代码中的 “Human” 称为 变量的 <strong>“静态类型”（static Type）</strong>，或者叫 <strong>“外观类型”（Apparent Type）</strong>,</li>
<li>“Man” 则被称为变量的 <strong>“实际类型”（Actual Type）</strong>或者叫做 <strong>“运行时类型”（Runtime Type）</strong>.</li>
<li>静态类型和实际类型在程序中都可能会发生变化，区别是 静态类型的变化仅仅在使用时发生， 变量本身的静态类型不会被改变，并且最终的静态类型在编译期可知的；而 实际类型变化的结果在运行期才可确定，编译期在编译程序的时候并不知道一个对象的实际类型时什么</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象human 的实际类型是可变的，编译期间 它完全是个 “薛定谔的人”，到底是 Man 还是woman，必须等到程序运行到这行的时候才能确定。</p>
</li>
<li><p>而human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()<br>方法的调用，在编译期完全可以明确转型的是Man还是Woman。</p>
</li>
</ul>
<p>main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全<strong>取决于传入参数的数量和数据类型</strong>。</p>
<p>代码中故意<strong>定义了两个静态类型相同</strong>，而<strong>实际类型不同的变量</strong>，但虚拟机（或者准确地说是编译器）<strong>在重载时是通过参数的静态类型</strong>而<strong>不是实际类型</strong>作为判定依据的。由于<strong>静态类型在编译期可知</strong>，所以<strong>在编译阶段</strong>，Javac编译器就<strong>根据参数的静态类型决定了会使用哪个重载版本</strong>，因此选择了<strong>sayHello(Human)作为调用目标</strong>，并把<strong>这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter8</span>.<span class="title">StaticDispatch</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">53</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #14.#44        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #45.#46        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #47            // hello,guy!</span><br><span class="line">   #4 = Methodref          #48.#49        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = String             #50            // hello,gentleman!</span><br><span class="line">   #6 = String             #51            // hello,lady!</span><br><span class="line">   #7 = Class              #52            // org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">   #8 = Methodref          #7.#44         // org/fenixsoft/jvm/chapter8/StaticDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 = Class              #53            // org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">  #10 = Methodref          #9.#44         // org/fenixsoft/jvm/chapter8/StaticDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = Class              #54            // org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">  #12 = Methodref          #11.#44        // org/fenixsoft/jvm/chapter8/StaticDispatch.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #13 = Methodref          #11.#55        // org/fenixsoft/jvm/chapter8/StaticDispatch.sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #14 = Class              #56            // java/lang/Object</span><br><span class="line">  #15 = Utf8               Woman</span><br><span class="line">  #16 = Utf8               InnerClasses</span><br><span class="line">  #17 = Utf8               Man</span><br><span class="line">  #18 = Class              #57            // org/fenixsoft/jvm/chapter8/StaticDispatch$Human</span><br><span class="line">  #19 = Utf8               Human</span><br><span class="line">  #20 = Utf8               &lt;init&gt;</span><br><span class="line">  #21 = Utf8               ()V</span><br><span class="line">  #22 = Utf8               Code</span><br><span class="line">  #23 = Utf8               LineNumberTable</span><br><span class="line">  #24 = Utf8               LocalVariableTable</span><br><span class="line">  #25 = Utf8               this</span><br><span class="line">  #26 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">  #27 = Utf8               sayHello</span><br><span class="line">  #28 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #29 = Utf8               guy</span><br><span class="line">  #30 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">  #31 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;)V</span><br><span class="line">  #32 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;</span><br><span class="line">  #33 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;)V</span><br><span class="line">  #34 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;</span><br><span class="line">  #35 = Utf8               main</span><br><span class="line">  #36 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #37 = Utf8               args</span><br><span class="line">  #38 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #39 = Utf8               man</span><br><span class="line">  #40 = Utf8               woman</span><br><span class="line">  #41 = Utf8               sr</span><br><span class="line">  #42 = Utf8               SourceFile</span><br><span class="line">  #43 = Utf8               StaticDispatch.java</span><br><span class="line">  #44 = NameAndType        #20:#21        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #45 = Class              #58            // java/lang/System</span><br><span class="line">  #46 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #47 = Utf8               hello,guy!</span><br><span class="line">  #48 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #49 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #50 = Utf8               hello,gentleman!</span><br><span class="line">  #51 = Utf8               hello,lady!</span><br><span class="line">  #52 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">  #53 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">  #54 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">  #55 = NameAndType        #27:#28        // sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #56 = Utf8               java/lang/Object</span><br><span class="line">  #57 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Human</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.jvm.chapter8.StaticDispatch();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Human)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello,guy!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Man)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #5                  // String hello,gentleman!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">23</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Woman)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #6                  // String hello,lady!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">27</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #7                  // class org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #8                  // Method org/fenixsoft/jvm/chapter8/StaticDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: new           #9                  // class org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        12: invokespecial #10                 // Method org/fenixsoft/jvm/chapter8/StaticDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        16: new           #11                 // class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">        <span class="number">19</span>: dup</span><br><span class="line">        20: invokespecial #12                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">23</span>: astore_3</span><br><span class="line">        <span class="number">24</span>: aload_3</span><br><span class="line">        <span class="number">25</span>: aload_1</span><br><span class="line">        26: invokevirtual #13                 //这里： Method sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">        <span class="number">29</span>: aload_3</span><br><span class="line">        <span class="number">30</span>: aload_2</span><br><span class="line">        31: invokevirtual #13                 //这里： Method sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">        <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">31</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">32</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">33</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">34</span>: <span class="number">24</span></span><br><span class="line">        line <span class="number">35</span>: <span class="number">29</span></span><br><span class="line">        line <span class="number">36</span>: <span class="number">34</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">35</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">27</span>     <span class="number">1</span>   man   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">           <span class="number">16</span>      <span class="number">19</span>     <span class="number">2</span> woman   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">           <span class="number">24</span>      <span class="number">11</span>     <span class="number">3</span>    sr   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticDispatch.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     static #15= #9 of #11; //Woman=class org/fenixsoft/jvm/chapter8/StaticDispatch$Woman of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">     static #17= #7 of #11; //Man=class org/fenixsoft/jvm/chapter8/StaticDispatch$Man of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">     static abstract #19= #18 of #11; //Human=class org/fenixsoft/jvm/chapter8/StaticDispatch$Human of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br></pre></td></tr></table></figure>



<p>所有依赖静态类型来决定执行版本的分派动作，都被称为 <strong>静态分派</strong>。 静态分配的最典型应用表现就是 <strong>方法重载</strong>。 静态分派 发生在编译阶段，因此确定静态分派的动作实际上并不是由虚拟机来执行的 ，这点也是为什么一些资料选择把它归入 为 “解析”而不是 “分派”的原因。</p>
<h5 id="重载方法匹配优先级"><a href="#重载方法匹配优先级" class="headerlink" title="重载方法匹配优先级"></a>重载方法匹配优先级</h5><p>需要注意Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个“相对更合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是个比较稀罕的事件，产生这种模糊结论的主要原因是字面量天生的模糊性，它不需要定义，所以字面量就没有显式的静态类型，它的静态类型只能通过语言、语法的规则去理解和推断。代码清单8-7演示了何谓“更加合适的”版本。</p>
<p>代码清单8-7　重载方法匹配优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Character&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Serializable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一次运行结果： <strong>hello char</strong>，这很好理解，’a’是一个char类型的数据，自然会寻找参数类型为char的重载方法，</p>
</li>
<li><p>如果注释掉 sayHello(char arg)方法，那输出会变为：<strong>hello int</strong> ，这时发生了一次自动类型转换，’a’除了可以代表一个字符串，还可以代表数字97（字符’a’的<br>Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的</p>
</li>
<li><p>我们继续注释掉sayHello(int arg)方法，那输出会变为： <strong>hello long</strong> .这时发生了两次自动类型转换，’a’转型为整数97之后，进一步转型为长整数97L，匹配了参数类型为long的重载。笔者在代码中没有写其他的类型如float、double等的重载，不过实际上自动转型还能继续发生多次，按照<strong>char&gt;int&gt;long&gt;float&gt;double的顺序转型进行匹配</strong>，但<strong>不会匹配到byte和short类型的重载</strong>，因为<strong>char到byte或short的转型是不安全的</strong>。</p>
</li>
<li><p>继续注释掉sayHello(long arg)方法，那输出会变为 : <strong>hello Character</strong>  ，这时发生了一次自动装箱，’a’被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为Character的重载</p>
</li>
<li><p>继续注释掉sayHello(Character arg)方法，那输出会变为： <strong>hello Serializable</strong>,  出现hello Serializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类所实现的接口类型，所以紧接着又发生一次自动转型。char可以转型成int，<br>但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现了另外一个接口java.lang.Comparable<Character>，如果同时出现两个参数分别为Serializable和Comparable<Character>的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示“类型模糊”（Type Ambiguous），并拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如：sayHello((Comparable<Character>)’a’)，才能编译通过</p>
</li>
<li><p>继续注释掉sayHello(Serializable arg)方法，输出会变为： <strong>hello Object</strong> ，这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。</p>
</li>
<li><p>我们把sayHello(Objectarg)也注释掉，输出将会变为： <strong>hello char …</strong>,7个重载方法已经被注释得只剩1个了，可见变长参数的重载优先级是最低的，这时候字符’a’被当作了一个char[]数组的元素。笔者使用的是char类型的变长参数，读者在验证时还可以选择int类型、Character类型、Object类型等的变长参数重载来把上面的过程重新折腾一遍。但是要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的[2]。</p>
</li>
</ul>
<p>另外还有一点读者可能比较容易混淆：笔者讲述的<strong>解析与分派这两者之间的关系并不是二选一的排他关系</strong>，它们是在<strong>不同层次上去筛选、确定目标方法</strong>的过程。例如前面说过静态方法会在编译期确定、在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，<strong>选择重载版本的过程也是通过静态分派</strong>完成的</p>
<ul>
<li>可以这么理解吗： <strong>overload重载是gen据静态类型来决定的（静态分派），  override是根据 实际类型来决定的（动态分派）。</strong></li>
</ul>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>看一下Java语言里动态分派的实现过程，它与Java语言多态性的另外一个重要体现[3]——重写（Override）有着很密切的关联。我们还是用前面的Man和Woman一起 sayHello的例子来讲解动态分派，请看代码清单8-8中所示的代码。</p>
<p>代码清单8-8　方法动态分派演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>

<h5 id="Java虚拟机是如何判断应该调用哪个方法"><a href="#Java虚拟机是如何判断应该调用哪个方法" class="headerlink" title="Java虚拟机是如何判断应该调用哪个方法"></a>Java虚拟机是如何判断应该调用哪个方法</h5><ul>
<li>可以这么理解吗： <strong>overload重载是gen据静态类型来决定的（静态分派），  override是根据 实际类型来决定的（动态分派）。</strong></li>
</ul>
<p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为<strong>静态类型同样都是Human的两个变量</strong>man和woman在调用sayHello()方法时产生了不同的行为，甚至变量man在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是因为这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？我们使用javap命令输出这段代码的字节码，尝试从中寻找答案，输出结果如代码清单8-9所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">	Code:</span><br><span class="line">        Stack=2, Locals=3, Args_size=1</span><br><span class="line">        0: new <span class="comment">#16; //class org/fenixsoft/polymorphic/DynamicDispatch$Man</span></span><br><span class="line">        3: dup</span><br><span class="line">        4: invokespecial <span class="comment">#18; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        7: astore_1</span><br><span class="line">        8: new <span class="comment">#19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span></span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial <span class="comment">#21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        24: new <span class="comment">#19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span></span><br><span class="line">        27: dup</span><br><span class="line">        28: invokespecial <span class="comment">#21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        31: astore_1</span><br><span class="line">        32: aload_1</span><br><span class="line">        33: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        36: <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>0～15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表的变量槽中，这些动作实际对应了Java源码中的这两行： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>

<p>接下来的16～21行是关键部分，16和20行的<strong>aload指令</strong>分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为接收者（Receiver）；</p>
<p>17和21行是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）都完全一样，但是这两句指令最终执行的目标方法并不相同。那看来解决问题的关键还必须从invokevirtual指令本身入手，要弄清楚它是如何确定调用方法版本、如何实现多态查找来着手分析才行。根据《Java虚拟机规范》，invokevirtual指令的运行时解析过程[4]大致分为以下几步：</p>
<ol>
<li><strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</strong>。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，<strong>如果通过则返回这个方法的直接引用</strong>，查找过程结束；不通过则返回java.lang.<strong>IllegalAccessError</strong>异常。</li>
<li>否则，按照<strong>继承关系从下往上依次</strong>对C的各个父类进行第二步的<strong>搜索和验证</strong>过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.<strong>AbstractMethodError</strong>异常。</li>
</ol>
<p>正是因为invokevirtual指令执行的<strong>第一步就是在运行期确定接收者的实际类型</strong>，所以两次调用中的invokevirtual指令并<strong>不是把常量池中方法的符号引用解析到直接引用上</strong>就结束了，还会<strong>根据方法接收者的实际类型来选择方法版本</strong>，这个过程就是<strong>Java语言中方法重写的本质</strong>。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为<strong>动态分派。</strong></p>
<p>既然这种多态性的<strong>根源在于虚方法调用指令invokevirtual的执行逻辑</strong>，那自然我们得出的结论就<strong>只会对方法有效，对字段是无效的，因为字段不使用这条指令</strong>。事实上，在Java里面只有虚方法存在，字段永远不可能是虚的，</p>
<p>换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。<strong>当子类声明了与父类同名的字段时</strong>，虽然在子类的内存中两个字段都会存在，但是<strong>子类的字段会遮蔽父类的同名字段</strong>。</p>
<p>为了加深理解，又编撰了一份“劣质面试题式”的代码片段，请阅读代码清单8-10，思考运行后会输出什么结果。</p>
<p>代码清单8-10　字段没有多态性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段不参与多态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHasNoPolymorphic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            money = <span class="number">2</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Father, i have $&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            money = <span class="number">4</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Son,  i have $&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father gay = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">&quot;This gay has $&quot;</span> + gay.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果为: </span><br><span class="line">I am Son,  i have $<span class="number">0</span></span><br><span class="line">I am Son,  i have $<span class="number">4</span></span><br><span class="line">This gay has $<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出两句都是“I am Son”，</p>
<ul>
<li>这是因为Son类在创建的时候，首先隐式调用了<strong>Father的构造函数</strong>，而Father构造函数中<strong>对showMeTheMoney()的调用是一次虚方法调用</strong>，实际执行的版本是Son::showMeTheMoney()方法，所以输出的是“I am Son”，这点经过前面的分析相信读者是没有疑问的了。</li>
<li>而这时候虽然父类的money字段已经被初始化成2了，但Son::showMeTheMoney()方法中访问的却是<strong>子类的money字段</strong>，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。</li>
<li>main()的最后一句<strong>通过静态类型访问到了父类中的money</strong>，输出了2。</li>
</ul>
<p><strong>todo  消化一下</strong></p>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><h5 id="宗量"><a href="#宗量" class="headerlink" title="宗量"></a>宗量</h5><p>方法的接收者与方法的参数统称为方法的<strong>宗量</strong></p>
<p>根据分派基于多少种宗量，可以将分派划分为<strong>单分派</strong>和<strong>多分派</strong>两种。</p>
<p>单分派 是根据<strong>一个宗量对目标进行选择</strong>，</p>
<p>多分派则是根据<strong>多于一个宗量对目标方法进行选择。</strong></p>
<p>代码清单：  单分派和多分派</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果： </span><br><span class="line">    father choose <span class="number">360</span></span><br><span class="line">	son choose qq</span><br></pre></td></tr></table></figure>

<ul>
<li>main（）里调用了两次hardChoice 方法，这两次hardChoice 方法的选择结果在程序输出 中已经显示得很清楚了。 </li>
<li>我们关注得首先是 编译阶段中编译 器的选择过程，也就是静态分派的过程。</li>
<li>选择目标的依据有两点：<ul>
<li>一个是静态类型是 Father 还是SON</li>
<li>二是方法参数是QQ还是360</li>
</ul>
</li>
</ul>
<p>这次选择结果的最终产物是产生了2条invokevirtual 指令，两条指令的参数 分别是常量池中指向 Father:: hardChoice(360)  以及 Father:: hardChoice(QQ)方法的符号引用</p>
<ul>
<li>因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型</li>
</ul>
<h5 id="动态分派的过程"><a href="#动态分派的过程" class="headerlink" title="动态分派的过程"></a>动态分派的过程</h5><p>再看看运行阶段中虚拟机的选择，也就是<strong>动态分派</strong>的过程。</p>
<p>在执行 “son.hardChoice(new QQ()) ” 这行方法时，更准确的说，是在执行这行代码所对应的  Invokevirtual指令时，由于编译期已经决定目标方法的签名 必须为 hardChoice（QQ） ,虚拟机此时 不会关心传递过来的参数 “QQ”到底是 “腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型 都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的接收者的实际类型是 Father 还是 Son 。</p>
<p>因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型 。</p>
<p>根据上述论证的结果，我们可以总结一句： </p>
<p>如今的Java语言是一门静态多分派、动态单分派的语言。</p>
<p>强调”如今的Java语言”是因为这个结论未必会恒久不变。JDK10 时Java语法中新出现 var关键字，</p>
<p>var 是在编译时根据声明语句中赋值符右侧的表达式类型来静态地推断类型。这本质时一种语法糖：</p>
<h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>前面介绍的分派过程，作为对Java虚拟机概念模型的解释基本上已经足够了，它已经解决了虚拟机在分派中“<strong>会做什么</strong>”这问题，但是 问Java虚拟机 “<strong>具体如果做到</strong>” 的，答案则可能因为 各种虚拟机的实现不同会有些差别。</p>
<p>动态分派 是执行非常频繁的动作，而且动态分派的方法版本 选择过程 需要运行时在接收者类型的方法元数据中 选择合适的目标方法，因此Java虚拟机实现基于执行性能的考虑，真实运行时一般不会如此频繁的去反复搜索类型元数据。</p>
<p>面对这种情况，一种基础而且常见的优化手段 是为类型在方法中建一个虚方法表（Virtual Method Table，也称为 vtable），与此对应的，在invokeinterface 执行时也会用到 接口方法表-Interface Method Table，简称itable。 使用虚方法表 索引来代替元数据查找以提高性能。  我们来看看上面代码 所对应的虚方法表结构示例： 如下图所示</p>
<p><img src="/uploads/jvm/11diapatch/methodTable.png"></p>
<p>虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是 一致的，都指向父类的实现入口。</p>
<p>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为 指向子类实现版本的入口地址。</p>
<p>在上图中，son重写了来自 Father的全部方法，因此son的方法表 没有指向Father类型数据的箭头。</p>
<p>但是son 和 Father都没有重写来自Object的方法，所以他们的方法表中所有从Object 继承来的方法都指向了Object的类型数据。</p>
<p>为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中 都应当具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。 <strong>虚方法表一般在类加载的连接阶段进行初始化</strong>，准备了类的变量初始值后，虚拟机 会把 该<strong>类的虚方法表也一同初始化完毕。</strong></p>
<p>上面说的<strong>查虚方法表</strong> 是 <strong>分派调用</strong>的一种<strong>优化手段</strong>，<strong>由于Java对象里面的方法 默认（即不使用final 修饰）就是虚方法</strong>，虚拟机除了使用虚方法表外，为了进一步提高性能，还会使用<strong>类型继承分析（Class Hierarchy Analysis，CHA）</strong> ，<strong>守护内联（Guarded Inlining）</strong>，<strong>内联缓存（Inline Cache）</strong> 等多种非稳定的激进优化来争取更大的性能空间，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">深入理解jvm-10-Java模块化系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-18 23:00:29" itemprop="dateCreated datePublished" datetime="2021-01-18T23:00:29+08:00">2021-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java模块化系统-TODO-DODO"><a href="#Java模块化系统-TODO-DODO" class="headerlink" title="Java模块化系统(TODO DODO)"></a>Java模块化系统(TODO DODO)</h1><p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p>
<ul>
<li>依赖其他模块的列表。</li>
<li>导出的包列表，即其他模块可以使用的列表。</li>
<li>开放的包列表，即其他模块可反射访问模块的列表。</li>
<li>使用的服务列表。</li>
<li>提供服务的实现列表</li>
</ul>
<h2 id="可配置的封装隔离机制"><a href="#可配置的封装隔离机制" class="headerlink" title="可配置的封装隔离机制"></a>可配置的封装隔离机制</h2><ul>
<li>可配置的封装隔离机制首先要解决JDK 9之前基于<strong>类路径（ClassPath）来查找依赖</strong>的可靠性问题。此前，如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常</li>
<li>而在JDK 9以后，如果启用了<strong>模块化进行封装</strong>，模块就可以声明对其他模块的<strong>显式依赖</strong>，这样Java虚拟机就能够在<strong>启动时验证</strong>应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分[1]由于类型依赖而引发的运行时异常</li>
<li>可配置的封装隔离机制还<strong>解决了原来类路径上跨JAR文件的public类型的可访问性问题</strong>。JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更<strong>精细的可访问性控制</strong>，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种<strong>访问控制也主要是在类加载过程中</strong>完成的</li>
</ul>
<h2 id="模块的兼容性"><a href="#模块的兼容性" class="headerlink" title="模块的兼容性"></a>模块的兼容性</h2><ul>
<li>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9提出了与“<strong>类路径</strong>”（ClassPath）相对应的“<strong>模块路径</strong>”（ModulePath）的概念</li>
<li>就是某个类库到底是模块还是传统的JAR包，只取决于<strong>它存放在哪种路径上</strong>。</li>
<li>只要是放在<strong>类路径上的JAR文件</strong>，无论其中是否包含模块化信息（是否包含了module-info.class文件），它都会被当作<strong>传统的JAR包</strong>来对待；</li>
<li>相应地，只要放在<strong>模块路径上的JAR文件</strong>，即使没有使用JMOD后缀，甚至说其中并不包含module-info.class文件，它也仍然会被当作一个<strong>模块</strong>来对待。</li>
</ul>
<h3 id="保障规则："><a href="#保障规则：" class="headerlink" title="保障规则："></a>保障规则：</h3><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上，即使这些版本的JDK已经使用模块来封装了Java SE的标准类库，模块化系统的这套规则也仍然保证了传统程序可以访问到所有标准类库模块中导出的包</p>
<h4 id="JAR文件在类路径的访问规则"><a href="#JAR文件在类路径的访问规则" class="headerlink" title="JAR文件在类路径的访问规则"></a>JAR文件在类路径的访问规则</h4><ul>
<li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li>
</ul>
<h4 id="模块在模块路径的访问规则"><a href="#模块在模块路径的访问规则" class="headerlink" title="模块在模块路径的访问规则"></a>模块在模块路径的访问规则</h4><ul>
<li>模块在模块路径的访问规则：模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</li>
</ul>
<h4 id="JAR文件在模块路径的访问规则"><a href="#JAR文件在模块路径的访问规则" class="headerlink" title="JAR文件在模块路径的访问规则"></a>JAR文件在模块路径的访问规则</h4><ul>
<li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li>
</ul>
<p>以上3条规则保证了即使Java应用依然使用传统的类路径，升级到JDK 9对应用来说几乎（类加载器上的变动还是可能会导致少许可见的影响，将在下节介绍）不会有任何感觉，项目也不需要专门为了升级JDK版本而去把传统JAR包升级成模块。</p>
<p>除了向后兼容性外，随着JDK 9模块化系统的引入，更值得关注的是它本身面临的模块间的管理和兼容性问题：如果同一个模块发行了多个不同的版本，那只能由开发者在编译打包时人工选择好正确版本的模块来保证依赖的正确性。Java模块化系统目前不支持在模块定义中加入版本号来管理和约束依赖，本身也不支持多版本号的概念和版本选择功能。</p>
<p>我们不论是在Java命令、Java类库的API抑或是《Java虚拟机规范》定义的Class文件格式里都能轻易地找到证据，表明模块版本应是编译、加载、运行期间<br>都可以使用的。譬如输入“java–list-modules”，会得到明确带着版本号的模块列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.base@12.0.1</span><br><span class="line">java.compiler@12.0.1</span><br><span class="line">java.datatransfer@12.0.1</span><br><span class="line">java.desktop@12.0.1</span><br><span class="line">java.instrument@12.0.1</span><br><span class="line">java.logging@12.0.1</span><br><span class="line">java.management@12.0.1</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>在JDK 9时加入Class文件格式的<strong>Module属性</strong>，里面有<strong>module_version_index</strong>这样的字段，用户可以在编译时使用“<strong>javac–module-version</strong>”来指定模块版本，在Java类库API中也存在java.lang.module.ModuleDescriptor.Version这样的接口可以在运行时获取到模块的版本号。这一切迹象都证明了<strong>Java模块化系统对版本号的支持本可以不局限在编译期</strong>。</p>
<h2 id="模块化下的类加载器"><a href="#模块化下的类加载器" class="headerlink" title="模块化下的类加载器"></a>模块化下的类加载器</h2><p>为了保证兼容性，JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架构以及双亲委派模型。但是为了模块化系统的顺利施行，模块化下的类加载器仍然发生了一些应该被注意到变动，主要包括以下几个方面。</p>
<h3 id="扩展类加载器被取代"><a href="#扩展类加载器被取代" class="headerlink" title="扩展类加载器被取代"></a>扩展类加载器被取代</h3><ul>
<li>首先，是扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。</li>
<li>这其实是一个很顺理成章的变动，既然整个JDK都基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留**<JAVA_HOME>\lib\ext**目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了，用来加载这部分类库的扩展类加载器也完成了它的历史使命。</li>
<li>类似地，在新版的JDK中也<strong>取消了<JAVA_HOME>\jre</strong>目录，因为随时可以组合构建出程序运行所需的JRE来，譬如假设我们只使用java.base模块中的类型，那么随时可以通过以下命令打包出一个“JRE”：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jlink -p <span class="variable">$JAVA_HOME</span>/jmods --add-modules java.base --output jre</span><br></pre></td></tr></table></figure>

<h3 id="BuiltinClassLoade"><a href="#BuiltinClassLoade" class="headerlink" title="BuiltinClassLoade"></a>BuiltinClassLoade</h3><ul>
<li>其次，平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK 9及更高版本的JDK中崩溃。</li>
<li>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</li>
</ul>
<p><img src="/uploads/jvm/09ClassLoader/01-ClassLoader_before.png"></p>
<p><img src="/uploads/jvm/09ClassLoader/02-ClassLoader_after.png"></p>
<p>图7-6中有“BootClassLoader”存在，启动类加载器现在是在Java虚拟机内部和Java类库共同协作实现的类加载器，尽管有了BootClassLoader这样的Java类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景（譬如Object.class.getClassLoader()）中仍然会返回null来代替，而不会得到BootClassLoader的实例。</p>
<h3 id="类加载的委派关系发生了变动"><a href="#类加载的委派关系发生了变动" class="headerlink" title="类加载的委派关系发生了变动"></a>类加载的委派关系发生了变动</h3><p><img src="source/uploads/jvm/09ClassLoader/03-ClassLoader_Parentnew.png"></p>
<p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。</p>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，也许这可以算是对双亲委派的第四次破坏。</p>
<h4 id="类加载器负责加载的模块"><a href="#类加载器负责加载的模块" class="headerlink" title="类加载器负责加载的模块"></a>类加载器负责加载的模块</h4><h5 id="启动类加载器负责加载的模块"><a href="#启动类加载器负责加载的模块" class="headerlink" title="启动类加载器负责加载的模块"></a>启动类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.base java.security.sasl</span><br><span class="line">java.datatransfer java.xml</span><br><span class="line">java.desktop jdk.httpserver</span><br><span class="line">java.instrument jdk.internal.vm.ci</span><br><span class="line">java.logging jdk.management</span><br><span class="line">java.management jdk.management.agent</span><br><span class="line">java.management.rmi jdk.naming.rmi</span><br><span class="line">java.naming jdk.net</span><br><span class="line">java.prefs jdk.sctp</span><br><span class="line">java.rmi jdk.unsupported</span><br></pre></td></tr></table></figure>



<h5 id="平台类加载器负责加载的模块"><a href="#平台类加载器负责加载的模块" class="headerlink" title="平台类加载器负责加载的模块"></a>平台类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.activation* 					jdk.accessibility</span><br><span class="line">java.compiler* 						jdk.charsets</span><br><span class="line">java.corba* 						jdk.crypto.cryptoki</span><br><span class="line">java.scripting 						jdk.crypto.ec</span><br><span class="line">java.se 							jdk.dynalink</span><br><span class="line">java.se.ee 							jdk.incubator.httpclient</span><br><span class="line">java.security.jgss					jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio 					jdk.jsobject</span><br><span class="line">java.sql 							jdk.localedata</span><br><span class="line">java.sql.rowset						jdk.naming.dns</span><br><span class="line">java.transaction* 					jdk.scripting.nashorn</span><br><span class="line">java.xml.bind* 						jdk.security.auth</span><br><span class="line">java.xml.crypto 					jdk.security.jgss</span><br><span class="line">java.xml.ws* 						jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation* 			jdk.zipfs</span><br></pre></td></tr></table></figure>

<h5 id="应用程序类加载器负责加载的模块"><a href="#应用程序类加载器负责加载的模块" class="headerlink" title="应用程序类加载器负责加载的模块"></a>应用程序类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jdk.aot 						jdk.jdeps</span><br><span class="line">jdk.attach 						jdk.jdi</span><br><span class="line">jdk.compiler 					jdk.jdwp.agent</span><br><span class="line">jdk.editpad 					jdk.jlink</span><br><span class="line">jdk.hotspot.agent 				jdk.jshell</span><br><span class="line">jdk.internal.ed					jdk.jstatd</span><br><span class="line">jdk.internal.jvmstat 			jdk.pack</span><br><span class="line">jdk.internal.le 				jdk.policytool</span><br><span class="line">jdk.internal.opt 				jdk.rmic</span><br><span class="line">jdk.jartool 					jdk.scripting.nashorn.shell</span><br><span class="line">jdk.javadoc 					jdk.xml.bind*</span><br><span class="line">jdk.jcmd 						jdk.xml.ws*</span><br><span class="line">jdk.jconsole</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">深入理解jvm-09-类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-18 20:53:23" itemprop="dateCreated datePublished" datetime="2021-01-18T20:53:23+08:00">2021-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>Java虚拟机设计团队 有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流” 这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 “<strong>类加载器</strong>”（Class Loader）。</p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><ul>
<li>类加载器虽然只用于实现类的加载，但它在Java程序中起到的作用却<strong>远超类加载阶段</strong>。</li>
<li>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的<strong>唯一性</strong>，<strong>每一个类加载器都拥有一个独立的类名称空间</strong>。</li>
<li>比较2个类是否“<strong>相等</strong>”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这2个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这2个类就必定不相等。</li>
<li>这里所说的“相等”，包括了类的Class对象的 equals() 、isAssignableFrom()、 isInstance()方法的返回结果，也包括了使用instanceof 关键字做对象所属关系判断等 各种情况。</li>
<li>下面代码演示了不同的类加载器对instanceof关键字运算的结果的影响</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;org.fenixsoft.jvm.chapter7.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.jvm.chapter7.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter7</span>.<span class="title">ClassLoaderTest</span></span></span><br><span class="line"><span class="class">	<span class="title">false</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码构造了一个简单的类加载器，它可以加载与自己在同意路径下的Class 文件，我们使用这个类加载器去加载了一个名为 “ class org.fenixsoft.jvm.chapter7.ClassLoaderTest” 的类，并实例化了这个类的对象。</li>
<li>todo： 看一下类加载器的源码，如：loadClass（）、defineClass（）等</li>
<li>两行输出结果中，从第一行可以看到这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化出来的，但在第二行的输出中却发现这个对象与类org.fenixsoft.classloading.ClassLoaderTest做所属类型检查的时候返回了false。 </li>
<li> 因为Java虚拟机中同时存在两个 ClassLoaderTest 类，一个是由虚拟机的应用程序类加载器所加载的， 另一个是我们自定义的类加载器加载的，虽然他们都来自于同一个Class文件，但在JVM中仍然是两个互相独立的类，做对象所属类型检查时的结果自然为false。</li>
</ul>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>站在Java 虚拟机的角度来看，只存在2种不同的类加载器：</p>
<ul>
<li> 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器由C++ 语言实现，是虚拟机自身的一部分</li>
<li>另一种就是其他所有的类加载器，这些类加载器都有Java语言实现，独立存在虚拟机外部，全部继承自抽象类 java.lang.ClassLoader</li>
</ul>
<p>站在Java开发人员的角度来看，类加载器应当划分的更细致一些，从JDK1.2以来，Java一直保持 3层类加载器、双亲委派的 类加载架构。</p>
<p>3层类加载器：</p>
<h3 id="启动类加载器（Bootstrap-ClassLoader）："><a href="#启动类加载器（Bootstrap-ClassLoader）：" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）："></a>启动类加载器（Bootstrap ClassLoader）：</h3><ul>
<li>负责加载存放在%JAVA_HOME%\lib 目录，或者被 -Xbootclasspath 参数所指定的路径存放的，而且是Java虚拟机能够识别的（PS：java虚拟机识别是按照文件名识别的，如rt.jar,  tool.jar ，名字不符合类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li>
<li>启动类加载器无法被java程序直接引用，用户在编写自定义的ClassLoader 时，如果需要把加载请求委派给  启动类加载器 去处理，直接使用<strong>null</strong> 代替即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the class loader for the class.  Some implementations may use </span></span><br><span class="line"><span class="comment">    * null to represent the bootstrap class loader. This method will return</span></span><br><span class="line"><span class="comment">    * null in such implementations if this class was loaded by the bootstrap</span></span><br><span class="line"><span class="comment">    * class loader.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; If a security manager is present, and the caller&#x27;s class loader is</span></span><br><span class="line"><span class="comment">    * not null and the caller&#x27;s class loader is not the same as or an ancestor of</span></span><br><span class="line"><span class="comment">    * the class loader for the class whose class loader is requested, then</span></span><br><span class="line"><span class="comment">    * this method calls the security manager&#x27;s &#123;<span class="doctag">@code</span> checkPermission&#125;</span></span><br><span class="line"><span class="comment">    * method with a &#123;<span class="doctag">@code</span> RuntimePermission(&quot;getClassLoader&quot;)&#125;</span></span><br><span class="line"><span class="comment">    * permission to ensure it&#x27;s ok to access the class loader for the class.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this object</span></span><br><span class="line"><span class="comment">    * represents a primitive type or void, null is returned.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the class loader that loaded the class or interface</span></span><br><span class="line"><span class="comment">    *          represented by this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">    *    if a security manager exists and its</span></span><br><span class="line"><span class="comment">    *    &#123;<span class="doctag">@code</span> checkPermission&#125; method denies</span></span><br><span class="line"><span class="comment">    *    access to the class loader for the class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.ClassLoader</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ClassLoader cl = getClassLoader0();</span><br><span class="line">       <span class="keyword">if</span> (cl == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Returns the class loader for the class.  Some implementations may use     <strong>null to represent the bootstrap class loader.</strong> </p>
<p>This method will <strong>return  null in</strong> such implementations if this class was <strong>loaded by the bootstrap  class loader</strong>.</p>
<h3 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h3><ul>
<li><p>这个类加载器时在类 sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。</p>
</li>
<li><p>它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
</li>
<li><p>根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代</p>
</li>
<li><p>由于扩展类加载器是由 Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载 Class文件</p>
</li>
</ul>
<h3 id="应用程序类加载器（Application-Class-Loader）"><a href="#应用程序类加载器（Application-Class-Loader）" class="headerlink" title="应用程序类加载器（Application Class Loader）"></a>应用程序类加载器（Application Class Loader）</h3><ul>
<li>这个类加载器由sun.misc.Launcher$AppClassLoader来实现</li>
<li>由于应用程序类加载器是ClassLoader类中的getSystem- ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。</li>
<li>它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li>
<li>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h3 id="类加载器双亲委派模型"><a href="#类加载器双亲委派模型" class="headerlink" title="类加载器双亲委派模型"></a>类加载器双亲委派模型</h3><p><strong>图7-2　类加载器双亲委派模型</strong></p>
<pre class="mermaid">classDiagram
BootstrapClassLoader <-- ExtensionClassLoader : 父亲
ExtensionClassLoader <-- ApplicationClassLoader : 父亲
ApplicationClassLoader <-- Custom_ClassLoader1 : 父亲
ApplicationClassLoader <-- Custom_ClassLoader2 : 父亲</pre>

<ul>
<li><p>图7-2中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents DelegationModel）”。</p>
</li>
<li><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
</li>
<li><p>不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
</li>
<li><p>类加载器的双亲委派模型在JDK 1.2时期被引入，并被广泛应用于此后几乎所有的Java程序中，但它并不是一个具有强制性约束力的模型，而是Java设计者们推荐给开发者的一种类加载器实现的最佳实践。</p>
</li>
</ul>
<h4 id="双亲委派工作过程"><a href="#双亲委派工作过程" class="headerlink" title="双亲委派工作过程"></a>双亲委派工作过程</h4><ul>
<li>如果一个ClassLoader 收到了 类加载的请求，</li>
<li>它首先不会自己去尝试加载这个类，而是把这个请求委派给 <strong>父类加载器</strong> 去完成，每一个层次的类加载器都是如此，</li>
<li>因此所有的加载请求最终都应该送到最顶层的启动类加载器中，</li>
<li>只有当 父类加载器 反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去完成加载。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li>Java中类随着它的类加载器一起具有了一种带有优先级的层次关系。</li>
<li>例如：类java.lang.Object ，它存放在rt.jar 中，无论哪一个类加载要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器 环境中都能保证时同一个类。</li>
<li>反之 如果没有使用双亲委派模型，都有各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现 多个不同的Object类，Java类型体系中最基础的行为也就无从保证。</li>
</ul>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">	<span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 在父类加载器无法加载时</span></span><br><span class="line">	<span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑清晰易懂：</p>
<ul>
<li><p>先检查请求加载的类型是否已经被加载过，</p>
<ul>
<li><p>若没有则调用父加载器的loadClass()方法，</p>
</li>
<li><p>若父加载器为空则默认使用启动类加载器作为父加载器。</p>
</li>
</ul>
</li>
<li><p>假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
</li>
</ul>
<h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<h3 id="第一次破坏双亲委派"><a href="#第一次破坏双亲委派" class="headerlink" title="第一次破坏双亲委派"></a>第一次破坏双亲委派</h3><ul>
<li>第一次 “被破坏”其实发生在<strong>双亲委派模型出现之前</strong>——即JDK 1.2面世以前的“远古”时代。</li>
<li>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了<strong>兼容这些已有代码</strong>，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个<strong>新的protected方法findClass()**，并</strong>引导用户编写的类加载逻辑时尽可能去重写这个方法**，而不是在loadClass()中编写代码。</li>
<li>我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</li>
</ul>
<h3 id="第二次破坏双亲委派"><a href="#第二次破坏双亲委派" class="headerlink" title="第二次破坏双亲委派"></a>第二次破坏双亲委派</h3><ul>
<li>第二次“被破坏”是由这个模型自身的缺陷导致的，</li>
<li>双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，</li>
<li>但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</li>
<li>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</li>
<li>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内<br>都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>
<li>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种<strong>父类加载器去请求子类加载器完成类加载</strong>的行为，这种行为实际上是打通了双亲委派模型的层次结构来<strong>逆向使用类加载器</strong>，已经<strong>违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了<strong>java.util.ServiceLoader类</strong>，以<strong>META-INF/services</strong>中的配置信息，<strong>辅以责任链模式</strong>，这才算是给SPI的加载提供了一种相对合理的解决方案。</li>
</ul>
<h3 id="第三次破坏双亲委派"><a href="#第三次破坏双亲委派" class="headerlink" title="第三次破坏双亲委派"></a>第三次破坏双亲委派</h3><ul>
<li>第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：<strong>代码热替换</strong>（<strong>Hot Swap</strong>）、<strong>模块热部署</strong>（<strong>Hot Deployment</strong>）等。</li>
<li>说白了就是希望Java应用程序能像我们的电脑外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用关机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是大型系统或企业级软件开发者具有很大的吸引力。</li>
</ul>
<h3 id="OSGi实现热部署原理"><a href="#OSGi实现热部署原理" class="headerlink" title="OSGi实现热部署原理"></a>OSGi实现热部署原理</h3><p>OSGi实现模块化热部署的关键是它<strong>自定义的类加载器机制</strong>的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把<strong>Bundle连同类加载器一起换掉</strong>以实现代码的热替换。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以java.*开头的类，委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>上面的查找顺序中只有<strong>开头两点仍然符合双亲委派模型</strong>的原则，其余的类查找都是在<strong>平级的类加载器</strong>中进行的。</p>
<p>虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。</p>
<p><strong>只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新</strong>。</p>
<p>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">深入理解jvm-08-虚拟机类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-14 20:34:10" itemprop="dateCreated datePublished" datetime="2021-01-14T20:34:10+08:00">2021-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机的类加载机制：</p>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<p>在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载稍微增加一些性能开销，</p>
<p>但是却为了Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接的特点实现的。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期都将会经历 加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。 这7个阶段的发生顺序为:</p>
<p><img src="/uploads/jvm/08ClassLoading/01ClassLoadingLifecircle.png"></p>
<ul>
<li>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，</li>
<li>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</li>
<li>请注意，是按部就班地<strong>“开始”</strong>，而不是按部就班地“进行”或按部就班地<strong>“完成”</strong>，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</li>
</ul>
<h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，</p>
<p>这六种场景中的行为称为对一个类型进行主动引用。</p>
<p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p>
<p>下面举三个例子来说明何为被动引用，分别见代码清单7-1、代码清单7-2和代码清单7-3。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><h4 id="通过子类引用父类的静态字段，不会导致子类初始化"><a href="#通过子类引用父类的静态字段，不会导致子类初始化" class="headerlink" title="通过子类引用父类的静态字段，不会导致子类初始化"></a>通过子类引用父类的静态字段，不会导致子类初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示一：</span></span><br><span class="line"><span class="comment">* 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">SuperClass init!</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。</p>
</li>
<li><p>对于静态字段，只有<strong>直接定义这个字段的类</strong>才会被初始化，因此<strong>通过其子类来引用父类中定义的静态字段</strong>，只会<strong>触发</strong><br><strong>父类的初始化</strong>而不会触发子类的初始化。</p>
</li>
<li><p>至于是否要触发子类的加载和验证阶段，在《Java虚拟机规范》中并未明确规定，所以这点取决于虚拟机的具体实现。对于HotSpot虚拟机来说，可通过-XX：+TraceClassLoading参数观察到此操作是会导致子类加载的。</p>
</li>
</ul>
<h4 id="通过数组定义来引用类，不会触发此类的初始化"><a href="#通过数组定义来引用类，不会触发此类的初始化" class="headerlink" title="通过数组定义来引用类，不会触发此类的初始化"></a>通过数组定义来引用类，不会触发此类的初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被动使用类字段演示二：</span><br><span class="line"> * 通过数组定义来引用类，不会触发此类的初始化</span><br><span class="line"> **/</span><br><span class="line">public class NotInitialization_2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SuperClass[] sca = new SuperClass[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 javap -verbose NotInitialization_2.class</span><br><span class="line">&#123;</span><br><span class="line">  public org.fenixsoft.jvm.chapter7.NotInitialization_2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lorg/fenixsoft/jvm/chapter7/NotInitialization_2;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: anewarray     <span class="comment">#2                  // class org/fenixsoft/jvm/chapter7/SuperClass</span></span><br><span class="line">         5: astore_1</span><br><span class="line">         6: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 6</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  args   [Ljava/lang/String;</span><br><span class="line">            6       1     1   sca   [Lorg/fenixsoft/jvm/chapter7/SuperClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行之后发现没有输出“SuperClassinit！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。</p>
</li>
<li><p>但是这段代码里面触发了另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是<br>一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</p>
</li>
<li><p>这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里</p>
</li>
</ul>
<h4 id="常量在编译阶段会存入调用类的常量池中"><a href="#常量在编译阶段会存入调用类的常量池中" class="headerlink" title="常量在编译阶段会存入调用类的常量池中"></a>常量在编译阶段会存入调用类的常量池中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示三：</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行之后，也没有输出“ConstClass init！”，、</p>
</li>
<li><p>这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在编译阶段通过*<strong>常量传播优化**<em>，已经将此常量的值“helloworld”直接存储在NotInitialization类的</em></strong>常量池*<strong>中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类</strong>对自身常量池的引用**了</p>
</li>
<li><p>也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class文件后就已不存在任何联系了。</p>
</li>
</ul>
<h2 id="接口的加载过程"><a href="#接口的加载过程" class="headerlink" title="接口的加载过程"></a>接口的加载过程</h2><ul>
<li>接口的加载过程与类加载过程稍有不同，</li>
<li>针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，</li>
<li>而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[2]，用于初始化接口中所定义的成员变量。</li>
<li>接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：<br>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><ul>
<li><p>“<strong>加载</strong>”（Loading）阶段是整个“<strong>类加载</strong>”（Class Loading）过程中的一个阶段，</p>
</li>
<li><p>希望没有混淆这两个看起来很相似的名词。在加载阶段，Java虚拟机需要完成以下三件事情：</p>
</li>
</ul>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<ul>
<li><p>《Java虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与Java应用的灵活度都是相当大的。</p>
</li>
<li><p>例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。仅仅这一点空隙，Java虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台。例如：</p>
<ol>
<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是Web Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</li>
<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
<li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li>
</ol>
</li>
<li><p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p>
</li>
<li><p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的</p>
</li>
<li><p>但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p>
<ol>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>
</ol>
</li>
</ul>
<ul>
<li><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在**<em>方法区**</em>之中了（<strong>平安面试遇到过，编译后的数据放在哪个内存区域</strong>（<strong>方法区</strong>））</p>
</li>
<li><p>类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
</li>
<li><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><ul>
<li><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
</li>
<li><p>因为使用纯粹的java语言是可以拦截一些异常的，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果尝试这样去做了，编译器会毫不留情地抛出异常、拒绝编译。</p>
</li>
<li><p>但是 Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。上述Java代码无法做到的事情在字节码层面上都是可以实现的，至少语义上是可以表达出来的</p>
</li>
<li><p>所以 Java虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是Java虚拟机保护自身的一项必要措施。</p>
</li>
<li><p>验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重</p>
</li>
</ul>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
<li>and so on …</li>
</ul>
<p>验证阶段的主要目的是保证输入的<strong>字节流</strong>能<strong>正确地解析并存储于方法区</strong>之内，格式上符合描述一个Java类型信息的要求。</p>
<p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，</p>
<p>所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方<br>法重载，例如方法参数都一致，但返回值类型却不同等）</li>
<li>and so on … </li>
</ul>
<p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，</p>
<p>主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p>在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的</li>
<li> and so on …</li>
</ul>
<p>如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再严密的检查，也依然不能保证这一点。</p>
<p>这里涉及了离散数学中一个很著名的问题——“停机问题”（Halting Problem）[2]，即不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p>
<p>在我们讨论字节码校验的上下文语境里，通俗一点的解释是通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在Bug。</p>
<h5 id="Ps"><a href="#Ps" class="headerlink" title="Ps:"></a>Ps:</h5><ul>
<li>由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行</li>
<li>具体做法是给方法体Code属性的属性表中新增加了一项名为“<strong>StackMapTable</strong>”的新属性，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，</li>
<li>在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。这样就将字节码验证的<strong>类型推导</strong>转变为<strong>类型检查</strong>，从而节省了大量校验时间</li>
</ul>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，</p>
<p>这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，</p>
<p>通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>本阶段通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当前类访问。</li>
<li>and so on …</li>
</ul>
<p>符号引用验证的主要目的是确保解析行为能正常执行，</p>
<p>如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：<br>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<h5 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h5><p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><ul>
<li><p>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）<strong>分配内存并设置类变量初始值</strong>的阶段，</p>
</li>
<li><p>从概念上讲，这些变量所使用的内存都应当在<strong>方法区</strong>中进行分配，但必须注意到方法区本身是一个逻辑上的区域，</p>
</li>
<li><p>在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；</p>
</li>
<li><p>而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了，</p>
</li>
</ul>
<p>关于准备阶段，还有两个容易产生混淆的概念需要着重强调，</p>
<ul>
<li><p>首先是这时候进行内存分配的仅包括<strong>类变量</strong>，而不包括实例变量，</p>
</li>
<li><p>实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li><p>其次是这里所说的<strong>初始值</strong>“<strong>通常情况</strong>”下是<strong>数据类型的零值</strong>，</p>
</li>
<li><p>假设一个类变量的定义为：public static int value = 123;</p>
</li>
<li><p>那变量value在准备阶段过后的<strong>初始值为0</strong>而不是123，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于<strong>类构造器</strong><clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</p>
</li>
</ul>
<p><strong>基本数据类型的零值</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“<strong>特殊情况</strong>”：如果类字段的字段属性表中存在<strong>ConstantValue</strong>属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，假设上面类变量value的定义修改为：</p>
<p>public static final int value = 123;</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据Con-stantValue的设置<br>将value赋值为123。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p>在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p>
<h4 id="符号引用-Symbolic-References"><a href="#符号引用-Symbolic-References" class="headerlink" title="符号引用(Symbolic References):"></a>符号引用(Symbolic References):</h4><ul>
<li><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
</li>
<li><p>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，</p>
</li>
<li><p>但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p>
</li>
</ul>
<h4 id="直接引用（Direct-References）："><a href="#直接引用（Direct-References）：" class="headerlink" title="直接引用（Direct References）："></a>直接引用（Direct References）：</h4><ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
<li>直接引用是和虚拟机实现的内存布局直接相关的，</li>
<li>同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li>
<li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p>
<p>所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引<br>用将要被使用前才去解析它。</p>
<p>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>这7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CON-STANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、<br>CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型</p>
<p>后4种(CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info)，它们都和动态语言支持密切相关</p>
<h4 id="4-1-类或接口的解析"><a href="#4-1-类或接口的解析" class="headerlink" title="4.1 类或接口的解析"></a>4.1 类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个<strong>从未解析过的符号引用N</strong>解析为一个<strong>类或接口C的直接引用</strong>，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<ol>
<li><p>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</p>
</li>
<li><p>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</p>
</li>
<li><p>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，<br>但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p>
</li>
</ol>
<p>针对上面第3点访问权限验证，在JDK 9引入了模块化以后，一个public类型也不再意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。</p>
<p>如果我们说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p>
<ul>
<li>被访问类C是public的，并且与访问类D处于同一个模块。</li>
<li>被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问</li>
<li>被访问类C不是public的，但是它与访问类D处于同一个包中</li>
</ul>
<h4 id="4-2-字段解析"><a href="#4-2-字段解析" class="headerlink" title="4.2 字段解析"></a>4.2 字段解析</h4><p>要解析一个未被解析过的字段符号引用，</p>
<ul>
<li><p>首先将会对字段表内class_index[3]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。</p>
<ul>
<li><p>如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。</p>
</li>
<li><p>如果解析成功完成，那把这个字段所属的类或接口用C表示，</p>
</li>
</ul>
</li>
</ul>
<p>《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：</p>
<ol>
<li><p>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</p>
</li>
</ol>
<p> 如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<p>如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac编译器就可能直接拒绝其编译为Class文件。</p>
<p>在代码清单7-4中演示了这种情况，如果注释了Sub类中的“public static int A=4；”，接口与父类同时存在字段A，那Oracle公司实现的Javac编译器将提示“<strong>The field Sub.A is ambiguous</strong>”，并且会拒绝编译这段代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class FieldResolution &#123;</span><br><span class="line"></span><br><span class="line">    interface Interface0 &#123;</span><br><span class="line">        int A = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Interface1 extends Interface0 &#123;</span><br><span class="line">        int A = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Interface2 &#123;</span><br><span class="line">        int A = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Parent implements Interface1 &#123;</span><br><span class="line">        public static int A = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Sub extends Parent implements Interface2 &#123;</span><br><span class="line">        public static int A = 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/uploads/jvm/08ClassLoading/02-analysisError.png"></p>
<h4 id="4-3-方法解析"><a href="#4-3-方法解析" class="headerlink" title="4.3 方法解析"></a>4.3 方法解析</h4><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index[4]项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，</p>
<p>接下来虚拟机将会按照如下步骤进行后续的方法搜索：(TODO 不是很理解，回头看 <strong>字节码结构</strong>)</p>
<p>ps :简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</p>
<ol>
<li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li>
</ol>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此<br>方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h4 id="4-4-接口方法解析"><a href="#4-4-接口方法解析" class="headerlink" title="4.4 接口方法解析"></a>4.4 接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，</p>
<p>如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<ol>
<li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法,但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<p>在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。</p>
<p>但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常。</p>
<p>[1] invokedynamic指令是在JDK 7时加入到字节码中的，当时确实只为了做动态语言（如JRuby、<br>Scala）支持，Java语言本身并不会用到它。而到了JDK 8时代，Java有了Lambda表达式和接口的默认方<br>法，它们在底层调用时就会用到invokedynamic指令，这时再提动态语言支持其实已不完全切合，我们<br>就只把它当个代称吧。笔者将会在第8章中介绍这部分内容。<br>[2] 严格来说，CONSTANT_String_info这种类型的常量也有解析过程，但是很简单而且直观，不再做<br>独立介绍。<br>[3] 参见第6章中关于CONSTANT_Fieldref_info常量的相关内容。<br>[4] 参见第6章关于CONSTANT_Methodref_info常量的相关内容。<br>[5] 参见第6章中关于CONSTANT_InterfaceMethodref_info常量的相关内容。</p>
<h3 id="5-初始化-应用程序发挥作用-clinit"><a href="#5-初始化-应用程序发挥作用-clinit" class="headerlink" title="5.初始化(应用程序发挥作用 clinit)"></a>5.初始化(应用程序发挥作用 clinit)</h3><p>类的初始化阶段是类加载过程的最后一个步骤，</p>
<p>之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全<strong>由Java虚拟机来主导控制</strong>。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将<strong>主导权移交给应用程序</strong>。</p>
<p>进行<strong>准备阶段</strong>时，变量已经赋过一次系统要求的<strong>初始零值</strong>，而在<strong>初始化阶段</strong>，则会根据程序员通过<strong>程序编码</strong>制定的主观计划去初始化类变量和其他资源。</p>
<p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及<clinit>()方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作[1]。</p>
<p><clinit>()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块</strong>（static{}块）中的语句合并产生的，</p>
<p><strong>编译器收集的顺序</strong>是由语句在源文件中<strong>出现的顺序</strong>决定的，静态语句块中只能访问到<strong>定义在静态语句块之前</strong>的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如代码清单7-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">        System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值<br>操作，如代码清单7-6中，字段B的值将会是2而不是1。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test01 &#123;</span><br><span class="line">    static class Parent &#123;</span><br><span class="line">        public static int A = 1;  //step1</span><br><span class="line">        static &#123;</span><br><span class="line">            A = 2; //step2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Sub extends Parent &#123;</span><br><span class="line">        public static int B = A; //step3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： 2</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</p>
</li>
<li><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，</p>
<ul>
<li>如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等<br>待，直到活动线程执行完毕<clinit>()方法。</li>
</ul>
</li>
<li><p>如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞[2]，在实际应用中这种阻塞往往是很隐蔽的。</p>
<p>  代码清单7-7演示了这种场景。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不加上这个if语句，编译器将提示“Initializer does not complete normally”并拒绝编译</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;init DeadLoopClass&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下，一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待：</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]init DeadLoopClass</span><br></pre></td></tr></table></figure>

<p>[2] 需要注意，其他线程虽然会被阻塞，但如果执行＜clinit＞()方法的那条线程退出＜clinit＞()方法后，其他线程唤醒后则不会再次进入＜clinit＞()方法。同一个类加载器下，一个类型只会被初始化一次。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">深入理解jvm-07-字节码指令简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-13 22:48:01" itemprop="dateCreated datePublished" datetime="2021-01-13T22:48:01+08:00">2021-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h1><ul>
<li>Java虚拟机的指令 由一个字节长度的，代表着某种特定操作含义的数字（称为操作码，<strong>Opcode</strong>） 以及零至多个代表操作所需参数（称为操作数，<strong>Operand</strong>）构成。</li>
<li>由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码Opcode，指令参数Operand都存放在操作数栈中</li>
<li>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构</li>
<li>由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条</li>
<li>又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构</li>
<li>这种操作在某种程度上会导致解释执行字节码时将损失一些性能，但这样做的优势也同样明显：</li>
<li><ul>
<li>放弃了操作数长度对齐[1]，就意味着可以省略掉大量的填充和间隔符号；</li>
<li>用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JVM解释器 最基本执行模型伪代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	自动计算PC寄存器的值+1；</span><br><span class="line">	根据PC寄存器指示的位置，从字节码流中取出操作码；</span><br><span class="line">	<span class="keyword">if</span>(字节码存在操作数)&#123;</span><br><span class="line">		从字节码流中取出操作数；</span><br><span class="line">	&#125;</span><br><span class="line">	执行操作码所定义的操作；</span><br><span class="line">&#125;<span class="keyword">while</span>（字节码流长度&gt;0）</span><br></pre></td></tr></table></figure>



<h2 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h2><h3 id="字节码指令："><a href="#字节码指令：" class="headerlink" title="字节码指令："></a>字节码指令：</h3><ul>
<li>在Java虚拟机的指令集中，<strong>大多数</strong>指令都包含<strong>其操作所对应的数据类型信息</strong>。举个例子，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据</li>
<li>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference</li>
<li>也有一些指令的助记符中<strong>没有明确指明操作类型的字母</strong>，例如arraylength指令，它没有代表数据类型的特殊字符</li>
<li>还有另外一些指令，例如无条件跳转指令goto则是<strong>与数据类型无关的指令</strong></li>
<li>因为Java虚拟机的<strong>操作码长度只有一字节</strong>，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力</li>
<li>如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么指令的数量恐怕就会超出一字节所能表示的数量范围了</li>
<li>因此，Java虚拟机的指令集<strong>对于特定的操作只提供了有限的类型相关指令去支持它</strong></li>
<li>换句话说，指令集将会被故意设计成非完全独立的（<strong>Not Orthogonal</strong>）</li>
</ul>
<ul>
<li>表6-40列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。</li>
<li>如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。</li>
<li>例如load指令有操作int类型的iload，但是没有操作byte类型的同类指令。</li>
</ul>
<p><img src="/uploads/jvm/07ByteOpCond/01-opcode-01.png"></p>
<p><img src="/uploads/jvm/07ByteOpCond/02-opcode-02.png"></p>
<h3 id="总结上图指令集："><a href="#总结上图指令集：" class="headerlink" title="总结上图指令集："></a>总结上图指令集：</h3><p>从表6-40中看来，</p>
<ul>
<li><p>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。</p>
</li>
<li><p>编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，</p>
</li>
<li><p>将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。</p>
</li>
<li><p>与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p>
</li>
<li><p>因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</p>
</li>
<li><p>阅读字节码作为了解Java虚拟机的基础技能，是一项应当熟练掌握的能力。</p>
</li>
</ul>
<h3 id="字节码操作按用途分类："><a href="#字节码操作按用途分类：" class="headerlink" title="字节码操作按用途分类："></a>字节码操作按用途分类：</h3><p>笔者将字节码操作按用途大致分为9类，下面按照分类来为读者概略介绍这些指令的用法。</p>
<h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之间来回传输，这类指令包括：</p>
<ul>
<li>将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n></li>
<li>将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n></li>
<li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></li>
<li>扩充局部变量表的访问索引的指令：wide</li>
</ul>
<p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>），这些指令助记符实际上代表了一组指令（例如iload_<n>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。</p>
<p>这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p>
<p>除了这点不同以外，它们的语义与原生的通用指令是完全一致的（例如iload_0的语义与操作数为0时的iload指令语义完全一致</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// Java源码</span><br><span class="line">public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">    int x;</span><br><span class="line">    try &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">    	<span class="built_in">return</span> x;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    	x = 2;</span><br><span class="line">   	 	<span class="built_in">return</span> x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	x = 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后的ByteCode字节码及异常表</span><br><span class="line">public int inc();</span><br><span class="line">    Code:</span><br><span class="line">        Stack=1, Locals=5, Args_size=1</span><br><span class="line">            0: iconst_1 // try块中的x=1  (将常量1加载到操作数栈)</span><br><span class="line">            1: istore_1  //（将1 从操作数栈存储到局部变量表）</span><br><span class="line">            2: iload_1 // 保存x到returnValue中，此时x=1  （将局部变量 加载到操作数栈）</span><br><span class="line">            3: istore   4  将操作数栈 存储到局部变量表</span><br><span class="line">            5: iconst_3 // finaly块中的x=3</span><br><span class="line">            6: istore_1</span><br><span class="line">            7: iload     4 // 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            9: ireturn</span><br><span class="line">            10: astore_2 // 给catch中定义的Exception e赋值，存储在变量槽 2中</span><br><span class="line">            11: iconst_2 // catch块中的x=2</span><br><span class="line">            12: istore_1</span><br><span class="line">            13: iload_1 // 保存x到returnValue中，此时x=2</span><br><span class="line">            14: istore    4</span><br><span class="line">            16: iconst_3 // finaly块中的x=3</span><br><span class="line">            17: istore_1</span><br><span class="line">            18: iload      4 // 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            20: ireturn</span><br><span class="line">            21: astore_3 // 如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</span><br><span class="line">            22: iconst_3 // finaly块中的x=3</span><br><span class="line">            23: istore_1</span><br><span class="line">            24: aload_3 // 将异常放置到栈顶，并抛出</span><br><span class="line">            25: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">    from to target <span class="built_in">type</span></span><br><span class="line">        0 5 10 Class java/lang/Exception</span><br><span class="line">        0 5 21 any</span><br><span class="line">        10 16 21 any</span><br></pre></td></tr></table></figure>



<h4 id="运算指令："><a href="#运算指令：" class="headerlink" title="运算指令："></a>运算指令：</h4><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<p>大体上运算指令可以分为两种：</p>
<ul>
<li>对整型数据进行运算的指令</li>
<li>对浮点型数据进行运算的指令</li>
</ul>
<ol>
<li>整数与浮点数的算术指令在<strong>溢出</strong> 和<strong>被零除</strong>的时候也有各自不同的行为表现 </li>
<li>无论是哪种算术指令，均是使用Java虚拟机的算术类型来进行计算的，</li>
<li>换句话说是不存在直接支持byte、short、char和boolean类型的算术指令，</li>
</ol>
<h5 id="int-指令："><a href="#int-指令：" class="headerlink" title="int 指令："></a>int 指令：</h5><p>对于上述几种数据的运算，应使用操作int类型的指令代替。所有的算术指令包括：</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem</li>
<li>取反指令：ineg、lneg、fneg、dneg</li>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
<li>局部变量自增指令：iinc</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li>
</ul>
<h5 id="运算溢出问题："><a href="#运算溢出问题：" class="headerlink" title="运算溢出问题："></a>运算溢出问题：</h5><ul>
<li>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象，对于程序员来说是很容易理解的，</li>
<li>但其实《Java虚拟机规范》中并没有明确定义过整型数据溢出具体会得到什么计算结果，仅规定了在处理整型数据时，</li>
<li>只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，</li>
<li>其余任何整型数运算场景都不应该抛出运行时异常</li>
</ul>
<h5 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题:"></a>浮点数精度问题:</h5><ul>
<li>《Java虚拟机规范》要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754规范中所规定行为和限制，也就是说Java虚拟机必须完全支持IEEE 754中定义的“非正规浮点数值”（DenormalizedFloating-Point Number）和“逐级下溢”（Gradual Underflow）的运算规则。这些规则将会使某些数值算法处理起来变得明确，不会出现模棱两可的困境</li>
<li>以上规则要求Java虚拟机在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值；</li>
<li>如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的</li>
<li>这种舍入模式也是IEEE 754规范中的默认舍入模式，称为向最接近数舍入模式</li>
<li>而在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近，但是不大于原值的数字来作为最精确的舍入结果。</li>
<li>Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一种运算信号），</li>
<li>当一个操作产生溢出时，将会使用有符号的无穷大来表示；</li>
<li>如果某个操作结果没有明确的数学定义的话，将会使用NaN（Not a Number）值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</li>
</ul>
<h5 id="long类型与浮点数值比较原则："><a href="#long类型与浮点数值比较原则：" class="headerlink" title="long类型与浮点数值比较原则："></a>long类型与浮点数值比较原则：</h5><ul>
<li><p>在对long类型数值进行比较时，Java虚拟机采用带符号的比较方式，</p>
</li>
<li><p>而对浮点数值进行比较时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（NonsignalingComparison）方式进行。</p>
</li>
</ul>
<h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<h5 id="宽化类型转换（WideningNumeric-Conversion）"><a href="#宽化类型转换（WideningNumeric-Conversion）" class="headerlink" title="宽化类型转换（WideningNumeric Conversion）"></a>宽化类型转换（WideningNumeric Conversion）</h5><p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（WideningNumeric Conversion，即小范围类型向大范围类型的安全转换）：</p>
<ul>
<li>int类型到long、float或者double类型</li>
<li>long类型到float、double类型</li>
<li>float类型到double类型</li>
</ul>
<h5 id="窄化类型转换（Narrowing-Numeric-Conversion）"><a href="#窄化类型转换（Narrowing-Numeric-Conversion）" class="headerlink" title="窄化类型转换（Narrowing Numeric Conversion）"></a>窄化类型转换（Narrowing Numeric Conversion）</h5><p>处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。</p>
<p>窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p>
<ul>
<li>在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。对于了解计算机数值存储和表示的程序员来说这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N字节的首位了。</li>
</ul>
<h6 id="浮点型转整形（int、long）"><a href="#浮点型转整形（int、long）" class="headerlink" title="浮点型转整形（int、long）"></a>浮点型转整形（int、long）</h6><p>Java虚拟机将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，必须遵循以下转换规则：</p>
<ul>
<li>如果浮点值是NaN，那转换结果就是int或long类型的0。</li>
<li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在目标类型T（int或long）的表示范围之类，那转换结果就是v；</li>
<li>否则，将根据v的符号，转换为T所能表示的最大或者最小正数。</li>
</ul>
<h6 id="Double转float"><a href="#Double转float" class="headerlink" title="Double转float"></a>Double转float</h6><ul>
<li>从double类型到float类型做窄化转换的过程与IEEE 754中定义的一致，通过IEEE 754向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。</li>
<li>如果转换结果的绝对值太小、无法使用float来表示的话，将返回float类型的正负零；</li>
<li>如果转换结果的绝对值太大、无法使用float来表示的话，将返回float类型的正负无穷大。</li>
<li>对于double类型的NaN值将按规定转换为float类型的NaN值。</li>
</ul>
<h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。</p>
<p>对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p>
<ul>
<li>创建类实例的指令：new</li>
<li>创建数组的指令：newarray、anewarray、multianewarray</li>
<li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore</li>
<li>取数组长度的指令：arraylength</li>
<li>检查类实例类型的指令：instanceof、checkcast</li>
</ul>
<h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li>
<li>将栈最顶端的两个数值互换：swap</li>
</ul>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，</p>
<p>从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。</p>
<p>控制转移指令包括：</p>
<ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li>
<li>复合条件分支：tableswitch、lookupswitch</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li>
</ul>
<p>在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否null，也有专门的指令用来检测null值。</p>
<ul>
<li>对于boolean类型、byte类型、char类型和short类型的条件分支比较操作，都使用int类型的比较指令来完成</li>
<li>对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，），运算<br>指令会**<em>返回一个整型值**</em>到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。</li>
<li>由于**<em>各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便、完善就显得尤为重要，而Java虚拟机提供的**</em>int类型的条件分支指令是最为丰富、强大的。</li>
</ul>
<h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4><p>方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下五条指令用于方法调用：</p>
<ul>
<li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li>
<li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li>
<li>invokestatic指令：用于调用类静态方法（static方法）。</li>
<li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法</li>
</ul>
<p>前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</p>
<ul>
<li>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的</li>
<li>包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。</li>
</ul>
<h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，</p>
<p>《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成。</p>
<h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p>
<h5 id="方法级同步："><a href="#方法级同步：" class="headerlink" title="方法级同步："></a>方法级同步：</h5><ul>
<li>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。</li>
<li>虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。</li>
<li>当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，<ul>
<li>如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。</li>
</ul>
</li>
<li>在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。<ul>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</li>
</ul>
</li>
</ul>
<h5 id="方法内指令级同步："><a href="#方法内指令级同步：" class="headerlink" title="方法内指令级同步："></a>方法内指令级同步：</h5><ul>
<li>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，</li>
<li>Java虚拟机的指令集中有 <strong><em>monitorenter</em></strong> 和 <strong><em>monitorexit</em></strong> 两条指令来支持synchronized关键字的语义，</li>
<li>正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，</li>
<li>譬如有代码清单6-6所示的代码。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 代码清单6-6　代码同步演示</span><br><span class="line"></span><br><span class="line">void onlyMe(Foo f) &#123;</span><br><span class="line">    synchronized(f) &#123;</span><br><span class="line">    	doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译后，这段代码生成的字节码序列如下：</span><br><span class="line">Method void onlyMe(Foo)</span><br><span class="line">0 aload_1          // 将对象f入栈</span><br><span class="line">1 dup 　　          // 复制栈顶元素（即f的引用）</span><br><span class="line">2 astore_2         // 将栈顶元素存储到局部变量表变量槽 2中</span><br><span class="line">3 monitorenter     // 以栈定元素（即f）作为锁，开始同步</span><br><span class="line">4 aload_0          // 将局部变量槽 0（即this指针）的元素入栈</span><br><span class="line">5 invokevirtual <span class="comment">#5 // 调用doSomething()方法</span></span><br><span class="line">8 aload_2           // 将局部变量Slow 2的元素（即f）入栈</span><br><span class="line">9 monitorexit       // 退出同步</span><br><span class="line">10 goto 18          // 方法正常结束，跳转到18返回</span><br><span class="line">13 astore_3         // 从这步开始是异常路径，见下面异常表的Taget 13</span><br><span class="line">14 aload_2          // 将局部变量Slow 2的元素（即f）入栈</span><br><span class="line">15 monitorexit      // 退出同步</span><br><span class="line">16 aload_3          // 将局部变量Slow 3的元素（即异常对象）入栈</span><br><span class="line">17 athrow 			// 把异常对象重新抛出给onlyMe()方法的调用者</span><br><span class="line">18 <span class="built_in">return</span> 			// 方法正常返回</span><br><span class="line">Exception table:</span><br><span class="line">FromTo Target Type</span><br><span class="line">4 10 13 any</span><br><span class="line">13 16 13 any</span><br></pre></td></tr></table></figure>



<ul>
<li>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</li>
<li>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</li>
</ul>
<h3 id="公有设计，私有实现"><a href="#公有设计，私有实现" class="headerlink" title="公有设计，私有实现"></a>公有设计，私有实现</h3><p>《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：<strong>Class文件格式</strong>以及 <strong>字节码指令集</strong></p>
<p>任何一款Java虚拟机实现都必须能够**<em>读取Class文件并精确实现**</em>包含在其中的Java虚拟机代码的语义。拿着《Java虚拟机规范》一成不变地逐字实现其中要求的内容当然是一种可行的途径，</p>
<p>但一个优秀的虚拟机实现，在满足《Java虚拟机规范》的约束下对具体实现做出修改和优化也是完全可行的，</p>
<p>并且《Java虚拟机规范》中明确鼓励实现者这样去做。只要优化以后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整保持，那实现者就可以选择以任何方式去实现这些语义，</p>
<p>虚拟机在后台如何处理Class文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可[1]。</p>
<p>虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么，虚拟机实现的方式主要有以下两种：</p>
<ul>
<li>将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集；</li>
<li>将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即即时编译器代码生成技术）。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">深入理解jvm-06-类文件结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-11 22:03:21" itemprop="dateCreated datePublished" datetime="2021-01-11T22:03:21+08:00">2021-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><h3 id="平台无关性："><a href="#平台无关性：" class="headerlink" title="平台无关性："></a>平台无关性：</h3><ul>
<li>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石</li>
</ul>
<h3 id="语言无关性："><a href="#语言无关性：" class="headerlink" title="语言无关性："></a>语言无关性：</h3><ul>
<li>Java技术发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，</li>
<li>他们在发布规范文档的时候，也刻意把Java的规范拆分成了：</li>
<li><strong><em>《Java语言规范》（The Java Language Specification）</em></strong></li>
<li><strong><em>及《Java虚拟机规范》（The Java Virtual Machine Specification）</em></strong></li>
</ul>
<p><strong><em>在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上”</em></strong><br><strong><em>（In the future，we will consider bounded extensions to the Java virtual machine to provide better support for other languages）</em></strong></p>
<ul>
<li><strong><em>作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，以Class文件作为他们产品的交付媒介。</em></strong></li>
</ul>
<p>例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把它们的源程序代码编译成Class文件。虚拟机丝毫不关心Class的来源是什么语言</p>
<ul>
<li>Java语言中的各种语法、关键字、常量变量和运算符号的语义 最终都会由多条字节码指令组合来表达 ，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。（类似于 java语言的功能只是 字节码功能的一个子集）</li>
<li>因此有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于java的语言特性提供了发挥空间</li>
</ul>
<p><img src="/uploads/jvm/08-JVM-nobindLanguage.png"></p>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>注意：</p>
<ul>
<li>任何一个Class文件都对应着唯一的一个类或接口的定义信息</li>
<li>类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）</li>
</ul>
<ul>
<li>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在</li>
<li>当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割成若干个8个字节进行存储。</li>
</ul>
<p><strong><em>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”</em></strong></p>
<ul>
<li>无符号数： 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表：  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</li>
</ul>
<p><img src="/uploads/jvm/09-jvm-wufahao-info.png"></p>
<ul>
<li>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</li>
</ul>
<h3 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h3><p>Class的结构不像XML等描述语言，由于它没有任何分隔符号，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>魔数：</p>
<ul>
<li><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件</p>
</li>
<li><p>使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动</p>
</li>
<li><p>Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE（咖啡宝贝？）</p>
</li>
<li><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，</p>
</li>
<li><p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul>
<li>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</li>
</ul>
<h4 id="常量池容量计数值"><a href="#常量池容量计数值" class="headerlink" title="常量池容量计数值"></a>常量池容量计数值</h4><ul>
<li><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）</p>
</li>
<li><p>与Java语言习惯不同，这个容量计数器从1开始，而不是从0开始。</p>
</li>
<li><p>之所以从1开始是因为 ：  在Class文件格式规范制定之时，设计者将第0项常量控出来是有特殊考虑，目的在于 <strong><em>当某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义 ，可以把索引值设置为0</em></strong>来表示。 </p>
</li>
<li><p>如下 图所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。</p>
<p><img src="/uploads/jvm/10-jvm-constantPool.png"></p>
</li>
</ul>
<h4 id="常量类型："><a href="#常量类型：" class="headerlink" title="常量类型："></a>常量类型：</h4><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p>
<ul>
<li><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p>
</li>
<li><p>符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
<h4 id="JVM动态连接"><a href="#JVM动态连接" class="headerlink" title="JVM动态连接"></a>JVM动态连接</h4><ul>
<li>在Class文件中不会保存各个方法、字段最终在内存中的布局信息</li>
<li>这些字段、方法的符号引用不经过虚拟机在运行期转换的话 是无法得到真正的内存入口地址，也就无法直接被虚拟机直接使用</li>
<li>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</li>
</ul>
<h4 id="常量池的项目类型"><a href="#常量池的项目类型" class="headerlink" title="常量池的项目类型"></a>常量池的项目类型</h4><ul>
<li>常量池中每一项常量都是一个表，</li>
<li>最初常量表中共有11种结构 各不相同的表结构数据，后来为了更好的支持动态语言调用，额外增加了4种动态语言相关的常量（）<ul>
<li>JDK 7时增加了前三种：<strong>CONSTANT_MethodHandle_info</strong>、<strong>CONSTANT_MethodType_info</strong>和<strong>CONSTANT_InvokeDynamic_info</strong>。出于性能和易用性的考虑（JDK 7设计时已经考虑到，预留了17个常量标志位），在JDK 11中又增加了第四种常量<strong>CONSTANT_Dynamic_info</strong>。</li>
</ul>
</li>
<li>为了支持Java模块化系统（Jigsaw），又加入了<strong>CONSTANT_Module_info</strong>和<strong>CONSTANT_Package_info</strong>两个常量</li>
<li>截至JDK13，常量表中分别有17种不同类型的常量。</li>
</ul>
<p><img src="/uploads/jvm/12-jvm-constantPool-projectType.png"></p>
<h4 id="常量结构："><a href="#常量结构：" class="headerlink" title="常量结构："></a>常量结构：</h4><ul>
<li>之所以说常量池时最烦琐的数据，是因为这<strong>17种常量类型各自有着完全独立的数据结构</strong>，两两之间被没有什么共性和联系</li>
</ul>
<h5 id="CONSTANT-Class-info"><a href="#CONSTANT-Class-info" class="headerlink" title="CONSTANT_Class_info"></a>CONSTANT_Class_info</h5><ul>
<li><p>回头看看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，</p>
</li>
<li><p>查表6-3的标志列可知这个常量属于<strong>CONSTANT_Class_info</strong>类型，此类型的常量代表一个<strong>类或者接口的符号引用</strong>。</p>
</li>
<li><p>CONSTANT_Class_info的结构比较简单，如表6-4所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>其中 tag 是标志位，它用于区分常量类型；</li>
<li>name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了整个类（或者接口）的全限定名。</li>
<li>本例中的 name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量。</li>
<li>继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个<strong>CONSTANT_Utf8_info</strong>类型的常量。</li>
</ul>
<h5 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a>CONSTANT_Utf8_info</h5><p> CONSTANT_Utf8_info 类型的结构如表6-5所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody></table>
<ul>
<li>length值说明了这个UTF-8编码的字符串长度是多少字节，</li>
<li>它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串</li>
<li>UTF-8缩略编码与普通UTF-8编码的区别是：<br>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，<br>从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符<br>的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</li>
<li>由于Class文件中方法、字段等都需要引用 CONSTANT_Utf8_info 型常量来描述名称，所以 CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度（length的最大值），即u2类型能表达的最大值65535。</li>
<li><strong><em>所以Java程序中如果定义了超过64KB</em></strong> 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</li>
</ul>
<h4 id="javap-工具"><a href="#javap-工具" class="headerlink" title="javap 工具"></a>javap 工具</h4><p>在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。</p>
<p>代码清单6-2中列出了使用javap工具的-verbose参数输出的TestClass.class文件字节码内容（为节省篇幅，此清单中省略了常量池以外的信息）。</p>
<p><strong><em>代码清单6-2　使用javap命令输出常量表</em></strong></p>
<p><img src="/uploads/jvm/13-jvm-constantPool-javap.png"></p>
<ul>
<li>从代码清单6-2中可以看到，计算机已经帮我们把整个常量池的21项常量都计算了出来</li>
<li>其中有些常量似乎从来没有在代码中出现过，如“I”“V”“<init>”“LineNumberTable”“LocalVariableTable”等，这些看起来在源代码中不存在的常量是哪里来的？</li>
<li>这部分常量的确不来源于Java源代码，它们都是编译器自动生成的。会被字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用，它们将会被用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么</li>
<li>因为Java中的“类”是无穷无尽的，无法通过简单的无符号数来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达</li>
</ul>
<h4 id="常量池中的17种数据类型的结构总表"><a href="#常量池中的17种数据类型的结构总表" class="headerlink" title="常量池中的17种数据类型的结构总表"></a>常量池中的17种数据类型的结构总表</h4><p><img src="/uploads/jvm/14-jvm-constantPool-01.png"></p>
<p><img src="/uploads/jvm/14-jvm-constantPool-02.png"></p>
<p><img src="/uploads/jvm/14-jvm-constantPool-03.png"></p>
<h3 id="访问标志（access-flags）"><a href="#访问标志（access-flags）" class="headerlink" title="访问标志（access flags）"></a>访问标志（access flags）</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access flags），这个标志用于识别一些类或者接口层次的访问信息。包括：</p>
<ul>
<li>这个Class是类还是接口</li>
<li>是否定义为public</li>
<li>是否定义为abstract类型</li>
<li>如果是类，是否被声明为final</li>
<li>等等，具体的标志位以及标志的含义见下：</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令的新语义，<br>invokespecial指令的语义在JDK1.0.2发生过改变，为了区别这条指令使用哪种语义，<br>JDK1.0.2之后编译出来的类 这个标志都必须为 真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口和抽象类来说，此标志为真，其他类型都是 假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识 这个类并非由用户代码产生的</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这是一个枚举</td>
</tr>
<tr>
<td>ACC_MODULE</td>
<td>0x8000</td>
<td>标识这是一个模块</td>
</tr>
</tbody></table>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><ul>
<li>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，</li>
<li>而接口索引集合（interfaces）是一组u2类型的数据的集合</li>
<li>Class文件中由这三项数据来确定该类型的继承关系</li>
</ul>
<h4 id="类索引："><a href="#类索引：" class="headerlink" title="类索引："></a>类索引：</h4><p>用于确定这个类的全限定名</p>
<h4 id="父类索引："><a href="#父类索引：" class="headerlink" title="父类索引："></a>父类索引：</h4><p>用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了<br>java.lang.Object外，所有Java类的父类索引都不为0</p>
<h4 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h4><p>用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>
<ul>
<li><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型CONSTANT_Class_info的类描述符常量，</p>
</li>
<li><p>通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</p>
</li>
</ul>
<p><img src="/uploads/jvm/15-jvm-class-index.png"></p>
<h3 id="字段表-field-info-集合"><a href="#字段表-field-info-集合" class="headerlink" title="字段表(field_info)集合"></a>字段表(field_info)集合</h3><ul>
<li>字段表（field_info）用于描述接口或者类中声明的变量。</li>
<li>Java语言中的“字段”（Field）包括**<em>类级变量以及实例级变量**</em>，</li>
<li>但**<em>不包括在方法内部声明的局部变量**</em></li>
</ul>
<h4 id="字段可以包括的修饰符有"><a href="#字段可以包括的修饰符有" class="headerlink" title="字段可以包括的修饰符有:"></a>字段可以包括的修饰符有:</h4><p>字段的作用域（public、private、protected修饰符）、是<strong>实例变量还是类变量（static修饰符）</strong>、可变性（final）、</p>
<p><strong>并发可见性（volatile修饰符，是否强制从主内存读写</strong>）、<strong>可否被序列化（transient修饰符</strong>）、字段数据类型（基本类型、对象、数组）、字段名称。</p>
<ul>
<li>字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li>
</ul>
<h4 id="字段表的最终格式"><a href="#字段表的最终格式" class="headerlink" title="字段表的最终格式:"></a>字段表的最终格式:</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如表6-9所示。</p>
<p>表6-9　字段访问标志<br><img src="/uploads/jvm/16-jvm-attribute-accessFlags.png"></p>
<p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符</p>
<h4 id="全限定名："><a href="#全限定名：" class="headerlink" title="全限定名："></a>全限定名：</h4><p>以代码清单6-1中的代码为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”号表示全限定名结束。</p>
<h4 id="简单名称："><a href="#简单名称：" class="headerlink" title="简单名称："></a>简单名称：</h4><p>简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</p>
<h4 id="描述符："><a href="#描述符：" class="headerlink" title="描述符："></a>描述符：</h4><ul>
<li><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p>
</li>
<li><p>根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，</p>
</li>
<li><p>而对象类型则用字符L加对象的全限定名来表示</p>
</li>
</ul>
<p><img src="/uploads/jvm/17-jvm-attribute-desc.png"></p>
<ul>
<li>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。</li>
<li>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，</li>
<li>方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</li>
</ul>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h4><ul>
<li><p><strong>字段表集合中不会列出从父类或者父接口中继承而来的字段</strong></p>
</li>
<li><p>但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</p>
</li>
<li><p>另外，在<strong>Java语言中字段是无法重载的</strong>，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，</p>
</li>
<li><p>但是<strong>对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法</strong>的</p>
</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul>
<li><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，</p>
</li>
<li><p>依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项</p>
</li>
</ul>
<p>表6-11　方法表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<ul>
<li>因为<strong>volatile关键字和transient关键字不能修饰方法</strong>，所以<strong>方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志</strong>。</li>
<li>与之相对，<strong>synchronized、native、strictfp和abstract关键字可以修饰方法</strong>，<strong>方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、</strong><br><strong>ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志</strong>。</li>
<li>对于方法表，所有标志位及其取值可参见表6-12。</li>
</ul>
<p><img src="/uploads/jvm/18-jvm-method_access_flag.png"></p>
<h4 id="方法里的代码去哪了"><a href="#方法里的代码去哪了" class="headerlink" title="方法里的代码去哪了"></a>方法里的代码去哪了</h4><ul>
<li>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了</li>
<li>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，</li>
<li>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器“<clinit>()”方法和实例构造器“<init>()”方法 </li>
</ul>
<h4 id="重载（-Java语言）"><a href="#重载（-Java语言）" class="headerlink" title="重载（ Java语言）"></a>重载（ Java语言）</h4><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名 。</p>
<h5 id="特征签名："><a href="#特征签名：" class="headerlink" title="特征签名："></a>特征签名：</h5><ul>
<li><p>指 一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名中，所以java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</p>
</li>
<li><p>但是 在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</p>
</li>
<li><p>Java代码的方法特征签名只包括方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表，</p>
</li>
</ul>
<h3 id="属性表（attribute-info）集合"><a href="#属性表（attribute-info）集合" class="headerlink" title="属性表（attribute_info）集合"></a>属性表（attribute_info）集合</h3><p>后续各类属性表中 都会包含xx_index，那是代表对 常量池的引用，例如：</p>
<p>跟随access_flags标志的是两项索引值：<strong>name_index</strong> 和 <strong>descriptor_index</strong>。它们都是对<strong>常量池项的引用</strong>，分别代表着<strong>字段的简单名称以及字段和方法的描述符</strong></p>
<ul>
<li>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</li>
<li>为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项，这些属性具体见表6-13。</li>
</ul>
<p>表6-13　虚拟机规范预定义的属性</p>
<p><img src="/uploads/jvm/19-jvm-attributeinfo-01.png"></p>
<p><img src="/uploads/jvm/19-jvm-attributeinfo-02.png"></p>
<h4 id="Code属性（重点）："><a href="#Code属性（重点）：" class="headerlink" title="Code属性（重点）："></a>Code属性（重点）：</h4><p>理解Code属性是学习后面字节码执行引擎的必要基础，能直接阅读字节码也是工作中分析java代码语义问题的必要工具和基本技能</p>
<p>Code属性是Class文件中最重要的一个属性</p>
<ul>
<li><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。</p>
</li>
<li><p>Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，</p>
</li>
<li><p>譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。</p>
</li>
</ul>
<p>表6-15　Code属性表的结构</p>
<p><img src="/uploads/jvm/20-jvm-attributeinfo-Code.png"></p>
<ul>
<li><strong>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称，</strong></li>
<li><strong>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节</strong>。</li>
<li>max_stack代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度</li>
<li>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</li>
<li>方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理程序的参数（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</li>
<li>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那顾名思义每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令。</li>
<li><strong><em>ps:</em></strong>   关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了*<strong>一个方法不允许超过65535条字节码指令**<em>，即它实际只使用了u2的长度，</em></strong>如果超过这个限制，Javac编译器就会拒绝编译***。一般来讲，编写Java代码时只要不是刻意去编写一个超级长的方法来为难编译器，是不太可能超过这个最大值的限制的。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就有可能因为方法生成字节码超长的原因而导致编译失败。</li>
</ul>
<p>如果**<em>把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分**</em>，那么在整<br>个Class文件里，<strong>Code属性用于描述代码</strong>，<strong>所有的其他数据项目都用于描述元数据</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 原始Java代码</span><br><span class="line">public class TestClass &#123;</span><br><span class="line">    private int m;</span><br><span class="line">    public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">    	<span class="built_in">return</span> m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////编译后</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\&gt;javap -verbose TestClass</span><br><span class="line">// 常量表部分的输出见代码清单6-1，因版面原因这里省略掉</span><br><span class="line">&#123;</span><br><span class="line">public org.fenixsoft.clazz.TestClass();</span><br><span class="line">//构造方法</span><br><span class="line">    Code:</span><br><span class="line">        Stack=1, Locals=1, Args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial <span class="comment">#10; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        4: <span class="built_in">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">    	line 3: 0</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start Length Slot Name Signature</span><br><span class="line">        0 5 0 this Lorg/fenixsoft/clazz/TestClass;</span><br><span class="line"></span><br><span class="line">// 方法 2</span><br><span class="line">public int inc();</span><br><span class="line">Code:</span><br><span class="line">    Stack=2, Locals=1, Args_size=1</span><br><span class="line">    0: aload_0</span><br><span class="line">    1: getfield <span class="comment">#18; //Field m:I</span></span><br><span class="line">    4: iconst_1</span><br><span class="line">    5: iadd</span><br><span class="line">    6: ireturn</span><br><span class="line">LineNumberTable:</span><br><span class="line">	line 8: 0</span><br><span class="line">LocalVariableTable:</span><br><span class="line">    Start Length Slot Name Signature</span><br><span class="line">    0 7 0 this Lorg/fenixsoft/clazz/TestClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问:"></a>疑问:</h4><ul>
<li>这个类有两个方法——实例构造器<init>()和inc()，这两个方法很明显都是没有参数的，为什么Args_size会为1？</li>
<li>而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么会等于1？</li>
</ul>
<h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><ul>
<li><p>一条Java语言里面的潜规则：在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，</p>
</li>
<li><p>而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。</p>
</li>
<li><p>因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。</p>
</li>
<li><p>这个处理只对实例方法有效，如果代码清单6-1中的inc()方法被声明为static，那Args_size就不会等于1而是等于0了。</p>
</li>
<li></li>
</ul>
<h4 id="异常表："><a href="#异常表：" class="headerlink" title="异常表："></a>异常表：</h4><p>如果存在异常表，那它的格式应如表6-16所示，包含四个字段，这些字段的含义为：如果当字节码从第start_pc行[1]到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。</p>
<p>表6-16　属性表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>start_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>end_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>handler_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>catch_pc</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>异常表实际上是Java代码的一部分，尽管字节码中有最初为处理异常而设计的跳转指令，</li>
<li>但《Java虚拟机规范》中明确要求Java语言的编译器<strong>应当选择使用异常表</strong>而不是通过跳转指令来实现Java异常及finally处理机制[2]。</li>
</ul>
<p>代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了<strong>在字节码层面try-catchfinally是如何体现的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Java源码</span><br><span class="line">public int inc() &#123;</span><br><span class="line">    int x;</span><br><span class="line">    try &#123;</span><br><span class="line">        x &#x3D; 1;</span><br><span class="line">    	return x;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    	x &#x3D; 2;</span><br><span class="line">   	 	return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	x &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 编译后的ByteCode字节码及异常表</span><br><span class="line">public int inc();</span><br><span class="line">    Code:</span><br><span class="line">        Stack&#x3D;1, Locals&#x3D;5, Args_size&#x3D;1</span><br><span class="line">            0: iconst_1 &#x2F;&#x2F; try块中的x&#x3D;1</span><br><span class="line">            1: istore_1</span><br><span class="line">            2: iload_1 &#x2F;&#x2F; 保存x到returnValue中，此时x&#x3D;1</span><br><span class="line">            3: istore   4</span><br><span class="line">            5: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            6: istore_1</span><br><span class="line">            7: iload     4 &#x2F;&#x2F; 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            9: ireturn</span><br><span class="line">            10: astore_2 &#x2F;&#x2F; 给catch中定义的Exception e赋值，存储在变量槽 2中</span><br><span class="line">            11: iconst_2 &#x2F;&#x2F; catch块中的x&#x3D;2</span><br><span class="line">            12: istore_1</span><br><span class="line">            13: iload_1 &#x2F;&#x2F; 保存x到returnValue中，此时x&#x3D;2</span><br><span class="line">            14: istore    4</span><br><span class="line">            16: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            17: istore_1</span><br><span class="line">            18: iload      4 &#x2F;&#x2F; 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            20: ireturn</span><br><span class="line">            21: astore_3 &#x2F;&#x2F; 如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</span><br><span class="line">            22: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            23: istore_1</span><br><span class="line">            24: aload_3 &#x2F;&#x2F; 将异常放置到栈顶，并抛出</span><br><span class="line">            25: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">    from to target type</span><br><span class="line">        0 5 10 Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">        0 5 21 any</span><br><span class="line">        10 16 21 any</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>编译器为这段Java源码生成了三条异常表记录，对应三条可能出现的代码执行路径。从Java代码的语义上讲，这三条执行路径分别为：</p>
<ul>
<li>如果try语句块中出现属于Exception或其子类的异常，转到catch语句块处理；</li>
<li>如果try语句块中出现不属于Exception或其子类的异常，转到finally语句块处理；</li>
<li>如果catch语句块中出现任何异常，转到finally语句块处理。</li>
</ul>
<p>返回到我们上面提出的问题，这段代码的返回值应该是多少？熟悉Java语言的读者应该很容易说出答案：</p>
<ul>
<li>如果没有出现异常，返回值是1；</li>
<li>如果出现了Exception异常，返回值是2；</li>
<li>如果出现了Exception以外的异常，方法非正常退出，没有返回值。</li>
</ul>
<p>我们一起来分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。</p>
<ol>
<li>字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且*<strong>将此时x的值复制一份副本到最后一***<br>*</strong>个本地变量表的变量槽中*<strong>（**<em>这个变量槽里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为</em></strong><br><strong><em>方法返回值使用</em></strong>。为了讲解方便，给这个变量槽起个名字：returnValue）。</li>
<li>如果这时候没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后*<strong>将之前保存在returnValue中的整数1***  读入到 *</strong>操作栈***<br><strong><em>顶</em></strong>，**<em>最后ireturn指令会以int形式返回操作栈顶中的值**</em>，方法结束。</li>
<li>如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是<strong>将2赋值给变量x</strong>，然后将变量*<strong>x此时的值赋给returnValue*<strong>，最后</strong>再**<br><strong>将变量x的值改为3</strong>。*</strong>方法返回前同样将returnValue中保留的整数2读到了操作栈顶***。</li>
<li>从第21行开始的代码，作用是<strong>将变量x的值赋为3</strong>，并<strong>将栈顶的异常抛出</strong>，方法结束。</li>
</ol>
<p><strong><em>总结一下：</em></strong></p>
<ul>
<li>如果先给x赋值，再将x值 复制一个副本到本地变量表的 变量槽中，该变量槽中的值在ireturn指令执行时 会被读到操作栈顶，就是最终要 return的值，而不是 x的变量值</li>
<li>如果没有异常，还是会走finally的方法块给x进行赋值，但是最终返回的是 之前本地变量表的变量槽中的值，并不是走完finally块的时候 x的值 </li>
<li>如果发生了异常，且异常属于 catch方法的异常或者其异常子类，则 进catch方法块，给x赋值为2，然后将x=2 的值赋给returnValue，然后执行finally 的x=3,最后将 returnValue的值读到栈顶，输出</li>
<li>如果发生了catch块之外的异常，则 先执行finally 的x=3，再将异常堆栈信息读到栈顶，抛出去，最终不会return x，而是以异常堆栈的形式结束</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    // Java源码</span><br><span class="line">    public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">        int x;</span><br><span class="line">        try &#123;</span><br><span class="line">            x = 1;</span><br><span class="line">            List&lt;Object&gt; list = Arrays.asList();</span><br><span class="line">//            list.get(1);</span><br><span class="line">            System.out.println(1 / 0);</span><br><span class="line">            System.out.println(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">//            ClassCastException(<span class="string">&quot;异常外&quot;</span>)</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">            x = 2;</span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            x = 3;</span><br><span class="line">//            <span class="built_in">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test2 test2 = new Test2();</span><br><span class="line">        int inc = test2.inc();</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><ul>
<li><p>这里的Exceptions属性是在方法表中与Code属性平级的一项属性，不要与前面刚刚讲解完的异常表产生混淆。</p>
</li>
<li><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。</p>
<p>它的结构见表6-17。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_exceptions</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>exception_index_table</td>
<td>number_of_exceptons</td>
</tr>
</tbody></table>
<p>此属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示；exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p>
<h4 id="LocalVariableTable及LocalVariableTypeTable属性"><a href="#LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTable及LocalVariableTypeTable属性"></a>LocalVariableTable及LocalVariableTypeTable属性</h4><ul>
<li><p>LocalVariableTable属性用于描述**<em>栈帧中局部变量表的变量与Java源码中定义的变量之间的关系**</em>，</p>
</li>
<li><p>它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p>
</li>
<li><p>如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
</li>
<li><p>LocalVariableTable属性的结构如表6-19所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>local_variable_table_length</td>
<td>1</td>
</tr>
<tr>
<td>loca_variable_info</td>
<td>loca_variable_table</td>
<td>local_variable_table_length</td>
</tr>
</tbody></table>
<p>其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构如表6-20所示。<br>| 类型               | 名称                       | 数量                |<br>| —————— | ————————– | ——————- |<br>| u2                 |start_pc       | 1                   |<br>| u2                 | length           | 1                   |<br>| u2                 |name_index | 1                   |<br>| u2                 | descriptor_index                     |1 |<br>| u2                 | index | 1                   |</p>
<ul>
<li>start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围</li>
<li>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</li>
<li>index是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时（double和long），它占用的变量槽为index和index+1两个</li>
</ul>
<h4 id="LocalVariableTypeTable（用于支持泛型）"><a href="#LocalVariableTypeTable（用于支持泛型）" class="headerlink" title="LocalVariableTypeTable（用于支持泛型）"></a>LocalVariableTypeTable（用于支持泛型）</h4><ul>
<li><p>在JDK 5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”——LocalVariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。</p>
</li>
<li><p>对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[3]，描述符就不能准确描述泛型类型了。因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。</p>
</li>
</ul>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><ul>
<li><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。</p>
</li>
<li><p>类似“int x=123”和“static int x=123”这样的变量定义在Java程序里面是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。</p>
</li>
<li><p>对**<em>非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>()方法中进行的**</em>；</p>
</li>
<li><p>而对于**<em>类变量**</em>，则有两种方式可以选择：</p>
</li>
<li><ul>
<li>在类构造器<clinit>()方法中</li>
<li>或者使用ConstantValue属性。</li>
</ul>
</li>
<li><p>目前Oracle公司实现的Javac编译器的选择是，如果**<em>同时使用final和static来修饰一个变量**</em>（按照习惯，这里称“常量”更贴切），并且这个变量的<strong>数据类型是基本类型或者java.lang.String</strong>的话，就将会<strong>生成ConstantValue属性</strong>来进行初始化；</p>
</li>
<li><p>如果这个变量<strong>没有被final修饰</strong>，或者<strong>并非基本类型及字符串</strong>，则将会选择在<clinit>()方法中进行初始化。</p>
</li>
<li><p>虽然有final关键字才更符合“ConstantValue”的语义，但<strong>《Java虚拟机规范》中并没有强制要求字段必须设置ACC_FINAL标志，只要求有ConstantValue属性的字段必须设置ACC_STATIC标志而已，</strong></p>
</li>
<li><p><strong>对final关键字的要求是Javac编译器自己加入的限制</strong>。而对ConstantValue的属性值只能限于基本类型和String这点，其实并不能算是什么限制，这是理所当然的结果。</p>
</li>
</ul>
<p>因为此属性的属性值只是一个常量池的索引号，**<em>由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量**</em>，所以就算<br>ConstantValue属性想支持别的类型也无能为力。</p>
<p>ConstantValue属性的结构如表6-23所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_value_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>从数据结构中可以看出ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。</li>
<li>constantvalue_index数据项代表了常量池中一个字面量常量的引用，</li>
<li>根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</li>
</ul>
<h4 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h4><ul>
<li>InnerClasses属性用于记录<strong>内部类与宿主类之间的关联</strong>。</li>
<li>如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</li>
<li>InnerClasses属性的结构如表6-24所示。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_classes</td>
<td>1</td>
</tr>
<tr>
<td>loca_classes_info</td>
<td>inner_classes</td>
<td>number_of_classes</td>
</tr>
</tbody></table>
<p>数据项number_of_classes代表需要记录多少个内部类信息，</p>
<p>每一个内部类的信息都由一个inner_classes_info表进行描述。</p>
<p>inner_classes_info表的结构如表6-25所示。<br>| 类型               | 名称                       | 数量                |<br>| —————— | ————————– | ——————- |<br>| u2                 |inner_class_of_index     | 1                   |<br>| u4                 | outer_class_of_index          | 1                   |<br>| u2                 | inner_name_index | 1                   |<br>| loca_classes_info |      inner_classes_access_flag                     |1 |</p>
<ul>
<li>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</li>
<li>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为0。</li>
<li>inner_class_access_flags是内部类的访问标志，类似于类的access_flags，</li>
</ul>
<h4 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h4><ul>
<li>Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</li>
<li>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</li>
<li>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，</li>
<li>在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位。</li>
<li>编译器通过生成一些在源代码中不存在的Synthetic方法、字段甚至是整个类的方式，实现了越权访问（越过private修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法（Bridge Method）。</li>
<li>所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位中的一项，</li>
<li>唯一的例外是实例构造器“<init>()”方法和类构造器“<clinit>()”方法。</li>
</ul>
<h4 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h4><ul>
<li><p>StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code属性的属性表中。</p>
</li>
<li><p>这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（TypeChecker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
</li>
<li><p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。</p>
</li>
<li><p>类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p>
</li>
<li><p>StackMapTable属性的结构如表6-28所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_entries</td>
<td>1</td>
</tr>
<tr>
<td>stack_map_frame</td>
<td>stack_map_frame_entries</td>
<td>number_of_entries</td>
</tr>
</tbody></table>
<ul>
<li>在Java SE 7版之后的《Java虚拟机规范》中，明确规定对于版本号大于或等于50.0的Class文件，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性，这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。</li>
<li>一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</li>
</ul>
<h4 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h4><ul>
<li>Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。</li>
<li>在JDK 5里面大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（ParameterizedType），则Signature属性会为它记录泛型签名信息。</li>
<li>之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</li>
<li>使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。</li>
<li>但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，</li>
<li>现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。<br>Signature属性的结构如表6-29所示</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>signature_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>其中signature_index项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名或方法类型签名或字段类型签名。</li>
<li>如果当前的Signature属性是类文件的属性，则这个结构表示类签名，</li>
<li>如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，</li>
<li>如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。</li>
</ul>
<h4 id="MethodParameters属性"><a href="#MethodParameters属性" class="headerlink" title="MethodParameters属性"></a>MethodParameters属性</h4><ul>
<li>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。</li>
<li>MethodParameters的作用是记录方法的各个形参名称和信息。</li>
</ul>
<h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><ul>
<li>最初，基于存储空间的考虑，Class文件默认是不储存方法参数名称的，因为给参数起什么名字对计算机执行程序来说是没有任何区别的，所以只要在源码中妥当命名就可以了。</li>
<li>随着Java的流行，这点确实为程序的传播和二次复用带来了诸多不便，由于Class文件中没有参数的名称，如果只有单独的程序包而不附加JavaDoc的话，在IDE中编辑使用包里面的方法时是无法获得方法调用的智能提示的，这就阻碍了JAR包的传播。</li>
<li>后来，“-g：var”就成为了Javac以及许多IDE编译Class时采用的默认值，这样会将方法参数的名称生成到LocalVariableTable属性之中。</li>
<li>不过此时问题仍然没有全部解决，LocalVariableTable属性是Code属性的子属性——没有方法体存在，自然就不会有局部变量表，</li>
<li>但是对于其他情况，譬如抽象方法和接口方法，是理所当然地可以不存在方法体的，对于方法签名来说，还是没有找到一个统一完整的保留方法参数名称的地方。</li>
<li>所以JDK 8中新增的这个属性，使得编译器可以（编译时加上-parameters参数）将方法名称也写进Class文件中，而且MethodParameters是方法表的属性，与Code属性平级的，可以运行时通过反射API获取</li>
</ul>
<p>MethodParameters的结构如表6-32所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>parameters_count</td>
<td>1</td>
</tr>
<tr>
<td>parameter</td>
<td>parameters</td>
<td>parameters_count</td>
</tr>
</tbody></table>
<p>其中，引用到的parameter结构如表6-33所示。<br>表6-33　parameter属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
</tbody></table>
<h4 id="模块化相关属性"><a href="#模块化相关属性" class="headerlink" title="模块化相关属性"></a>模块化相关属性</h4><ul>
<li>JDK 9的一个重量级功能是Java的模块化功能，</li>
<li>因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，</li>
<li>所以，Class文件格式也扩展了**<em>Module、ModulePackages和ModuleMainClas**</em>s三个属性用于支持Java模块化相关功能</li>
</ul>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module:"></a>Module:</h5><p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块*<strong>requires、exports、opens、uses**<em>和</em></strong>provides***定义的全部内容</p>
<p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储<br>了这个模块requires、exports、opens、uses和provides定义的全部内容，其结构如表6-34所示。</p>
<p>表6-34　Module属性结构</p>
<p><img src="/uploads/jvm/22-jvm-Module.png"></p>
<p><strong><em>TODO： 暂时用不到，就先不了解了</em></strong></p>
<h5 id="ModulePackages"><a href="#ModulePackages" class="headerlink" title="ModulePackages"></a>ModulePackages</h5><p>ModulePackages是另一个用于支持Java模块化的变长属性，它用于描述该模块中所有的包，不论是<br>不是被export或者open的。</p>
<h5 id="ModuleMainClass"><a href="#ModuleMainClass" class="headerlink" title="ModuleMainClass"></a>ModuleMainClass</h5><p>ModuleMainClass属性是一个定长属性，用于确定该模块的主类（Main Class），其结构</p>
<h4 id="运行时注解相关属性"><a href="#运行时注解相关属性" class="headerlink" title="运行时注解相关属性"></a>运行时注解相关属性</h4><h5 id="背景：-1"><a href="#背景：-1" class="headerlink" title="背景："></a>背景：</h5><ul>
<li>早在JDK 5时期，Java语言的语法进行了多项增强，其中之一是提供了对注解（Annotation）的支持。</li>
<li>为了存储源码中注解信息，Class文件同步增加了 <strong><em>RuntimeVisibleAnnotations</em></strong>  、*<strong>RuntimeInvisibleAnnotations**<em>、</em></strong>RuntimeVisibleParameterAnnotations*** 和 <strong><em>RuntimeInvisibleParameterAnnotations</em></strong>四个属性。</li>
<li>到了JDK 8时期，进一步加强了Java语言的注解使用范围，又新增类型注解（JSR 308），所以Class文件中也同步增加了 <strong><em>RuntimeVisibleTypeAnnotations</em></strong> 和<br>**<em>RuntimeInvisibleTypeAnnotations**</em> 两个属性。</li>
<li>由于这六个属性不论结构还是功能都比较雷同，因此我们把它们合并到一起，以**<em>RuntimeVisibleAnnotations**</em>为代表进行介绍。</li>
<li><strong>RuntimeVisibleAnnotations</strong>是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，</li>
<li>当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</li>
<li></li>
<li>RuntimeVisibleAnnotations属性的结构如表6-38所示。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_annotations</td>
<td>1</td>
</tr>
<tr>
<td>annotation</td>
<td>annotations</td>
<td>num_annotations</td>
</tr>
</tbody></table>
<p>num_annotations是annotations数组的计数器，annotations中每个元素都代表了一个运行时可见的注解，注解在Class文件中以annotation结构来存储，</p>
<p>具体如表6-39所示<br>表6-39　annotation属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>type_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_element_value_pairs</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>element_value_pairs</td>
<td>num_element_value_pair</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">RocketMQ-02-RocketMQ快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-06 20:59:26" itemprop="dateCreated datePublished" datetime="2021-01-06T20:59:26+08:00">2021-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RocketMQ入门"><a href="#RocketMQ入门" class="headerlink" title="RocketMQ入门"></a>RocketMQ入门</h1><h2 id="核心概念说明"><a href="#核心概念说明" class="headerlink" title="核心概念说明"></a>核心概念说明</h2><p><img src="/uploads/RocketMQ/RocketMQ01.png" alt="image-20210106210340592"></p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ul>
<li>消息生产者，负责产生消息，一般由业务系统负责产生消息。</li>
</ul>
<h4 id="Producer-Group"><a href="#Producer-Group" class="headerlink" title="Producer Group"></a>Producer Group</h4><ul>
<li>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul>
<li>消息费者，负责消费消息，一般是后台系统负责异步消费。</li>
</ul>
<h4 id="Push-Consumer"><a href="#Push-Consumer" class="headerlink" title="Push Consumer"></a>Push Consumer</h4><ul>
<li>服务端向消费者端推送消息</li>
</ul>
<h4 id="Pull-Consumer"><a href="#Pull-Consumer" class="headerlink" title="Pull Consumer"></a>Pull Consumer</h4><ul>
<li>消费者端向服务定时拉取消息</li>
</ul>
<h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><ul>
<li> 一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</li>
</ul>
<h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><ul>
<li><p>集群架构中的组织协调员</p>
</li>
<li><p>收集broker的工作情况</p>
</li>
<li><p>不负责消息的处理</p>
</li>
</ul>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><ul>
<li>是RocketMQ的核心负责消息的发送、接收、高可用等（真正干活的）</li>
<li>需要定时发送自身情况到NameServer，默认10秒发送一次，超时2分钟会认为该broker失效。</li>
</ul>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><ul>
<li><p>不同类型的消息以不同的Topic名称进行区分，如User、Order等</p>
</li>
<li><p>是逻辑概念</p>
</li>
</ul>
<h3 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h3><ul>
<li>消息队列，用于存储消息</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;zlm-mqProducer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置nameserver的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建topic，参数分别是：broker的名称，topic的名称，queue的数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        producer.createTopic(<span class="string">&quot;broker-zhangliming&quot;</span>, <span class="string">&quot;zhangliming-test-topic&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;topic创建成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="发送消息（同步）"><a href="#发送消息（同步）" class="headerlink" title="发送消息（同步）"></a>发送消息（同步）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;我的第一个消息-add!&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;add&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消息id：C0A800693F5814DAD5DC1E4E22F20000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">3</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A800693F5814DAD5DC1E4E22F20000, offsetMsgId=C0A83E5A00002A9F00000000000000BA, messageQueue=MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">3</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Message数据结构"><a href="#Message数据结构" class="headerlink" title="Message数据结构"></a>Message数据结构</h3><table>
<thead>
<tr>
<th>字段名</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Topic</td>
<td>null</td>
<td>必填，线下环境不需要申请，线上环境需要申请后才能使用</td>
</tr>
<tr>
<td>Body</td>
<td>null</td>
<td>必填，二进制形式，序列化由应用决定，Producer 与 Consumer 要协商好序列化形式。</td>
</tr>
<tr>
<td>Tags</td>
<td>null</td>
<td>选填，类似于 Gmail 为每封邮件设置的标签，方便服务器过滤使用。<br/>目前只支持每个消息设置一个 tag，所以也可以类比为 Notify 的 MessageType 概念</td>
</tr>
<tr>
<td>Keys</td>
<td>null</td>
<td>选填，代表这条消息的业务关键词，服务器会根据 keys 创建哈希索引，<br>设置后，可以在 Console 系统根据 Topic、Keys 来查询消息，<br>由于是哈希索引，请尽可能保证 key 唯一，例如订单号，商品 Id 等。</td>
</tr>
<tr>
<td>Flag</td>
<td>0</td>
<td>选填，完全由应用来设置，RocketMQ 不做干预</td>
</tr>
<tr>
<td>DelayTimeLevel</td>
<td>0</td>
<td>选填，消息延时级别，0 表示不延时，大于 0 会延时特定的时间才会被消费</td>
</tr>
<tr>
<td>WaitStoreMsgOK</td>
<td>True</td>
<td>选填，表示消息是否在服务器落盘后才返回应答。</td>
</tr>
</tbody></table>
<h3 id="发送消息（异步）"><a href="#发送消息（异步）" class="headerlink" title="发送消息（异步）"></a>发送消息（异步）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;我的第一个异步发送消息!&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        producer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送成功了!&quot;</span> + sendResult);</span><br><span class="line">                System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送失败!&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">发送成功了!SendResult [sendStatus=SEND_OK, msgId=C0A8006943E014DAD5DC1E5694380000, offsetMsgId=C0A83E5A00002A9F0000000000000174, messageQueue=MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">1</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line">消息id：C0A8006943E014DAD5DC1E5694380000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">1</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;haoke-consumer&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅消息，接收的是所有消息</span></span><br><span class="line"><span class="comment">//        consumer.subscribe(&quot;my-topic&quot;, &quot;*&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;add || update&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;消息:&quot;</span> + <span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息 -&gt; &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消息:我的第一个消息-add!</span><br><span class="line">消息:我的第一个消息-add!</span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">186</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609938835416</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">8951</span>, storeTimestamp=<span class="number">1609938835430</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000000, commitLogOffset=<span class="number">0</span>, bodyCRC=<span class="number">2131316890</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, CONSUME_START_TIME=<span class="number">1609939507601</span>, UNIQ_KEY=C0A8006920E814DAD5DC1E4E1BD80000, WAIT=<span class="keyword">true</span>, TAGS=add&#125;, body=[-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">102</span>, -<span class="number">124</span>, -<span class="number">25</span>, -<span class="number">84</span>, -<span class="number">84</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">128</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">86</span>, -<span class="number">26</span>, -<span class="number">74</span>, -<span class="number">120</span>, -<span class="number">26</span>, -<span class="number">127</span>, -<span class="number">81</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">33</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">3</span>, storeSize=<span class="number">186</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609938837234</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">8964</span>, storeTimestamp=<span class="number">1609938837241</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F00000000000000BA, commitLogOffset=<span class="number">186</span>, bodyCRC=<span class="number">2131316890</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, CONSUME_START_TIME=<span class="number">1609939507601</span>, UNIQ_KEY=C0A800693F5814DAD5DC1E4E22F20000, WAIT=<span class="keyword">true</span>, TAGS=add&#125;, body=[-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">102</span>, -<span class="number">124</span>, -<span class="number">25</span>, -<span class="number">84</span>, -<span class="number">84</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">128</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">86</span>, -<span class="number">26</span>, -<span class="number">74</span>, -<span class="number">120</span>, -<span class="number">26</span>, -<span class="number">127</span>, -<span class="number">81</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">33</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="消息过滤器"><a href="#消息过滤器" class="headerlink" title="消息过滤器"></a>消息过滤器</h2><ul>
<li><p>RocketMQ支持根据用户自定义属性进行过滤，过滤表达式类似于SQL的where，如：a&gt; 5 AND b =’abc’</p>
</li>
<li><p>原因是默认配置下，不支持自定义属性，需要设置开启 broker.conf中配置,见第一章可以看见配置<br>enablePropertyFilter=true</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.MessageSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅消息，接收的是所有消息</span></span><br><span class="line"><span class="comment">//        consumer.subscribe(&quot;my-topic&quot;, &quot;*&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;my-topic-filter&quot;</span>, MessageSelector.bySql(<span class="string">&quot;sex=&#x27;女&#x27; AND age&gt;=18&quot;</span>));</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;消息:&quot;</span> + <span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息 -&gt; &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">2</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940231764</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9804</span>, storeTimestamp=<span class="number">1609940231769</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F00000000000003CE, commitLogOffset=<span class="number">974</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">3</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940231776</span>, UNIQ_KEY=C0A800692B3C14DAD5DC1E636A540000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">21</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">1</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940241237</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9818</span>, storeTimestamp=<span class="number">1609940241243</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000490, commitLogOffset=<span class="number">1168</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940241244</span>, UNIQ_KEY=C0A8006908F014DAD5DC1E638F550000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">22</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">3</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940251652</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9836</span>, storeTimestamp=<span class="number">1609940251657</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000552, commitLogOffset=<span class="number">1362</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">4</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940251658</span>, UNIQ_KEY=C0A8006934D414DAD5DC1E63B8030000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">23</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;这是一个用户的消息, id = 1003&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic-filter&quot;</span>, <span class="string">&quot;delete&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        message.putUserProperty(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        message.putUserProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    消息id：C0A80069251814DAD5DC1E63D08D0000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic-filter, brokerName=broker-zhangliming, queueId=<span class="number">0</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A80069251814DAD5DC1E63D08D0000, offsetMsgId=C0A83E5A00002A9F0000000000000614, messageQueue=MessageQueue [topic=my-topic-filter, brokerName=broker-zhangliming, queueId=<span class="number">0</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="producer详解"><a href="#producer详解" class="headerlink" title="producer详解"></a>producer详解</h2><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>在某些业务中，consumer在消费消息时，是需要按照生产者发送消息的顺序进行消费的，比如在电商系统中，订单的消息，会有创建订单、订单支付、订单完成，如果消息的顺序发生改变，那么这样的消息就没有意义了。</p>
<p><img src="/uploads/RocketMQ/RocketMQ02.png" alt="image-20210106210340592"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;HAOKE_ORDER_PRODUCER&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> orderId = i % <span class="number">10</span>; <span class="comment">// 模拟生成订单id</span></span><br><span class="line">            String msgStr = <span class="string">&quot;order --&gt; &quot;</span> + i +<span class="string">&quot;, id = &quot;</span>+ orderId;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;haoke_order_topic&quot;</span>, <span class="string">&quot;ORDER_MSG&quot;</span>,</span><br><span class="line">                    msgStr.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(message, (mqs, msg, arg) -&gt; &#123;</span><br><span class="line">                Integer id = (Integer) arg;</span><br><span class="line">                <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">            &#125;, orderId);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">                DefaultMQPushConsumer(<span class="string">&quot;HAOKE_ORDER_CONSUMER&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;haoke_order_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                                + msg.getQueueId() + <span class="string">&quot; &quot;</span></span><br><span class="line">                                + <span class="keyword">new</span> String(msg.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                System.out.println(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs);</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：相同订单id的消息会落到同一个queue中，一个消费者线程会顺序消费queue，从而实现顺序消费消<br>息。</p>
<h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><h3 id="回顾是什么事务"><a href="#回顾是什么事务" class="headerlink" title="回顾是什么事务"></a>回顾是什么事务</h3><p>聊什么是事务，最经典的例子就是转账操作，用户A转账给用户B1000元的过程如下：<br>用户A发起转账请求，用户A账户减去1000元<br>用户B的账户增加1000元<br>如果，用户A账户减去1000元后，出现了故障（如网络故障），那么需要将该操作回滚，用户A账户增加1000元。<br>这就是事务。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>随着项目越来越复杂，越来越服务化，就会导致系统间的事务问题，这个就是分布式事务问题。<br>分布式事务分类有这几种：</p>
<ul>
<li>基于单个JVM，数据库分库分表了（跨多个数据库）。</li>
<li>基于多JVM，服务拆分了（不跨数据库）。</li>
<li>基于多JVM，服务拆分了 并且数据库分库分表了。</li>
</ul>
<p>解决分布式事务问题的方案有很多，使用消息实现只是其中的一种。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Half-Prepare-Message"><a href="#Half-Prepare-Message" class="headerlink" title="Half(Prepare) Message"></a>Half(Prepare) Message</h4><p>指的是暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次<br>确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息。</p>
<h4 id="Message-Status-Check"><a href="#Message-Status-Check" class="headerlink" title="Message Status Check"></a>Message Status Check</h4><p>由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长<br>期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回<br>查。</p>
<p><img src="/uploads/RocketMQ/RocketMQ03.png" alt="image-20210106210340592"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/uploads/RocketMQ/RocketMQ04.png" alt="image-20210106210340592"></p>
<ol>
<li>发送方向 MQ 服务端发送消息。</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后MQ Server 将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, LocalTransactionState&gt; STATE_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行具体的业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 发送的消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户A账户减500元.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">//模拟调用服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             System.out.println(1/0);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户B账户加500元.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            STATE_MAP.put(msg.getTransactionId(), LocalTransactionState.COMMIT_MESSAGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二次提交确认</span></span><br><span class="line"><span class="comment">//            return LocalTransactionState.UNKNOW;</span></span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        STATE_MAP.put(msg.getTransactionId(), LocalTransactionState.ROLLBACK_MESSAGE);</span><br><span class="line">        <span class="comment">// 回滚</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息回查</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;状态回查 ---&gt; &quot;</span> + msg.getTransactionId() +<span class="string">&quot; &quot;</span> +STATE_MAP.get(msg.getTransactionId()) );</span><br><span class="line">        <span class="keyword">return</span> STATE_MAP.get(msg.getTransactionId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;transaction_producer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> TransactionListenerImpl());</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;pay_topic&quot;</span>, <span class="string">&quot;用户A给用户B转账500元&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        producer.sendMessageInTransaction(message, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">99999</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;HAOKE_CONSUMER&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅topic，接收此Topic下的所有消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;pay_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h4><p>返回commit状态时，消费者能够接收到消息，返回rollback状态时，消费者接受不到消息。</p>
<h2 id="consumer详解"><a href="#consumer详解" class="headerlink" title="consumer详解"></a>consumer详解</h2><h3 id="push和pull模式"><a href="#push和pull模式" class="headerlink" title="push和pull模式"></a>push和pull模式</h3><p>在RocketMQ中，消费者有两种模式，一种是push模式，另一种是pull模式。</p>
<ul>
<li>(常用)push模式：客户端与服务端建立连接后，当服务端有消息时，将消息推送到客户端。</li>
<li>pull模式：客户端不断的轮询请求服务端，来获取新的消息。<br>但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式，即consumer轮询从broker拉取消息。<br>区别：</li>
<li> Push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。</li>
<li>Pull方式里，取消息的过程需要用户自己写，首先通过打算消费的Topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取的开始offset，直到取完了，再换另一个MessageQueue。</li>
<li>疑问：既然是采用pull方式实现，RocketMQ如何保证消息的实时性呢？</li>
</ul>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的<br>数据，再返回，然后进入循环周期。<br>客户端像传统轮询一样从服务端请求数据，服务端会阻塞请求不会立刻返回，直到有数据或超时才返回给客<br>户端，然后关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p>
<p><img src="/uploads/RocketMQ/RocketMQ05.png" alt="image-20210106210340592"></p>
<h2 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h2><p>DefaultMQPushConsumer实现了自动保存offset值以及实现多个consumer的负载均衡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置组名</span></span><br><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;HAOKE_IM&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过groupname将多个consumer组合在一起，那么就会存在一个问题，消息发送到这个组后，消息怎么分配呢？<br>这个时候，就需要指定消息模式，分别有集群和广播模式。</p>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>同一个 ConsumerGroup(GroupName相同) 里的每 个 Consumer 只消费所订阅消息的一部分内容， 同<br>一个 ConsumerGroup 里所有的 Consumer消费的内容合起来才是所订阅 Topic 内容的整体， 从而达到<br>负载均衡的目的 。</p>
<h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p>同一个 ConsumerGroup里的每个 Consumer都 能消费到所订阅 Topic 的全部消息，也就是一个消息会<br>被多次分发，被多个 Consumer消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集群模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"><span class="comment">// 广播模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure>

<h3 id="重复消息的解决方案"><a href="#重复消息的解决方案" class="headerlink" title="重复消息的解决方案"></a>重复消息的解决方案</h3><p>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办<br>法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<ol>
<li>消费端处理消息的业务逻辑保持幂等性</li>
<li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li>
</ol>
<ul>
<li>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</li>
<li>第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</li>
<li>第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。</li>
<li>第2条可以消息系统实现，也可以业务端实现。</li>
<li>正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以</li>
<li>最好还是**<em>由业务端自己处理消息重复的问题**</em>，这也是RocketMQ不解决消息重复的问题的原因。</li>
<li>  RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</li>
</ul>
<h2 id="RocketMQ存储"><a href="#RocketMQ存储" class="headerlink" title="RocketMQ存储"></a>RocketMQ存储</h2><p>RocketMQ中的消息数据存储，采用了零拷贝技术（使用 mmap + write 方式），文件系统采用 Linux Ext4 文件系<br>统进行存储。</p>
<h3 id="消息数据的存储"><a href="#消息数据的存储" class="headerlink" title="消息数据的存储"></a>消息数据的存储</h3><p>在RocketMQ中，消息数据是保存在磁盘文件中，为了保证写入的性能，RocketMQ尽可能保证顺序写入，顺序写<br>入的效率比随机写入的效率高很多。<br>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的，CommitLog是真正存储数据的文件，<br>ConsumeQueue是索引文件，存储数据指向到物理文件的配置。</p>
<p><img src="/uploads/RocketMQ/RocketMQ06.png" alt="image-20210106210340592"></p>
<p>如上图所示：</p>
<ul>
<li>消息主体以及元数据都存储在CommitLog当中</li>
<li>Consume Queue相当于kafka中的partition，是一个逻辑队列，存储了这个Queue在CommiLog中的起始<br>offset，log大小和MessageTag的hashCode。</li>
<li>每次读取消息队列先读取consumerQueue,然后再通过consumerQueue去commitLog中拿到消息主体。</li>
</ul>
<p>文件位置：</p>
<p><img src="/uploads/RocketMQ/RocketMQ07.png" alt="image-20210106210340592"></p>
<h2 id="同步刷盘与异步刷盘"><a href="#同步刷盘与异步刷盘" class="headerlink" title="同步刷盘与异步刷盘"></a>同步刷盘与异步刷盘</h2><p>RocketMQ 为了提高性能，会尽可能地保证 磁盘的顺序写。消息在通过 Producer 写入 RocketMQ 的时候，有两<br>种写磁盘方式，分别是同步刷盘与异步刷盘。</p>
<ul>
<li><p>同步刷盘</p>
<ul>
<li>在返回写成功状态时，消息已经被写入磁盘 。</li>
<li>具体流程是：消息写入内存的 PAGECACHE 后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程<br>执行完成后唤醒等待的线程，返回消息写成功的状态 。</li>
</ul>
</li>
<li><p>异步刷盘</p>
</li>
<li><p>在返回写成功状态时，消息可能只是被写入了内存的 PAGECACHE，写操作的返回快，吞吐量大</p>
<ul>
<li>当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</li>
</ul>
</li>
<li><p>broker配置文件中指定刷盘方式</p>
<ul>
<li>flushDiskType=ASYNC_FLUSH – 异步</li>
<li>flushDiskType=SYNC_FLUSH – 同步</li>
</ul>
</li>
</ul>
<p><img src="/uploads/RocketMQ/RocketMQ08.png" alt="image-20210106210340592"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinshi</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"4oBiQGiWDHdACABLWjT7ouaV-gzGzoHsz","appKey":"fr4vMSPUjcHLtIrF2hmRF6UE","serverURLs":"https://4obiqgiw.lc-cn-n1-shared.com","placeholder":"国王不动，手下怎么跟随? --反叛的鲁鲁修","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"cdh":"https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"}, {
      el: '#valine-comments',
      path: "/page/4/",
      serverURLs: "https://4obiqgiw.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>


</body>
</html>
