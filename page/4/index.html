<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="HCj467TtuvFkAzzdCvYvbniAeNiUy7TUwp2hG1qGWQE">
  <meta name="baidu-site-verification" content="LppFIbSdZO">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limingzhang666.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","width":320,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="拨开云雾见青天">
<meta property="og:type" content="website">
<meta property="og:title" content="Yinshi&#39;s Blog">
<meta property="og:url" content="https://limingzhang666.github.io/page/4/index.html">
<meta property="og:site_name" content="Yinshi&#39;s Blog">
<meta property="og:description" content="拨开云雾见青天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yinshi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://limingzhang666.github.io/page/4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yinshi's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yinshi's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yinshi"
      src="/images/yinshi01_avatar.jpg">
  <p class="site-author-name" itemprop="name">Yinshi</p>
  <div class="site-description" itemprop="description">拨开云雾见青天</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/limingzhang666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limingzhang666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:laimingcham@163.com" title="E-Mail → mailto:laimingcham@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/limingzhang666" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">深入理解jvm-11-虚拟机字节码执行引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-19 23:42:20" itemprop="dateCreated datePublished" datetime="2021-01-19T23:42:20+08:00">2021-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>执行引擎是Java虚拟机核心的组成部分之一。</p>
</li>
<li><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，</p>
</li>
<li><p>其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，</p>
</li>
<li><p>而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
</li>
</ul>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><h3 id="栈帧（Stack-Frame）"><a href="#栈帧（Stack-Frame）" class="headerlink" title="栈帧（Stack Frame）"></a>栈帧（Stack Frame）</h3><ul>
<li><p>Java虚拟机以方法作为最基本的执行单元，而 <strong>栈帧</strong> （Stack Frame）则是用于java虚拟机进行方法调用和方法执行背后的数据结构， 它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p>
</li>
<li><p>栈帧存储了方法的<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>和<strong>方法返回地址</strong> 等信息，</p>
</li>
<li><p>每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从<strong>入栈到出栈</strong>的过程</p>
</li>
<li><p>在编译Java程序源码的时候，栈帧需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。</p>
</li>
<li><p>一个栈帧需要分配多少内存，并不会收到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式</p>
</li>
</ul>
<ul>
<li>一个线程中的方法调用链 可能会很长，以java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。</li>
<li>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame）,与这个栈帧关联的方法 被称为 “当前方法”（Current Method）。</li>
<li>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，</li>
</ul>
<h3 id="栈帧的概念结构"><a href="#栈帧的概念结构" class="headerlink" title="栈帧的概念结构"></a>栈帧的概念结构</h3><p><img src="/uploads/jvm/10StackFrame/01-StackFrameConstruct.png"></p>
<h4 id="局部变量表（Local-Variables-Table）"><a href="#局部变量表（Local-Variables-Table）" class="headerlink" title="局部变量表（Local Variables Table）"></a>局部变量表（Local Variables Table）</h4><ul>
<li><p>局部变量表 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量表。 </p>
</li>
<li><p>在Java程序被编译成Class文件时，就在方法的Code属性中的<strong>max_locals</strong> 数据项中确定了该方法所需分配的局部变量表的最大容量</p>
</li>
<li><p>局部变量表的容量以 变量槽（Variable slot）为最小单位，</p>
</li>
<li><p>《Java虚拟机规范》被没有明确指出一个变量槽应占用的 内存空间大小，只有向导性的说每个变量槽 Variable Slot 都应该能存放一个  boolean 、 byte、 char、 short、 int、 float、 reference 或看return Address类型的数据</p>
</li>
</ul>
<h5 id="局部变量表中的数据类型"><a href="#局部变量表中的数据类型" class="headerlink" title="局部变量表中的数据类型"></a>局部变量表中的数据类型</h5><ul>
<li>一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference[1]和returnAddress这8种类型。</li>
<li>而第7种reference类型表示对一个对象实例的引用，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则将无法实现《Java语言规范》中定义的语法约定</li>
<li>第8种returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转，但现在也已经全部改为采用异常表来代替了</li>
<li>对于64位的数据类型，Java虚拟机会以 <strong>高位对齐</strong> 的方式为其分配 <strong>两个连续的变量槽空间</strong> 。Java语言中明确的64位的数据类型只有 long 和 double 两种。</li>
<li>这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中允许把一次long和double数据类型读写分割为两次32位读写的做法有些类<br>似。</li>
<li>由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。</li>
</ul>
<ul>
<li><p>Java虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会<strong>同时使用第N和N+1两个变量槽</strong>.</p>
</li>
<li><p>对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机<strong>不允许采用任何方式单独访问其中的某一个</strong>，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。</p>
</li>
<li><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<strong>参数值到参数列表</strong>的传递过程，即 <strong>实参到形参</strong>的传递。如果执行的时实例方法（没有被 static 修饰的方法），那局部变量表中的<strong>第0 位索引</strong>的变量槽 默认是 用于传递<strong>方法实例的引用</strong>，在方法中可以通过 关键字“this” 来访问到这个隐含的参数。 其余的参数 则是按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
</li>
</ul>
<h5 id="局部变量表的重用"><a href="#局部变量表的重用" class="headerlink" title="局部变量表的重用"></a>局部变量表的重用</h5><ul>
<li>为了尽可能的节省栈帧耗用的内存空间，<strong>局部变量表中的变量槽是可以重用</strong>的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体（就是一个方法体中的局部变量可能用到一半就不使用了，比如方法体有10行，而局部变量只在其中的3-4行被使用，那这个局部变量就没有覆盖整个方法体），如果当前字节码PC计数器的值 已经超过了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。</li>
<li>不过这样的设计除了节省栈帧空间外，还会伴随少量的<strong>副作用</strong></li>
<li>例如 在某些情况下变量槽的复用会直接影响到系统的GC 行为，如下如代码所示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M </span></span><br><span class="line"><span class="comment"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseVariableSlot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result: (我这里使用的JDK <span class="number">9</span>)</span><br><span class="line">[<span class="number">0.028</span>s][info][gc] Using G1</span><br><span class="line">[<span class="number">0.142</span>s][info][gc] GC(<span class="number">0</span>) <span class="function">Pause Initial <span class="title">Mark</span> <span class="params">(G1 Humongous Allocation)</span> 2M-&gt;1<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 1.368ms</span></span><br><span class="line"><span class="function">[0.142s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle</span></span><br><span class="line"><span class="function">[0.171s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Remark 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.724ms</span></span><br><span class="line"><span class="function">[0.171s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Cleanup 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.174ms</span></span><br><span class="line"><span class="function">[0.175s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">2</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 3.810ms</span></span><br><span class="line"><span class="function">[0.175s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle 33.128ms</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span></span><br></pre></td></tr></table></figure>

<p>代码中可以看到：</p>
<p>向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上“-verbose：gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收掉这64MB的内存。</p>
<p>代码没有回收掉 placeHolder所占的内存说的过去，因为执行system.gc()时，变量 placeholder 还处于作用域之内，虚拟机自然不敢回收掉placeholder 的内存。</p>
<p>我们修改一下代码，改成这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M</span></span><br><span class="line"><span class="comment"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseVariableSlot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result： 同上</span><br><span class="line">    [<span class="number">0.026</span>s][info][gc] Using G1</span><br><span class="line">[<span class="number">0.137</span>s][info][gc] GC(<span class="number">0</span>) <span class="function">Pause Initial <span class="title">Mark</span> <span class="params">(G1 Humongous Allocation)</span> 2M-&gt;1<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 1.593ms</span></span><br><span class="line"><span class="function">[0.137s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle</span></span><br><span class="line"><span class="function">[0.162s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Remark 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.727ms</span></span><br><span class="line"><span class="function">[0.165s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">2</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 3.594ms</span></span><br><span class="line"><span class="function">[0.166s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Cleanup 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.001ms</span></span><br><span class="line"><span class="function">[0.166s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle 28.351ms</span></span><br></pre></td></tr></table></figure>

<p>加入了花括号之后，placeholder的作用域被限制在了 花括号之内，从代码逻辑上讲，在执行 system.gc()的时候，placeholder 已经不可能再被访问了，但执行这段程序的时候，发现 64M的内存 还是没有被回收掉，</p>
<p>为什么呢，解释之前我们再修改一下代码,先对这段代码进行第二次修改，在调用System.gc()之前加入一行“int  a=0；”，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M</span><br><span class="line"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> */</span><br><span class="line">public class ReuseVariableSlot &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            byte[] placeholder = new byte[64 * 1024 * 1024];</span><br><span class="line">        &#125;</span><br><span class="line">         int a = 0;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> result: </span><br><span class="line"> [0.026s][info][gc] Using G1</span><br><span class="line">[0.145s][info][gc] GC(0) Pause Initial Mark (G1 Humongous Allocation) 2M-&gt;1M(80M) 1.527ms</span><br><span class="line">[0.145s][info][gc] GC(1) Concurrent Cycle</span><br><span class="line">[0.170s][info][gc] GC(1) Pause Remark 66M-&gt;66M(80M) 0.789ms</span><br><span class="line">[0.170s][info][gc] GC(1) Pause Cleanup 66M-&gt;66M(80M) 0.351ms</span><br><span class="line">[0.170s][info][gc] GC(1) Concurrent Cycle 25.457ms</span><br><span class="line">[0.174s][info][gc] GC(2) Pause Full (System.gc()) 66M-&gt;1M(80M) 3.362ms </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现加上 int a = 0; 之后，发现内存被回收了 （[info][gc] GC(2) Pause Full (System.gc()) 66M-&gt;1M(80M) 3.362ms ）</p>
<h5 id="代码总结："><a href="#代码总结：" class="headerlink" title="代码总结："></a>代码总结：</h5><p>上面的代码 ，<strong>placeholder 能否被回收</strong> 的根本原因是：  </p>
<ul>
<li>局部变量表的变量槽 是否还存有 关于placeholder数组对象的 <strong>引用</strong></li>
<li>第一次修改中（加花括号），代码虽然 已经离开了placeholder的作用域，但在之后，在没有发生过任何对局部变量表的读写 操作，placeholder 原本所占用的变量槽  还没有被其他变量所复用，所以作为 GC ROOTs 一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断。再绝大部分情况下影响很轻微。 但如果遇到 一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大部分内存但实际已经不会再使用的变量， 手动 将其设置为 null值 （用来代替 int a=0，把变量对应的局部变量槽清空）便不见得是一个绝对无意义的操作 。这是<strong>奇技淫巧</strong> ，并不是很认同。</li>
<li>这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到即时编译器的编译条件）下的“奇技”来使用。Java语言的一本非常著名的书籍《Practical Java》中将把“不使用的对象应手动赋值为null”作为一条推荐的编码规则（笔者并不认同这条规则），但是并没有解释具体原因</li>
<li>这是<strong>奇技淫巧</strong> ，并不是很认同。因为：<ul>
<li>从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法</li>
<li>更关键的是，从执行角度来讲，使用赋null操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，概念模型与实际执行过程是外部看起来等效，内部看上去则可以完全不同。当虚拟机使用解释器执行时，通常与概念模型还会比较接近，但经过即时编译器施加了各种编译优化措施以后，两者的差异就会非常大，只保证程序执行的结果与概念一致。在实际情况中，即时编译才是虚拟机执行代码的主要方式，赋null值的操作在经过即时编译优化后几乎是一定会被当作无效操作消除掉的，这时候将变量设置为null就是毫无意义的行为。字节码被即时编译为本地代码后，对GC Roots的枚举也与解释执行时期有显著差别，以前面的例子来看，经过第一次修改的代码（第二个方法）在经过即时编译后，System.gc()执行时就可以正确地回收内存，根本无须写成代码（第三个方法）的样子。</li>
</ul>
</li>
</ul>
<h5 id="局部变量表不存在准备阶段"><a href="#局部变量表不存在准备阶段" class="headerlink" title="局部变量表不存在准备阶段"></a>局部变量表不存在准备阶段</h5><ul>
<li><p>局部变量表不像类变量那样存在“准备阶段”，</p>
</li>
<li><p>之前我们在《虚拟机的类加载过程》学过，类的字段变量 有2次赋初始值的过程，  一次是在 准备阶段，赋予系统初始值；另外一次是在 初始化阶段，赋予程序员在代码中定义的初始值。 因此 即使在初始化阶段 程序员没有为类变量赋值也没有关系，类变量仍然具有一个决定的初始值（零值，默认值），不会产生歧义。</p>
</li>
<li><p>但是 局部变量就不一样 了，如果一个局部变量定义了，但没有赋初始值，那它是完全不能使用的。</p>
</li>
<li><p>所以不要认为 Java中任何情况都存在 诸如 整型变量默认为0、布尔型变量默认为 false 等这样的默认值规则。</p>
</li>
<li><p>如果局部变量不赋初始值，编译期在编译期间能检查到并提示出来，ide工具是会报错的。</p>
</li>
<li><p>即使编译能通过或者 通过手动的方式生成字节码，在《虚拟机的类加载过程》的字节码验证阶段，也会被虚拟机发现，从而导致 类加载失败。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a; <span class="comment">//</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result:  编译期报错：  可能尚未初始化变量a</span><br></pre></td></tr></table></figure>



<h3 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h3><ul>
<li><p>操作数栈 （Operand Stack）也常被称为操作栈，它是一个<strong>先入后出</strong> (Last In First Out,LIFO） 栈。 </p>
</li>
<li><p>同局部变量表一样， 操作数栈的最大深度也在编译的时候被写入到 Code 属性的 <strong>max_stacks</strong> 数据项之中。</p>
</li>
<li><p>操作数栈的每一个元素 都可以是包括long 和 double 在内的<strong>任意java数据类型</strong> 。32位 数据类型 所占的栈容量为 1，64 位数据类型所占的栈容量为  2。</p>
</li>
<li><p>javac 编译器的数据流分析工作保证了 在方法执行的任何时候，操作数栈的深度 都不会超过 在 max_stacks 数据项设定的最大值。</p>
</li>
</ul>
<h5 id="方法执行时的操作栈动作"><a href="#方法执行时的操作栈动作" class="headerlink" title="方法执行时的操作栈动作"></a>方法执行时的操作栈动作</h5><ul>
<li><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。  在方法的执行过程中，会有各种<strong>字节码指令</strong> 往  <strong>操作数栈</strong> 中写入和提取 内容， 也就是出栈和入栈操作。</p>
<p>譬如 在做算术运算的时候 ，通过将运算涉及的操作数栈 压入栈顶后 ，然后 调用运算指令来执行。</p>
</li>
</ul>
<p>又譬如 在调用其他方法的时候 ，通过操作数栈 来进行方法参数的传递。</p>
<p>举个例子， 例如整数加法 的字节码 iadd, 这条指令在运行的时候 ，要求操作数栈中最接近 栈顶的2个元素 已经存入了2个int 型的数值，当执行 iadd这个指令时候，会把这2 个int 值出栈 并相加，然后将 相加的结果重新入栈 。</p>
<h5 id="字节码指令严格匹配操作栈元素数据类型"><a href="#字节码指令严格匹配操作栈元素数据类型" class="headerlink" title="字节码指令严格匹配操作栈元素数据类型"></a>字节码指令严格匹配操作栈元素数据类型</h5><p>操作数栈中元素的数据类型必须 与字节码指令的序列严格匹配，在编译程序代码的时候，编译期必须严格保证这一点，在类校验阶段的数据流分析中还要 再次验证这一点。</p>
<p>例如： iadd指令只能 用于整型数据的加法，该指令在执行时，最接近栈顶的2个元素的数据类型 必须为int 型，不能出现一个long 和一个float 使用iadd指令相加的 情况。</p>
<h5 id="栈帧的优化"><a href="#栈帧的优化" class="headerlink" title="栈帧的优化"></a>栈帧的优化</h5><ul>
<li><p>Java虚拟机的<strong>解释执行引擎</strong> 被称为“<strong>基于栈的执行引擎</strong>”, 里面的栈 就是操作数栈。后续还会对基于栈的代码执行过程进行更详细的讲解。介绍它与更常见的<strong>基于寄存器的执行引擎</strong>有那些差别</p>
</li>
<li><p>在概念 模型中，两个不同栈帧（Stack Frame）作为不同方法的虚拟机栈 元素，是<strong>完全互相独立</strong>的。  但是在大多数虚拟机的实现中，会对这块进行一些<strong>优化处理</strong> ，令2个 不同方法的栈帧出现一部分 <strong>重叠</strong>。让下面的栈帧的部分操作数栈 与 上面栈帧的部分局部变量表 重叠在一起，这样做不仅节约了 一些空间，更重要的是 在进行方法调用的时候 就可以直接共用 一部分数据，无需进行<strong>额外的 参数 复制传递</strong>了 。重叠的过程如下图所示： </p>
</li>
</ul>
<p><img src="/uploads/jvm/10StackFrame/02-StackFrameOverlap.png"></p>
<h3 id="动态连接（Dynamic-Linking）"><a href="#动态连接（Dynamic-Linking）" class="headerlink" title="动态连接（Dynamic Linking）"></a>动态连接（Dynamic Linking）</h3><p>每个栈帧 都包含一个指向<strong>运行时常量池</strong> 中<strong>该栈帧所属方法的引用</strong>，持有这个引用 是为了支持方法调用过程中的<strong>动态连接</strong>。</p>
<p>通过之前文章，我们知道 Class文件 的常量池中存有 大量的符号引用，字节码中的<strong>方法调用指令</strong> 就以 常量池里<strong>指向方法的符号连接</strong> 作为参数。</p>
<ul>
<li>这些符号引用一部分将在 <strong>类加载阶段</strong>或者<strong>第一次使用的时候</strong>就被转化为<strong>直接引用</strong>，这种转化称为  <strong>静态解析</strong></li>
<li>另外一部分将在<strong>每一次运行期间</strong>都<strong>转化 为直接引用</strong>，这部分就称为 <strong>动态连接</strong>。后续后详细讲解</li>
</ul>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有 2种 方式退出这个方法。</p>
<ul>
<li>第一种退出方式是执行引擎遇到任意一个方法<strong>返回的字节码指令</strong>，这时候 可能会有返回值 传递给上层方法调用者 （调用当前方法的方法称为 <strong>主调方法</strong> 或者 “<strong>调用者</strong>”）， 方法是否有返回值 以及返回值的类型 将根据 何种方法返回指令来决定，这种退出方式 称为 “<strong>正常调用完成（Normal Method Invocation Completion）</strong>”</li>
<li>另外一种退出方式 就是方法执行过程中 遇到了异常，并且这个异常没有在方法体内得到妥善处理。  无论是Java虚拟机内部的异常，还是代码中<strong>athrow字指令</strong> 产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式 称为 “**异常调用完成(Abrupt Method Invocation Completion)**”  。一个方法使用异常完成出口的方式退出，是不会给他的上层调用者 提供任何返回值的。</li>
</ul>
<p>无论采用何种退出方式，在方法退出之后，都必须<strong>返回最初方法被调用的位置</strong>，程序才能继续执行。</p>
<p>方法返回时 可能需要在栈帧中 保存一些信息，用来帮助<strong>恢复它的上层主调方法的执行状态</strong> 。 </p>
<p>一般来说，方法正常退出时，<strong>主调方法的PC计数器的值 就可以作为返回地址</strong>，栈帧中很可能 会保存这个计数器值。</p>
<p>而异常退出的时候，返回地址就是 通过异常处理器 来确定的，栈帧中 一般不会保存这部分信息 （主调方法的PC计数器值）</p>
<h5 id="方法退出的过程"><a href="#方法退出的过程" class="headerlink" title="方法退出的过程"></a>方法退出的过程</h5><p>方法退出的过程实际上等同于<strong>把 当前栈帧出栈</strong>，因此退出时可能执行的操作有：</p>
<ul>
<li>恢复上层主调方法的局部变量表和操作数栈，</li>
<li>把返回值（如果有的话） 压入 调用者（主调方法对应的）栈帧的操作数栈中，</li>
<li>调整PC计数器值 以指向方法调用指令后面的 的一条指令等。</li>
</ul>
<p>这些都是 基于概念模型的讨论，只有具体到某一款 java虚拟机实现，会执行哪些操作才能确定下来</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>
<p>在讨论概念时候，一般会把 <strong>动态连接，方法返回地址 与 其他附加信息</strong>全部归为一类，称为<strong>栈帧信息</strong> 。</p>
<h2 id="方法调用详解（TODO）"><a href="#方法调用详解（TODO）" class="headerlink" title="方法调用详解（TODO）"></a>方法调用详解（TODO）</h2><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体执行过程。</p>
<p>在程序执行时，进行方法调用是最普遍最频繁的操作之一，Class文件的编译过程中 不包含传统程序语言编译的连接步骤，一切方法调用在Class文件 里面存储的都是 符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。 这个特性给了Java带来了更强大的动态扩展能力，也使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用的目标方法在Class 文件里面都是一个 常量池的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是:  方法在程序真正执行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。 换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<strong>解析</strong>（<strong>Resolution</strong>）</p>
<h4 id="编译期可知，运行期不可变"><a href="#编译期可知，运行期不可变" class="headerlink" title="编译期可知，运行期不可变"></a>编译期可知，运行期不可变</h4><p>在Java语言中，符合“编译期可知，运行期不可变”这个要求的方法，主要有 <strong>静态方法</strong> 和<strong>私有方法</strong>两大类，前者与类型直接关联，后者在外部不可访问，这两种方法各自的特点决定了他们都不可能通过继承或 别的方式重写出其他版本，因为它们都适合在类解析阶段进行解析。</p>
<h4 id="方法调用字节码指令"><a href="#方法调用字节码指令" class="headerlink" title="方法调用字节码指令"></a>方法调用字节码指令</h4><p>调用不同类型的方法，字节码指令集里面设计了不同的指令。在Java虚拟机支持 以下5条方法调用字节码指令，分别是：</p>
<ol>
<li>invokestatic ： 用于调用静态方法</li>
<li>invokespecial：  用于调用实例构造器<init>()方法、私有方法和父类中的方法</li>
<li>invokevirtual :  用于调用所有的虚方法</li>
<li>invokeinterface: 用于调用接口方法，会在运行时在确定一个实现该接口的对象</li>
<li>invokedynamic：  现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ol>
<h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><ul>
<li>前面的1-4条调用指令，分配逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</li>
<li>只要能被invokespecial 和 invokestatic指令调用的方法，都可以在解析阶段中确定唯一的调用版本 ，Java语言里符合这个条件的方法 有： </li>
</ul>
<p><strong>静态方法、私有方法、实例构造器、父类方法</strong>4种，再加上被 final修饰的方法（尽管它用invokevirtual）指令调用，这5种方法调用会再类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“<strong>非虚方法</strong>”（<strong>Non-Virtual Method</strong>），与之相反的，其他方法就被称为 <strong>虚方法（Virtual Method）</strong></p>
<p>方法静态解析演示：</p>
<p>演示了一种常见的解析调用的例子，该样例中，<strong>静态方法sayHello 只可能属于类型 StaticResolution ，没有任何途径可以覆盖或隐藏这个方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态解析演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticResolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticResolution.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 javap -verbose StaticResolution.class   得到下面结果：</p>
<p>使用javap命令查看这段程序对应的字节码，会发现的确是通过<strong>invokestatic</strong>命令来调用sayHello()方法，而且其调用的方法版本已经在编译时就明确以<strong>常量池项的形式</strong>固化在字节码指令的参数之中（ #5 = Methodref ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> Last modified <span class="number">2021</span>-<span class="number">1</span>-<span class="number">18</span>; size <span class="number">672</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">4041d</span>61106416a1bb60c338694bf8d00</span><br><span class="line">  Compiled from <span class="string">&quot;StaticResolution.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter8</span>.<span class="title">StaticResolution</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">53</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#22         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #25            // hello world</span><br><span class="line">   #4 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Methodref          #6.#28         // org/fenixsoft/jvm/chapter8/StaticResolution.sayHello:()V</span><br><span class="line">   #6 = Class              #29            // org/fenixsoft/jvm/chapter8/StaticResolution</span><br><span class="line">   #7 = Class              #30            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticResolution;</span><br><span class="line">  #15 = Utf8               sayHello</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               StaticResolution.java</span><br><span class="line">  #22 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #23 = Class              #31            // java/lang/System</span><br><span class="line">  #24 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;</span><br><span class="line">  #25 = Utf8               hello world</span><br><span class="line">  #26 = Class              #34            // java/io/PrintStream</span><br><span class="line">  #27 = NameAndType        #35:#36        // println:(Ljava/lang/String;)V</span><br><span class="line">  #28 = NameAndType        #15:#9         // sayHello:()V</span><br><span class="line">  #29 = Utf8               org/fenixsoft/jvm/chapter8/StaticResolution</span><br><span class="line">  #30 = Utf8               java/lang/Object</span><br><span class="line">  #31 = Utf8               java/lang/System</span><br><span class="line">  #32 = Utf8               out</span><br><span class="line">  #33 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #34 = Utf8               java/io/PrintStream</span><br><span class="line">  #35 = Utf8               println</span><br><span class="line">  #36 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.jvm.chapter8.StaticResolution();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticResolution;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: invokestatic  #5                  // Method sayHello:()V</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticResolution.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java中的非虚方法除了使用  <strong>invokespecial、invokestatic</strong> 调用的方法之外，还有一种就是 <strong>被final 修饰的实例方法</strong>。历史设计的原因，final 方法使用的是 <strong>invokevirtual</strong> 指令调用的，但是因为它无法被覆盖，没有其他版本的可能，所以也无须 对方法接收者 进行多态选择，又或者说 多态选择的结果肯定是唯一的。</p>
<p>再《Java语言规范》中明确定义了被 final修饰的方法是一种<strong>非虚方法</strong>.</p>
<h4 id="解析调用："><a href="#解析调用：" class="headerlink" title="解析调用："></a>解析调用：</h4><p>解析调用一定是一个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部 转变为 明确的直接引用，不必延迟到运行期再去完成。</p>
<h4 id="分派调用："><a href="#分派调用：" class="headerlink" title="分派调用："></a>分派调用：</h4><p>另一种主要的方法调用形式：  <strong>分派（Dispatch）</strong>调用则复杂许多，它可能是静态的也可能是动态的，按照分派依据 的宗量数可分为 <strong>单分派</strong> 和 <strong>多分派</strong>。 这两类分派两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派 4种分派组合情况 </p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>As we all know, Java 是一门面向对象的程序语言，因为java具备面向对象的 3个基本特征：  <strong>继承、封装 和多态。</strong></p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p> <strong>“分派”（Dispatch）</strong> 这个词本身就具有动态性，一般不应用在静态语境中。这部分原本在 英文原版的《Java虚拟机规范》和 《Java语言规范》里的说法都是:  </p>
<p>“Method Overload Resolution 方法重载解析” ,但部分外文资料和国内翻译的许多中文资料都将这种行为 称为 “静态分派”。</p>
<p>为了解释静态分派和重载（Overload），笔者准备了一段经常出现在面试题中的程序代码，读者不妨先看一遍，想一下程序的输出结果是什么。后面的话题将围绕这个类的方法来编写重载代码，以分析虚拟机和编译器确定方法版本的过程。程序如代码清单8-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    hello,guy!</span><br><span class="line">hello,guy!</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>为什么虚拟机会选择执行参数类型为Human的重载版本呢？在解决这个问题之前，我们先通过如下代码来定义两个关键概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

<ul>
<li>我们把上面代码中的 “Human” 称为 变量的 <strong>“静态类型”（static Type）</strong>，或者叫 <strong>“外观类型”（Apparent Type）</strong>,</li>
<li>“Man” 则被称为变量的 <strong>“实际类型”（Actual Type）</strong>或者叫做 <strong>“运行时类型”（Runtime Type）</strong>.</li>
<li>静态类型和实际类型在程序中都可能会发生变化，区别是 静态类型的变化仅仅在使用时发生， 变量本身的静态类型不会被改变，并且最终的静态类型在编译期可知的；而 实际类型变化的结果在运行期才可确定，编译期在编译程序的时候并不知道一个对象的实际类型时什么</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象human 的实际类型是可变的，编译期间 它完全是个 “薛定谔的人”，到底是 Man 还是woman，必须等到程序运行到这行的时候才能确定。</p>
</li>
<li><p>而human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()<br>方法的调用，在编译期完全可以明确转型的是Man还是Woman。</p>
</li>
</ul>
<p>main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全<strong>取决于传入参数的数量和数据类型</strong>。</p>
<p>代码中故意<strong>定义了两个静态类型相同</strong>，而<strong>实际类型不同的变量</strong>，但虚拟机（或者准确地说是编译器）<strong>在重载时是通过参数的静态类型</strong>而<strong>不是实际类型</strong>作为判定依据的。由于<strong>静态类型在编译期可知</strong>，所以<strong>在编译阶段</strong>，Javac编译器就<strong>根据参数的静态类型决定了会使用哪个重载版本</strong>，因此选择了<strong>sayHello(Human)作为调用目标</strong>，并把<strong>这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter8</span>.<span class="title">StaticDispatch</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">53</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #14.#44        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #45.#46        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #47            // hello,guy!</span><br><span class="line">   #4 = Methodref          #48.#49        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = String             #50            // hello,gentleman!</span><br><span class="line">   #6 = String             #51            // hello,lady!</span><br><span class="line">   #7 = Class              #52            // org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">   #8 = Methodref          #7.#44         // org/fenixsoft/jvm/chapter8/StaticDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 = Class              #53            // org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">  #10 = Methodref          #9.#44         // org/fenixsoft/jvm/chapter8/StaticDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = Class              #54            // org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">  #12 = Methodref          #11.#44        // org/fenixsoft/jvm/chapter8/StaticDispatch.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #13 = Methodref          #11.#55        // org/fenixsoft/jvm/chapter8/StaticDispatch.sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #14 = Class              #56            // java/lang/Object</span><br><span class="line">  #15 = Utf8               Woman</span><br><span class="line">  #16 = Utf8               InnerClasses</span><br><span class="line">  #17 = Utf8               Man</span><br><span class="line">  #18 = Class              #57            // org/fenixsoft/jvm/chapter8/StaticDispatch$Human</span><br><span class="line">  #19 = Utf8               Human</span><br><span class="line">  #20 = Utf8               &lt;init&gt;</span><br><span class="line">  #21 = Utf8               ()V</span><br><span class="line">  #22 = Utf8               Code</span><br><span class="line">  #23 = Utf8               LineNumberTable</span><br><span class="line">  #24 = Utf8               LocalVariableTable</span><br><span class="line">  #25 = Utf8               this</span><br><span class="line">  #26 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">  #27 = Utf8               sayHello</span><br><span class="line">  #28 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #29 = Utf8               guy</span><br><span class="line">  #30 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">  #31 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;)V</span><br><span class="line">  #32 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;</span><br><span class="line">  #33 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;)V</span><br><span class="line">  #34 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;</span><br><span class="line">  #35 = Utf8               main</span><br><span class="line">  #36 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #37 = Utf8               args</span><br><span class="line">  #38 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #39 = Utf8               man</span><br><span class="line">  #40 = Utf8               woman</span><br><span class="line">  #41 = Utf8               sr</span><br><span class="line">  #42 = Utf8               SourceFile</span><br><span class="line">  #43 = Utf8               StaticDispatch.java</span><br><span class="line">  #44 = NameAndType        #20:#21        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #45 = Class              #58            // java/lang/System</span><br><span class="line">  #46 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #47 = Utf8               hello,guy!</span><br><span class="line">  #48 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #49 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #50 = Utf8               hello,gentleman!</span><br><span class="line">  #51 = Utf8               hello,lady!</span><br><span class="line">  #52 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">  #53 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">  #54 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">  #55 = NameAndType        #27:#28        // sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #56 = Utf8               java/lang/Object</span><br><span class="line">  #57 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Human</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.jvm.chapter8.StaticDispatch();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Human)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello,guy!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Man)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #5                  // String hello,gentleman!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">23</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Woman)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #6                  // String hello,lady!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">27</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #7                  // class org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #8                  // Method org/fenixsoft/jvm/chapter8/StaticDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: new           #9                  // class org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        12: invokespecial #10                 // Method org/fenixsoft/jvm/chapter8/StaticDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        16: new           #11                 // class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">        <span class="number">19</span>: dup</span><br><span class="line">        20: invokespecial #12                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">23</span>: astore_3</span><br><span class="line">        <span class="number">24</span>: aload_3</span><br><span class="line">        <span class="number">25</span>: aload_1</span><br><span class="line">        26: invokevirtual #13                 //这里： Method sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">        <span class="number">29</span>: aload_3</span><br><span class="line">        <span class="number">30</span>: aload_2</span><br><span class="line">        31: invokevirtual #13                 //这里： Method sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">        <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">31</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">32</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">33</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">34</span>: <span class="number">24</span></span><br><span class="line">        line <span class="number">35</span>: <span class="number">29</span></span><br><span class="line">        line <span class="number">36</span>: <span class="number">34</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">35</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">27</span>     <span class="number">1</span>   man   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">           <span class="number">16</span>      <span class="number">19</span>     <span class="number">2</span> woman   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">           <span class="number">24</span>      <span class="number">11</span>     <span class="number">3</span>    sr   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticDispatch.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     static #15= #9 of #11; //Woman=class org/fenixsoft/jvm/chapter8/StaticDispatch$Woman of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">     static #17= #7 of #11; //Man=class org/fenixsoft/jvm/chapter8/StaticDispatch$Man of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">     static abstract #19= #18 of #11; //Human=class org/fenixsoft/jvm/chapter8/StaticDispatch$Human of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br></pre></td></tr></table></figure>



<p>所有依赖静态类型来决定执行版本的分派动作，都被称为 <strong>静态分派</strong>。 静态分配的最典型应用表现就是 <strong>方法重载</strong>。 静态分派 发生在编译阶段，因此确定静态分派的动作实际上并不是由虚拟机来执行的 ，这点也是为什么一些资料选择把它归入 为 “解析”而不是 “分派”的原因。</p>
<h5 id="重载方法匹配优先级"><a href="#重载方法匹配优先级" class="headerlink" title="重载方法匹配优先级"></a>重载方法匹配优先级</h5><p>需要注意Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个“相对更合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是个比较稀罕的事件，产生这种模糊结论的主要原因是字面量天生的模糊性，它不需要定义，所以字面量就没有显式的静态类型，它的静态类型只能通过语言、语法的规则去理解和推断。代码清单8-7演示了何谓“更加合适的”版本。</p>
<p>代码清单8-7　重载方法匹配优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Character&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Serializable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一次运行结果： <strong>hello char</strong>，这很好理解，’a’是一个char类型的数据，自然会寻找参数类型为char的重载方法，</p>
</li>
<li><p>如果注释掉 sayHello(char arg)方法，那输出会变为：<strong>hello int</strong> ，这时发生了一次自动类型转换，’a’除了可以代表一个字符串，还可以代表数字97（字符’a’的<br>Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的</p>
</li>
<li><p>我们继续注释掉sayHello(int arg)方法，那输出会变为： <strong>hello long</strong> .这时发生了两次自动类型转换，’a’转型为整数97之后，进一步转型为长整数97L，匹配了参数类型为long的重载。笔者在代码中没有写其他的类型如float、double等的重载，不过实际上自动转型还能继续发生多次，按照<strong>char&gt;int&gt;long&gt;float&gt;double的顺序转型进行匹配</strong>，但<strong>不会匹配到byte和short类型的重载</strong>，因为<strong>char到byte或short的转型是不安全的</strong>。</p>
</li>
<li><p>继续注释掉sayHello(long arg)方法，那输出会变为 : <strong>hello Character</strong>  ，这时发生了一次自动装箱，’a’被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为Character的重载</p>
</li>
<li><p>继续注释掉sayHello(Character arg)方法，那输出会变为： <strong>hello Serializable</strong>,  出现hello Serializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类所实现的接口类型，所以紧接着又发生一次自动转型。char可以转型成int，<br>但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现了另外一个接口java.lang.Comparable<Character>，如果同时出现两个参数分别为Serializable和Comparable<Character>的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示“类型模糊”（Type Ambiguous），并拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如：sayHello((Comparable<Character>)’a’)，才能编译通过</p>
</li>
<li><p>继续注释掉sayHello(Serializable arg)方法，输出会变为： <strong>hello Object</strong> ，这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。</p>
</li>
<li><p>我们把sayHello(Objectarg)也注释掉，输出将会变为： <strong>hello char …</strong>,7个重载方法已经被注释得只剩1个了，可见变长参数的重载优先级是最低的，这时候字符’a’被当作了一个char[]数组的元素。笔者使用的是char类型的变长参数，读者在验证时还可以选择int类型、Character类型、Object类型等的变长参数重载来把上面的过程重新折腾一遍。但是要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的[2]。</p>
</li>
</ul>
<p>另外还有一点读者可能比较容易混淆：笔者讲述的<strong>解析与分派这两者之间的关系并不是二选一的排他关系</strong>，它们是在<strong>不同层次上去筛选、确定目标方法</strong>的过程。例如前面说过静态方法会在编译期确定、在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，<strong>选择重载版本的过程也是通过静态分派</strong>完成的</p>
<ul>
<li>可以这么理解吗： <strong>overload重载是gen据静态类型来决定的（静态分派），  override是根据 实际类型来决定的（动态分派）。</strong></li>
</ul>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>看一下Java语言里动态分派的实现过程，它与Java语言多态性的另外一个重要体现[3]——重写（Override）有着很密切的关联。我们还是用前面的Man和Woman一起 sayHello的例子来讲解动态分派，请看代码清单8-8中所示的代码。</p>
<p>代码清单8-8　方法动态分派演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>

<h5 id="Java虚拟机是如何判断应该调用哪个方法"><a href="#Java虚拟机是如何判断应该调用哪个方法" class="headerlink" title="Java虚拟机是如何判断应该调用哪个方法"></a>Java虚拟机是如何判断应该调用哪个方法</h5><ul>
<li>可以这么理解吗： <strong>overload重载是gen据静态类型来决定的（静态分派），  override是根据 实际类型来决定的（动态分派）。</strong></li>
</ul>
<p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为<strong>静态类型同样都是Human的两个变量</strong>man和woman在调用sayHello()方法时产生了不同的行为，甚至变量man在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是因为这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？我们使用javap命令输出这段代码的字节码，尝试从中寻找答案，输出结果如代码清单8-9所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">	Code:</span><br><span class="line">        Stack=2, Locals=3, Args_size=1</span><br><span class="line">        0: new <span class="comment">#16; //class org/fenixsoft/polymorphic/DynamicDispatch$Man</span></span><br><span class="line">        3: dup</span><br><span class="line">        4: invokespecial <span class="comment">#18; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        7: astore_1</span><br><span class="line">        8: new <span class="comment">#19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span></span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial <span class="comment">#21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        24: new <span class="comment">#19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span></span><br><span class="line">        27: dup</span><br><span class="line">        28: invokespecial <span class="comment">#21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        31: astore_1</span><br><span class="line">        32: aload_1</span><br><span class="line">        33: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        36: <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>0～15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表的变量槽中，这些动作实际对应了Java源码中的这两行： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>

<p>接下来的16～21行是关键部分，16和20行的<strong>aload指令</strong>分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为接收者（Receiver）；</p>
<p>17和21行是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）都完全一样，但是这两句指令最终执行的目标方法并不相同。那看来解决问题的关键还必须从invokevirtual指令本身入手，要弄清楚它是如何确定调用方法版本、如何实现多态查找来着手分析才行。根据《Java虚拟机规范》，invokevirtual指令的运行时解析过程[4]大致分为以下几步：</p>
<ol>
<li><strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</strong>。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，<strong>如果通过则返回这个方法的直接引用</strong>，查找过程结束；不通过则返回java.lang.<strong>IllegalAccessError</strong>异常。</li>
<li>否则，按照<strong>继承关系从下往上依次</strong>对C的各个父类进行第二步的<strong>搜索和验证</strong>过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.<strong>AbstractMethodError</strong>异常。</li>
</ol>
<p>正是因为invokevirtual指令执行的<strong>第一步就是在运行期确定接收者的实际类型</strong>，所以两次调用中的invokevirtual指令并<strong>不是把常量池中方法的符号引用解析到直接引用上</strong>就结束了，还会<strong>根据方法接收者的实际类型来选择方法版本</strong>，这个过程就是<strong>Java语言中方法重写的本质</strong>。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为<strong>动态分派。</strong></p>
<p>既然这种多态性的<strong>根源在于虚方法调用指令invokevirtual的执行逻辑</strong>，那自然我们得出的结论就<strong>只会对方法有效，对字段是无效的，因为字段不使用这条指令</strong>。事实上，在Java里面只有虚方法存在，字段永远不可能是虚的，</p>
<p>换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。<strong>当子类声明了与父类同名的字段时</strong>，虽然在子类的内存中两个字段都会存在，但是<strong>子类的字段会遮蔽父类的同名字段</strong>。</p>
<p>为了加深理解，又编撰了一份“劣质面试题式”的代码片段，请阅读代码清单8-10，思考运行后会输出什么结果。</p>
<p>代码清单8-10　字段没有多态性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段不参与多态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHasNoPolymorphic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            money = <span class="number">2</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Father, i have $&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            money = <span class="number">4</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Son,  i have $&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father gay = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">&quot;This gay has $&quot;</span> + gay.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果为: </span><br><span class="line">I am Son,  i have $<span class="number">0</span></span><br><span class="line">I am Son,  i have $<span class="number">4</span></span><br><span class="line">This gay has $<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出两句都是“I am Son”，</p>
<ul>
<li>这是因为Son类在创建的时候，首先隐式调用了<strong>Father的构造函数</strong>，而Father构造函数中<strong>对showMeTheMoney()的调用是一次虚方法调用</strong>，实际执行的版本是Son::showMeTheMoney()方法，所以输出的是“I am Son”，这点经过前面的分析相信读者是没有疑问的了。</li>
<li>而这时候虽然父类的money字段已经被初始化成2了，但Son::showMeTheMoney()方法中访问的却是<strong>子类的money字段</strong>，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。</li>
<li>main()的最后一句<strong>通过静态类型访问到了父类中的money</strong>，输出了2。</li>
</ul>
<p><strong>todo  消化一下</strong></p>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><h5 id="宗量"><a href="#宗量" class="headerlink" title="宗量"></a>宗量</h5><p>方法的接收者与方法的参数统称为方法的<strong>宗量</strong></p>
<p>根据分派基于多少种宗量，可以将分派划分为<strong>单分派</strong>和<strong>多分派</strong>两种。</p>
<p>单分派 是根据<strong>一个宗量对目标进行选择</strong>，</p>
<p>多分派则是根据<strong>多于一个宗量对目标方法进行选择。</strong></p>
<p>代码清单：  单分派和多分派</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果： </span><br><span class="line">    father choose <span class="number">360</span></span><br><span class="line">	son choose qq</span><br></pre></td></tr></table></figure>

<ul>
<li>main（）里调用了两次hardChoice 方法，这两次hardChoice 方法的选择结果在程序输出 中已经显示得很清楚了。 </li>
<li>我们关注得首先是 编译阶段中编译 器的选择过程，也就是静态分派的过程。</li>
<li>选择目标的依据有两点：<ul>
<li>一个是静态类型是 Father 还是SON</li>
<li>二是方法参数是QQ还是360</li>
</ul>
</li>
</ul>
<p>这次选择结果的最终产物是产生了2条invokevirtual 指令，两条指令的参数 分别是常量池中指向 Father:: hardChoice(360)  以及 Father:: hardChoice(QQ)方法的符号引用</p>
<ul>
<li>因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型</li>
</ul>
<h5 id="动态分派的过程"><a href="#动态分派的过程" class="headerlink" title="动态分派的过程"></a>动态分派的过程</h5><p>再看看运行阶段中虚拟机的选择，也就是<strong>动态分派</strong>的过程。</p>
<p>在执行 “son.hardChoice(new QQ()) ” 这行方法时，更准确的说，是在执行这行代码所对应的  Invokevirtual指令时，由于编译期已经决定目标方法的签名 必须为 hardChoice（QQ） ,虚拟机此时 不会关心传递过来的参数 “QQ”到底是 “腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型 都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的接收者的实际类型是 Father 还是 Son 。</p>
<p>因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型 。</p>
<p>根据上述论证的结果，我们可以总结一句： </p>
<p>如今的Java语言是一门静态多分派、动态单分派的语言。</p>
<p>强调”如今的Java语言”是因为这个结论未必会恒久不变。JDK10 时Java语法中新出现 var关键字，</p>
<p>var 是在编译时根据声明语句中赋值符右侧的表达式类型来静态地推断类型。这本质时一种语法糖：</p>
<h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>前面介绍的分派过程，作为对Java虚拟机概念模型的解释基本上已经足够了，它已经解决了虚拟机在分派中“<strong>会做什么</strong>”这问题，但是 问Java虚拟机 “<strong>具体如果做到</strong>” 的，答案则可能因为 各种虚拟机的实现不同会有些差别。</p>
<p>动态分派 是执行非常频繁的动作，而且动态分派的方法版本 选择过程 需要运行时在接收者类型的方法元数据中 选择合适的目标方法，因此Java虚拟机实现基于执行性能的考虑，真实运行时一般不会如此频繁的去反复搜索类型元数据。</p>
<p>面对这种情况，一种基础而且常见的优化手段 是为类型在方法中建一个虚方法表（Virtual Method Table，也称为 vtable），与此对应的，在invokeinterface 执行时也会用到 接口方法表-Interface Method Table，简称itable。 使用虚方法表 索引来代替元数据查找以提高性能。  我们来看看上面代码 所对应的虚方法表结构示例： 如下图所示</p>
<p><img src="/uploads/jvm/11diapatch/methodTable.png"></p>
<p>虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是 一致的，都指向父类的实现入口。</p>
<p>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为 指向子类实现版本的入口地址。</p>
<p>在上图中，son重写了来自 Father的全部方法，因此son的方法表 没有指向Father类型数据的箭头。</p>
<p>但是son 和 Father都没有重写来自Object的方法，所以他们的方法表中所有从Object 继承来的方法都指向了Object的类型数据。</p>
<p>为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中 都应当具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。 <strong>虚方法表一般在类加载的连接阶段进行初始化</strong>，准备了类的变量初始值后，虚拟机 会把 该<strong>类的虚方法表也一同初始化完毕。</strong></p>
<p>上面说的<strong>查虚方法表</strong> 是 <strong>分派调用</strong>的一种<strong>优化手段</strong>，<strong>由于Java对象里面的方法 默认（即不使用final 修饰）就是虚方法</strong>，虚拟机除了使用虚方法表外，为了进一步提高性能，还会使用<strong>类型继承分析（Class Hierarchy Analysis，CHA）</strong> ，<strong>守护内联（Guarded Inlining）</strong>，<strong>内联缓存（Inline Cache）</strong> 等多种非稳定的激进优化来争取更大的性能空间，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">深入理解jvm-10-Java模块化系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-18 23:00:29" itemprop="dateCreated datePublished" datetime="2021-01-18T23:00:29+08:00">2021-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java模块化系统-TODO-DODO"><a href="#Java模块化系统-TODO-DODO" class="headerlink" title="Java模块化系统(TODO DODO)"></a>Java模块化系统(TODO DODO)</h1><p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p>
<ul>
<li>依赖其他模块的列表。</li>
<li>导出的包列表，即其他模块可以使用的列表。</li>
<li>开放的包列表，即其他模块可反射访问模块的列表。</li>
<li>使用的服务列表。</li>
<li>提供服务的实现列表</li>
</ul>
<h2 id="可配置的封装隔离机制"><a href="#可配置的封装隔离机制" class="headerlink" title="可配置的封装隔离机制"></a>可配置的封装隔离机制</h2><ul>
<li>可配置的封装隔离机制首先要解决JDK 9之前基于<strong>类路径（ClassPath）来查找依赖</strong>的可靠性问题。此前，如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常</li>
<li>而在JDK 9以后，如果启用了<strong>模块化进行封装</strong>，模块就可以声明对其他模块的<strong>显式依赖</strong>，这样Java虚拟机就能够在<strong>启动时验证</strong>应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分[1]由于类型依赖而引发的运行时异常</li>
<li>可配置的封装隔离机制还<strong>解决了原来类路径上跨JAR文件的public类型的可访问性问题</strong>。JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更<strong>精细的可访问性控制</strong>，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种<strong>访问控制也主要是在类加载过程中</strong>完成的</li>
</ul>
<h2 id="模块的兼容性"><a href="#模块的兼容性" class="headerlink" title="模块的兼容性"></a>模块的兼容性</h2><ul>
<li>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9提出了与“<strong>类路径</strong>”（ClassPath）相对应的“<strong>模块路径</strong>”（ModulePath）的概念</li>
<li>就是某个类库到底是模块还是传统的JAR包，只取决于<strong>它存放在哪种路径上</strong>。</li>
<li>只要是放在<strong>类路径上的JAR文件</strong>，无论其中是否包含模块化信息（是否包含了module-info.class文件），它都会被当作<strong>传统的JAR包</strong>来对待；</li>
<li>相应地，只要放在<strong>模块路径上的JAR文件</strong>，即使没有使用JMOD后缀，甚至说其中并不包含module-info.class文件，它也仍然会被当作一个<strong>模块</strong>来对待。</li>
</ul>
<h3 id="保障规则："><a href="#保障规则：" class="headerlink" title="保障规则："></a>保障规则：</h3><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上，即使这些版本的JDK已经使用模块来封装了Java SE的标准类库，模块化系统的这套规则也仍然保证了传统程序可以访问到所有标准类库模块中导出的包</p>
<h4 id="JAR文件在类路径的访问规则"><a href="#JAR文件在类路径的访问规则" class="headerlink" title="JAR文件在类路径的访问规则"></a>JAR文件在类路径的访问规则</h4><ul>
<li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li>
</ul>
<h4 id="模块在模块路径的访问规则"><a href="#模块在模块路径的访问规则" class="headerlink" title="模块在模块路径的访问规则"></a>模块在模块路径的访问规则</h4><ul>
<li>模块在模块路径的访问规则：模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</li>
</ul>
<h4 id="JAR文件在模块路径的访问规则"><a href="#JAR文件在模块路径的访问规则" class="headerlink" title="JAR文件在模块路径的访问规则"></a>JAR文件在模块路径的访问规则</h4><ul>
<li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li>
</ul>
<p>以上3条规则保证了即使Java应用依然使用传统的类路径，升级到JDK 9对应用来说几乎（类加载器上的变动还是可能会导致少许可见的影响，将在下节介绍）不会有任何感觉，项目也不需要专门为了升级JDK版本而去把传统JAR包升级成模块。</p>
<p>除了向后兼容性外，随着JDK 9模块化系统的引入，更值得关注的是它本身面临的模块间的管理和兼容性问题：如果同一个模块发行了多个不同的版本，那只能由开发者在编译打包时人工选择好正确版本的模块来保证依赖的正确性。Java模块化系统目前不支持在模块定义中加入版本号来管理和约束依赖，本身也不支持多版本号的概念和版本选择功能。</p>
<p>我们不论是在Java命令、Java类库的API抑或是《Java虚拟机规范》定义的Class文件格式里都能轻易地找到证据，表明模块版本应是编译、加载、运行期间<br>都可以使用的。譬如输入“java–list-modules”，会得到明确带着版本号的模块列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.base@12.0.1</span><br><span class="line">java.compiler@12.0.1</span><br><span class="line">java.datatransfer@12.0.1</span><br><span class="line">java.desktop@12.0.1</span><br><span class="line">java.instrument@12.0.1</span><br><span class="line">java.logging@12.0.1</span><br><span class="line">java.management@12.0.1</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>在JDK 9时加入Class文件格式的<strong>Module属性</strong>，里面有<strong>module_version_index</strong>这样的字段，用户可以在编译时使用“<strong>javac–module-version</strong>”来指定模块版本，在Java类库API中也存在java.lang.module.ModuleDescriptor.Version这样的接口可以在运行时获取到模块的版本号。这一切迹象都证明了<strong>Java模块化系统对版本号的支持本可以不局限在编译期</strong>。</p>
<h2 id="模块化下的类加载器"><a href="#模块化下的类加载器" class="headerlink" title="模块化下的类加载器"></a>模块化下的类加载器</h2><p>为了保证兼容性，JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架构以及双亲委派模型。但是为了模块化系统的顺利施行，模块化下的类加载器仍然发生了一些应该被注意到变动，主要包括以下几个方面。</p>
<h3 id="扩展类加载器被取代"><a href="#扩展类加载器被取代" class="headerlink" title="扩展类加载器被取代"></a>扩展类加载器被取代</h3><ul>
<li>首先，是扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。</li>
<li>这其实是一个很顺理成章的变动，既然整个JDK都基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留**<JAVA_HOME>\lib\ext**目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了，用来加载这部分类库的扩展类加载器也完成了它的历史使命。</li>
<li>类似地，在新版的JDK中也<strong>取消了<JAVA_HOME>\jre</strong>目录，因为随时可以组合构建出程序运行所需的JRE来，譬如假设我们只使用java.base模块中的类型，那么随时可以通过以下命令打包出一个“JRE”：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jlink -p <span class="variable">$JAVA_HOME</span>/jmods --add-modules java.base --output jre</span><br></pre></td></tr></table></figure>

<h3 id="BuiltinClassLoade"><a href="#BuiltinClassLoade" class="headerlink" title="BuiltinClassLoade"></a>BuiltinClassLoade</h3><ul>
<li>其次，平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK 9及更高版本的JDK中崩溃。</li>
<li>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</li>
</ul>
<p><img src="/uploads/jvm/09ClassLoader/01-ClassLoader_before.png"></p>
<p><img src="/uploads/jvm/09ClassLoader/02-ClassLoader_after.png"></p>
<p>图7-6中有“BootClassLoader”存在，启动类加载器现在是在Java虚拟机内部和Java类库共同协作实现的类加载器，尽管有了BootClassLoader这样的Java类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景（譬如Object.class.getClassLoader()）中仍然会返回null来代替，而不会得到BootClassLoader的实例。</p>
<h3 id="类加载的委派关系发生了变动"><a href="#类加载的委派关系发生了变动" class="headerlink" title="类加载的委派关系发生了变动"></a>类加载的委派关系发生了变动</h3><p><img src="source/uploads/jvm/09ClassLoader/03-ClassLoader_Parentnew.png"></p>
<p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。</p>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，也许这可以算是对双亲委派的第四次破坏。</p>
<h4 id="类加载器负责加载的模块"><a href="#类加载器负责加载的模块" class="headerlink" title="类加载器负责加载的模块"></a>类加载器负责加载的模块</h4><h5 id="启动类加载器负责加载的模块"><a href="#启动类加载器负责加载的模块" class="headerlink" title="启动类加载器负责加载的模块"></a>启动类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.base java.security.sasl</span><br><span class="line">java.datatransfer java.xml</span><br><span class="line">java.desktop jdk.httpserver</span><br><span class="line">java.instrument jdk.internal.vm.ci</span><br><span class="line">java.logging jdk.management</span><br><span class="line">java.management jdk.management.agent</span><br><span class="line">java.management.rmi jdk.naming.rmi</span><br><span class="line">java.naming jdk.net</span><br><span class="line">java.prefs jdk.sctp</span><br><span class="line">java.rmi jdk.unsupported</span><br></pre></td></tr></table></figure>



<h5 id="平台类加载器负责加载的模块"><a href="#平台类加载器负责加载的模块" class="headerlink" title="平台类加载器负责加载的模块"></a>平台类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.activation* 					jdk.accessibility</span><br><span class="line">java.compiler* 						jdk.charsets</span><br><span class="line">java.corba* 						jdk.crypto.cryptoki</span><br><span class="line">java.scripting 						jdk.crypto.ec</span><br><span class="line">java.se 							jdk.dynalink</span><br><span class="line">java.se.ee 							jdk.incubator.httpclient</span><br><span class="line">java.security.jgss					jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio 					jdk.jsobject</span><br><span class="line">java.sql 							jdk.localedata</span><br><span class="line">java.sql.rowset						jdk.naming.dns</span><br><span class="line">java.transaction* 					jdk.scripting.nashorn</span><br><span class="line">java.xml.bind* 						jdk.security.auth</span><br><span class="line">java.xml.crypto 					jdk.security.jgss</span><br><span class="line">java.xml.ws* 						jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation* 			jdk.zipfs</span><br></pre></td></tr></table></figure>

<h5 id="应用程序类加载器负责加载的模块"><a href="#应用程序类加载器负责加载的模块" class="headerlink" title="应用程序类加载器负责加载的模块"></a>应用程序类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jdk.aot 						jdk.jdeps</span><br><span class="line">jdk.attach 						jdk.jdi</span><br><span class="line">jdk.compiler 					jdk.jdwp.agent</span><br><span class="line">jdk.editpad 					jdk.jlink</span><br><span class="line">jdk.hotspot.agent 				jdk.jshell</span><br><span class="line">jdk.internal.ed					jdk.jstatd</span><br><span class="line">jdk.internal.jvmstat 			jdk.pack</span><br><span class="line">jdk.internal.le 				jdk.policytool</span><br><span class="line">jdk.internal.opt 				jdk.rmic</span><br><span class="line">jdk.jartool 					jdk.scripting.nashorn.shell</span><br><span class="line">jdk.javadoc 					jdk.xml.bind*</span><br><span class="line">jdk.jcmd 						jdk.xml.ws*</span><br><span class="line">jdk.jconsole</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">深入理解jvm-09-类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-18 20:53:23" itemprop="dateCreated datePublished" datetime="2021-01-18T20:53:23+08:00">2021-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>Java虚拟机设计团队 有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流” 这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 “<strong>类加载器</strong>”（Class Loader）。</p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><ul>
<li>类加载器虽然只用于实现类的加载，但它在Java程序中起到的作用却<strong>远超类加载阶段</strong>。</li>
<li>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的<strong>唯一性</strong>，<strong>每一个类加载器都拥有一个独立的类名称空间</strong>。</li>
<li>比较2个类是否“<strong>相等</strong>”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这2个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这2个类就必定不相等。</li>
<li>这里所说的“相等”，包括了类的Class对象的 equals() 、isAssignableFrom()、 isInstance()方法的返回结果，也包括了使用instanceof 关键字做对象所属关系判断等 各种情况。</li>
<li>下面代码演示了不同的类加载器对instanceof关键字运算的结果的影响</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;org.fenixsoft.jvm.chapter7.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.jvm.chapter7.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter7</span>.<span class="title">ClassLoaderTest</span></span></span><br><span class="line"><span class="class">	<span class="title">false</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码构造了一个简单的类加载器，它可以加载与自己在同意路径下的Class 文件，我们使用这个类加载器去加载了一个名为 “ class org.fenixsoft.jvm.chapter7.ClassLoaderTest” 的类，并实例化了这个类的对象。</li>
<li>todo： 看一下类加载器的源码，如：loadClass（）、defineClass（）等</li>
<li>两行输出结果中，从第一行可以看到这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化出来的，但在第二行的输出中却发现这个对象与类org.fenixsoft.classloading.ClassLoaderTest做所属类型检查的时候返回了false。 </li>
<li> 因为Java虚拟机中同时存在两个 ClassLoaderTest 类，一个是由虚拟机的应用程序类加载器所加载的， 另一个是我们自定义的类加载器加载的，虽然他们都来自于同一个Class文件，但在JVM中仍然是两个互相独立的类，做对象所属类型检查时的结果自然为false。</li>
</ul>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>站在Java 虚拟机的角度来看，只存在2种不同的类加载器：</p>
<ul>
<li> 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器由C++ 语言实现，是虚拟机自身的一部分</li>
<li>另一种就是其他所有的类加载器，这些类加载器都有Java语言实现，独立存在虚拟机外部，全部继承自抽象类 java.lang.ClassLoader</li>
</ul>
<p>站在Java开发人员的角度来看，类加载器应当划分的更细致一些，从JDK1.2以来，Java一直保持 3层类加载器、双亲委派的 类加载架构。</p>
<p>3层类加载器：</p>
<h3 id="启动类加载器（Bootstrap-ClassLoader）："><a href="#启动类加载器（Bootstrap-ClassLoader）：" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）："></a>启动类加载器（Bootstrap ClassLoader）：</h3><ul>
<li>负责加载存放在%JAVA_HOME%\lib 目录，或者被 -Xbootclasspath 参数所指定的路径存放的，而且是Java虚拟机能够识别的（PS：java虚拟机识别是按照文件名识别的，如rt.jar,  tool.jar ，名字不符合类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li>
<li>启动类加载器无法被java程序直接引用，用户在编写自定义的ClassLoader 时，如果需要把加载请求委派给  启动类加载器 去处理，直接使用<strong>null</strong> 代替即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the class loader for the class.  Some implementations may use </span></span><br><span class="line"><span class="comment">    * null to represent the bootstrap class loader. This method will return</span></span><br><span class="line"><span class="comment">    * null in such implementations if this class was loaded by the bootstrap</span></span><br><span class="line"><span class="comment">    * class loader.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; If a security manager is present, and the caller&#x27;s class loader is</span></span><br><span class="line"><span class="comment">    * not null and the caller&#x27;s class loader is not the same as or an ancestor of</span></span><br><span class="line"><span class="comment">    * the class loader for the class whose class loader is requested, then</span></span><br><span class="line"><span class="comment">    * this method calls the security manager&#x27;s &#123;<span class="doctag">@code</span> checkPermission&#125;</span></span><br><span class="line"><span class="comment">    * method with a &#123;<span class="doctag">@code</span> RuntimePermission(&quot;getClassLoader&quot;)&#125;</span></span><br><span class="line"><span class="comment">    * permission to ensure it&#x27;s ok to access the class loader for the class.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this object</span></span><br><span class="line"><span class="comment">    * represents a primitive type or void, null is returned.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the class loader that loaded the class or interface</span></span><br><span class="line"><span class="comment">    *          represented by this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">    *    if a security manager exists and its</span></span><br><span class="line"><span class="comment">    *    &#123;<span class="doctag">@code</span> checkPermission&#125; method denies</span></span><br><span class="line"><span class="comment">    *    access to the class loader for the class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.ClassLoader</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ClassLoader cl = getClassLoader0();</span><br><span class="line">       <span class="keyword">if</span> (cl == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Returns the class loader for the class.  Some implementations may use     <strong>null to represent the bootstrap class loader.</strong> </p>
<p>This method will <strong>return  null in</strong> such implementations if this class was <strong>loaded by the bootstrap  class loader</strong>.</p>
<h3 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h3><ul>
<li><p>这个类加载器时在类 sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。</p>
</li>
<li><p>它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
</li>
<li><p>根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代</p>
</li>
<li><p>由于扩展类加载器是由 Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载 Class文件</p>
</li>
</ul>
<h3 id="应用程序类加载器（Application-Class-Loader）"><a href="#应用程序类加载器（Application-Class-Loader）" class="headerlink" title="应用程序类加载器（Application Class Loader）"></a>应用程序类加载器（Application Class Loader）</h3><ul>
<li>这个类加载器由sun.misc.Launcher$AppClassLoader来实现</li>
<li>由于应用程序类加载器是ClassLoader类中的getSystem- ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。</li>
<li>它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li>
<li>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h3 id="类加载器双亲委派模型"><a href="#类加载器双亲委派模型" class="headerlink" title="类加载器双亲委派模型"></a>类加载器双亲委派模型</h3><p><strong>图7-2　类加载器双亲委派模型</strong></p>
<pre class="mermaid">classDiagram
BootstrapClassLoader <-- ExtensionClassLoader : 父亲
ExtensionClassLoader <-- ApplicationClassLoader : 父亲
ApplicationClassLoader <-- Custom_ClassLoader1 : 父亲
ApplicationClassLoader <-- Custom_ClassLoader2 : 父亲</pre>

<ul>
<li><p>图7-2中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents DelegationModel）”。</p>
</li>
<li><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
</li>
<li><p>不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
</li>
<li><p>类加载器的双亲委派模型在JDK 1.2时期被引入，并被广泛应用于此后几乎所有的Java程序中，但它并不是一个具有强制性约束力的模型，而是Java设计者们推荐给开发者的一种类加载器实现的最佳实践。</p>
</li>
</ul>
<h4 id="双亲委派工作过程"><a href="#双亲委派工作过程" class="headerlink" title="双亲委派工作过程"></a>双亲委派工作过程</h4><ul>
<li>如果一个ClassLoader 收到了 类加载的请求，</li>
<li>它首先不会自己去尝试加载这个类，而是把这个请求委派给 <strong>父类加载器</strong> 去完成，每一个层次的类加载器都是如此，</li>
<li>因此所有的加载请求最终都应该送到最顶层的启动类加载器中，</li>
<li>只有当 父类加载器 反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去完成加载。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li>Java中类随着它的类加载器一起具有了一种带有优先级的层次关系。</li>
<li>例如：类java.lang.Object ，它存放在rt.jar 中，无论哪一个类加载要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器 环境中都能保证时同一个类。</li>
<li>反之 如果没有使用双亲委派模型，都有各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现 多个不同的Object类，Java类型体系中最基础的行为也就无从保证。</li>
</ul>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">	<span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 在父类加载器无法加载时</span></span><br><span class="line">	<span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑清晰易懂：</p>
<ul>
<li><p>先检查请求加载的类型是否已经被加载过，</p>
<ul>
<li><p>若没有则调用父加载器的loadClass()方法，</p>
</li>
<li><p>若父加载器为空则默认使用启动类加载器作为父加载器。</p>
</li>
</ul>
</li>
<li><p>假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
</li>
</ul>
<h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<h3 id="第一次破坏双亲委派"><a href="#第一次破坏双亲委派" class="headerlink" title="第一次破坏双亲委派"></a>第一次破坏双亲委派</h3><ul>
<li>第一次 “被破坏”其实发生在<strong>双亲委派模型出现之前</strong>——即JDK 1.2面世以前的“远古”时代。</li>
<li>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了<strong>兼容这些已有代码</strong>，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个<strong>新的protected方法findClass()**，并</strong>引导用户编写的类加载逻辑时尽可能去重写这个方法**，而不是在loadClass()中编写代码。</li>
<li>我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</li>
</ul>
<h3 id="第二次破坏双亲委派"><a href="#第二次破坏双亲委派" class="headerlink" title="第二次破坏双亲委派"></a>第二次破坏双亲委派</h3><ul>
<li>第二次“被破坏”是由这个模型自身的缺陷导致的，</li>
<li>双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，</li>
<li>但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</li>
<li>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</li>
<li>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内<br>都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>
<li>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种<strong>父类加载器去请求子类加载器完成类加载</strong>的行为，这种行为实际上是打通了双亲委派模型的层次结构来<strong>逆向使用类加载器</strong>，已经<strong>违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了<strong>java.util.ServiceLoader类</strong>，以<strong>META-INF/services</strong>中的配置信息，<strong>辅以责任链模式</strong>，这才算是给SPI的加载提供了一种相对合理的解决方案。</li>
</ul>
<h3 id="第三次破坏双亲委派"><a href="#第三次破坏双亲委派" class="headerlink" title="第三次破坏双亲委派"></a>第三次破坏双亲委派</h3><ul>
<li>第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：<strong>代码热替换</strong>（<strong>Hot Swap</strong>）、<strong>模块热部署</strong>（<strong>Hot Deployment</strong>）等。</li>
<li>说白了就是希望Java应用程序能像我们的电脑外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用关机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是大型系统或企业级软件开发者具有很大的吸引力。</li>
</ul>
<h3 id="OSGi实现热部署原理"><a href="#OSGi实现热部署原理" class="headerlink" title="OSGi实现热部署原理"></a>OSGi实现热部署原理</h3><p>OSGi实现模块化热部署的关键是它<strong>自定义的类加载器机制</strong>的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把<strong>Bundle连同类加载器一起换掉</strong>以实现代码的热替换。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以java.*开头的类，委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>上面的查找顺序中只有<strong>开头两点仍然符合双亲委派模型</strong>的原则，其余的类查找都是在<strong>平级的类加载器</strong>中进行的。</p>
<p>虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。</p>
<p><strong>只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新</strong>。</p>
<p>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">深入理解jvm-08-虚拟机类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-14 20:34:10" itemprop="dateCreated datePublished" datetime="2021-01-14T20:34:10+08:00">2021-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机的类加载机制：</p>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<p>在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载稍微增加一些性能开销，</p>
<p>但是却为了Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接的特点实现的。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期都将会经历 加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。 这7个阶段的发生顺序为:</p>
<p><img src="/uploads/jvm/08ClassLoading/01ClassLoadingLifecircle.png"></p>
<ul>
<li>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，</li>
<li>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</li>
<li>请注意，是按部就班地<strong>“开始”</strong>，而不是按部就班地“进行”或按部就班地<strong>“完成”</strong>，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</li>
</ul>
<h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，</p>
<p>这六种场景中的行为称为对一个类型进行主动引用。</p>
<p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p>
<p>下面举三个例子来说明何为被动引用，分别见代码清单7-1、代码清单7-2和代码清单7-3。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><h4 id="通过子类引用父类的静态字段，不会导致子类初始化"><a href="#通过子类引用父类的静态字段，不会导致子类初始化" class="headerlink" title="通过子类引用父类的静态字段，不会导致子类初始化"></a>通过子类引用父类的静态字段，不会导致子类初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示一：</span></span><br><span class="line"><span class="comment">* 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">SuperClass init!</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。</p>
</li>
<li><p>对于静态字段，只有<strong>直接定义这个字段的类</strong>才会被初始化，因此<strong>通过其子类来引用父类中定义的静态字段</strong>，只会<strong>触发</strong><br><strong>父类的初始化</strong>而不会触发子类的初始化。</p>
</li>
<li><p>至于是否要触发子类的加载和验证阶段，在《Java虚拟机规范》中并未明确规定，所以这点取决于虚拟机的具体实现。对于HotSpot虚拟机来说，可通过-XX：+TraceClassLoading参数观察到此操作是会导致子类加载的。</p>
</li>
</ul>
<h4 id="通过数组定义来引用类，不会触发此类的初始化"><a href="#通过数组定义来引用类，不会触发此类的初始化" class="headerlink" title="通过数组定义来引用类，不会触发此类的初始化"></a>通过数组定义来引用类，不会触发此类的初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被动使用类字段演示二：</span><br><span class="line"> * 通过数组定义来引用类，不会触发此类的初始化</span><br><span class="line"> **/</span><br><span class="line">public class NotInitialization_2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SuperClass[] sca = new SuperClass[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 javap -verbose NotInitialization_2.class</span><br><span class="line">&#123;</span><br><span class="line">  public org.fenixsoft.jvm.chapter7.NotInitialization_2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lorg/fenixsoft/jvm/chapter7/NotInitialization_2;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: anewarray     <span class="comment">#2                  // class org/fenixsoft/jvm/chapter7/SuperClass</span></span><br><span class="line">         5: astore_1</span><br><span class="line">         6: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 6</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  args   [Ljava/lang/String;</span><br><span class="line">            6       1     1   sca   [Lorg/fenixsoft/jvm/chapter7/SuperClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行之后发现没有输出“SuperClassinit！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。</p>
</li>
<li><p>但是这段代码里面触发了另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是<br>一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</p>
</li>
<li><p>这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里</p>
</li>
</ul>
<h4 id="常量在编译阶段会存入调用类的常量池中"><a href="#常量在编译阶段会存入调用类的常量池中" class="headerlink" title="常量在编译阶段会存入调用类的常量池中"></a>常量在编译阶段会存入调用类的常量池中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示三：</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行之后，也没有输出“ConstClass init！”，、</p>
</li>
<li><p>这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在编译阶段通过*<strong>常量传播优化**<em>，已经将此常量的值“helloworld”直接存储在NotInitialization类的</em></strong>常量池*<strong>中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类</strong>对自身常量池的引用**了</p>
</li>
<li><p>也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class文件后就已不存在任何联系了。</p>
</li>
</ul>
<h2 id="接口的加载过程"><a href="#接口的加载过程" class="headerlink" title="接口的加载过程"></a>接口的加载过程</h2><ul>
<li>接口的加载过程与类加载过程稍有不同，</li>
<li>针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，</li>
<li>而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[2]，用于初始化接口中所定义的成员变量。</li>
<li>接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：<br>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><ul>
<li><p>“<strong>加载</strong>”（Loading）阶段是整个“<strong>类加载</strong>”（Class Loading）过程中的一个阶段，</p>
</li>
<li><p>希望没有混淆这两个看起来很相似的名词。在加载阶段，Java虚拟机需要完成以下三件事情：</p>
</li>
</ul>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<ul>
<li><p>《Java虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与Java应用的灵活度都是相当大的。</p>
</li>
<li><p>例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。仅仅这一点空隙，Java虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台。例如：</p>
<ol>
<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是Web Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</li>
<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
<li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li>
</ol>
</li>
<li><p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p>
</li>
<li><p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的</p>
</li>
<li><p>但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p>
<ol>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>
</ol>
</li>
</ul>
<ul>
<li><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在**<em>方法区**</em>之中了（<strong>平安面试遇到过，编译后的数据放在哪个内存区域</strong>（<strong>方法区</strong>））</p>
</li>
<li><p>类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
</li>
<li><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><ul>
<li><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
</li>
<li><p>因为使用纯粹的java语言是可以拦截一些异常的，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果尝试这样去做了，编译器会毫不留情地抛出异常、拒绝编译。</p>
</li>
<li><p>但是 Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。上述Java代码无法做到的事情在字节码层面上都是可以实现的，至少语义上是可以表达出来的</p>
</li>
<li><p>所以 Java虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是Java虚拟机保护自身的一项必要措施。</p>
</li>
<li><p>验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重</p>
</li>
</ul>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
<li>and so on …</li>
</ul>
<p>验证阶段的主要目的是保证输入的<strong>字节流</strong>能<strong>正确地解析并存储于方法区</strong>之内，格式上符合描述一个Java类型信息的要求。</p>
<p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，</p>
<p>所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方<br>法重载，例如方法参数都一致，但返回值类型却不同等）</li>
<li>and so on … </li>
</ul>
<p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，</p>
<p>主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p>在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的</li>
<li> and so on …</li>
</ul>
<p>如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再严密的检查，也依然不能保证这一点。</p>
<p>这里涉及了离散数学中一个很著名的问题——“停机问题”（Halting Problem）[2]，即不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p>
<p>在我们讨论字节码校验的上下文语境里，通俗一点的解释是通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在Bug。</p>
<h5 id="Ps"><a href="#Ps" class="headerlink" title="Ps:"></a>Ps:</h5><ul>
<li>由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行</li>
<li>具体做法是给方法体Code属性的属性表中新增加了一项名为“<strong>StackMapTable</strong>”的新属性，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，</li>
<li>在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。这样就将字节码验证的<strong>类型推导</strong>转变为<strong>类型检查</strong>，从而节省了大量校验时间</li>
</ul>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，</p>
<p>这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，</p>
<p>通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>本阶段通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当前类访问。</li>
<li>and so on …</li>
</ul>
<p>符号引用验证的主要目的是确保解析行为能正常执行，</p>
<p>如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：<br>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<h5 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h5><p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><ul>
<li><p>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）<strong>分配内存并设置类变量初始值</strong>的阶段，</p>
</li>
<li><p>从概念上讲，这些变量所使用的内存都应当在<strong>方法区</strong>中进行分配，但必须注意到方法区本身是一个逻辑上的区域，</p>
</li>
<li><p>在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；</p>
</li>
<li><p>而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了，</p>
</li>
</ul>
<p>关于准备阶段，还有两个容易产生混淆的概念需要着重强调，</p>
<ul>
<li><p>首先是这时候进行内存分配的仅包括<strong>类变量</strong>，而不包括实例变量，</p>
</li>
<li><p>实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li><p>其次是这里所说的<strong>初始值</strong>“<strong>通常情况</strong>”下是<strong>数据类型的零值</strong>，</p>
</li>
<li><p>假设一个类变量的定义为：public static int value = 123;</p>
</li>
<li><p>那变量value在准备阶段过后的<strong>初始值为0</strong>而不是123，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于<strong>类构造器</strong><clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</p>
</li>
</ul>
<p><strong>基本数据类型的零值</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“<strong>特殊情况</strong>”：如果类字段的字段属性表中存在<strong>ConstantValue</strong>属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，假设上面类变量value的定义修改为：</p>
<p>public static final int value = 123;</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据Con-stantValue的设置<br>将value赋值为123。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p>在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p>
<h4 id="符号引用-Symbolic-References"><a href="#符号引用-Symbolic-References" class="headerlink" title="符号引用(Symbolic References):"></a>符号引用(Symbolic References):</h4><ul>
<li><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
</li>
<li><p>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，</p>
</li>
<li><p>但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p>
</li>
</ul>
<h4 id="直接引用（Direct-References）："><a href="#直接引用（Direct-References）：" class="headerlink" title="直接引用（Direct References）："></a>直接引用（Direct References）：</h4><ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
<li>直接引用是和虚拟机实现的内存布局直接相关的，</li>
<li>同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li>
<li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p>
<p>所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引<br>用将要被使用前才去解析它。</p>
<p>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>这7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CON-STANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、<br>CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型</p>
<p>后4种(CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info)，它们都和动态语言支持密切相关</p>
<h4 id="4-1-类或接口的解析"><a href="#4-1-类或接口的解析" class="headerlink" title="4.1 类或接口的解析"></a>4.1 类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个<strong>从未解析过的符号引用N</strong>解析为一个<strong>类或接口C的直接引用</strong>，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<ol>
<li><p>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</p>
</li>
<li><p>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</p>
</li>
<li><p>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，<br>但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p>
</li>
</ol>
<p>针对上面第3点访问权限验证，在JDK 9引入了模块化以后，一个public类型也不再意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。</p>
<p>如果我们说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p>
<ul>
<li>被访问类C是public的，并且与访问类D处于同一个模块。</li>
<li>被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问</li>
<li>被访问类C不是public的，但是它与访问类D处于同一个包中</li>
</ul>
<h4 id="4-2-字段解析"><a href="#4-2-字段解析" class="headerlink" title="4.2 字段解析"></a>4.2 字段解析</h4><p>要解析一个未被解析过的字段符号引用，</p>
<ul>
<li><p>首先将会对字段表内class_index[3]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。</p>
<ul>
<li><p>如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。</p>
</li>
<li><p>如果解析成功完成，那把这个字段所属的类或接口用C表示，</p>
</li>
</ul>
</li>
</ul>
<p>《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：</p>
<ol>
<li><p>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</p>
</li>
</ol>
<p> 如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<p>如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac编译器就可能直接拒绝其编译为Class文件。</p>
<p>在代码清单7-4中演示了这种情况，如果注释了Sub类中的“public static int A=4；”，接口与父类同时存在字段A，那Oracle公司实现的Javac编译器将提示“<strong>The field Sub.A is ambiguous</strong>”，并且会拒绝编译这段代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class FieldResolution &#123;</span><br><span class="line"></span><br><span class="line">    interface Interface0 &#123;</span><br><span class="line">        int A = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Interface1 extends Interface0 &#123;</span><br><span class="line">        int A = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Interface2 &#123;</span><br><span class="line">        int A = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Parent implements Interface1 &#123;</span><br><span class="line">        public static int A = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Sub extends Parent implements Interface2 &#123;</span><br><span class="line">        public static int A = 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/uploads/jvm/08ClassLoading/02-analysisError.png"></p>
<h4 id="4-3-方法解析"><a href="#4-3-方法解析" class="headerlink" title="4.3 方法解析"></a>4.3 方法解析</h4><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index[4]项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，</p>
<p>接下来虚拟机将会按照如下步骤进行后续的方法搜索：(TODO 不是很理解，回头看 <strong>字节码结构</strong>)</p>
<p>ps :简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</p>
<ol>
<li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li>
</ol>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此<br>方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h4 id="4-4-接口方法解析"><a href="#4-4-接口方法解析" class="headerlink" title="4.4 接口方法解析"></a>4.4 接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，</p>
<p>如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<ol>
<li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法,但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<p>在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。</p>
<p>但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常。</p>
<p>[1] invokedynamic指令是在JDK 7时加入到字节码中的，当时确实只为了做动态语言（如JRuby、<br>Scala）支持，Java语言本身并不会用到它。而到了JDK 8时代，Java有了Lambda表达式和接口的默认方<br>法，它们在底层调用时就会用到invokedynamic指令，这时再提动态语言支持其实已不完全切合，我们<br>就只把它当个代称吧。笔者将会在第8章中介绍这部分内容。<br>[2] 严格来说，CONSTANT_String_info这种类型的常量也有解析过程，但是很简单而且直观，不再做<br>独立介绍。<br>[3] 参见第6章中关于CONSTANT_Fieldref_info常量的相关内容。<br>[4] 参见第6章关于CONSTANT_Methodref_info常量的相关内容。<br>[5] 参见第6章中关于CONSTANT_InterfaceMethodref_info常量的相关内容。</p>
<h3 id="5-初始化-应用程序发挥作用-clinit"><a href="#5-初始化-应用程序发挥作用-clinit" class="headerlink" title="5.初始化(应用程序发挥作用 clinit)"></a>5.初始化(应用程序发挥作用 clinit)</h3><p>类的初始化阶段是类加载过程的最后一个步骤，</p>
<p>之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全<strong>由Java虚拟机来主导控制</strong>。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将<strong>主导权移交给应用程序</strong>。</p>
<p>进行<strong>准备阶段</strong>时，变量已经赋过一次系统要求的<strong>初始零值</strong>，而在<strong>初始化阶段</strong>，则会根据程序员通过<strong>程序编码</strong>制定的主观计划去初始化类变量和其他资源。</p>
<p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及<clinit>()方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作[1]。</p>
<p><clinit>()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块</strong>（static{}块）中的语句合并产生的，</p>
<p><strong>编译器收集的顺序</strong>是由语句在源文件中<strong>出现的顺序</strong>决定的，静态语句块中只能访问到<strong>定义在静态语句块之前</strong>的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如代码清单7-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">        System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值<br>操作，如代码清单7-6中，字段B的值将会是2而不是1。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test01 &#123;</span><br><span class="line">    static class Parent &#123;</span><br><span class="line">        public static int A = 1;  //step1</span><br><span class="line">        static &#123;</span><br><span class="line">            A = 2; //step2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Sub extends Parent &#123;</span><br><span class="line">        public static int B = A; //step3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： 2</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</p>
</li>
<li><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，</p>
<ul>
<li>如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等<br>待，直到活动线程执行完毕<clinit>()方法。</li>
</ul>
</li>
<li><p>如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞[2]，在实际应用中这种阻塞往往是很隐蔽的。</p>
<p>  代码清单7-7演示了这种场景。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不加上这个if语句，编译器将提示“Initializer does not complete normally”并拒绝编译</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;init DeadLoopClass&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下，一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待：</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]init DeadLoopClass</span><br></pre></td></tr></table></figure>

<p>[2] 需要注意，其他线程虽然会被阻塞，但如果执行＜clinit＞()方法的那条线程退出＜clinit＞()方法后，其他线程唤醒后则不会再次进入＜clinit＞()方法。同一个类加载器下，一个类型只会被初始化一次。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">深入理解jvm-07-字节码指令简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-13 22:48:01" itemprop="dateCreated datePublished" datetime="2021-01-13T22:48:01+08:00">2021-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-07-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h1><ul>
<li>Java虚拟机的指令 由一个字节长度的，代表着某种特定操作含义的数字（称为操作码，<strong>Opcode</strong>） 以及零至多个代表操作所需参数（称为操作数，<strong>Operand</strong>）构成。</li>
<li>由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码Opcode，指令参数Operand都存放在操作数栈中</li>
<li>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构</li>
<li>由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条</li>
<li>又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构</li>
<li>这种操作在某种程度上会导致解释执行字节码时将损失一些性能，但这样做的优势也同样明显：</li>
<li><ul>
<li>放弃了操作数长度对齐[1]，就意味着可以省略掉大量的填充和间隔符号；</li>
<li>用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JVM解释器 最基本执行模型伪代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	自动计算PC寄存器的值+1；</span><br><span class="line">	根据PC寄存器指示的位置，从字节码流中取出操作码；</span><br><span class="line">	<span class="keyword">if</span>(字节码存在操作数)&#123;</span><br><span class="line">		从字节码流中取出操作数；</span><br><span class="line">	&#125;</span><br><span class="line">	执行操作码所定义的操作；</span><br><span class="line">&#125;<span class="keyword">while</span>（字节码流长度&gt;0）</span><br></pre></td></tr></table></figure>



<h2 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h2><h3 id="字节码指令："><a href="#字节码指令：" class="headerlink" title="字节码指令："></a>字节码指令：</h3><ul>
<li>在Java虚拟机的指令集中，<strong>大多数</strong>指令都包含<strong>其操作所对应的数据类型信息</strong>。举个例子，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据</li>
<li>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference</li>
<li>也有一些指令的助记符中<strong>没有明确指明操作类型的字母</strong>，例如arraylength指令，它没有代表数据类型的特殊字符</li>
<li>还有另外一些指令，例如无条件跳转指令goto则是<strong>与数据类型无关的指令</strong></li>
<li>因为Java虚拟机的<strong>操作码长度只有一字节</strong>，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力</li>
<li>如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么指令的数量恐怕就会超出一字节所能表示的数量范围了</li>
<li>因此，Java虚拟机的指令集<strong>对于特定的操作只提供了有限的类型相关指令去支持它</strong></li>
<li>换句话说，指令集将会被故意设计成非完全独立的（<strong>Not Orthogonal</strong>）</li>
</ul>
<ul>
<li>表6-40列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。</li>
<li>如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。</li>
<li>例如load指令有操作int类型的iload，但是没有操作byte类型的同类指令。</li>
</ul>
<p><img src="/uploads/jvm/07ByteOpCond/01-opcode-01.png"></p>
<p><img src="/uploads/jvm/07ByteOpCond/02-opcode-02.png"></p>
<h3 id="总结上图指令集："><a href="#总结上图指令集：" class="headerlink" title="总结上图指令集："></a>总结上图指令集：</h3><p>从表6-40中看来，</p>
<ul>
<li><p>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。</p>
</li>
<li><p>编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，</p>
</li>
<li><p>将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。</p>
</li>
<li><p>与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。</p>
</li>
<li><p>因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</p>
</li>
<li><p>阅读字节码作为了解Java虚拟机的基础技能，是一项应当熟练掌握的能力。</p>
</li>
</ul>
<h3 id="字节码操作按用途分类："><a href="#字节码操作按用途分类：" class="headerlink" title="字节码操作按用途分类："></a>字节码操作按用途分类：</h3><p>笔者将字节码操作按用途大致分为9类，下面按照分类来为读者概略介绍这些指令的用法。</p>
<h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之间来回传输，这类指令包括：</p>
<ul>
<li>将一个局部变量加载到操作栈：iload、iload_<n>、lload、lload_<n>、fload、fload_<n>、dload、dload_<n>、aload、aload_<n></li>
<li>将一个数值从操作数栈存储到局部变量表：istore、istore_<n>、lstore、lstore_<n>、fstore、fstore_<n>、dstore、dstore_<n>、astore、astore_<n></li>
<li>将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_<i>、lconst_<l>、fconst_<f>、dconst_<d></li>
<li>扩充局部变量表的访问索引的指令：wide</li>
</ul>
<p>存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p>
<p>上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_<n>），这些指令助记符实际上代表了一组指令（例如iload_<n>，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。</p>
<p>这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这几组特殊指令，它们省略掉了显式的操作数，不需要进行取操作数的动作，因为实际上操作数就隐含在指令中。</p>
<p>除了这点不同以外，它们的语义与原生的通用指令是完全一致的（例如iload_0的语义与操作数为0时的iload指令语义完全一致</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// Java源码</span><br><span class="line">public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">    int x;</span><br><span class="line">    try &#123;</span><br><span class="line">        x = 1;</span><br><span class="line">    	<span class="built_in">return</span> x;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    	x = 2;</span><br><span class="line">   	 	<span class="built_in">return</span> x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	x = 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后的ByteCode字节码及异常表</span><br><span class="line">public int inc();</span><br><span class="line">    Code:</span><br><span class="line">        Stack=1, Locals=5, Args_size=1</span><br><span class="line">            0: iconst_1 // try块中的x=1  (将常量1加载到操作数栈)</span><br><span class="line">            1: istore_1  //（将1 从操作数栈存储到局部变量表）</span><br><span class="line">            2: iload_1 // 保存x到returnValue中，此时x=1  （将局部变量 加载到操作数栈）</span><br><span class="line">            3: istore   4  将操作数栈 存储到局部变量表</span><br><span class="line">            5: iconst_3 // finaly块中的x=3</span><br><span class="line">            6: istore_1</span><br><span class="line">            7: iload     4 // 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            9: ireturn</span><br><span class="line">            10: astore_2 // 给catch中定义的Exception e赋值，存储在变量槽 2中</span><br><span class="line">            11: iconst_2 // catch块中的x=2</span><br><span class="line">            12: istore_1</span><br><span class="line">            13: iload_1 // 保存x到returnValue中，此时x=2</span><br><span class="line">            14: istore    4</span><br><span class="line">            16: iconst_3 // finaly块中的x=3</span><br><span class="line">            17: istore_1</span><br><span class="line">            18: iload      4 // 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            20: ireturn</span><br><span class="line">            21: astore_3 // 如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</span><br><span class="line">            22: iconst_3 // finaly块中的x=3</span><br><span class="line">            23: istore_1</span><br><span class="line">            24: aload_3 // 将异常放置到栈顶，并抛出</span><br><span class="line">            25: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">    from to target <span class="built_in">type</span></span><br><span class="line">        0 5 10 Class java/lang/Exception</span><br><span class="line">        0 5 21 any</span><br><span class="line">        10 16 21 any</span><br></pre></td></tr></table></figure>



<h4 id="运算指令："><a href="#运算指令：" class="headerlink" title="运算指令："></a>运算指令：</h4><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<p>大体上运算指令可以分为两种：</p>
<ul>
<li>对整型数据进行运算的指令</li>
<li>对浮点型数据进行运算的指令</li>
</ul>
<ol>
<li>整数与浮点数的算术指令在<strong>溢出</strong> 和<strong>被零除</strong>的时候也有各自不同的行为表现 </li>
<li>无论是哪种算术指令，均是使用Java虚拟机的算术类型来进行计算的，</li>
<li>换句话说是不存在直接支持byte、short、char和boolean类型的算术指令，</li>
</ol>
<h5 id="int-指令："><a href="#int-指令：" class="headerlink" title="int 指令："></a>int 指令：</h5><p>对于上述几种数据的运算，应使用操作int类型的指令代替。所有的算术指令包括：</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd</li>
<li>减法指令：isub、lsub、fsub、dsub</li>
<li>乘法指令：imul、lmul、fmul、dmul</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv</li>
<li>求余指令：irem、lrem、frem、drem</li>
<li>取反指令：ineg、lneg、fneg、dneg</li>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
<li>局部变量自增指令：iinc</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</li>
</ul>
<h5 id="运算溢出问题："><a href="#运算溢出问题：" class="headerlink" title="运算溢出问题："></a>运算溢出问题：</h5><ul>
<li>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象，对于程序员来说是很容易理解的，</li>
<li>但其实《Java虚拟机规范》中并没有明确定义过整型数据溢出具体会得到什么计算结果，仅规定了在处理整型数据时，</li>
<li>只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，</li>
<li>其余任何整型数运算场景都不应该抛出运行时异常</li>
</ul>
<h5 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题:"></a>浮点数精度问题:</h5><ul>
<li>《Java虚拟机规范》要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754规范中所规定行为和限制，也就是说Java虚拟机必须完全支持IEEE 754中定义的“非正规浮点数值”（DenormalizedFloating-Point Number）和“逐级下溢”（Gradual Underflow）的运算规则。这些规则将会使某些数值算法处理起来变得明确，不会出现模棱两可的困境</li>
<li>以上规则要求Java虚拟机在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值；</li>
<li>如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的</li>
<li>这种舍入模式也是IEEE 754规范中的默认舍入模式，称为向最接近数舍入模式</li>
<li>而在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近，但是不大于原值的数字来作为最精确的舍入结果。</li>
<li>Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一种运算信号），</li>
<li>当一个操作产生溢出时，将会使用有符号的无穷大来表示；</li>
<li>如果某个操作结果没有明确的数学定义的话，将会使用NaN（Not a Number）值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</li>
</ul>
<h5 id="long类型与浮点数值比较原则："><a href="#long类型与浮点数值比较原则：" class="headerlink" title="long类型与浮点数值比较原则："></a>long类型与浮点数值比较原则：</h5><ul>
<li><p>在对long类型数值进行比较时，Java虚拟机采用带符号的比较方式，</p>
</li>
<li><p>而对浮点数值进行比较时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（NonsignalingComparison）方式进行。</p>
</li>
</ul>
<h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<h5 id="宽化类型转换（WideningNumeric-Conversion）"><a href="#宽化类型转换（WideningNumeric-Conversion）" class="headerlink" title="宽化类型转换（WideningNumeric Conversion）"></a>宽化类型转换（WideningNumeric Conversion）</h5><p>Java虚拟机直接支持（即转换时无须显式的转换指令）以下数值类型的宽化类型转换（WideningNumeric Conversion，即小范围类型向大范围类型的安全转换）：</p>
<ul>
<li>int类型到long、float或者double类型</li>
<li>long类型到float、double类型</li>
<li>float类型到double类型</li>
</ul>
<h5 id="窄化类型转换（Narrowing-Numeric-Conversion）"><a href="#窄化类型转换（Narrowing-Numeric-Conversion）" class="headerlink" title="窄化类型转换（Narrowing Numeric Conversion）"></a>窄化类型转换（Narrowing Numeric Conversion）</h5><p>处理窄化类型转换（Narrowing Numeric Conversion）时，就必须显式地使用转换指令来完成，这些转换指令包括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。</p>
<p>窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p>
<ul>
<li>在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单丢弃除最低位N字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。对于了解计算机数值存储和表示的程序员来说这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N字节的首位了。</li>
</ul>
<h6 id="浮点型转整形（int、long）"><a href="#浮点型转整形（int、long）" class="headerlink" title="浮点型转整形（int、long）"></a>浮点型转整形（int、long）</h6><p>Java虚拟机将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，必须遵循以下转换规则：</p>
<ul>
<li>如果浮点值是NaN，那转换结果就是int或long类型的0。</li>
<li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v。如果v在目标类型T（int或long）的表示范围之类，那转换结果就是v；</li>
<li>否则，将根据v的符号，转换为T所能表示的最大或者最小正数。</li>
</ul>
<h6 id="Double转float"><a href="#Double转float" class="headerlink" title="Double转float"></a>Double转float</h6><ul>
<li>从double类型到float类型做窄化转换的过程与IEEE 754中定义的一致，通过IEEE 754向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。</li>
<li>如果转换结果的绝对值太小、无法使用float来表示的话，将返回float类型的正负零；</li>
<li>如果转换结果的绝对值太大、无法使用float来表示的话，将返回float类型的正负无穷大。</li>
<li>对于double类型的NaN值将按规定转换为float类型的NaN值。</li>
</ul>
<h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。</p>
<p>对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令包括：</p>
<ul>
<li>创建类实例的指令：new</li>
<li>创建数组的指令：newarray、anewarray、multianewarray</li>
<li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic</li>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore</li>
<li>取数组长度的指令：arraylength</li>
<li>检查类实例类型的指令：instanceof、checkcast</li>
</ul>
<h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li>
<li>将栈最顶端的两个数值互换：swap</li>
</ul>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，</p>
<p>从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。</p>
<p>控制转移指令包括：</p>
<ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne</li>
<li>复合条件分支：tableswitch、lookupswitch</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li>
</ul>
<p>在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个数据的值是否null，也有专门的指令用来检测null值。</p>
<ul>
<li>对于boolean类型、byte类型、char类型和short类型的条件分支比较操作，都使用int类型的比较指令来完成</li>
<li>对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，），运算<br>指令会**<em>返回一个整型值**</em>到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。</li>
<li>由于**<em>各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便、完善就显得尤为重要，而Java虚拟机提供的**</em>int类型的条件分支指令是最为丰富、强大的。</li>
</ul>
<h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4><p>方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下五条指令用于方法调用：</p>
<ul>
<li>invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li>
<li>invokeinterface指令：用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li>invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li>
<li>invokestatic指令：用于调用类静态方法（static方法）。</li>
<li>invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法</li>
</ul>
<p>前面四条调用指令的分派逻辑都固化在Java虚拟机内部，用户无法改变，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</p>
<ul>
<li>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的</li>
<li>包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。</li>
</ul>
<h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p>在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常的情况之外，</p>
<p>《Java虚拟机规范》还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如前面介绍整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成。</p>
<h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor，更常见的是直接将它称为“锁”）来实现的。</p>
<h5 id="方法级同步："><a href="#方法级同步：" class="headerlink" title="方法级同步："></a>方法级同步：</h5><ul>
<li>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。</li>
<li>虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否被声明为同步方法。</li>
<li>当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，<ul>
<li>如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。</li>
</ul>
</li>
<li>在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。<ul>
<li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</li>
</ul>
</li>
</ul>
<h5 id="方法内指令级同步："><a href="#方法内指令级同步：" class="headerlink" title="方法内指令级同步："></a>方法内指令级同步：</h5><ul>
<li>同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，</li>
<li>Java虚拟机的指令集中有 <strong><em>monitorenter</em></strong> 和 <strong><em>monitorexit</em></strong> 两条指令来支持synchronized关键字的语义，</li>
<li>正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，</li>
<li>譬如有代码清单6-6所示的代码。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 代码清单6-6　代码同步演示</span><br><span class="line"></span><br><span class="line">void onlyMe(Foo f) &#123;</span><br><span class="line">    synchronized(f) &#123;</span><br><span class="line">    	doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编译后，这段代码生成的字节码序列如下：</span><br><span class="line">Method void onlyMe(Foo)</span><br><span class="line">0 aload_1          // 将对象f入栈</span><br><span class="line">1 dup 　　          // 复制栈顶元素（即f的引用）</span><br><span class="line">2 astore_2         // 将栈顶元素存储到局部变量表变量槽 2中</span><br><span class="line">3 monitorenter     // 以栈定元素（即f）作为锁，开始同步</span><br><span class="line">4 aload_0          // 将局部变量槽 0（即this指针）的元素入栈</span><br><span class="line">5 invokevirtual <span class="comment">#5 // 调用doSomething()方法</span></span><br><span class="line">8 aload_2           // 将局部变量Slow 2的元素（即f）入栈</span><br><span class="line">9 monitorexit       // 退出同步</span><br><span class="line">10 goto 18          // 方法正常结束，跳转到18返回</span><br><span class="line">13 astore_3         // 从这步开始是异常路径，见下面异常表的Taget 13</span><br><span class="line">14 aload_2          // 将局部变量Slow 2的元素（即f）入栈</span><br><span class="line">15 monitorexit      // 退出同步</span><br><span class="line">16 aload_3          // 将局部变量Slow 3的元素（即异常对象）入栈</span><br><span class="line">17 athrow 			// 把异常对象重新抛出给onlyMe()方法的调用者</span><br><span class="line">18 <span class="built_in">return</span> 			// 方法正常返回</span><br><span class="line">Exception table:</span><br><span class="line">FromTo Target Type</span><br><span class="line">4 10 13 any</span><br><span class="line">13 16 13 any</span><br></pre></td></tr></table></figure>



<ul>
<li>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</li>
<li>为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</li>
</ul>
<h3 id="公有设计，私有实现"><a href="#公有设计，私有实现" class="headerlink" title="公有设计，私有实现"></a>公有设计，私有实现</h3><p>《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：<strong>Class文件格式</strong>以及 <strong>字节码指令集</strong></p>
<p>任何一款Java虚拟机实现都必须能够**<em>读取Class文件并精确实现**</em>包含在其中的Java虚拟机代码的语义。拿着《Java虚拟机规范》一成不变地逐字实现其中要求的内容当然是一种可行的途径，</p>
<p>但一个优秀的虚拟机实现，在满足《Java虚拟机规范》的约束下对具体实现做出修改和优化也是完全可行的，</p>
<p>并且《Java虚拟机规范》中明确鼓励实现者这样去做。只要优化以后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整保持，那实现者就可以选择以任何方式去实现这些语义，</p>
<p>虚拟机在后台如何处理Class文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可[1]。</p>
<p>虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么，虚拟机实现的方式主要有以下两种：</p>
<ul>
<li>将输入的Java虚拟机代码在加载时或执行时翻译成另一种虚拟机的指令集；</li>
<li>将输入的Java虚拟机代码在加载时或执行时翻译成宿主机处理程序的本地指令集（即即时编译器代码生成技术）。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">深入理解jvm-06-类文件结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-11 22:03:21" itemprop="dateCreated datePublished" datetime="2021-01-11T22:03:21+08:00">2021-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-06-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h2><h3 id="平台无关性："><a href="#平台无关性：" class="headerlink" title="平台无关性："></a>平台无关性：</h3><ul>
<li>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石</li>
</ul>
<h3 id="语言无关性："><a href="#语言无关性：" class="headerlink" title="语言无关性："></a>语言无关性：</h3><ul>
<li>Java技术发展之初，设计者们就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，</li>
<li>他们在发布规范文档的时候，也刻意把Java的规范拆分成了：</li>
<li><strong><em>《Java语言规范》（The Java Language Specification）</em></strong></li>
<li><strong><em>及《Java虚拟机规范》（The Java Virtual Machine Specification）</em></strong></li>
</ul>
<p><strong><em>在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上”</em></strong><br><strong><em>（In the future，we will consider bounded extensions to the Java virtual machine to provide better support for other languages）</em></strong></p>
<ul>
<li><strong><em>作为一个通用的、与机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为他们语言的运行基础，以Class文件作为他们产品的交付媒介。</em></strong></li>
</ul>
<p>例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把它们的源程序代码编译成Class文件。虚拟机丝毫不关心Class的来源是什么语言</p>
<ul>
<li>Java语言中的各种语法、关键字、常量变量和运算符号的语义 最终都会由多条字节码指令组合来表达 ，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。（类似于 java语言的功能只是 字节码功能的一个子集）</li>
<li>因此有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于java的语言特性提供了发挥空间</li>
</ul>
<p><img src="/uploads/jvm/08-JVM-nobindLanguage.png"></p>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>注意：</p>
<ul>
<li>任何一个Class文件都对应着唯一的一个类或接口的定义信息</li>
<li>类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）</li>
</ul>
<ul>
<li>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在</li>
<li>当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前[2]的方式分割成若干个8个字节进行存储。</li>
</ul>
<p><strong><em>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”</em></strong></p>
<ul>
<li>无符号数： 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li>
<li>表：  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</li>
</ul>
<p><img src="/uploads/jvm/09-jvm-wufahao-info.png"></p>
<ul>
<li>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”。</li>
</ul>
<h3 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h3><p>Class的结构不像XML等描述语言，由于它没有任何分隔符号，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering，Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，全部都不允许改变</p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>魔数：</p>
<ul>
<li><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件</p>
</li>
<li><p>使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动</p>
</li>
<li><p>Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE（咖啡宝贝？）</p>
</li>
<li><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，</p>
</li>
<li><p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
</li>
</ul>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul>
<li>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</li>
</ul>
<h4 id="常量池容量计数值"><a href="#常量池容量计数值" class="headerlink" title="常量池容量计数值"></a>常量池容量计数值</h4><ul>
<li><p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）</p>
</li>
<li><p>与Java语言习惯不同，这个容量计数器从1开始，而不是从0开始。</p>
</li>
<li><p>之所以从1开始是因为 ：  在Class文件格式规范制定之时，设计者将第0项常量控出来是有特殊考虑，目的在于 <strong><em>当某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义 ，可以把索引值设置为0</em></strong>来表示。 </p>
</li>
<li><p>如下 图所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。</p>
<p><img src="/uploads/jvm/10-jvm-constantPool.png"></p>
</li>
</ul>
<h4 id="常量类型："><a href="#常量类型：" class="headerlink" title="常量类型："></a>常量类型：</h4><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p>
<ul>
<li><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p>
</li>
<li><p>符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
</li>
</ul>
<h4 id="JVM动态连接"><a href="#JVM动态连接" class="headerlink" title="JVM动态连接"></a>JVM动态连接</h4><ul>
<li>在Class文件中不会保存各个方法、字段最终在内存中的布局信息</li>
<li>这些字段、方法的符号引用不经过虚拟机在运行期转换的话 是无法得到真正的内存入口地址，也就无法直接被虚拟机直接使用</li>
<li>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</li>
</ul>
<h4 id="常量池的项目类型"><a href="#常量池的项目类型" class="headerlink" title="常量池的项目类型"></a>常量池的项目类型</h4><ul>
<li>常量池中每一项常量都是一个表，</li>
<li>最初常量表中共有11种结构 各不相同的表结构数据，后来为了更好的支持动态语言调用，额外增加了4种动态语言相关的常量（）<ul>
<li>JDK 7时增加了前三种：<strong>CONSTANT_MethodHandle_info</strong>、<strong>CONSTANT_MethodType_info</strong>和<strong>CONSTANT_InvokeDynamic_info</strong>。出于性能和易用性的考虑（JDK 7设计时已经考虑到，预留了17个常量标志位），在JDK 11中又增加了第四种常量<strong>CONSTANT_Dynamic_info</strong>。</li>
</ul>
</li>
<li>为了支持Java模块化系统（Jigsaw），又加入了<strong>CONSTANT_Module_info</strong>和<strong>CONSTANT_Package_info</strong>两个常量</li>
<li>截至JDK13，常量表中分别有17种不同类型的常量。</li>
</ul>
<p><img src="/uploads/jvm/12-jvm-constantPool-projectType.png"></p>
<h4 id="常量结构："><a href="#常量结构：" class="headerlink" title="常量结构："></a>常量结构：</h4><ul>
<li>之所以说常量池时最烦琐的数据，是因为这<strong>17种常量类型各自有着完全独立的数据结构</strong>，两两之间被没有什么共性和联系</li>
</ul>
<h5 id="CONSTANT-Class-info"><a href="#CONSTANT-Class-info" class="headerlink" title="CONSTANT_Class_info"></a>CONSTANT_Class_info</h5><ul>
<li><p>回头看看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，</p>
</li>
<li><p>查表6-3的标志列可知这个常量属于<strong>CONSTANT_Class_info</strong>类型，此类型的常量代表一个<strong>类或者接口的符号引用</strong>。</p>
</li>
<li><p>CONSTANT_Class_info的结构比较简单，如表6-4所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>其中 tag 是标志位，它用于区分常量类型；</li>
<li>name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info类型常量，此常量代表了整个类（或者接口）的全限定名。</li>
<li>本例中的 name_index值（偏移地址：0x0000000B）为0x0002，也就是指向了常量池中的第二项常量。</li>
<li>继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个<strong>CONSTANT_Utf8_info</strong>类型的常量。</li>
</ul>
<h5 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a>CONSTANT_Utf8_info</h5><p> CONSTANT_Utf8_info 类型的结构如表6-5所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody></table>
<ul>
<li>length值说明了这个UTF-8编码的字符串长度是多少字节，</li>
<li>它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串</li>
<li>UTF-8缩略编码与普通UTF-8编码的区别是：<br>从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，<br>从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’开始到’\uffff’之间的所有字符<br>的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</li>
<li>由于Class文件中方法、字段等都需要引用 CONSTANT_Utf8_info 型常量来描述名称，所以 CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度（length的最大值），即u2类型能表达的最大值65535。</li>
<li><strong><em>所以Java程序中如果定义了超过64KB</em></strong> 英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</li>
</ul>
<h4 id="javap-工具"><a href="#javap-工具" class="headerlink" title="javap 工具"></a>javap 工具</h4><p>在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap。</p>
<p>代码清单6-2中列出了使用javap工具的-verbose参数输出的TestClass.class文件字节码内容（为节省篇幅，此清单中省略了常量池以外的信息）。</p>
<p><strong><em>代码清单6-2　使用javap命令输出常量表</em></strong></p>
<p><img src="/uploads/jvm/13-jvm-constantPool-javap.png"></p>
<ul>
<li>从代码清单6-2中可以看到，计算机已经帮我们把整个常量池的21项常量都计算了出来</li>
<li>其中有些常量似乎从来没有在代码中出现过，如“I”“V”“<init>”“LineNumberTable”“LocalVariableTable”等，这些看起来在源代码中不存在的常量是哪里来的？</li>
<li>这部分常量的确不来源于Java源代码，它们都是编译器自动生成的。会被字段表（field_info）、方法表（method_info）、属性表（attribute_info）所引用，它们将会被用来描述一些不方便使用“固定字节”进行表达的内容，譬如描述方法的返回值是什么，有几个参数，每个参数的类型是什么</li>
<li>因为Java中的“类”是无穷无尽的，无法通过简单的无符号数来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达</li>
</ul>
<h4 id="常量池中的17种数据类型的结构总表"><a href="#常量池中的17种数据类型的结构总表" class="headerlink" title="常量池中的17种数据类型的结构总表"></a>常量池中的17种数据类型的结构总表</h4><p><img src="/uploads/jvm/14-jvm-constantPool-01.png"></p>
<p><img src="/uploads/jvm/14-jvm-constantPool-02.png"></p>
<p><img src="/uploads/jvm/14-jvm-constantPool-03.png"></p>
<h3 id="访问标志（access-flags）"><a href="#访问标志（access-flags）" class="headerlink" title="访问标志（access flags）"></a>访问标志（access flags）</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access flags），这个标志用于识别一些类或者接口层次的访问信息。包括：</p>
<ul>
<li>这个Class是类还是接口</li>
<li>是否定义为public</li>
<li>是否定义为abstract类型</li>
<li>如果是类，是否被声明为final</li>
<li>等等，具体的标志位以及标志的含义见下：</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>是否为public</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>是否被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令的新语义，<br>invokespecial指令的语义在JDK1.0.2发生过改变，为了区别这条指令使用哪种语义，<br>JDK1.0.2之后编译出来的类 这个标志都必须为 真</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标识这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口和抽象类来说，此标志为真，其他类型都是 假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标识 这个类并非由用户代码产生的</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标识这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标识这是一个枚举</td>
</tr>
<tr>
<td>ACC_MODULE</td>
<td>0x8000</td>
<td>标识这是一个模块</td>
</tr>
</tbody></table>
<h3 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h3><ul>
<li>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，</li>
<li>而接口索引集合（interfaces）是一组u2类型的数据的集合</li>
<li>Class文件中由这三项数据来确定该类型的继承关系</li>
</ul>
<h4 id="类索引："><a href="#类索引：" class="headerlink" title="类索引："></a>类索引：</h4><p>用于确定这个类的全限定名</p>
<h4 id="父类索引："><a href="#父类索引：" class="headerlink" title="父类索引："></a>父类索引：</h4><p>用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了<br>java.lang.Object外，所有Java类的父类索引都不为0</p>
<h4 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h4><p>用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>
<ul>
<li><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型CONSTANT_Class_info的类描述符常量，</p>
</li>
<li><p>通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</p>
</li>
</ul>
<p><img src="/uploads/jvm/15-jvm-class-index.png"></p>
<h3 id="字段表-field-info-集合"><a href="#字段表-field-info-集合" class="headerlink" title="字段表(field_info)集合"></a>字段表(field_info)集合</h3><ul>
<li>字段表（field_info）用于描述接口或者类中声明的变量。</li>
<li>Java语言中的“字段”（Field）包括**<em>类级变量以及实例级变量**</em>，</li>
<li>但**<em>不包括在方法内部声明的局部变量**</em></li>
</ul>
<h4 id="字段可以包括的修饰符有"><a href="#字段可以包括的修饰符有" class="headerlink" title="字段可以包括的修饰符有:"></a>字段可以包括的修饰符有:</h4><p>字段的作用域（public、private、protected修饰符）、是<strong>实例变量还是类变量（static修饰符）</strong>、可变性（final）、</p>
<p><strong>并发可见性（volatile修饰符，是否强制从主内存读写</strong>）、<strong>可否被序列化（transient修饰符</strong>）、字段数据类型（基本类型、对象、数组）、字段名称。</p>
<ul>
<li>字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li>
</ul>
<h4 id="字段表的最终格式"><a href="#字段表的最终格式" class="headerlink" title="字段表的最终格式:"></a>字段表的最终格式:</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义如表6-9所示。</p>
<p>表6-9　字段访问标志<br><img src="/uploads/jvm/16-jvm-attribute-accessFlags.png"></p>
<p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符</p>
<h4 id="全限定名："><a href="#全限定名：" class="headerlink" title="全限定名："></a>全限定名：</h4><p>以代码清单6-1中的代码为例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”号表示全限定名结束。</p>
<h4 id="简单名称："><a href="#简单名称：" class="headerlink" title="简单名称："></a>简单名称：</h4><p>简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</p>
<h4 id="描述符："><a href="#描述符：" class="headerlink" title="描述符："></a>描述符：</h4><ul>
<li><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</p>
</li>
<li><p>根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，</p>
</li>
<li><p>而对象类型则用字符L加对象的全限定名来表示</p>
</li>
</ul>
<p><img src="/uploads/jvm/17-jvm-attribute-desc.png"></p>
<ul>
<li>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。</li>
<li>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，</li>
<li>方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</li>
</ul>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h4><ul>
<li><p><strong>字段表集合中不会列出从父类或者父接口中继承而来的字段</strong></p>
</li>
<li><p>但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</p>
</li>
<li><p>另外，在<strong>Java语言中字段是无法重载的</strong>，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，</p>
</li>
<li><p>但是<strong>对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法</strong>的</p>
</li>
</ul>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><ul>
<li><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，</p>
</li>
<li><p>依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项</p>
</li>
</ul>
<p>表6-11　方法表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<ul>
<li>因为<strong>volatile关键字和transient关键字不能修饰方法</strong>，所以<strong>方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志</strong>。</li>
<li>与之相对，<strong>synchronized、native、strictfp和abstract关键字可以修饰方法</strong>，<strong>方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、</strong><br><strong>ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志</strong>。</li>
<li>对于方法表，所有标志位及其取值可参见表6-12。</li>
</ul>
<p><img src="/uploads/jvm/18-jvm-method_access_flag.png"></p>
<h4 id="方法里的代码去哪了"><a href="#方法里的代码去哪了" class="headerlink" title="方法里的代码去哪了"></a>方法里的代码去哪了</h4><ul>
<li>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了</li>
<li>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，</li>
<li>与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器“<clinit>()”方法和实例构造器“<init>()”方法 </li>
</ul>
<h4 id="重载（-Java语言）"><a href="#重载（-Java语言）" class="headerlink" title="重载（ Java语言）"></a>重载（ Java语言）</h4><p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名 。</p>
<h5 id="特征签名："><a href="#特征签名：" class="headerlink" title="特征签名："></a>特征签名：</h5><ul>
<li><p>指 一个方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名中，所以java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。</p>
</li>
<li><p>但是 在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</p>
</li>
<li><p>Java代码的方法特征签名只包括方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表，</p>
</li>
</ul>
<h3 id="属性表（attribute-info）集合"><a href="#属性表（attribute-info）集合" class="headerlink" title="属性表（attribute_info）集合"></a>属性表（attribute_info）集合</h3><p>后续各类属性表中 都会包含xx_index，那是代表对 常量池的引用，例如：</p>
<p>跟随access_flags标志的是两项索引值：<strong>name_index</strong> 和 <strong>descriptor_index</strong>。它们都是对<strong>常量池项的引用</strong>，分别代表着<strong>字段的简单名称以及字段和方法的描述符</strong></p>
<ul>
<li>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</li>
<li>为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项，这些属性具体见表6-13。</li>
</ul>
<p>表6-13　虚拟机规范预定义的属性</p>
<p><img src="/uploads/jvm/19-jvm-attributeinfo-01.png"></p>
<p><img src="/uploads/jvm/19-jvm-attributeinfo-02.png"></p>
<h4 id="Code属性（重点）："><a href="#Code属性（重点）：" class="headerlink" title="Code属性（重点）："></a>Code属性（重点）：</h4><p>理解Code属性是学习后面字节码执行引擎的必要基础，能直接阅读字节码也是工作中分析java代码语义问题的必要工具和基本技能</p>
<p>Code属性是Class文件中最重要的一个属性</p>
<ul>
<li><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。</p>
</li>
<li><p>Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，</p>
</li>
<li><p>譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。</p>
</li>
</ul>
<p>表6-15　Code属性表的结构</p>
<p><img src="/uploads/jvm/20-jvm-attributeinfo-Code.png"></p>
<ul>
<li><strong>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称，</strong></li>
<li><strong>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节</strong>。</li>
<li>max_stack代表了操作数栈（Operand Stack）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度，虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度</li>
<li>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</li>
<li>方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理程序的参数（Exception Handler Parameter，就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。操作数栈和局部变量表直接决定一个该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</li>
<li>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那顾名思义每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令。</li>
<li><strong><em>ps:</em></strong>   关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到2的32次幂，但是《Java虚拟机规范》中明确限制了*<strong>一个方法不允许超过65535条字节码指令**<em>，即它实际只使用了u2的长度，</em></strong>如果超过这个限制，Javac编译器就会拒绝编译***。一般来讲，编写Java代码时只要不是刻意去编写一个超级长的方法来为难编译器，是不太可能超过这个最大值的限制的。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就有可能因为方法生成字节码超长的原因而导致编译失败。</li>
</ul>
<p>如果**<em>把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分**</em>，那么在整<br>个Class文件里，<strong>Code属性用于描述代码</strong>，<strong>所有的其他数据项目都用于描述元数据</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 原始Java代码</span><br><span class="line">public class TestClass &#123;</span><br><span class="line">    private int m;</span><br><span class="line">    public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">    	<span class="built_in">return</span> m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///////////////////编译后</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\&gt;javap -verbose TestClass</span><br><span class="line">// 常量表部分的输出见代码清单6-1，因版面原因这里省略掉</span><br><span class="line">&#123;</span><br><span class="line">public org.fenixsoft.clazz.TestClass();</span><br><span class="line">//构造方法</span><br><span class="line">    Code:</span><br><span class="line">        Stack=1, Locals=1, Args_size=1</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial <span class="comment">#10; //Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        4: <span class="built_in">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">    	line 3: 0</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start Length Slot Name Signature</span><br><span class="line">        0 5 0 this Lorg/fenixsoft/clazz/TestClass;</span><br><span class="line"></span><br><span class="line">// 方法 2</span><br><span class="line">public int inc();</span><br><span class="line">Code:</span><br><span class="line">    Stack=2, Locals=1, Args_size=1</span><br><span class="line">    0: aload_0</span><br><span class="line">    1: getfield <span class="comment">#18; //Field m:I</span></span><br><span class="line">    4: iconst_1</span><br><span class="line">    5: iadd</span><br><span class="line">    6: ireturn</span><br><span class="line">LineNumberTable:</span><br><span class="line">	line 8: 0</span><br><span class="line">LocalVariableTable:</span><br><span class="line">    Start Length Slot Name Signature</span><br><span class="line">    0 7 0 this Lorg/fenixsoft/clazz/TestClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问:"></a>疑问:</h4><ul>
<li>这个类有两个方法——实例构造器<init>()和inc()，这两个方法很明显都是没有参数的，为什么Args_size会为1？</li>
<li>而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么会等于1？</li>
</ul>
<h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><ul>
<li><p>一条Java语言里面的潜规则：在任何实例方法里面，都可以通过“this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，</p>
</li>
<li><p>而它的实现非常简单，仅仅是通过在Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。</p>
</li>
<li><p>因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数值从1开始计算。</p>
</li>
<li><p>这个处理只对实例方法有效，如果代码清单6-1中的inc()方法被声明为static，那Args_size就不会等于1而是等于0了。</p>
</li>
<li></li>
</ul>
<h4 id="异常表："><a href="#异常表：" class="headerlink" title="异常表："></a>异常表：</h4><p>如果存在异常表，那它的格式应如表6-16所示，包含四个字段，这些字段的含义为：如果当字节码从第start_pc行[1]到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。</p>
<p>表6-16　属性表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>start_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>end_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>handler_pc</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>catch_pc</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>异常表实际上是Java代码的一部分，尽管字节码中有最初为处理异常而设计的跳转指令，</li>
<li>但《Java虚拟机规范》中明确要求Java语言的编译器<strong>应当选择使用异常表</strong>而不是通过跳转指令来实现Java异常及finally处理机制[2]。</li>
</ul>
<p>代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了<strong>在字节码层面try-catchfinally是如何体现的</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Java源码</span><br><span class="line">public int inc() &#123;</span><br><span class="line">    int x;</span><br><span class="line">    try &#123;</span><br><span class="line">        x &#x3D; 1;</span><br><span class="line">    	return x;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    	x &#x3D; 2;</span><br><span class="line">   	 	return x;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    	x &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 编译后的ByteCode字节码及异常表</span><br><span class="line">public int inc();</span><br><span class="line">    Code:</span><br><span class="line">        Stack&#x3D;1, Locals&#x3D;5, Args_size&#x3D;1</span><br><span class="line">            0: iconst_1 &#x2F;&#x2F; try块中的x&#x3D;1</span><br><span class="line">            1: istore_1</span><br><span class="line">            2: iload_1 &#x2F;&#x2F; 保存x到returnValue中，此时x&#x3D;1</span><br><span class="line">            3: istore   4</span><br><span class="line">            5: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            6: istore_1</span><br><span class="line">            7: iload     4 &#x2F;&#x2F; 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            9: ireturn</span><br><span class="line">            10: astore_2 &#x2F;&#x2F; 给catch中定义的Exception e赋值，存储在变量槽 2中</span><br><span class="line">            11: iconst_2 &#x2F;&#x2F; catch块中的x&#x3D;2</span><br><span class="line">            12: istore_1</span><br><span class="line">            13: iload_1 &#x2F;&#x2F; 保存x到returnValue中，此时x&#x3D;2</span><br><span class="line">            14: istore    4</span><br><span class="line">            16: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            17: istore_1</span><br><span class="line">            18: iload      4 &#x2F;&#x2F; 将returnValue中的值放到栈顶，准备给ireturn返回</span><br><span class="line">            20: ireturn</span><br><span class="line">            21: astore_3 &#x2F;&#x2F; 如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</span><br><span class="line">            22: iconst_3 &#x2F;&#x2F; finaly块中的x&#x3D;3</span><br><span class="line">            23: istore_1</span><br><span class="line">            24: aload_3 &#x2F;&#x2F; 将异常放置到栈顶，并抛出</span><br><span class="line">            25: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">    from to target type</span><br><span class="line">        0 5 10 Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">        0 5 21 any</span><br><span class="line">        10 16 21 any</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>编译器为这段Java源码生成了三条异常表记录，对应三条可能出现的代码执行路径。从Java代码的语义上讲，这三条执行路径分别为：</p>
<ul>
<li>如果try语句块中出现属于Exception或其子类的异常，转到catch语句块处理；</li>
<li>如果try语句块中出现不属于Exception或其子类的异常，转到finally语句块处理；</li>
<li>如果catch语句块中出现任何异常，转到finally语句块处理。</li>
</ul>
<p>返回到我们上面提出的问题，这段代码的返回值应该是多少？熟悉Java语言的读者应该很容易说出答案：</p>
<ul>
<li>如果没有出现异常，返回值是1；</li>
<li>如果出现了Exception异常，返回值是2；</li>
<li>如果出现了Exception以外的异常，方法非正常退出，没有返回值。</li>
</ul>
<p>我们一起来分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。</p>
<ol>
<li>字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且*<strong>将此时x的值复制一份副本到最后一***<br>*</strong>个本地变量表的变量槽中*<strong>（**<em>这个变量槽里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为</em></strong><br><strong><em>方法返回值使用</em></strong>。为了讲解方便，给这个变量槽起个名字：returnValue）。</li>
<li>如果这时候没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后*<strong>将之前保存在returnValue中的整数1***  读入到 *</strong>操作栈***<br><strong><em>顶</em></strong>，**<em>最后ireturn指令会以int形式返回操作栈顶中的值**</em>，方法结束。</li>
<li>如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是<strong>将2赋值给变量x</strong>，然后将变量*<strong>x此时的值赋给returnValue*<strong>，最后</strong>再**<br><strong>将变量x的值改为3</strong>。*</strong>方法返回前同样将returnValue中保留的整数2读到了操作栈顶***。</li>
<li>从第21行开始的代码，作用是<strong>将变量x的值赋为3</strong>，并<strong>将栈顶的异常抛出</strong>，方法结束。</li>
</ol>
<p><strong><em>总结一下：</em></strong></p>
<ul>
<li>如果先给x赋值，再将x值 复制一个副本到本地变量表的 变量槽中，该变量槽中的值在ireturn指令执行时 会被读到操作栈顶，就是最终要 return的值，而不是 x的变量值</li>
<li>如果没有异常，还是会走finally的方法块给x进行赋值，但是最终返回的是 之前本地变量表的变量槽中的值，并不是走完finally块的时候 x的值 </li>
<li>如果发生了异常，且异常属于 catch方法的异常或者其异常子类，则 进catch方法块，给x赋值为2，然后将x=2 的值赋给returnValue，然后执行finally 的x=3,最后将 returnValue的值读到栈顶，输出</li>
<li>如果发生了catch块之外的异常，则 先执行finally 的x=3，再将异常堆栈信息读到栈顶，抛出去，最终不会return x，而是以异常堆栈的形式结束</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    // Java源码</span><br><span class="line">    public int <span class="function"><span class="title">inc</span></span>() &#123;</span><br><span class="line">        int x;</span><br><span class="line">        try &#123;</span><br><span class="line">            x = 1;</span><br><span class="line">            List&lt;Object&gt; list = Arrays.asList();</span><br><span class="line">//            list.get(1);</span><br><span class="line">            System.out.println(1 / 0);</span><br><span class="line">            System.out.println(<span class="string">&quot;异常&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">//            ClassCastException(<span class="string">&quot;异常外&quot;</span>)</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line">            x = 2;</span><br><span class="line">            <span class="built_in">return</span> x;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            x = 3;</span><br><span class="line">//            <span class="built_in">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test2 test2 = new Test2();</span><br><span class="line">        int inc = test2.inc();</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><ul>
<li><p>这里的Exceptions属性是在方法表中与Code属性平级的一项属性，不要与前面刚刚讲解完的异常表产生混淆。</p>
</li>
<li><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。</p>
<p>它的结构见表6-17。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_exceptions</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>exception_index_table</td>
<td>number_of_exceptons</td>
</tr>
</tbody></table>
<p>此属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示；exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p>
<h4 id="LocalVariableTable及LocalVariableTypeTable属性"><a href="#LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTable及LocalVariableTypeTable属性"></a>LocalVariableTable及LocalVariableTypeTable属性</h4><ul>
<li><p>LocalVariableTable属性用于描述**<em>栈帧中局部变量表的变量与Java源码中定义的变量之间的关系**</em>，</p>
</li>
<li><p>它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g：none或-g：vars选项来取消或要求生成这项信息。</p>
</li>
<li><p>如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，譬如IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p>
</li>
<li><p>LocalVariableTable属性的结构如表6-19所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>local_variable_table_length</td>
<td>1</td>
</tr>
<tr>
<td>loca_variable_info</td>
<td>loca_variable_table</td>
<td>local_variable_table_length</td>
</tr>
</tbody></table>
<p>其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构如表6-20所示。<br>| 类型               | 名称                       | 数量                |<br>| —————— | ————————– | ——————- |<br>| u2                 |start_pc       | 1                   |<br>| u2                 | length           | 1                   |<br>| u2                 |name_index | 1                   |<br>| u2                 | descriptor_index                     |1 |<br>| u2                 | index | 1                   |</p>
<ul>
<li>start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围</li>
<li>name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</li>
<li>index是这个局部变量在栈帧的局部变量表中变量槽的位置。当这个变量数据类型是64位类型时（double和long），它占用的变量槽为index和index+1两个</li>
</ul>
<h4 id="LocalVariableTypeTable（用于支持泛型）"><a href="#LocalVariableTypeTable（用于支持泛型）" class="headerlink" title="LocalVariableTypeTable（用于支持泛型）"></a>LocalVariableTypeTable（用于支持泛型）</h4><ul>
<li><p>在JDK 5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”——LocalVariableTypeTable。这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature）。</p>
</li>
<li><p>对于非泛型类型来说，描述符和特征签名能描述的信息是能吻合一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[3]，描述符就不能准确描述泛型类型了。因此出现了LocalVariableTypeTable属性，使用字段的特征签名来完成泛型的描述。</p>
</li>
</ul>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><ul>
<li><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。</p>
</li>
<li><p>类似“int x=123”和“static int x=123”这样的变量定义在Java程序里面是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。</p>
</li>
<li><p>对**<em>非static类型的变量（也就是实例变量）的赋值是在实例构造器<init>()方法中进行的**</em>；</p>
</li>
<li><p>而对于**<em>类变量**</em>，则有两种方式可以选择：</p>
</li>
<li><ul>
<li>在类构造器<clinit>()方法中</li>
<li>或者使用ConstantValue属性。</li>
</ul>
</li>
<li><p>目前Oracle公司实现的Javac编译器的选择是，如果**<em>同时使用final和static来修饰一个变量**</em>（按照习惯，这里称“常量”更贴切），并且这个变量的<strong>数据类型是基本类型或者java.lang.String</strong>的话，就将会<strong>生成ConstantValue属性</strong>来进行初始化；</p>
</li>
<li><p>如果这个变量<strong>没有被final修饰</strong>，或者<strong>并非基本类型及字符串</strong>，则将会选择在<clinit>()方法中进行初始化。</p>
</li>
<li><p>虽然有final关键字才更符合“ConstantValue”的语义，但<strong>《Java虚拟机规范》中并没有强制要求字段必须设置ACC_FINAL标志，只要求有ConstantValue属性的字段必须设置ACC_STATIC标志而已，</strong></p>
</li>
<li><p><strong>对final关键字的要求是Javac编译器自己加入的限制</strong>。而对ConstantValue的属性值只能限于基本类型和String这点，其实并不能算是什么限制，这是理所当然的结果。</p>
</li>
</ul>
<p>因为此属性的属性值只是一个常量池的索引号，**<em>由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量**</em>，所以就算<br>ConstantValue属性想支持别的类型也无能为力。</p>
<p>ConstantValue属性的结构如表6-23所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_value_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>从数据结构中可以看出ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。</li>
<li>constantvalue_index数据项代表了常量池中一个字面量常量的引用，</li>
<li>根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</li>
</ul>
<h4 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h4><ul>
<li>InnerClasses属性用于记录<strong>内部类与宿主类之间的关联</strong>。</li>
<li>如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</li>
<li>InnerClasses属性的结构如表6-24所示。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_classes</td>
<td>1</td>
</tr>
<tr>
<td>loca_classes_info</td>
<td>inner_classes</td>
<td>number_of_classes</td>
</tr>
</tbody></table>
<p>数据项number_of_classes代表需要记录多少个内部类信息，</p>
<p>每一个内部类的信息都由一个inner_classes_info表进行描述。</p>
<p>inner_classes_info表的结构如表6-25所示。<br>| 类型               | 名称                       | 数量                |<br>| —————— | ————————– | ——————- |<br>| u2                 |inner_class_of_index     | 1                   |<br>| u4                 | outer_class_of_index          | 1                   |<br>| u2                 | inner_name_index | 1                   |<br>| loca_classes_info |      inner_classes_access_flag                     |1 |</p>
<ul>
<li>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</li>
<li>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为0。</li>
<li>inner_class_access_flags是内部类的访问标志，类似于类的access_flags，</li>
</ul>
<h4 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h4><ul>
<li>Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</li>
<li>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过代码中使用“@deprecated”注解进行设置。</li>
<li>Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，</li>
<li>在JDK 5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位。</li>
<li>编译器通过生成一些在源代码中不存在的Synthetic方法、字段甚至是整个类的方式，实现了越权访问（越过private修饰器）或其他绕开了语言限制的功能，这可以算是一种早期优化的技巧，其中最典型的例子就是枚举类中自动生成的枚举元素数组和嵌套类的桥接方法（Bridge Method）。</li>
<li>所有由不属于用户代码产生的类、方法及字段都应当至少设置Synthetic属性或者ACC_SYNTHETIC标志位中的一项，</li>
<li>唯一的例外是实例构造器“<init>()”方法和类构造器“<clinit>()”方法。</li>
</ul>
<h4 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h4><ul>
<li><p>StackMapTable属性在JDK 6增加到Class文件规范之中，它是一个相当复杂的变长属性，位于Code属性的属性表中。</p>
</li>
<li><p>这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（TypeChecker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
</li>
<li><p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frame），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示执行到该字节码时局部变量表和操作数栈的验证类型。</p>
</li>
<li><p>类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p>
</li>
<li><p>StackMapTable属性的结构如表6-28所示。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>number_of_entries</td>
<td>1</td>
</tr>
<tr>
<td>stack_map_frame</td>
<td>stack_map_frame_entries</td>
<td>number_of_entries</td>
</tr>
</tbody></table>
<ul>
<li>在Java SE 7版之后的《Java虚拟机规范》中，明确规定对于版本号大于或等于50.0的Class文件，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性，这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。</li>
<li>一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</li>
</ul>
<h4 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h4><ul>
<li>Signature属性在JDK 5增加到Class文件规范之中，它是一个可选的定长属性，可以出现于类、字段表和方法表结构的属性表中。</li>
<li>在JDK 5里面大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variable）或参数化类型（ParameterizedType），则Signature属性会为它记录泛型签名信息。</li>
<li>之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</li>
<li>使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。</li>
<li>但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，</li>
<li>现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。<br>Signature属性的结构如表6-29所示</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>signature_index</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>其中signature_index项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名或方法类型签名或字段类型签名。</li>
<li>如果当前的Signature属性是类文件的属性，则这个结构表示类签名，</li>
<li>如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，</li>
<li>如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。</li>
</ul>
<h4 id="MethodParameters属性"><a href="#MethodParameters属性" class="headerlink" title="MethodParameters属性"></a>MethodParameters属性</h4><ul>
<li>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。</li>
<li>MethodParameters的作用是记录方法的各个形参名称和信息。</li>
</ul>
<h5 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h5><ul>
<li>最初，基于存储空间的考虑，Class文件默认是不储存方法参数名称的，因为给参数起什么名字对计算机执行程序来说是没有任何区别的，所以只要在源码中妥当命名就可以了。</li>
<li>随着Java的流行，这点确实为程序的传播和二次复用带来了诸多不便，由于Class文件中没有参数的名称，如果只有单独的程序包而不附加JavaDoc的话，在IDE中编辑使用包里面的方法时是无法获得方法调用的智能提示的，这就阻碍了JAR包的传播。</li>
<li>后来，“-g：var”就成为了Javac以及许多IDE编译Class时采用的默认值，这样会将方法参数的名称生成到LocalVariableTable属性之中。</li>
<li>不过此时问题仍然没有全部解决，LocalVariableTable属性是Code属性的子属性——没有方法体存在，自然就不会有局部变量表，</li>
<li>但是对于其他情况，譬如抽象方法和接口方法，是理所当然地可以不存在方法体的，对于方法签名来说，还是没有找到一个统一完整的保留方法参数名称的地方。</li>
<li>所以JDK 8中新增的这个属性，使得编译器可以（编译时加上-parameters参数）将方法名称也写进Class文件中，而且MethodParameters是方法表的属性，与Code属性平级的，可以运行时通过反射API获取</li>
</ul>
<p>MethodParameters的结构如表6-32所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>parameters_count</td>
<td>1</td>
</tr>
<tr>
<td>parameter</td>
<td>parameters</td>
<td>parameters_count</td>
</tr>
</tbody></table>
<p>其中，引用到的parameter结构如表6-33所示。<br>表6-33　parameter属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
</tbody></table>
<h4 id="模块化相关属性"><a href="#模块化相关属性" class="headerlink" title="模块化相关属性"></a>模块化相关属性</h4><ul>
<li>JDK 9的一个重量级功能是Java的模块化功能，</li>
<li>因为模块描述文件（module-info.java）最终是要编译成一个独立的Class文件来存储的，</li>
<li>所以，Class文件格式也扩展了**<em>Module、ModulePackages和ModuleMainClas**</em>s三个属性用于支持Java模块化相关功能</li>
</ul>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module:"></a>Module:</h5><p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储了这个模块*<strong>requires、exports、opens、uses**<em>和</em></strong>provides***定义的全部内容</p>
<p>Module属性是一个非常复杂的变长属性，除了表示该模块的名称、版本、标志信息以外，还存储<br>了这个模块requires、exports、opens、uses和provides定义的全部内容，其结构如表6-34所示。</p>
<p>表6-34　Module属性结构</p>
<p><img src="/uploads/jvm/22-jvm-Module.png"></p>
<p><strong><em>TODO： 暂时用不到，就先不了解了</em></strong></p>
<h5 id="ModulePackages"><a href="#ModulePackages" class="headerlink" title="ModulePackages"></a>ModulePackages</h5><p>ModulePackages是另一个用于支持Java模块化的变长属性，它用于描述该模块中所有的包，不论是<br>不是被export或者open的。</p>
<h5 id="ModuleMainClass"><a href="#ModuleMainClass" class="headerlink" title="ModuleMainClass"></a>ModuleMainClass</h5><p>ModuleMainClass属性是一个定长属性，用于确定该模块的主类（Main Class），其结构</p>
<h4 id="运行时注解相关属性"><a href="#运行时注解相关属性" class="headerlink" title="运行时注解相关属性"></a>运行时注解相关属性</h4><h5 id="背景：-1"><a href="#背景：-1" class="headerlink" title="背景："></a>背景：</h5><ul>
<li>早在JDK 5时期，Java语言的语法进行了多项增强，其中之一是提供了对注解（Annotation）的支持。</li>
<li>为了存储源码中注解信息，Class文件同步增加了 <strong><em>RuntimeVisibleAnnotations</em></strong>  、*<strong>RuntimeInvisibleAnnotations**<em>、</em></strong>RuntimeVisibleParameterAnnotations*** 和 <strong><em>RuntimeInvisibleParameterAnnotations</em></strong>四个属性。</li>
<li>到了JDK 8时期，进一步加强了Java语言的注解使用范围，又新增类型注解（JSR 308），所以Class文件中也同步增加了 <strong><em>RuntimeVisibleTypeAnnotations</em></strong> 和<br>**<em>RuntimeInvisibleTypeAnnotations**</em> 两个属性。</li>
<li>由于这六个属性不论结构还是功能都比较雷同，因此我们把它们合并到一起，以**<em>RuntimeVisibleAnnotations**</em>为代表进行介绍。</li>
<li><strong>RuntimeVisibleAnnotations</strong>是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，</li>
<li>当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</li>
<li></li>
<li>RuntimeVisibleAnnotations属性的结构如表6-38所示。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_annotations</td>
<td>1</td>
</tr>
<tr>
<td>annotation</td>
<td>annotations</td>
<td>num_annotations</td>
</tr>
</tbody></table>
<p>num_annotations是annotations数组的计数器，annotations中每个元素都代表了一个运行时可见的注解，注解在Class文件中以annotation结构来存储，</p>
<p>具体如表6-39所示<br>表6-39　annotation属性结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>type_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>num_element_value_pairs</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>element_value_pairs</td>
<td>num_element_value_pair</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">RocketMQ-02-RocketMQ快速入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-06 20:59:26" itemprop="dateCreated datePublished" datetime="2021-01-06T20:59:26+08:00">2021-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/06/RocketMQ-02-RocketMQ%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RocketMQ入门"><a href="#RocketMQ入门" class="headerlink" title="RocketMQ入门"></a>RocketMQ入门</h1><h2 id="核心概念说明"><a href="#核心概念说明" class="headerlink" title="核心概念说明"></a>核心概念说明</h2><p><img src="/uploads/RocketMQ/RocketMQ01.png" alt="image-20210106210340592"></p>
<h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><ul>
<li>消息生产者，负责产生消息，一般由业务系统负责产生消息。</li>
</ul>
<h4 id="Producer-Group"><a href="#Producer-Group" class="headerlink" title="Producer Group"></a>Producer Group</h4><ul>
<li>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul>
<li>消息费者，负责消费消息，一般是后台系统负责异步消费。</li>
</ul>
<h4 id="Push-Consumer"><a href="#Push-Consumer" class="headerlink" title="Push Consumer"></a>Push Consumer</h4><ul>
<li>服务端向消费者端推送消息</li>
</ul>
<h4 id="Pull-Consumer"><a href="#Pull-Consumer" class="headerlink" title="Pull Consumer"></a>Pull Consumer</h4><ul>
<li>消费者端向服务定时拉取消息</li>
</ul>
<h4 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h4><ul>
<li> 一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</li>
</ul>
<h3 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h3><ul>
<li><p>集群架构中的组织协调员</p>
</li>
<li><p>收集broker的工作情况</p>
</li>
<li><p>不负责消息的处理</p>
</li>
</ul>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><ul>
<li>是RocketMQ的核心负责消息的发送、接收、高可用等（真正干活的）</li>
<li>需要定时发送自身情况到NameServer，默认10秒发送一次，超时2分钟会认为该broker失效。</li>
</ul>
<h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><ul>
<li><p>不同类型的消息以不同的Topic名称进行区分，如User、Order等</p>
</li>
<li><p>是逻辑概念</p>
</li>
</ul>
<h3 id="Message-Queue"><a href="#Message-Queue" class="headerlink" title="Message Queue"></a>Message Queue</h3><ul>
<li>消息队列，用于存储消息</li>
</ul>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;zlm-mqProducer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置nameserver的地址</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动生产者</span></span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建topic，参数分别是：broker的名称，topic的名称，queue的数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        producer.createTopic(<span class="string">&quot;broker-zhangliming&quot;</span>, <span class="string">&quot;zhangliming-test-topic&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;topic创建成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="发送消息（同步）"><a href="#发送消息（同步）" class="headerlink" title="发送消息（同步）"></a>发送消息（同步）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;我的第一个消息-add!&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;add&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消息id：C0A800693F5814DAD5DC1E4E22F20000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">3</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A800693F5814DAD5DC1E4E22F20000, offsetMsgId=C0A83E5A00002A9F00000000000000BA, messageQueue=MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">3</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Message数据结构"><a href="#Message数据结构" class="headerlink" title="Message数据结构"></a>Message数据结构</h3><table>
<thead>
<tr>
<th>字段名</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Topic</td>
<td>null</td>
<td>必填，线下环境不需要申请，线上环境需要申请后才能使用</td>
</tr>
<tr>
<td>Body</td>
<td>null</td>
<td>必填，二进制形式，序列化由应用决定，Producer 与 Consumer 要协商好序列化形式。</td>
</tr>
<tr>
<td>Tags</td>
<td>null</td>
<td>选填，类似于 Gmail 为每封邮件设置的标签，方便服务器过滤使用。<br/>目前只支持每个消息设置一个 tag，所以也可以类比为 Notify 的 MessageType 概念</td>
</tr>
<tr>
<td>Keys</td>
<td>null</td>
<td>选填，代表这条消息的业务关键词，服务器会根据 keys 创建哈希索引，<br>设置后，可以在 Console 系统根据 Topic、Keys 来查询消息，<br>由于是哈希索引，请尽可能保证 key 唯一，例如订单号，商品 Id 等。</td>
</tr>
<tr>
<td>Flag</td>
<td>0</td>
<td>选填，完全由应用来设置，RocketMQ 不做干预</td>
</tr>
<tr>
<td>DelayTimeLevel</td>
<td>0</td>
<td>选填，消息延时级别，0 表示不延时，大于 0 会延时特定的时间才会被消费</td>
</tr>
<tr>
<td>WaitStoreMsgOK</td>
<td>True</td>
<td>选填，表示消息是否在服务器落盘后才返回应答。</td>
</tr>
</tbody></table>
<h3 id="发送消息（异步）"><a href="#发送消息（异步）" class="headerlink" title="发送消息（异步）"></a>发送消息（异步）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendCallback;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;我的第一个异步发送消息!&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        producer.send(message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送成功了!&quot;</span> + sendResult);</span><br><span class="line">                System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">                System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送失败!&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        producer.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">发送成功了!SendResult [sendStatus=SEND_OK, msgId=C0A8006943E014DAD5DC1E5694380000, offsetMsgId=C0A83E5A00002A9F0000000000000174, messageQueue=MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">1</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line">消息id：C0A8006943E014DAD5DC1E5694380000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic, brokerName=broker-zhangliming, queueId=<span class="number">1</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.protocol.heartbeat.MessageModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;haoke-consumer&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 订阅消息，接收的是所有消息</span></span><br><span class="line"><span class="comment">//        consumer.subscribe(&quot;my-topic&quot;, &quot;*&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;my-topic&quot;</span>, <span class="string">&quot;add || update&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;消息:&quot;</span> + <span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息 -&gt; &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消息:我的第一个消息-add!</span><br><span class="line">消息:我的第一个消息-add!</span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">186</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609938835416</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">8951</span>, storeTimestamp=<span class="number">1609938835430</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000000, commitLogOffset=<span class="number">0</span>, bodyCRC=<span class="number">2131316890</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, CONSUME_START_TIME=<span class="number">1609939507601</span>, UNIQ_KEY=C0A8006920E814DAD5DC1E4E1BD80000, WAIT=<span class="keyword">true</span>, TAGS=add&#125;, body=[-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">102</span>, -<span class="number">124</span>, -<span class="number">25</span>, -<span class="number">84</span>, -<span class="number">84</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">128</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">86</span>, -<span class="number">26</span>, -<span class="number">74</span>, -<span class="number">120</span>, -<span class="number">26</span>, -<span class="number">127</span>, -<span class="number">81</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">33</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">3</span>, storeSize=<span class="number">186</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609938837234</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">8964</span>, storeTimestamp=<span class="number">1609938837241</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F00000000000000BA, commitLogOffset=<span class="number">186</span>, bodyCRC=<span class="number">2131316890</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, CONSUME_START_TIME=<span class="number">1609939507601</span>, UNIQ_KEY=C0A800693F5814DAD5DC1E4E22F20000, WAIT=<span class="keyword">true</span>, TAGS=add&#125;, body=[-<span class="number">26</span>, -<span class="number">120</span>, -<span class="number">111</span>, -<span class="number">25</span>, -<span class="number">102</span>, -<span class="number">124</span>, -<span class="number">25</span>, -<span class="number">84</span>, -<span class="number">84</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">128</span>, -<span class="number">28</span>, -<span class="number">72</span>, -<span class="number">86</span>, -<span class="number">26</span>, -<span class="number">74</span>, -<span class="number">120</span>, -<span class="number">26</span>, -<span class="number">127</span>, -<span class="number">81</span>, <span class="number">45</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">33</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="消息过滤器"><a href="#消息过滤器" class="headerlink" title="消息过滤器"></a>消息过滤器</h2><ul>
<li><p>RocketMQ支持根据用户自定义属性进行过滤，过滤表达式类似于SQL的where，如：a&gt; 5 AND b =’abc’</p>
</li>
<li><p>原因是默认配置下，不支持自定义属性，需要设置开启 broker.conf中配置,见第一章可以看见配置<br>enablePropertyFilter=true</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.MessageSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅消息，接收的是所有消息</span></span><br><span class="line"><span class="comment">//        consumer.subscribe(&quot;my-topic&quot;, &quot;*&quot;);</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;my-topic-filter&quot;</span>, MessageSelector.bySql(<span class="string">&quot;sex=&#x27;女&#x27; AND age&gt;=18&quot;</span>));</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;消息:&quot;</span> + <span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息 -&gt; &quot;</span> + msgs);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动消费者</span></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">2</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940231764</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9804</span>, storeTimestamp=<span class="number">1609940231769</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F00000000000003CE, commitLogOffset=<span class="number">974</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">3</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940231776</span>, UNIQ_KEY=C0A800692B3C14DAD5DC1E636A540000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">21</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">1</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">0</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940241237</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9818</span>, storeTimestamp=<span class="number">1609940241243</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000490, commitLogOffset=<span class="number">1168</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">1</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940241244</span>, UNIQ_KEY=C0A8006908F014DAD5DC1E638F550000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">22</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line">消息:美女<span class="number">002</span></span><br><span class="line">接收到消息 -&gt; [MessageExt [queueId=<span class="number">2</span>, storeSize=<span class="number">194</span>, queueOffset=<span class="number">3</span>, sysFlag=<span class="number">0</span>, bornTimestamp=<span class="number">1609940251652</span>, bornHost=/<span class="number">192.168</span>.<span class="number">62.1</span>:<span class="number">9836</span>, storeTimestamp=<span class="number">1609940251657</span>, storeHost=/<span class="number">192.168</span>.<span class="number">62.90</span>:<span class="number">10911</span>, msgId=C0A83E5A00002A9F0000000000000552, commitLogOffset=<span class="number">1362</span>, bodyCRC=<span class="number">1635276022</span>, reconsumeTimes=<span class="number">0</span>, preparedTransactionOffset=<span class="number">0</span>, toString()=Message&#123;topic=<span class="string">&#x27;my-topic-filter&#x27;</span>, flag=<span class="number">0</span>, properties=&#123;MIN_OFFSET=<span class="number">0</span>, MAX_OFFSET=<span class="number">4</span>, sex=女, CONSUME_START_TIME=<span class="number">1609940251658</span>, UNIQ_KEY=C0A8006934D414DAD5DC1E63B8030000, WAIT=<span class="keyword">true</span>, TAGS=delete, age=<span class="number">23</span>&#125;, body=[-<span class="number">25</span>, -<span class="number">66</span>, -<span class="number">114</span>, -<span class="number">27</span>, -<span class="number">91</span>, -<span class="number">77</span>, <span class="number">48</span>, <span class="number">48</span>, <span class="number">50</span>], transactionId=<span class="string">&#x27;null&#x27;</span>&#125;]]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;haoke&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;这是一个用户的消息, id = 1003&quot;</span>;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;my-topic-filter&quot;</span>, <span class="string">&quot;delete&quot;</span>, msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        message.putUserProperty(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        message.putUserProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        SendResult sendResult = producer.send(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息id：&quot;</span> + sendResult.getMsgId());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息队列：&quot;</span> + sendResult.getMessageQueue());</span><br><span class="line">        System.out.println(<span class="string">&quot;消息offset值：&quot;</span> + sendResult.getQueueOffset());</span><br><span class="line">        System.out.println(sendResult);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">    消息id：C0A80069251814DAD5DC1E63D08D0000</span><br><span class="line">消息队列：MessageQueue [topic=my-topic-filter, brokerName=broker-zhangliming, queueId=<span class="number">0</span>]</span><br><span class="line">消息offset值：<span class="number">0</span></span><br><span class="line">SendResult [sendStatus=SEND_OK, msgId=C0A80069251814DAD5DC1E63D08D0000, offsetMsgId=C0A83E5A00002A9F0000000000000614, messageQueue=MessageQueue [topic=my-topic-filter, brokerName=broker-zhangliming, queueId=<span class="number">0</span>], queueOffset=<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="producer详解"><a href="#producer详解" class="headerlink" title="producer详解"></a>producer详解</h2><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>在某些业务中，consumer在消费消息时，是需要按照生产者发送消息的顺序进行消费的，比如在电商系统中，订单的消息，会有创建订单、订单支付、订单完成，如果消息的顺序发生改变，那么这样的消息就没有意义了。</p>
<p><img src="/uploads/RocketMQ/RocketMQ02.png" alt="image-20210106210340592"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;HAOKE_ORDER_PRODUCER&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> orderId = i % <span class="number">10</span>; <span class="comment">// 模拟生成订单id</span></span><br><span class="line">            String msgStr = <span class="string">&quot;order --&gt; &quot;</span> + i +<span class="string">&quot;, id = &quot;</span>+ orderId;</span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">&quot;haoke_order_topic&quot;</span>, <span class="string">&quot;ORDER_MSG&quot;</span>,</span><br><span class="line">                    msgStr.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(message, (mqs, msg, arg) -&gt; &#123;</span><br><span class="line">                Integer id = (Integer) arg;</span><br><span class="line">                <span class="keyword">int</span> index = id % mqs.size();</span><br><span class="line">                <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">            &#125;, orderId);</span><br><span class="line">            System.out.println(sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span></span><br><span class="line">                DefaultMQPushConsumer(<span class="string">&quot;HAOKE_ORDER_CONSUMER&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;haoke_order_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerOrderly() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeOrderlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       ConsumeOrderlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                                + msg.getQueueId() + <span class="string">&quot; &quot;</span></span><br><span class="line">                                + <span class="keyword">new</span> String(msg.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                System.out.println(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs);</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：相同订单id的消息会落到同一个queue中，一个消费者线程会顺序消费queue，从而实现顺序消费消<br>息。</p>
<h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><h3 id="回顾是什么事务"><a href="#回顾是什么事务" class="headerlink" title="回顾是什么事务"></a>回顾是什么事务</h3><p>聊什么是事务，最经典的例子就是转账操作，用户A转账给用户B1000元的过程如下：<br>用户A发起转账请求，用户A账户减去1000元<br>用户B的账户增加1000元<br>如果，用户A账户减去1000元后，出现了故障（如网络故障），那么需要将该操作回滚，用户A账户增加1000元。<br>这就是事务。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>随着项目越来越复杂，越来越服务化，就会导致系统间的事务问题，这个就是分布式事务问题。<br>分布式事务分类有这几种：</p>
<ul>
<li>基于单个JVM，数据库分库分表了（跨多个数据库）。</li>
<li>基于多JVM，服务拆分了（不跨数据库）。</li>
<li>基于多JVM，服务拆分了 并且数据库分库分表了。</li>
</ul>
<p>解决分布式事务问题的方案有很多，使用消息实现只是其中的一种。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Half-Prepare-Message"><a href="#Half-Prepare-Message" class="headerlink" title="Half(Prepare) Message"></a>Half(Prepare) Message</h4><p>指的是暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次<br>确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息。</p>
<h4 id="Message-Status-Check"><a href="#Message-Status-Check" class="headerlink" title="Message Status Check"></a>Message Status Check</h4><p>由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长<br>期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回<br>查。</p>
<p><img src="/uploads/RocketMQ/RocketMQ03.png" alt="image-20210106210340592"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/uploads/RocketMQ/RocketMQ04.png" alt="image-20210106210340592"></p>
<ol>
<li>发送方向 MQ 服务端发送消息。</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
<li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后MQ Server 将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, LocalTransactionState&gt; STATE_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行具体的业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 发送的消息对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;用户A账户减500元.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">500</span>); <span class="comment">//模拟调用服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             System.out.println(1/0);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户B账户加500元.&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            STATE_MAP.put(msg.getTransactionId(), LocalTransactionState.COMMIT_MESSAGE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二次提交确认</span></span><br><span class="line"><span class="comment">//            return LocalTransactionState.UNKNOW;</span></span><br><span class="line">            <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        STATE_MAP.put(msg.getTransactionId(), LocalTransactionState.ROLLBACK_MESSAGE);</span><br><span class="line">        <span class="comment">// 回滚</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息回查</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;状态回查 ---&gt; &quot;</span> + msg.getTransactionId() +<span class="string">&quot; &quot;</span> +STATE_MAP.get(msg.getTransactionId()) );</span><br><span class="line">        <span class="keyword">return</span> STATE_MAP.get(msg.getTransactionId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">&quot;transaction_producer&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置事务监听器</span></span><br><span class="line">        producer.setTransactionListener(<span class="keyword">new</span> TransactionListenerImpl());</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(<span class="string">&quot;pay_topic&quot;</span>, <span class="string">&quot;用户A给用户B转账500元&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        producer.sendMessageInTransaction(message, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">99999</span>);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;HAOKE_CONSUMER&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;192.168.62.90:9876&quot;</span>);</span><br><span class="line">        <span class="comment">// 订阅topic，接收此Topic下的所有消息</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;pay_topic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(msg.getBody(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h4><p>返回commit状态时，消费者能够接收到消息，返回rollback状态时，消费者接受不到消息。</p>
<h2 id="consumer详解"><a href="#consumer详解" class="headerlink" title="consumer详解"></a>consumer详解</h2><h3 id="push和pull模式"><a href="#push和pull模式" class="headerlink" title="push和pull模式"></a>push和pull模式</h3><p>在RocketMQ中，消费者有两种模式，一种是push模式，另一种是pull模式。</p>
<ul>
<li>(常用)push模式：客户端与服务端建立连接后，当服务端有消息时，将消息推送到客户端。</li>
<li>pull模式：客户端不断的轮询请求服务端，来获取新的消息。<br>但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式，即consumer轮询从broker拉取消息。<br>区别：</li>
<li> Push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。</li>
<li>Pull方式里，取消息的过程需要用户自己写，首先通过打算消费的Topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取的开始offset，直到取完了，再换另一个MessageQueue。</li>
<li>疑问：既然是采用pull方式实现，RocketMQ如何保证消息的实时性呢？</li>
</ul>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>长轮询即是在请求的过程中，若是服务器端数据并没有更新，那么则将这个连接挂起，直到服务器推送新的<br>数据，再返回，然后进入循环周期。<br>客户端像传统轮询一样从服务端请求数据，服务端会阻塞请求不会立刻返回，直到有数据或超时才返回给客<br>户端，然后关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p>
<p><img src="/uploads/RocketMQ/RocketMQ05.png" alt="image-20210106210340592"></p>
<h2 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h2><p>DefaultMQPushConsumer实现了自动保存offset值以及实现多个consumer的负载均衡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置组名</span></span><br><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;HAOKE_IM&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过groupname将多个consumer组合在一起，那么就会存在一个问题，消息发送到这个组后，消息怎么分配呢？<br>这个时候，就需要指定消息模式，分别有集群和广播模式。</p>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>同一个 ConsumerGroup(GroupName相同) 里的每 个 Consumer 只消费所订阅消息的一部分内容， 同<br>一个 ConsumerGroup 里所有的 Consumer消费的内容合起来才是所订阅 Topic 内容的整体， 从而达到<br>负载均衡的目的 。</p>
<h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><p>同一个 ConsumerGroup里的每个 Consumer都 能消费到所订阅 Topic 的全部消息，也就是一个消息会<br>被多次分发，被多个 Consumer消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集群模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line"><span class="comment">// 广播模式</span></span><br><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure>

<h3 id="重复消息的解决方案"><a href="#重复消息的解决方案" class="headerlink" title="重复消息的解决方案"></a>重复消息的解决方案</h3><p>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办<br>法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<ol>
<li>消费端处理消息的业务逻辑保持幂等性</li>
<li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li>
</ol>
<ul>
<li>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</li>
<li>第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</li>
<li>第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。</li>
<li>第2条可以消息系统实现，也可以业务端实现。</li>
<li>正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以</li>
<li>最好还是**<em>由业务端自己处理消息重复的问题**</em>，这也是RocketMQ不解决消息重复的问题的原因。</li>
<li>  RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</li>
</ul>
<h2 id="RocketMQ存储"><a href="#RocketMQ存储" class="headerlink" title="RocketMQ存储"></a>RocketMQ存储</h2><p>RocketMQ中的消息数据存储，采用了零拷贝技术（使用 mmap + write 方式），文件系统采用 Linux Ext4 文件系<br>统进行存储。</p>
<h3 id="消息数据的存储"><a href="#消息数据的存储" class="headerlink" title="消息数据的存储"></a>消息数据的存储</h3><p>在RocketMQ中，消息数据是保存在磁盘文件中，为了保证写入的性能，RocketMQ尽可能保证顺序写入，顺序写<br>入的效率比随机写入的效率高很多。<br>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的，CommitLog是真正存储数据的文件，<br>ConsumeQueue是索引文件，存储数据指向到物理文件的配置。</p>
<p><img src="/uploads/RocketMQ/RocketMQ06.png" alt="image-20210106210340592"></p>
<p>如上图所示：</p>
<ul>
<li>消息主体以及元数据都存储在CommitLog当中</li>
<li>Consume Queue相当于kafka中的partition，是一个逻辑队列，存储了这个Queue在CommiLog中的起始<br>offset，log大小和MessageTag的hashCode。</li>
<li>每次读取消息队列先读取consumerQueue,然后再通过consumerQueue去commitLog中拿到消息主体。</li>
</ul>
<p>文件位置：</p>
<p><img src="/uploads/RocketMQ/RocketMQ07.png" alt="image-20210106210340592"></p>
<h2 id="同步刷盘与异步刷盘"><a href="#同步刷盘与异步刷盘" class="headerlink" title="同步刷盘与异步刷盘"></a>同步刷盘与异步刷盘</h2><p>RocketMQ 为了提高性能，会尽可能地保证 磁盘的顺序写。消息在通过 Producer 写入 RocketMQ 的时候，有两<br>种写磁盘方式，分别是同步刷盘与异步刷盘。</p>
<ul>
<li><p>同步刷盘</p>
<ul>
<li>在返回写成功状态时，消息已经被写入磁盘 。</li>
<li>具体流程是：消息写入内存的 PAGECACHE 后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程<br>执行完成后唤醒等待的线程，返回消息写成功的状态 。</li>
</ul>
</li>
<li><p>异步刷盘</p>
</li>
<li><p>在返回写成功状态时，消息可能只是被写入了内存的 PAGECACHE，写操作的返回快，吞吐量大</p>
<ul>
<li>当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</li>
</ul>
</li>
<li><p>broker配置文件中指定刷盘方式</p>
<ul>
<li>flushDiskType=ASYNC_FLUSH – 异步</li>
<li>flushDiskType=SYNC_FLUSH – 同步</li>
</ul>
</li>
</ul>
<p><img src="/uploads/RocketMQ/RocketMQ08.png" alt="image-20210106210340592"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/" class="post-title-link" itemprop="url">RocketMQ-01-使用DockerCompose安装RocketMQ</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-05 23:08:19" itemprop="dateCreated datePublished" datetime="2021-01-05T23:08:19+08:00">2021-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/RocketMQ/" itemprop="url" rel="index"><span itemprop="name">RocketMQ</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/05/RocketMQ-01-%E4%BD%BF%E7%94%A8DockerCompose%E5%AE%89%E8%A3%85RocketMQ/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="使用DockerCompose安装RocketMQ"><a href="#使用DockerCompose安装RocketMQ" class="headerlink" title="使用DockerCompose安装RocketMQ"></a>使用DockerCompose安装RocketMQ</h1><p>安装Docker 和 Docker-Compose 过程略</p>
<h2 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若没有目录，自行创建</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ  </span><br><span class="line">vi docker-compose.yml </span><br><span class="line"></span><br><span class="line">内容如下：</span><br><span class="line"></span><br><span class="line">version: <span class="string">&#x27;3.5&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  rmqnamesrv:</span><br><span class="line">    image: foxiswho/rocketmq:server</span><br><span class="line">    container_name: rmqnamesrv</span><br><span class="line">    ports:</span><br><span class="line">      - 9876:9876</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/logs:/opt/logs</span><br><span class="line">      - ./data/store:/opt/store</span><br><span class="line">    networks:</span><br><span class="line">        rmq:</span><br><span class="line">          aliases:</span><br><span class="line">            - rmqnamesrv</span><br><span class="line"></span><br><span class="line">  rmqbroker:</span><br><span class="line">    image: foxiswho/rocketmq:broker</span><br><span class="line">    container_name: rmqbroker</span><br><span class="line">    ports:</span><br><span class="line">      - 10909:10909</span><br><span class="line">      - 10911:10911</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data/logs:/opt/logs</span><br><span class="line">      - ./data/store:/opt/store</span><br><span class="line">      - ./data/brokerconf/broker.conf:/etc/rocketmq/broker.conf</span><br><span class="line">    environment:</span><br><span class="line">        NAMESRV_ADDR: <span class="string">&quot;rmqnamesrv:9876&quot;</span></span><br><span class="line">        JAVA_OPTS: <span class="string">&quot; -Duser.home=/opt&quot;</span></span><br><span class="line">        JAVA_OPT_EXT: <span class="string">&quot;-server -Xms128m -Xmx128m -Xmn128m&quot;</span></span><br><span class="line">    <span class="built_in">command</span>: mqbroker -c /etc/rocketmq/broker.conf</span><br><span class="line">    depends_on:</span><br><span class="line">      - rmqnamesrv</span><br><span class="line">    networks:</span><br><span class="line">      rmq:</span><br><span class="line">        aliases:</span><br><span class="line">          - rmqbroker</span><br><span class="line"></span><br><span class="line">  rmqconsole:</span><br><span class="line">    image: styletang/rocketmq-console-ng</span><br><span class="line">    container_name: rmqconsole</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    environment:</span><br><span class="line">        JAVA_OPTS: <span class="string">&quot;-Drocketmq.namesrv.addr=rmqnamesrv:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - rmqnamesrv</span><br><span class="line">    networks:</span><br><span class="line">      rmq:</span><br><span class="line">        aliases:</span><br><span class="line">          - rmqconsole</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  rmq:</span><br><span class="line">    name: rmq</span><br><span class="line">    driver: bridge</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自行创建 目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ/data/brokerconf</span><br><span class="line"></span><br><span class="line">vi broker.conf</span><br><span class="line"><span class="comment"># 内容如下：</span></span><br><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the &quot;License&quot;); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">#  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">#  See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">#  limitations under the License.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所属集群名字</span></span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line"><span class="comment"># 原因是默认配置下，不支持自定义属性，需要设置开启</span></span><br><span class="line">enablePropertyFilter=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># broker 名字，注意此处不同的配置文件填写的不一样，如果在 broker-a.properties 使用: broker-a,</span></span><br><span class="line"><span class="comment"># 在 broker-b.properties 使用: broker-b</span></span><br><span class="line">brokerName=broker-zhangliming</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 表示 Master，&gt; 0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># nameServer地址，分号分割</span></span><br><span class="line"><span class="comment"># namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动IP,如果 docker 报 com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;192.168.0.120:10909&gt; failed</span></span><br><span class="line"><span class="comment"># 解决方式1 加上一句 producer.setVipChannelEnabled(false);，解决方式2 brokerIP1 设置宿主机IP，不要使用docker 内部IP</span></span><br><span class="line">brokerIP1=192.168.62.90</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭 ！！！这里仔细看是 false，false，false</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件时间点，默认凌晨4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保留时间，默认48小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"></span><br><span class="line"><span class="comment"># commitLog 每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"></span><br><span class="line"><span class="comment"># ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"></span><br><span class="line"><span class="comment"># destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment"># redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment"># 检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment"># 存储路径</span></span><br><span class="line"><span class="comment"># storePathRootDir=/home/yinshi/rocketmq-all-4.1.0-incubating/store</span></span><br><span class="line"><span class="comment"># commitLog 存储路径</span></span><br><span class="line"><span class="comment"># storePathCommitLog=/home/yinshi/rocketmq-all-4.1.0-incubating/store/commitlog</span></span><br><span class="line"><span class="comment"># 消费队列存储</span></span><br><span class="line"><span class="comment"># storePathConsumeQueue=/home/yinshi/rocketmq-all-4.1.0-incubating/store/consumequeue</span></span><br><span class="line"><span class="comment"># 消息索引存储路径</span></span><br><span class="line"><span class="comment"># storePathIndex=/home/yinshi/rocketmq-all-4.1.0-incubating/store/index</span></span><br><span class="line"><span class="comment"># checkpoint 文件存储路径</span></span><br><span class="line"><span class="comment"># storeCheckpoint=/home/yinshi/rocketmq-all-4.1.0-incubating/store/checkpoint</span></span><br><span class="line"><span class="comment"># abort 文件存储路径</span></span><br><span class="line"><span class="comment"># abortFile=/home/yinshi/rocketmq-all-4.1.0-incubating/store/abort</span></span><br><span class="line"><span class="comment"># 限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"></span><br><span class="line"><span class="comment"># flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment"># flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment"># flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment"># flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker 的角色</span></span><br><span class="line"><span class="comment"># - ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment"># - SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment"># - SLAVE</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷盘方式</span></span><br><span class="line"><span class="comment"># - ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment"># - SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发消息线程池数量</span></span><br><span class="line"><span class="comment"># sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment"># 拉消息线程池数量</span></span><br><span class="line"><span class="comment"># pullMessageThreadPoolNums=128</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/docker/rocketMQ </span><br><span class="line"></span><br><span class="line"><span class="comment"># pull 镜像太慢</span></span><br><span class="line">vi /etc/docker/daemon.json </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>,<span class="string">&quot;https://hub-mirror.c.163.com&quot;</span>,<span class="string">&quot;https://registry.docker-cn.com&quot;</span>],</span><br><span class="line">	<span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;192.168.62.90:5000&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 重启docker ，然后</span></span><br><span class="line">systemctl restart docker </span><br><span class="line">docker-compose up</span><br><span class="line">docker images</span><br><span class="line">docker  ps</span><br></pre></td></tr></table></figure>



<h2 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h2><p>访问控制台 RocketMQ 控制台</p>
<h3 id="访问-http-192-168-62-90-8080-登入控制台"><a href="#访问-http-192-168-62-90-8080-登入控制台" class="headerlink" title="访问 http://192.168.62.90:8080 登入控制台"></a>访问 <a target="_blank" rel="noopener" href="http://192.168.62.90:8080/">http://192.168.62.90:8080</a> 登入控制台</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">深入理解jvm-05-调优案例分析与实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-28 23:12:21" itemprop="dateCreated datePublished" datetime="2020-12-28T23:12:21+08:00">2020-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-05-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><h2 id="大内存硬件上的程序部署策略"><a href="#大内存硬件上的程序部署策略" class="headerlink" title="大内存硬件上的程序部署策略"></a>大内存硬件上的程序部署策略</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>服务器的硬件为四路志强处理器、16GB物理内存，操作系统为64位CentOS 5.4，Resin作为Web服务器。整个服务器暂时没有部署别的应用，所有硬件资源都可以提供给这访问量并不算太大的文档网站使用。软件版本选用的是64位的JDK 5，管理员启用了一个虚拟机实例，使用-Xmx和-Xms参数将Java堆大小固定在12GB。使用一段时间后发现服务器的运行效果十分不理想，网站经常不定期出现长时间失去响应。</p>
<p>监控服务器运行状况后发现网站失去响应是由垃圾收集停顿所导致的，在该系统软硬件条件下，HotSpot虚拟机是以服务端模式运行，默认使用的是吞吐量优先收集器，回收12GB的Java堆，一次FullGC的停顿时间就高达14秒。由于程序设计的原因，访问文档时会把文档从磁盘提取到内存中，导致内存中出现很多由文档序列化产生的大对象，这些大对象大多在分配时就直接进入了老年代，没有在Minor GC中被清理掉。这种情况下即使有12GB的堆，内存也很快会被消耗殆尽，由此导致每隔几分钟出现十几秒的停顿，令网站开发、管理员都对使用Java技术开发网站感到很失望</p>
<ul>
<li><strong><em>回收大块堆内存而导致的长时间停顿</em></strong></li>
</ul>
<h3 id="解决方案（单体）："><a href="#解决方案（单体）：" class="headerlink" title="解决方案（单体）："></a>解决方案（单体）：</h3><p><strong><em>程序部署上的主要问题显然是过大的堆内存进行回收时带来的长时间的停顿</em></strong></p>
<ul>
<li><p>将Java堆分配的内存重新缩小到1.5GB或者2GB ，在深夜执行定时任务的方式触发Full GC甚至是自动重启应用服务器来保持内存可用空间在一个稳定的水平。</p>
</li>
<li><p>这样的确可以避免长时间停顿，</p>
</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>在硬件上的投资就显得非常浪费。</li>
</ul>
<h3 id="解决方案（集群）："><a href="#解决方案（集群）：" class="headerlink" title="解决方案（集群）："></a>解决方案（集群）：</h3><ul>
<li>建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了10GB内存。</li>
<li>另外建立一个Apache服务作为前端均衡代理作为访问门户。</li>
<li>考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问，处理器资源敏感度较低，</li>
<li>因此改为CMS收集器进行垃圾回收。</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致I/O异常。</li>
<li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点的连接池已经满了，而另外一些节点仍有较多空余</li>
</ul>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><p><strong><em>控制Full GC频率的关键是老年代的相对稳定</em></strong></p>
<p>这主要取决于应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。</p>
<p>目前单体应用在较大内存的硬件上主要的部署方式有两种：</p>
<ul>
<li>通过一个单独的Java虚拟机实例来管理大量的Java堆内存。</li>
<li>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源。</li>
</ul>
<h2 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h2><h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><p>这是一个学校的小型项目：基于B/S的电子考试系统，为了实现客户端能实时地从服务器端接收考试数据，系统使用了逆向AJAX技术（也称为Comet或者Server Side Push），选用CometD 1.1.1作为服务端推送框架，服务器是Jetty 7.1.4，硬件为一台很普通PC机，Core i5 CPU，4GB内存，运行32位Windows操作系统。</p>
<ul>
<li><p>测试期间发现服务端不定时抛出内存溢出异常，服务不一定每次都出现异常</p>
</li>
<li><p>尝试过把堆内存调到最大，32位系统最多到1.6GB基本无法再加大了，而且开大了基本没效果，抛出内存溢出异常好像还更加频繁</p>
</li>
<li><p>加入-XX：+HeapDumpOnOutOfMemoryError参数，居然也没有任何反应，抛出内存溢出异常时什么文件都没有产生</p>
</li>
<li><p>无奈之下只好挂着jstat紧盯屏幕，发现垃圾收集并不频繁，Eden区、Survivor区、老年代以及方法区的内存全部都很稳定，压力并不大，但就是照样不停抛出内存溢出异常</p>
</li>
<li><p>在内存溢出后从系统日志中找到异常堆栈如代码清单5-1所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 异常堆栈</span><br><span class="line"></span><br><span class="line">[org.eclipse.jetty.util.log] handle failed java.lang.OutOfMemoryError: null</span><br><span class="line">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:99)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)</span><br><span class="line">at org.eclipse.jetty.io.nio.DirectNIOBuffer.&lt;init&gt;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul>
<li>操作系统对每个进程能管理的内存是有限制的，这台服务器使用的32位Windows平台的限制是2GB，其中划了1.6GB给Java堆，</li>
<li>而Direct Memory耗用的内存并不算入这1.6GB的堆之内，因此它最大也只能在剩余的0.4GB空间中再分出一部分而已</li>
<li> 直接内存（Direct Memory）空间不足之后，不会主动触发GC ，只能等待老年代满了之后Full GC，顺便帮忙清理 直接内存的废弃对象 </li>
<li>否则就不得不一直等到抛出内存溢出异常时，先捕获到异常，再在Catch块里面通过System.gc()命令来触发垃圾收集</li>
<li>如果Java虚拟机再打开了-XX：+DisableExplicitGC开关，禁止了人工触发垃圾收集的话，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常</li>
</ul>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><ul>
<li>直接内存：可通过-XX：MaxDirectMemorySize调整大小，内存不足时抛出OutOf-MemoryError或者OutOfMemoryError：Direct buffer memory。</li>
<li>线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（如果线程请求的栈深度大于虚拟机所允许的深度）或者OutOfMemoryError</li>
<li>Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较可观。如果无法分配，可能会抛出IOException：Too many open files异常。</li>
<li>JNI代码：如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中，而是占用Java虚拟机的本地方法栈和本地内存的。</li>
<li>虚拟机和垃圾收集器：虚拟机、垃圾收集器的工作也是要消耗一定数量的内存的。</li>
</ul>
<h2 id="外部命令导致系统缓慢："><a href="#外部命令导致系统缓慢：" class="headerlink" title="外部命令导致系统缓慢："></a>外部命令导致系统缓慢：</h2><h3 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h3><p>一个数字校园应用系统，运行在一台四路处理器的Solaris 10操作系统上，中间件为GlassFish服务器。系统在做大并发压力测试的时候，发现请求响应时间比较慢，通过操作系统的mpstat工具发现处理器使用率很高，但是系统中占用绝大多数处理器资源的程序并不是该应用本身。这是个不正常的现象，通常情况下用户应用的处理器占用率应该占主要地位，才能说明系统是在正常工作。</p>
<p>通过Solaris 10的dtrace脚本可以查看当前情况下哪些系统调用花费了最多的处理器资源，dtrace运行后发现最消耗处理器资源的竟然是“fork”系统调用。众所周知，“fork”系统调用是Linux用来产生新进程的，在Java虚拟机中，用户编写的Java代码通常最多只会创建新的线程，不应当有进程的产生，这又是个相当不正常的现象。</p>
<p><strong><em>最终找到了答案：</em></strong> </p>
<ul>
<li>每个用户请求的处理都需要执行一个外部Shell脚本来获得系统的一些信息。</li>
<li>执行这个Shell脚本是通过 <strong><em>Java的Runtime.getRuntime().exec()</em></strong> 方法来调用的。</li>
<li>这种调用方式可以达到执行Shell脚本的目的，但是它在Java虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也会非常可观。</li>
<li>Java虚拟机执行这个命令的过程是首先**<em>复制一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程**</em>。</li>
<li>如果频繁执行这个操作，系统的消耗必然会很大，而且不仅是处理器消耗，内存负担也很重。</li>
</ul>
<h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>建议去掉这个Shell脚本执行的语句，改为使用Java的API去获取这些信息后，系统很快恢复了正常。</p>
<h2 id="服务器虚拟机进程崩溃"><a href="#服务器虚拟机进程崩溃" class="headerlink" title="服务器虚拟机进程崩溃"></a>服务器虚拟机进程崩溃</h2><h3 id="问题：-3"><a href="#问题：-3" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>一个基于B/S的MIS系统，硬件为两台双路处理器、8GB内存的HP系统，服务器是WebLogic9.2</p>
</li>
<li><p>正常运行一段时间后，最近发现在运行期间频繁出现集群节点的虚拟机进程自动关闭的现象，留下了一个hs_err_pid###.log文件后，虚拟机进程就消失了</p>
</li>
<li><p>两台物理机器里的每个节点都出现过进程崩溃的现象。从系统日志中注意到，每个节点的虚拟机进程在崩溃之前，都发生过大量相同的异常，</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//异常堆栈2</span><br><span class="line"></span><br><span class="line">java.net.SocketException: Connection reset</span><br><span class="line">at java.net.SocketInputStream.read(SocketInputStream.java:168)</span><br><span class="line">at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)</span><br><span class="line">at java.io.BufferedInputStream.read(BufferedInputStream.java:235)</span><br><span class="line">at org.apache.axis.transport.http.HTTPSender.readHeadersFromSocket(HTTPSender.java:583)</span><br><span class="line">at org.apache.axis.transport.http.HTTPSender.invoke(HTTPSender.java:143)</span><br><span class="line">... 99 more</span><br></pre></td></tr></table></figure>

<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li>这是一个远端断开连接的异常，通过系统管理员了解到系统最近与一个OA门户做了集成，在MIS系统工作流的待办事项变化时，要通过Web服务通知OA门户系统，把待办事项的变化同步到OA门户之中。</li>
<li>通过SoapUI测试了一下同步待办事项的几个Web服务，发现调用后竟然需要长达3分钟才能返回，并且返回结果都是超时导致的连接中断。</li>
<li>由于MIS系统的用户多，待办事项变化很快，为了不被OA系统速度拖累，使用了异步的方式调用Web服务</li>
<li>但由于**<em>两边服务速度的完全不对等，时间越长就累积了越多Web服务没有调用完成，导致在等待的线程和Socket连接越来越多，最终超过虚拟机的承受能力后导致虚拟机进程崩溃**</em></li>
</ul>
<h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><p>通知OA门户方修复无法使用的集成接口，并**<em>将异步调用改为生产者/消费者模式的消息队列实现**</em>后，系统恢复正常。</p>
<h2 id="不恰当数据结构导致内存占用过大"><a href="#不恰当数据结构导致内存占用过大" class="headerlink" title="不恰当数据结构导致内存占用过大"></a>不恰当数据结构导致内存占用过大</h2><h3 id="问题：-4"><a href="#问题：-4" class="headerlink" title="问题："></a>问题：</h3><ul>
<li><p>一个后台RPC服务器，使用64位Java虚拟机，内存配置为-Xms4g-Xmx8g-Xmn1g，使用ParNew加CMS的收集器组合。</p>
</li>
<li><p>平时对外服务的Minor GC时间约在30毫秒以内，完全可以接受。但业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析，这些数据会在内存中形成超过100万个HashMap&lt;Long，Long&gt;Entry，</p>
</li>
<li><p>在这段时间里面Minor GC就会造成超过500毫秒的停顿</p>
</li>
<li><p>，对于这种长度的停顿时间就接受不了了，具体情况如下面的收集器日志所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=95 (full 4):</span><br><span class="line">par new generation total 903168K, used 803142K [0x00002aaaae770000, 0x00002aaaebb70000, 0x00002aaaebb70000)</span><br><span class="line">eden space 802816K, 100% used [0x00002aaaae770000, 0x00002aaadf770000, 0x00002aaadf770000)</span><br><span class="line">from space 100352K, 0% used [0x00002aaae5970000, 0x00002aaae59c1910, 0x00002aaaebb70000)</span><br><span class="line">to space 100352K, 0% used [0x00002aaadf770000, 0x00002aaadf770000, 0x00002aaae5970000)</span><br><span class="line">concurrent mark-sweep generation total 5845540K, used 3898978K [0x00002aaaebb70000, 0x00002aac507f9000, 0x00002aacae770000)</span><br><span class="line">concurrent-mark-sweep perm gen total 65536K, used 40333K [0x00002aacae770000, 0x00002aacb2770000, 0x00002aacb2770000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2011-10-28T11:40:45.162+0800: 226.504: [GC 226.504: [ParNew: 803142K-&gt; 100352K(903168K), 0.5995670 secs] 4702120K-&gt;Heap after GC invocations=96 (full 4):</span><br><span class="line">par new generation total 903168K, used 100352K [0x00002aaaae770000, 0x00002-aaaebb70000, 0x00002aaaebb70000)</span><br><span class="line">eden space 802816K, 0% used [0x00002aaaae770000, 0x00002aaaae770000, 0x00002aaadf770000)</span><br><span class="line">from space 100352K, 100% used [0x00002aaadf770000, 0x00002aaae5970000, 0x00002aaae5970000)</span><br><span class="line">to space 100352K, 0% used [0x00002aaae5970000, 0x00002aaae5970000, 0x00002aaaebb70000)</span><br><span class="line">concurrent mark-sweep generation total 5845540K, used 3955980K [0x00002aaaebb70000, 0x00002aac507f9000, 0x00002aacae770000)</span><br><span class="line">concurrent-mark-sweep perm gen total 65536K, used 40333K [0x00002aacae770000, 0x00002aacb2770000, 0x00002aacb2770000)</span><br><span class="line">&#125;T</span><br><span class="line">otal time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 0.6070570 seconds</span><br></pre></td></tr></table></figure>



<h3 id="分析-："><a href="#分析-：" class="headerlink" title="分析 ："></a>分析 ：</h3><ul>
<li>观察这个案例的日志，平时Minor GC时间很短，原因是新生代的绝大部分对象都是可清除的，在Minor GC之后Eden和Survivor基本上处于完全空闲的状态。</li>
<li>但是在分析数据文件期间，800MB的Eden空间很快被填满引发垃圾收集</li>
<li>但Minor GC之后，新生代中绝大部分对象依然是存活的</li>
<li>ParNew收集器使用的是复制算法，这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，</li>
<li>如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确性就成为一个沉重的负担，因此导致垃圾收集的暂停时间明显变长。</li>
</ul>
<h3 id="解决方案1："><a href="#解决方案1：" class="headerlink" title="解决方案1："></a>解决方案1：</h3><p>如果不修改程序，仅从GC调优的角度去解决这个问题，可以考虑直接将Survivor空间去掉（加入参数-XX：SurvivorRatio=65536、</p>
<p>-XX ：MaxTenuringThreshold=0或者-XX：+Always-Tenure），让新生代中存活的对象在第一次Minor GC后立即进入老年代，等到Major GC的时候再去清理它们。</p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>这种措施可以治标，但也有很大副作用</p>
<h3 id="解决方案2："><a href="#解决方案2：" class="headerlink" title="解决方案2："></a>解决方案2：</h3><p>治本的方案必须要修改程序，因为这里产生问题的根本原因是用HashMap&lt;Long，Long&gt;结构来存储数据文件空间效率太低了。</p>
<ul>
<li>我们具体分析一下HashMap空间效率，在HashMap&lt;Long，Long&gt;结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16字节（2×8字节）。</li>
<li>这两个长整型数据包装成java.lang.Long对象之后，就分别具有8字节的Mark Word、8字节的Klass指针，再加8字节存储数据的long值。</li>
<li>然后这2个Long对象组成Map.Entry之后，又多了16字节的对象头，然后一个8字节的next字段和4字节的int型的hash字段，为了对齐，还必须添加4字节的空白填充，</li>
<li>最后还有HashMap中对这个Entry的8字节的引用，这样增加两个长整型数字，实际耗费的内存为(Long(24byte)×2)+Entry(32byte)+HashMapRef(8byte)=88byte，空间效率为有效数据除以全部内存空间，即16字节/88字节=18%，这确实太低了。</li>
</ul>
<ul>
<li>如果是写入数据库，是否可以采用 ，边读边写，200条commit 一次</li>
</ul>
<h2 id="由安全点导致长时间停顿"><a href="#由安全点导致长时间停顿" class="headerlink" title="　由安全点导致长时间停顿"></a>　由安全点导致长时间停顿</h2><h3 id="问题：-5"><a href="#问题：-5" class="headerlink" title="问题："></a>问题：</h3><p>有一个比较大的承担公共计算任务的离线HBase集群，运行在JDK 8上，使用G1收集器。每天都有大量的MapReduce或Spark离线分析任务对其进行访问，同时有很多其他在线集群Replication过来的数据写入，因为集群读写压力较大，而离线分析任务对延迟又不会特别敏感，所以将-XX：MaxGCPauseMillis参数设置到了500毫秒。</p>
<ul>
<li><p>不过运行一段时间后发现垃圾收集的停顿经常达到3秒以上，</p>
</li>
<li><p>而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒，现象如以下日志所示。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Times: user=1.51 sys=0.67, real=0.14 secs]</span><br><span class="line">2019-06-25T 12:12:43.376+0800: 3448319.277: Total time <span class="keyword">for</span> <span class="built_in">which</span> application threads were stopped: 2.2645818</span><br></pre></td></tr></table></figure>



<h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>在垃圾收集调优时，我们主要依据real时间为目标来优化程序，因为最终用户只关心发出请求到得到响应所花费的时间，也就是响应速度，而不太关心程序到底使用了多少个线程或者处理器来完成任务。</p>
<p>日志显示这次垃圾收集一共花费了0.14秒，但其中用户线程却足足停顿了有2.26秒，两者差距已经远远超出了正常的TTSP（Time To Safepoint）耗时的范畴。</p>
<ul>
<li>所以先加入参数-XX：+PrintSafepointStatistics和-XX：PrintSafepointStatisticsCount=1去查看安全点日志，具体如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmop [threads: total initially_running wait_to_block]</span><br><span class="line">65968.203: ForceAsyncSafepoint [931 1 2]</span><br><span class="line">[time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line">[2255 0 2255 11 0] 1</span><br></pre></td></tr></table></figure>

<ul>
<li>日志显示当前虚拟机的操作（VM Operation，VMOP）是等待所有用户线程进入到安全点，</li>
<li>但是有两个线程特别慢，导致发生了很长时间的自旋等待。</li>
<li>日志中的2255毫秒自旋（Spin）时间就是指由于部分线程已经走到了安全点，但还有一些特别慢的线程并没有到，</li>
<li>所以垃圾收集线程无法开始工作，只能空转（自旋）等待。</li>
</ul>
<ul>
<li>解决问题的第一步是把这两个特别慢的线程给找出来，这个倒不困难，添加-XX：+SafepointTimeout和-XX：SafepointTimeoutDelay=2000两个参数，</li>
<li>让虚拟机在等到线程进入安全点的时间超过2000毫秒时就认定为超时，这样就会输出导致问题的线程名称，得到的日志如下所示：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SafepointSynchronize::begin: Timeout detected:</span></span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: Timed out while spinning to reach a safepoint.</span></span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: Threads which did not reach the safepoint:</span></span><br><span class="line"><span class="comment"># &quot;RpcServer.listener,port=24600&quot; #32 daemon prio=5 os_prio=0 tid=0x00007f4c14b22840</span></span><br><span class="line">nid=0xa621 runnable [0x0000000000000000]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line"><span class="comment"># SafepointSynchronize::begin: (End of list)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从错误日志中顺利得到了导致问题的线程名称为“RpcServer.listener，port=24600”</li>
<li>有什么因素可以阻止线程进入安全点？</li>
<li>安全点是以“是否具有让程序长时间执行的特征”为原则进行选定的，</li>
<li>所以方法调用、循环跳转、异常跳转这些位置都可能会设置有安全点，</li>
<li>但是HotSpot虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用int类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环（CountedLoop），相对应地，使用long或者范围更大的数据类型作为索引值的循环就被称为不可数循环（Uncounted Loop），将会被放置安全点。</li>
<li>通常情况下这个优化措施是可行的，但循环执行的时间不单单是由其次数决定，如果循环体单次执行就特别慢，那即使是可数循环也可能会耗费很多的时间。</li>
</ul>
<h3 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h3><p>最终查明导致这个问题是HBase中一个连接超时清理的函数，由于集群会有多个MapReduce或Spark任务进行访问，而每个任务又会同时起多个Mapper/Reducer/Executer，其每一个都会作为一个HBase的客户端，这就导致了同时连接的数量会非常多。更为关键的是，清理连接的索引值就是int类型，所以这是一个可数循环，HotSpot不会在循环中插入安全点。当垃圾收集发生时，如果RpcServer的Listener线程刚好执行到该函数里的可数循环时，则必须等待循环全部跑完才能进入安全点，此时其他线程也必须一起等着，所以从现象上看就是长时间的停顿。找到了问题，解决起来就非常简单了，</p>
<p><strong><em>把循环索引的数据类型从int改为long即可，</em></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">深入理解jvm-04-垃圾收集算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-27 12:01:23" itemprop="dateCreated datePublished" datetime="2020-12-27T12:01:23+08:00">2020-12-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-04-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>两个分代假说：</p>
<h4 id="弱分代假说（Weak-Generational-Hypothesis）："><a href="#弱分代假说（Weak-Generational-Hypothesis）：" class="headerlink" title="弱分代假说（Weak Generational Hypothesis）："></a>弱分代假说（Weak Generational Hypothesis）：</h4><ul>
<li> 绝大多数对象都是朝生夕灭的 </li>
</ul>
<h4 id="强分代假说（Strong-Generaional-Hypothesis）："><a href="#强分代假说（Strong-Generaional-Hypothesis）：" class="headerlink" title="强分代假说（Strong Generaional Hypothesis）："></a>强分代假说（Strong Generaional Hypothesis）：</h4><ul>
<li> 熬过越多次GC过程的对象 就越难以消亡</li>
</ul>
<p>这两个分代假说共同奠定了多款常用GC器一致的设计原则：</p>
<ul>
<li>GC器应该将Java 堆Heap 划分出不同的区域，然后将回收对象依据其 年龄（对象熬过GC收集的次数） 分配到不同的区域进行存储 。</li>
<li>而不同的区域 因为其对象的不同特性，可以采用不同的垃圾收集算法 。</li>
<li>如果区域对象 大多数对象都是朝生夕灭 的，难以熬过GC过程的 ，那把他们放在一起，每次回收只标记那些少量存活的对象实例，这样就可以用少量代价回收大量空间</li>
<li>如果剩下的都是难以消亡的对象，就把这个年龄大的对象 集中放在一起，jvm使用低频率区回收这个区域。  </li>
<li>这样就兼顾了GC的时间开销 和内存空间的有效利用</li>
</ul>
<p>将java堆进行划分成 不同区域后，gc器 才可以每次只收集其中某一个 或某些部分的区域， 因此 出现了  MInor GC , Major GC, Full GC</p>
<p>这样的回收类型划分，</p>
<p>针对不同区域的，安排与里面存储对象存亡特征相匹配的 GC 算法，如 标记删除，标记复制，标记整理 </p>
<p>因为存在 跨代引用的场景，老年代与新生代 可能存在互相引用的情况，这样 纪要通过GCRoot的可达性分析 ，也要额外遍历整个老年代的对象 来确保可达性分析结果的正确性， 这样由很大的性能负担</p>
<p> 所以出行第三条经验法则</p>
<h4 id="跨代引用假说（Intergenerational-Reference-Hypothesis）："><a href="#跨代引用假说（Intergenerational-Reference-Hypothesis）：" class="headerlink" title="跨代引用假说（Intergenerational Reference Hypothesis）："></a>跨代引用假说（Intergenerational Reference Hypothesis）：</h4><ul>
<li><p>跨代引用相对于同代引用来说 仅仅占极少数</p>
</li>
<li><p>这其实是通过强分代假说和 弱分代假说逻辑推理得出的推论： </p>
</li>
<li><p>存在互相引用关系的2个对象，应该是倾向于同时生存和同时消亡的，</p>
</li>
<li><p>如果某个新生代对象存在跨代引用，那么由于老年代对象难以消亡，所以 新生代对象在GC过程的时候也难以消亡，从而得以存活。慢慢的随着 之前新生代对象的年龄的增长，它也会被 晋升到老年代之中，这时候就不存在 跨代引用了</p>
</li>
<li><p>ps:  依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描</p>
</li>
</ul>
<h2 id="GC-名词字典"><a href="#GC-名词字典" class="headerlink" title="GC 名词字典"></a>GC 名词字典</h2><ul>
<li><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
</li>
<li><p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p>
</li>
</ul>
<h2 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark-Sweep）算法"></a>标记-清除（Mark-Sweep）算法</h2><p>算法分为“标记”和“清除”两个阶段：</p>
<ul>
<li>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，</li>
<li>也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</li>
<li>标记过程就是对象是否属于垃圾的判定过程，</li>
<li>后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过<br>程的执行效率都随对象数量增长而降低</li>
<li>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ul>
<p><img src="/uploads/jvm/05-mark-sweep.png"></p>
<h2 id="标记-复制（Mark-Copy）算法"><a href="#标记-复制（Mark-Copy）算法" class="headerlink" title="标记-复制（Mark-Copy）算法"></a>标记-复制（Mark-Copy）算法</h2><h3 id="半区复制-（Semispace-Copying）"><a href="#半区复制-（Semispace-Copying）" class="headerlink" title="半区复制 （Semispace Copying）"></a>半区复制 （Semispace Copying）</h3><ul>
<li><p>将可用内存按容量分为大小相等的2块 ，每次只使用其中1块 。 </p>
</li>
<li><p>当这一块的内存用完了，就将还存活的对象复制到另一块上面 ，</p>
</li>
<li><p>然后就将还存活的对象复制到另一块上面，</p>
</li>
<li><p>然后再把已经使用过的内存空间一次清理掉。 </p>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>如果内存中多数对象都是存活的，这种算法会产生大量的内存间的复制 开销</p>
</li>
<li><p><strong><em>但是</em></strong>   在新生代这个 内存区域，98%的对象实例都熬不过第一轮收集，所以 不是算法有问题，是将算法 没有用到对的区域</p>
</li>
<li><p> 因为多数对象都是可回收的状态，所以算法复制的就是占少数的存活对象 </p>
</li>
<li><p>而且因为每次都是针对整个半区进行回收，分配内存时候也不用考虑 空间碎片整理的情况，只需要移动堆顶指针，按顺序分配即可，简单 高效</p>
</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>复制回收算法的代价是 将内存缩小一半，空间浪费未免太多了一点</li>
</ul>
<p><img src="/uploads/jvm/06-mark_copy.png"></p>
<h3 id="优化半区复制-（Appel式回收）"><a href="#优化半区复制-（Appel式回收）" class="headerlink" title="优化半区复制 （Appel式回收）"></a>优化半区复制 （Appel式回收）</h3><p>因为IBM 对 对象的朝生夕灭 特点做了调研，新生代中的对象 98% 熬不过第一轮收集，所以 提出了优化版的半区复制算法，即： </p>
<p>Appel 式回收：</p>
<h4 id="具体做法："><a href="#具体做法：" class="headerlink" title="具体做法："></a>具体做法：</h4><ul>
<li>将新生代  分为一块较大的Eden区（80%）  + Survivor_1（10%）+Survivor_2（10%）</li>
<li>每次分配内存时候，只使用 Eden（80%） 和 Survivor_1（10%），而 Survivor_2（10%）就暂时浪费掉</li>
<li>当 发生 GC的时候，就将 Eden（80%） 和 Survivor_1（10%）中的存活对象 复制到 Survivor_2（10%） 中</li>
<li>然后直接清理掉Eden（80%） 和 Survivor_1（10%）</li>
</ul>
<h4 id="逃生门”的安全设计（分配担保）："><a href="#逃生门”的安全设计（分配担保）：" class="headerlink" title="逃生门”的安全设计（分配担保）："></a>逃生门”的安全设计（分配担保）：</h4><p>98%的对象都熬不过第一轮GC 这个是 普通场景， 没有人能保证 每一次 GC后 ，继续存活的对象 不超过10% ，所以 Survivor_2（10%） 有可能装不下了。</p>
<p>这个时候 Appel 有一个 “逃生门”的安全设计 ：</p>
<ul>
<li>当 Survivor_2（10%）容纳不了一次  Minor GC （新生代GC，Young GC）存活对象， </li>
<li>就需要 依赖其他内存区域（实际上大多数是老年代） 进行分配担保，就将一部分 存活对象移入 老年代</li>
</ul>
<h4 id="分配担保-（Todo）"><a href="#分配担保-（Todo）" class="headerlink" title="分配担保 （Todo）"></a>分配担保 （Todo）</h4><ul>
<li>内存的分配担保好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有什么风险了。</li>
<li>内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代，这对虚拟机来说就是安全的</li>
</ul>
<h2 id="标记整理（Mark-Compact）算法"><a href="#标记整理（Mark-Compact）算法" class="headerlink" title="标记整理（Mark-Compact）算法"></a>标记整理（Mark-Compact）算法</h2><ul>
<li><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种标记-复制算法 .</p>
</li>
<li><p>针对老年代对象的存亡特征，提出了 有针对性的 “标记-整理”（Mark-Compact）算法</p>
</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li>首先标记出所有需要回收的对象，</li>
<li>让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，“标记-整理”算法的示意图如图3-4所示。</li>
</ul>
<p><img src="/uploads/jvm/07-mark-compact.png"></p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li><p>如果移动存活对象，尤其是在老年代 这种每次回收都有大量对象存活区域 ，移动存活对象并更新所有 引用这些对象的地方将会是一种极为负重的操作 ，</p>
<p>而且这种对象移动操作必须全程暂停用户应用程序才能进行。 Stop The World</p>
</li>
<li><p>如果不考虑移动和整理存活对象的话，，存活对象倒置 的空间碎片化问题就 只能依赖更为复杂的内存分配器和内存访问器来解决。</p>
</li>
<li><p>内存的访问 是用户程序最频繁的操作，如果这个环节上增加了额外的负担，势必影响用户程序的吞吐量</p>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><p>基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p>
</li>
<li><p>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿</p>
</li>
<li><p>但是从整个程序的吞吐量来看，移动对象会更划算。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的</p>
</li>
<li><p>HotSpot虚拟机里面关注吞吐量的ParallelScavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的</p>
</li>
<li><p>还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p>
</li>
</ul>
<h2 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h2><ul>
<li><p>枚举根节点的时候，用户线程必须要停顿。</p>
</li>
<li><p>根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</p>
</li>
<li><p>这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因</p>
</li>
</ul>
<ul>
<li>虚拟机应当是有办法直接得到哪些地方存放着对象引用的。</li>
<li>在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，</li>
<li>在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</li>
</ul>
<h3 id="安全点（SafePoint）"><a href="#安全点（SafePoint）" class="headerlink" title="安全点（SafePoint）"></a>安全点（SafePoint）</h3><ul>
<li>实际上HotSpot也的确没有为每条指令都生成OopMap,只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）</li>
<li>安全点的设定，决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停</li>
<li>安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。</li>
</ul>
<h4 id="抢先式中断（Preemptive-Suspension）："><a href="#抢先式中断（Preemptive-Suspension）：" class="headerlink" title="抢先式中断（Preemptive Suspension）："></a>抢先式中断（Preemptive Suspension）：</h4><p>抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>
<p>现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</p>
<h4 id="主动式中断（Voluntary-Suspension）"><a href="#主动式中断（Voluntary-Suspension）" class="headerlink" title="主动式中断（Voluntary Suspension）:"></a>主动式中断（Voluntary Suspension）:</h4><ul>
<li>当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</li>
<li>轮询标志的地方和安全点是重合的，</li>
<li>另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li>
</ul>
<h3 id="安全区域（Safe-Region）："><a href="#安全区域（Safe-Region）：" class="headerlink" title="安全区域（Safe Region）："></a>安全区域（Safe Region）：</h3><ul>
<li><p>用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p>
</li>
<li><p>对于这种情况，就必须引入安全区域（Safe Region）来解决。</p>
</li>
<li><p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
</li>
<li><p>我们也可以把安全区域看作被扩展拉伸了的安全点 </p>
</li>
</ul>
<p>当用户线程执行到安全区域里面的代码时，</p>
<ul>
<li>首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</li>
<li>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），</li>
<li>如果完成了，那线程就当作没事发生过，继续执行；</li>
<li>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</li>
</ul>
<h3 id="记忆集与卡表（Remembered-Set）："><a href="#记忆集与卡表（Remembered-Set）：" class="headerlink" title="记忆集与卡表（Remembered Set）："></a>记忆集与卡表（Remembered Set）：</h3><ul>
<li><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围</p>
</li>
<li><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</p>
</li>
<li><p>在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节</p>
</li>
</ul>
<h4 id="卡精度："><a href="#卡精度：" class="headerlink" title="卡精度："></a>卡精度：</h4><p>  每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinshi</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"4oBiQGiWDHdACABLWjT7ouaV-gzGzoHsz","appKey":"fr4vMSPUjcHLtIrF2hmRF6UE","serverURLs":"https://4obiqgiw.lc-cn-n1-shared.com","placeholder":"国王不动，手下怎么跟随? --反叛的鲁鲁修","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"cdh":"https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"}, {
      el: '#valine-comments',
      path: "/page/4/",
      serverURLs: "https://4obiqgiw.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>


</body>
</html>
