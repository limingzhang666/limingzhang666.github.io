<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="HCj467TtuvFkAzzdCvYvbniAeNiUy7TUwp2hG1qGWQE">
  <meta name="baidu-site-verification" content="LppFIbSdZO">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limingzhang666.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","width":320,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="拨开云雾见青天">
<meta property="og:type" content="website">
<meta property="og:title" content="Yinshi&#39;s Blog">
<meta property="og:url" content="https://limingzhang666.github.io/page/3/index.html">
<meta property="og:site_name" content="Yinshi&#39;s Blog">
<meta property="og:description" content="拨开云雾见青天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yinshi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://limingzhang666.github.io/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yinshi's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yinshi's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yinshi"
      src="/images/yinshi01_avatar.jpg">
  <p class="site-author-name" itemprop="name">Yinshi</p>
  <div class="site-description" itemprop="description">拨开云雾见青天</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">65</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/limingzhang666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limingzhang666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:laimingcham@163.com" title="E-Mail → mailto:laimingcham@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/limingzhang666" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-17-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-17-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">深入理解jvm-17-线程安全与锁优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-01 20:44:15" itemprop="dateCreated datePublished" datetime="2021-02-01T20:44:15+08:00">2021-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-17-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-17-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>《Java并发编程实战（Java Concurrency In Practice）》的作者Brian Goetz为“线程安全”做出了一个比较恰当的定义：</p>
<ul>
<li>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是 线程安全的</li>
<li>这个定义就很严谨而且有可操作性，它要求线程安全的代码都必须具备一个共同特征：<strong>代码本身封装了所有必要的正确性保障手段（如互斥同步等</strong>），令调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。这点听起来简单，但其实并不容易做到，在许多场景中，我们都会将这个定义弱化一些</li>
</ul>
<h3 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h3><ul>
<li><p>在Java语言中，线程安全具体是如何体现的？</p>
</li>
<li><p>有哪些操作是线程安全的？</p>
</li>
</ul>
<p>为了更深入地理解线程安全，在这里我们可以不把线程安全当作一个非真即假的二元排他选项来看待，而是按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为以下五类：<strong>不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</strong></p>
<h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>在Java语言里面，<strong>不可变（Immutable）的对象一定是线程安全的</strong>，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。  在讲解“final关键字带来的可见性”时曾经提到过一点：  只要一个不可变对象被正确的构建出来（即没有发生this 引用逃逸的情况），那其外部的可见状态永远都不会改变，永远都不会看到它再多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、最纯粹的。</p>
<ul>
<li><p>Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。</p>
</li>
<li><p>如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。</p>
</li>
<li><p>不妨类比java.lang.String类的对象实例，它是一个典型的不可变对象，用户调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象</p>
</li>
<li><p>保证对象行为不影响自己状态的途径有很多种，最简单的一种就是把对象里面带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的，例如代码清单13-1中所示的java.lang.Integer构造函数，它通过将内部状态变量value定义为final来保障状态不变</p>
</li>
<li><p>代码清单13-1　JDK中Integer类的构造函数</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The value of the &lt;code&gt;Integer&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a newly allocated &lt;code&gt;Integer&lt;/code&gt; object that</span></span><br><span class="line"><span class="comment">* represents the specified &lt;code&gt;int&lt;/code&gt; value.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value the value to be represented by the</span></span><br><span class="line"><span class="comment">* &lt;code&gt;Integer&lt;/code&gt; object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java类库API中符合不可变要求的类型，除了上面提到的String之外，常用的还有枚举类型及java.lang.Number的部分子类，如Long和Double等数值包装类型、BigInteger和BigDecimal等大数据类型。但同为Number子类型的原子类AtomicInteger和AtomicLong则是可变的，读者不妨看看这两个原子类的源码，想一想为什么它们要设计成可变的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This class intended to be implemented using VarHandles, but there</span></span><br><span class="line"><span class="comment">     * are unresolved cyclic startup dependencies.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value; <span class="comment">//因为 被 volatile修饰了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicInteger with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>绝对的线程安全能够完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的，甚至不切实际的代价。</p>
<p>在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。</p>
<p>我们可以通过Java API中一个不是“绝对线程安全”的“线程安全类型”来看看这个语境里的“绝对”究竟是什么意思。</p>
<p>如果说java.util.Vector是一个线程安全的容器，相信所有的Java程序员对此都不会有异议，<strong>因为它的add()、get()和size()等方法都是被synchronized修饰的</strong>，尽管这样效率不高，但保证了具备原子性、可见性和有序性。不过，即使它所有的方法都被修饰成synchronized，也不意味着调用它的时候就永远都不再需要同步手段了，请看看代码清单13-2中的测试代码。</p>
<p>代码清单13-2　对Vector线程安全的测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTestCase_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        System.out.println((vector.get(i)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line">            <span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">Exception in thread <span class="string">&quot;Thread-469&quot;</span> java.lang.ArrayIndexOutOfBoundsException: Array index out of range: <span class="number">17</span></span><br><span class="line">	at java.base/java.util.Vector.get(Vector.java:<span class="number">777</span>)</span><br><span class="line">	at org.fenixsoft.jvm.chapter13.VectorTestCase_1$<span class="number">2.</span>run(VectorTestCase_1.java:<span class="number">31</span>)</span><br><span class="line">	at java.base/java.lang.Thread.run(Thread.java:<span class="number">844</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>尽管这里使用到的Vector的get()、remove()和size()方法都是同步的，</p>
<ul>
<li>但是在多线程的环境中，如果不在方法调用端做额外的同步措施，使用这段代码仍然是不安全的。</li>
<li>因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i已经不再可用，再用访问数组就会抛出一个ArrayIndexOutOfBoundsException异常。</li>
<li>如果要保证这段代码能正确执行下去，我们不得不把removeThread和printThread的定义改成代码清单13-3所示的这样</li>
</ul>
<p>代码清单13-3　必须加入同步保证Vector访问的线程安全性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTestCase_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            vector.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            System.out.println((vector.get(i)));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">            <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>假如Vector一定要做到绝对的线程安全，那就必须<strong>在它内部维护一组一致性的快照访问</strong>才行，每次对其中元素进行改动都要产生新的快照，这样要付出的时间和空间成本都是非常大的。</li>
</ul>
<h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，</p>
<ul>
<li>但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。代码清单13-2和代码清单13-3就是相对线程安<br>全的案例。</li>
<li>在Java语言中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。</li>
</ul>
<h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，</p>
<ul>
<li>但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，</li>
<li>通常就是指这种情况。Java类库API中大部分的类都是线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</li>
</ul>
<h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ul>
<li>了解过什么是线程安全之后，紧接着的一个问题就是我们应该如何实现线程安全。这听起来似乎是一件由代码如何编写来决定的事情，不应该出现在讲解Java虚拟机的书里。确实，如何实现线程安全与代码编写有很大的关系，</li>
<li>但虚拟机提供的同步和锁机制也起到了至关重要的作用。如何编写代码实现线程安全，以及虚拟机如何实现同步与锁这两方面都会涉及，相对而言更偏重后者一些，只要读者明白了Java虚拟机线程安全措施的原理与运作过程，自己再去思考代码如何编写就不是一件困难的事情了。</li>
</ul>
<h4 id="互斥同步（Mutual-Exclusion-amp-Synchronization）"><a href="#互斥同步（Mutual-Exclusion-amp-Synchronization）" class="headerlink" title="互斥同步（Mutual Exclusion &amp; Synchronization）"></a>互斥同步（Mutual Exclusion &amp; Synchronization）</h4><p>互斥同步（Mutual Exclusion &amp; Synchronization）是一种最常见也是最主要的并发正确性保障手段。</p>
<ul>
<li><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，当使用信号量的时候）线程使用。</p>
</li>
<li><p>而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是常见的互斥实现方式。</p>
</li>
<li><p>因此在“互斥同步”这四个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p>
</li>
</ul>
<ul>
<li>在Java里面，最基本的互斥同步手段就是<strong>synchronized</strong>关键字，这是一种块结构（BlockStructured）的同步语法。</li>
<li>synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。</li>
<li>这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。</li>
<li>如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；</li>
<li>如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</li>
</ul>
<p>根据《Java虚拟机规范》的要求，<strong>在执行monitorenter指令时，首先要去尝试获取对象的锁。</strong>如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一，</p>
<p>而<strong>在执行monitorexit指令时会将锁计数器的值减一</strong>。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。</p>
<p>我们可以得出两个关于synchronized的直接推论，这是使用它时需特别注意的：</p>
<ul>
<li>被synchronized修饰的同步块<strong>对同一条线程来说是可重入的</strong>。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li>
<li>被synchronized修饰的同步块<strong>在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入</strong>。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。</li>
</ul>
<p>从执行成本的角度看，持有锁是一个重量级（Heavy-Weight）的操作。</p>
<p>在主流Java虚拟机实现中，Java的线程是映射到操作系统的原生内核线程之上的，如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。</p>
<p>尤其是对于代码特别简单的同步块（譬如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间甚至会比用户代码本身执行的时间还要长。因此才说，synchronized是Java语言中一个重量级的操作，有经验的程序员都只会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，以避免频繁地切入核心态之中</p>
<h3 id="锁Lock"><a href="#锁Lock" class="headerlink" title="锁Lock"></a>锁Lock</h3><p>除了synchronized关键字以外，自JDK 5起（实现了JSR 166[1]），Java类库中新提供了java.util.concurrent包（下文称J.U.C包），其中的<br><strong>java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段</strong>。基于Lock接口，用户能够以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔的空间。</p>
<h4 id="重入锁（ReentrantLock）"><a href="#重入锁（ReentrantLock）" class="headerlink" title="重入锁（ReentrantLock）"></a>重入锁（ReentrantLock）</h4><p>重入锁（ReentrantLock）是Lock接口最常见的一种实现[2]，顾名思义，它与synchronized一样是可重入[3]的。在基本用法上，ReentrantLock也与synchronized很相似，只是代码写法上稍有区别而已。不过，ReentrantLock与synchronized相比增加了一些高级功能，</p>
<p>主要有以下三项：等待可中断、可实现公平锁及锁可以绑定多个条件。</p>
<ul>
<li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。</li>
<li>锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。</li>
</ul>
<p>ReentrantLock在功能上是synchronized的超集，在性能上又至少不会弱于synchronized，那synchronized修饰符是否应该被直接抛弃，不再使用了呢？当然不是，基于以下理由，仍然推荐在synchronized与ReentrantLock都可满足需要时优先使用synchronized：</p>
<ul>
<li>synchronized是在<strong>Java语法层面的同步，足够清晰，也足够简单</strong>。每个Java程序员都熟悉synchronized，但J.U.C中的Lock接口则并非如此。因此在只需要基础的同步功能时，更推荐synchronized。</li>
<li>Lock应该<strong>确保在finally块中释放锁</strong>，否则一旦受同步保护的代码块中抛出异常，则有可能永远不会释放持有的锁。这一点必须由程序员自己来保证，而使用synchronized的话则可以由Java虚拟机来确保即使出现异常，锁也能被自动释放。</li>
<li>从长远来看，Java虚拟机更容易针对synchronized来进行优化，因为Java虚拟机可以在线程和对象的元数据中记录synchronized中锁的相关信息，而使用J.U.C中的Lock的话，Java虚拟机是很难得知具体哪些锁对象是由特定线程锁持有的。</li>
</ul>
<h3 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h3><ul>
<li>互斥同步面临的<strong>主要问题是进行线程阻塞和唤醒所带来的性能开销</strong>，因此这种同步也被称为阻塞同步（Blocking Synchronization）。</li>
<li>从解决问题的方式上看，<strong>互斥同步属于一种悲观的并发策略</strong>，其总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享的数据是否真的会出现竞争，它都会进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁），这将会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。</li>
</ul>
<p>随着硬件指令集的发展，我们已经有了另外一个选择：<strong>基于冲突检测的乐观并发策略</strong>，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，<strong>最常用的补偿措施是不断地重试</strong>，直到出现没有竞争的共享数据为止。<strong>这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步（Non-Blocking Synchronization</strong>），使用这种措施的代码也常被称为<strong>无锁（Lock-Free）编程。</strong></p>
<p>为什么说使用乐观并发策略需要“硬件指令集的发展”？</p>
<p>因为我们必须要求<strong>操作和冲突检测这两个步骤具备原子性</strong>。靠什么来保证原子性？如果这里再使用互斥同步来保证就完全失去意义了，所以我们只能靠硬件来实现这件事情，<strong>硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成</strong>，这类指令常用的有：</p>
<ul>
<li>测试并设置（Test-and-Set）；</li>
<li>获取并增加（Fetch-and-Increment）；</li>
<li>·交换（Swap）；</li>
<li><strong>比较并交换（Compare-and-Swap，下文称CAS）</strong>；</li>
<li>加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）</li>
</ul>
<p>前面的三条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能也是类似的.</p>
<p>因为Java里最终暴露出来的是CAS操作，所以我们以CAS指令为例进行讲解。</p>
<h4 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h4><ul>
<li>CAS指令需要有三个操作数，分别是<strong>内存位置</strong>（在Java中可以简单地理解为变量的内存地址，用V表示）、<strong>旧的预期值</strong>（用A表示）和<strong>准备设置的新值</strong>（用B表示）。</li>
<li>CAS指令执行时，<strong>当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值</strong>，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。</li>
<li>在JDK 5之后，Java类库中才开始使用CAS操作，该操作由<strong>sun.misc.Unsafe</strong>类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供。</li>
<li>HotSpot虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了[5]。</li>
<li>不过由于Unsafe类在设计上就不是提供给用户程序调用的类（Unsafe::getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的Class才能访问它），因此在JDK 9之前只有Java类库可以使用CAS，譬如J.U.C包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作来实现。</li>
<li>而如果用户程序也有使用CAS操作的需求，那要么就采用反射手段突破Unsafe的访问限制，要么就只能通过Java类库API来间接使用它。直到JDK 9之后，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作</li>
</ul>
<p>下面笔者将用一段在前面章节中没有解决的问题代码来介绍如何通过CAS操作避免阻塞同步。测试的代码如代码清单12-1所示，为了节省版面笔者就不重复贴到这里了。这段代码里我们曾经通过20个线程自增10000次的操作来<strong>证明volatile变量不具备原子性</strong>，那么如何才能让它具备原子性呢？之前我们的解决方案是<strong>把race++操作或increase()方法用同步块包裹起来</strong>，这毫无疑问是一个解决方案，但是如果改成代码清单13-4所示的写法，效率将会提高许多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomic变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger race = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用AtomicInteger代替int后，程序输出了正确的结果，这一切都要归功于incrementAndGet()方法的原子性。它的实现其实非常简单，如代码清单13-5所示</li>
<li>代码清单13-5　incrementAndGet()方法的JDK源码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Atomically increments the current value,</span></span><br><span class="line"><span class="comment">   * with memory effects as specified by &#123;<span class="doctag">@link</span> VarHandle#getAndAdd&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Equivalent to &#123;<span class="doctag">@code</span> addAndGet(1)&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Atomically adds the given value to the current value of a field</span></span><br><span class="line"><span class="comment">   * or array element within the given object &#123;<span class="doctag">@code</span> o&#125;</span></span><br><span class="line"><span class="comment">   * at the given &#123;<span class="doctag">@code</span> offset&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> o object/array to update the field/element in</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> offset field/element offset</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> v;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          v = getIntVolatile(o, offset);</span><br><span class="line">      &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Atomically updates Java variable to &#123;<span class="doctag">@code</span> x&#125; if it is currently</span></span><br><span class="line"><span class="comment">   * holding &#123;<span class="doctag">@code</span> expected&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment">   * and write.  Corresponds to C11 atomic_compare_exchange_strong.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>incrementAndGet()方法在一个无限循环中，不断尝试将一个比当前值大一的新值赋值给自己。如果失败了，那说明在执行CAS操作的时候，旧值已经发生改变，于是再次循环进行下一次操作，直到设置成功为止。</p>
<h4 id="CAS操作的“ABA问题”"><a href="#CAS操作的“ABA问题”" class="headerlink" title="CAS操作的“ABA问题”"></a>CAS操作的“ABA问题”</h4><p>尽管CAS看起来很美好，既简单又高效，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是真正完美的，它存在一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那就能说明它的值没有被其他线程改变过了吗？</p>
<p>这是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA问题”</p>
<h3 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h3><p>要保证线程安全，也并非一定要进行阻塞或非阻塞同步，<strong>同步与线程安全两者没有必然的联系</strong>。<strong>同步只是保障存在共享数据争用时正确性的手段，如果能让一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性</strong>，因此会有一些代码天生就是线程安全的，笔者简单介绍其中的两类。</p>
<h4 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h4><ul>
<li>可重入代码（Reentrant Code）：这种代码又称纯代码（Pure Code），是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。</li>
<li>在特指多线程的上下文语境里（不涉及信号量等因素），我们可以认为可重入代码是线程安全代码的一个真子集，这意味着相对线程安全来说，可重入性是更为基础的特性，它可以保证代码线程安全，</li>
<li>即所有可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的。</li>
<li>可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。</li>
<li>我们可以通过一个比较简单的原则来判断代码是否具备可重入性：如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</li>
</ul>
<h4 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h4><ul>
<li>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可<br>见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</li>
<li>大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</li>
<li>Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字将它声明为“易变的”；</li>
<li>如果一个变量只要被某个线程独享，可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</li>
</ul>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>高效并发是从JDK 5升级到JDK 6后一项重要的改进项，HotSpot虚拟机开发团队在这个版本上花费了大量的资源去实现各种锁优化技术，</p>
<p>如<strong>适应性自旋（Adaptive Spinning）、锁消除（LockElimination）、锁膨胀（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（BiasedLocking）</strong>等，这些技术都是为了在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率。</p>
<h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h3><ul>
<li>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力</li>
<li>同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得</li>
<li>如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。</li>
<li>为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</li>
<li><strong>自旋等待不能代替阻塞</strong>，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果<strong>锁被占用的时间很</strong><br><strong>短，自旋等待的效果就会非常好</strong>，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。</li>
<li>因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是十次，用户也可以使用参数-XX：PreBlockSpin来自行更改。</li>
</ul>
<ul>
<li>在JDK 6中对自旋锁的优化，引入了自适应的自旋。</li>
<li>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。</li>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。</li>
<li>另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。</li>
<li>有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机就会变得越来越“聪明”了。</li>
</ul>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><ul>
<li>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是<strong>对被检测到不可能存在共享数据竞争的锁进行消除</strong></li>
<li>锁消除的主要判定依据<strong>来源于逃逸分析的数据支持，</strong>如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可<br>以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</li>
</ul>
<p>代码清单13-6　一段看起来没有同步的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也知道，由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编译器会对String连接做自动优化。在JDK 5之前，字符串加法会转化为StringBuffer对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。即代码清单13-6所示的代码可能会变成代码清单13-7所示的样子[1]。</p>
<p>代码清单13-7　Javac转化后的字符串连接操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，经过逃逸分析后会发现它的动态作用域被限制在concatString()方法内<br>部。也就是sb的所有引用都永远不会逃逸到concatString()方法之外，其他线程无法访问到它，所以这里虽然有锁，但是可以被安全地消除掉。在解释执行时这里仍然会加锁，但在经过服务端编译器的即时编译之后，这段代码就会忽略所有的同步措施而直接执行。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。</p>
<p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>代码清单13-7所示连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，</p>
<p>以代码清单13-7为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。</p>
<ul>
<li><p>不过，需要强调一点，<strong>轻量级锁并不是用来代替重量级锁的</strong>，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
</li>
<li><p>要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须要对HotSpot虚拟机对象的内存布局（尤其是对象头部分）有所了解</p>
</li>
</ul>
<p>HotSpot虚拟机的对象头（Object Header）分为两部分，</p>
<ul>
<li><p>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“MarkWord”。这部分是实现轻量级锁和偏向锁的关键。</p>
</li>
<li><p>另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</p>
</li>
<li><p>由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，Mark Word被设计成一个非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。</p>
</li>
<li><p>它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，对象未被锁定的状态下，Mark Word的32个比特空间里的25个比特将用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，还有1个比特固定为0（这表示未进入偏向模式）。对象除了未被锁定的正常状态外，还有轻量级锁定、重量级锁定、GC标记、可偏向等几种不同状态，这些状态下对象头的存储内容如表13-1所示。</p>
</li>
</ul>
<p><img src="source/uploads/jvm/15lock/01MarkWord.png"></p>
<h4 id="轻量级锁的工作过程"><a href="#轻量级锁的工作过程" class="headerlink" title="轻量级锁的工作过程"></a>轻量级锁的工作过程</h4><ol>
<li><p>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（LockRecord）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图13-3所示。</p>
<p><img src="source/uploads/jvm/15lock/02stackAndObjectHeader.png"></p>
</li>
<li><p>然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图13-4所示</p>
</li>
</ol>
<p><img src="source/uploads/jvm/15lock/03AfterstackAndObjectHeader.png"></p>
<p>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，</p>
<p>如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，</p>
<p>否则就说明这个锁对象已经被其他线程抢占了。</p>
<p>如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，<strong>必须要膨胀为重量级锁</strong>，锁标志的状态值变为“10”，此时Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</p>
<p>上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的DisplacedMark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁也是JDK 6中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说<strong>轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量</strong>，那<strong>偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了</strong>。</p>
<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<h4 id="偏向锁过程"><a href="#偏向锁过程" class="headerlink" title="偏向锁过程"></a>偏向锁过程</h4><p>假设当前虚拟机启用了偏向锁（启用参数-XX：+UseBiased Locking，这是自JDK 6起HotSpot虚拟机的默认值），那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操等）。</p>
<p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照上面介绍的轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象Mark Word的关系如图13-5所示。</p>
<p><img src="source/uploads/jvm/15lock/04pianxiangLOCK"></p>
<p>细心的读者看到这里可能会发现一个问题：当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？</p>
<ul>
<li>在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。</li>
<li>作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变</li>
<li>因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</li>
</ul>
<p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数-XX：-UseBiasedLocking来禁止偏向锁优化反而可以提升性能。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-16-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-16-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">深入理解jvm-16-Java内存模型与线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-31 13:39:44" itemprop="dateCreated datePublished" datetime="2021-01-31T13:39:44+08:00">2021-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-16-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-16-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h1><p>衡量一个服务性能的高低好坏，<strong>每秒事务处理数（Transactions Per Second，TPS</strong>）是重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又是有非常密切的关系。对于计算量相同的任务，程序线程并发协调得有条不紊，效率自然就会很高；反之 线程之间频繁争用数据，互相阻塞甚至死锁，将会大大降低程序得并发能力。</p>
<h2 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h2><p>我们先花费一点时间去了解一下物理计算机中的并发问题。<strong>物理机遇到的并发问题与虚拟机中的情况有很多相似之处</strong>，物理机对并发的处理方案对虚拟<br>机的实现也有相当大的参考意义。</p>
<p>物理机：</p>
<p>由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲： </p>
<ul>
<li> 将运算需要使用的数据复制到缓存中，让运算能快速的进行，</li>
<li>当运算结束后，在将缓存中的数据同步到内存之中，这样处理器就无须等待缓慢的内存读写了。</li>
</ul>
<p>基于高速缓存的存储交互很好地解决了处理器和内存速度之间的矛盾，但是也为计算机系统带来了更高的复杂度，它引入了一个新的问题：  <strong>缓存一致性（Cache  Coherence）</strong> 。在多路处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存（Main Memory），这种系统被称为 <strong>共享内存多核系统（Shared Memory Multi-processors system）</strong>，如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。如果真的发生这种情况，那同步回到主内存时该以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p>
<p>从本章开始，我们将会频繁见到“<strong>内存模型</strong>”一词，它可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</p>
<ul>
<li>不同架构的物理机器可以拥有不一样的内存模型，</li>
<li>而Java虚拟机也有自己的内存模型，并且这里介绍的<strong>内存访问操作以及硬件的缓存访问操作具有高度的可类比性。</strong></li>
</ul>
<p><img src="/uploads/jvm/14memoryModel/cpu-memory-interaction.png"></p>
<p>除了增加<strong>高速缓存</strong>之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）优化</strong>，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但<strong>并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致</strong>，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有   <strong>指令重排序（Instruction Reorder）优化</strong>。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>《Java虚拟机规范》中曾试图定义一种<strong>“Java内存模型”（Java Memory Model，JMM）</strong>来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是也必须定义得足够宽松，使得虚拟机的实现能有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，</p>
<p>直至JDK 5（实现了JSR-133[3]）发布后，Java内存模型才终于成熟、完善起来了。</p>
<h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><ul>
<li><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节</p>
</li>
<li><p>此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了<strong>实例字段、静态字段和构成数组对象的元素</strong>，但是<strong>不包括局部变量与方法参数</strong>，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题</p>
</li>
<li><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时提到的主内存名字一样，两者也可以类比，但物理上它仅是虚拟机内存的一部分）</p>
</li>
<li><p>每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本[2]，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据</p>
</li>
<li><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图12-2所示，注意与图12-1进行对比。</p>
</li>
</ul>
<p><img src="/uploads/jvm/14memoryModel/thread-memory-interaction.png"></p>
<p>ps： 如果局部变量是一个reference类型，它引用的对象在Java堆中可被各个线程共享，但是reference本身在Java栈的局部变量表中是线程私有的</p>
<h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从<strong>主内存拷贝到工作内存</strong>、如何从<strong>工作内存同步回主内存</strong>这一类的实现细节，Java内存模型中定义了以下8中操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）</p>
<ul>
<li>lock（锁定）： 作用于 <strong>主内存的变量</strong>，它把一个变量标识为一条线程独占的状态</li>
<li>unlock(解锁): 作用域主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）： 作用域主内存的变量，它把一个变量的值从主内存传输到 线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）： 作用于 工作内存的变量，它把read操作从主内存中得到的变量值 放入到工作内存的变量副本中。</li>
<li>use（使用）： 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>
<li>store（存储）： 作用于工作内存的变量，它把工作内存中一个变量的值 传送到主内存中，以便随后的write操作使用</li>
<li>write(写入)： 作用于主内存的变量，它把store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。</p>
<p>注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令<br>的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但 <strong>lock操作可以被同一条线程重复执行多次</strong>，多次执行lock后，<strong>只有执行相同次数的unlock操作，变量才会被解锁。</strong></li>
<li>如果对一个变量执行lock操作，那将会<strong>清空工作内存中此变量的值</strong>，在执行引擎使用这个变量前，需要<strong>重新执行load或assign操作以初始化变量的值</strong>。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字 volatile可以说时java虚拟机提供的最轻量级的同步机制，了解volatile 变量的语义对后面理解多线程操作的其他特性很有意义。</p>
<p>当一个变量被定义为 volatile 之后，它将具备两项特性： </p>
<ul>
<li>第一项是 保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时需要 都需要通过主内存来完成。 比如： 线程A修改了一个普通变量的值，然后向主内存进行回写， 另外一条线程B在线程A回写完成了之后 再对主内存进行读取操作，新变量值才会对线程B可见。</li>
<li>关于volatile变量的可见性，经常会被开发人员误解，他们会误以为这句话的描述时正确的： “<strong>volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反映到其他线程之中</strong>。换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是线程安全的”  这句话的<strong>论据部分并没有错，</strong>但是由其论据并不能得出“基于volatile变量的运算在并发下是线程安全的”这样的结论。</li>
<li>volatile变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但<strong>由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题</strong>），但是<strong>Java里面的运算操作符并非原子操作</strong>，这导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因，请看代码清单12-1中演示的例子。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile变量自增运算测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析:"></a>结果分析:</h4><p>这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字。这是为什么呢？</p>
<p>问题就出在自增运算“race++”之中，我们用Javap反编译这段代码后会得到代码清单12-2所示，发现只有一行代码的increase()方法在Class文件中是由4条字节码指令构成（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上已经很容易分析出并发失败的原因了：当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。</p>
<p>代码清单12-2　VolatileTest的字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">        Stack=<span class="number">2</span>, Locals=<span class="number">0</span>, Args_size=<span class="number">0</span></span><br><span class="line">        0: getstatic		 #13; //Field race:I</span><br><span class="line">        <span class="number">3</span>: iconst_1</span><br><span class="line">        <span class="number">4</span>: iadd</span><br><span class="line">        5: putstatic		 #13; //Field race:I</span><br><span class="line">        <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>实事求是地说，使用字节码来分析并发问题仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器要运行许多行代码才能实现它的语义。如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令。</p>
<p>此处使用-XX：+PrintAssembly参数输出反汇编来分析才会更加严谨一些，</p>
<p><strong>由于volatile 变量只能保证可见性，在不符合一下两条规则的运算场景中</strong>，我们仍然要通过加锁（使用synchronized、java.util.concurrent中的锁 或者原子类）来保证原子性：</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<p>而在像代码清单12-3所示的这类场景中就很适合使用volatile变量来控制并发，当shutdown()方法被调用时，能保证所有线程中执行的doWork()方法都立即停下来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	shutdownRequested = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123;</span><br><span class="line">    <span class="comment">// 代码的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用volatile 变量的第二个语义是  <strong>禁止指令重排序优化</strong>，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序 与程序代码中的执行顺序一致。因为在同一个线程的方法执行过程中无法感知到这点，这就是Java内存模型中描述的所谓“<strong>线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）”</strong></p>
<p>代码清单12-4　指令重排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息，当读取完成后</span></span><br><span class="line"><span class="comment">// 将initialized设置为true,通知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> HashMap();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">// 等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span> (!initialized) &#123;</span><br><span class="line">	sleep();</span><br><span class="line">&#125;/</span><br><span class="line">/ 使用线程A中初始化好的配置信息</span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>

<p>上面的代码时一段伪代码，其中描述的是 开发中常见的配置读取过程。只是我们在处理配置文件的时候一般都不会并发，所以没有察觉到这会有问题。</p>
<p>如果定义initialized 变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一条代码 initialized=true 被提前执行。这样在线程B中使用配置信息的代码就可能出现错误，而 volatile 关键字则可以避免此类情况的发生 。</p>
<p>指令重排序是并发编程中最容易导致开发人员产生疑惑的地方之一，除了上面伪代码的例子之外，再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。代码清单12-5所示是一段标准的双锁检测（Double Check Lock，DCL）单例[3]代码，可以观察加入volatile和未加入volatile关键字时所生成的汇编代码的差别。<br>代码清单12-5　DCL单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        	&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，这段代码对instance变量赋值的部分如代码清单12-6所示。<br>代码清单12-6　对instance变量赋值</p>
<p><img src="/uploads/jvm/14memoryModel/MemoryBarries.png" alt="image-20210131213832956"></p>
<p>通过对比发现，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150(%esi)这句便是赋值操作）多执行了一个“lock addl$0x0，(%esp)”操作，这个操作的作用相当于一个<strong>内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置</strong>，注意不要与第3章中介绍的垃圾收集器用于捕获变量访问的内存屏障互相混淆），只有一个处理器访问内存时，并不需要内存屏障；但如果有两个或更多处理器访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。</p>
<h4 id="volatile性能问题"><a href="#volatile性能问题" class="headerlink" title="volatile性能问题"></a>volatile性能问题</h4><ul>
<li>在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），</li>
<li>但是由于虚拟机对锁实行的许多消除和优化，使得我们很难确切地说volatile就会比synchronized快上多少。</li>
<li>volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行</li>
<li>不过即便如此，大多数场景下volatile的总开销仍然要比锁来得更低</li>
<li>我们在volatile与锁中选择的唯一判断依据<strong>仅仅是volatile的语义能否满足使用场景的需求。</strong></li>
</ul>
<h4 id="Java内存模型中对volatile变量定义的特殊规则"><a href="#Java内存模型中对volatile变量定义的特殊规则" class="headerlink" title="Java内存模型中对volatile变量定义的特殊规则"></a>Java内存模型中对volatile变量定义的特殊规则</h4><p>假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则：</p>
<ol>
<li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现。  （<strong>这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改</strong>）</li>
<li>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现。（<strong>这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以</strong><br><strong>看到自己对变量V所做的修改。</strong>）</li>
<li>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的<br>对变量W的read或write动作。如果A先于B，那么P先于Q。(<strong>这条规则要求volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序</strong><br><strong>相同。</strong>)</li>
</ol>
<h4 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h4><p>Java内存模型是围绕在并发过程中如何处理原子性、可见性和有序性着三个特征来建立的。</p>
<ol>
<li>原子性</li>
</ol>
<ul>
<li><p>由Java内存模型来直接保证的原子性变量操作包括 read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的访问、读写 都具备原子性的（例外就是long和double 的非原子性协定，）</p>
</li>
<li><p>如果应用场景需要一个更大范围的原子性保证，Java内存模型 还提供了lock 和 unlock操作来满足这种需求，尽管虚拟机 未把lock 和unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitor-enter 和 monitor-exit来隐式地使用这两个操作。 这两个字节码指令映射到Java代码中就是同步块-synchronized 关键字，因此在synchronized 块之间地操作也具备原子性。</p>
</li>
</ul>
<ol start="2">
<li>可见性</li>
</ol>
<p>可见性就指 ：当一个线程修改了共享变量地值的时候，其他线程能够立即得知这个修改。之前地volatile 变量就是这样的。</p>
<ul>
<li><p>Java内存模型是通过在变量修改后将新值同步回主内存， 在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。</p>
</li>
<li><p>除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。</p>
</li>
<li><p>而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</p>
</li>
</ul>
<ol start="3">
<li>有序性</li>
</ol>
<ul>
<li><p>Java程序中天然的有序性可以总结为1句话： <strong>如果在本线程内观察，所有的操作都是有序的</strong>； <strong>如果在一个线程中观察 另一个线程，所有的操作都是无序的</strong>。</p>
</li>
<li><p>前半句是指“<strong>线程内似表现为串行的语义”（Within-Thread As-If-SerialSemantics）</strong>，后半句是指“<strong>指令重排序”现象和“工作内存与主内存同步延迟</strong>”现象。</p>
</li>
<li><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
</li>
</ul>
<h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型苦涩难懂的定义之中。</p>
<p>先行发生是 Java内存模型中定义的两项操作之间的偏序关系，比如操作A 先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响 能被操作B观察到，影响包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>代码清单12-8　先行发生原则示例1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 以下操作在线程A中执行</span><br><span class="line">i = 1;</span><br><span class="line">// 以下操作在线程B中执行</span><br><span class="line">j = i;</span><br><span class="line">// 以下操作在线程C中执行</span><br><span class="line">i = 2;</span><br></pre></td></tr></table></figure>



<p>假设线程A中的操作“i=1”先行发生于线程B的操作“j=i”，那我们就可以确定在线程B的操作执行后，变量j的值一定是等于1，得出这个结论的依据有两个：</p>
<ul>
<li>一是根据先行发生原则，“i=1”的结果可以被观察到</li>
<li>二是线程C还没登场，线程A操作结束之后没有其他线程会修改变量i的值</li>
</ul>
<p>现在再来考虑线程C，我们依然保持线程A和B之间的先行发生关系，而C出现在线程A和B的操作之间，但是C与B没有先行发生关系，那j的值会是多少呢？</p>
<p>答案是不确定！1和2都有可能，因为线程C对变量i的影响可能会被线程B观察到，也可能不会，这时候<strong>线程B就存在读取到过期数据的风险</strong>，不具备多线程安全性。</p>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li><strong>程序次序规则（Program Order Rule）</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li><strong>管程锁定规则（Monitor Lock Rule）</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</li>
<li><strong>volatile变量规则（Volatile Variable Rule）</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</li>
<li><strong>线程启动规则（Thread Start Rule）</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则（Thread Termination Rule）</strong>：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</li>
<li><strong>线程中断规则（Thread Interruption Rule）</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生</li>
<li><strong>对象终结规则（Finalizer Rule）</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li><strong>传递性（Transitivity）</strong>：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<p>Java语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些，下面演示一下如何使用这些规则去判定操作间是否具备顺序性，对于读写共享变量的操作来说，就是线程是否安全。读者还可以从下面这个例子中感受一下“时间上的先后顺序”与“先行发生”之间有什么不同。演示例子如<br>代码清单12-9所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="function">pubilc <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>代码清单12-9中显示的是一组再普通不过的getter/setter方法，假设存在线程A和B，线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？<br>我们依次分析一下先行发生原则中的各项规则。</p>
<ul>
<li><p>由于两个方法分别由线程A和B调用，不在一个线程中，所以程序次序规则在这里不适用；</p>
</li>
<li><p>由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；</p>
</li>
<li><p>由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；</p>
</li>
<li><p>后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。</p>
</li>
<li><p>因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，</p>
</li>
<li><p>因此我们可以判定，尽管线程A在操作时间上先于线程B，但是无法确定线程B中getValue()方法的返回结果，换句话说，这里面的操作不是线程安全的。</p>
<p>那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：</p>
<ul>
<li>要么把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；</li>
<li>要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来<br>实现先行发生关系。</li>
</ul>
</li>
</ul>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java线程如何实现并不受Java虚拟机规范的约束，这是一个与具体虚拟机相关的话题。</p>
<ul>
<li>Java线程在早期的Classic虚拟机上（JDK 1.2以前），是基于一种被称为“绿色线程”（Green Threads）的用户线程实现的，</li>
<li>但从JDK 1.3起，“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型。</li>
</ul>
<p>以HotSpot为例，它的每一个Java线程都是直接映射到一个<strong>操作系统原生线程来实现的</strong>，而且中间没有额外的间接结构，所以<strong>HotSpot自己是不会去干涉线程调度的</strong>（可以设置线程优先级给操作系统提供调度建议），全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是<strong>由操作系统完成的</strong>，也都是由操作系统全权决定的。</p>
<h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是<strong>协同式（Cooperative Threads-Scheduling）线程调度和抢占式（Preemptive Threads-Scheduling）线程调度。</strong></p>
<ul>
<li><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题.</p>
<p>它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在<br>那里。</p>
</li>
<li><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。譬如在Java中，有Thread::yield()方法可以主动让出执行时间，但是如果想要主动获取执行时间，线程本身是没有什么办法的。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程甚至整个系统阻塞的问题。Java使用的线程调度方式就是抢占式调度.</p>
</li>
<li><p>虽然说Java线程调度是系统自动完成的，但是我们仍然可以“建议”操作系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作是通过设置线程优先级来完成的。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）。在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p>
</li>
<li><p>不过，<strong>线程优先级并不是一项稳定的调节手段</strong>，很显然因为主流虚拟机上的Java线程是被映射到系统的原生线程上来实现的，所以线程调度最终还是由操作系统说了算</p>
</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是：</p>
<ul>
<li><p>新建（New）：创建后尚未启动的线程处于这种状态。</p>
</li>
<li><p>运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</p>
</li>
<li><p>无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：</p>
<ul>
<li><p>没有设置Timeout参数的Object::wait()方法；</p>
</li>
<li><p>没有设置Timeout参数的Thread::join()方法；</p>
</li>
<li><p>LockSupport::park()方法。</p>
</li>
</ul>
</li>
<li><p>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p>
<ul>
<li>Thread::sleep()方法；</li>
<li>设置了Timeout参数的Object::wait()方法；</li>
<li>设置了Timeout参数的Thread::join()方法；</li>
<li>LockSupport::parkNanos()方法；</li>
<li>LockSupport::parkUntil()方法。</li>
</ul>
</li>
<li><p>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到<br>一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时<br>间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>
</li>
<li><p>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</p>
</li>
</ul>
<p>上述6种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如图12-6所示。</p>
<p><img src="/uploads/jvm/14memoryModel/thread-status-trans.png"></p>
<h2 id="Java与协程"><a href="#Java与协程" class="headerlink" title="Java与协程"></a>Java与协程</h2><h3 id="内核线程的局限"><a href="#内核线程的局限" class="headerlink" title="内核线程的局限"></a>内核线程的局限</h3><p>可以通过一个具体场景来解释目前Java线程面临的困境。今天对Web应用的服务要求，不论是在请求数量上还是在复杂度上，与十多年前相比已不可同日而语，这一方面是源于业务量的增长，另一方面来自于为了应对业务复杂化而不断进行的服务细分。现代B/S系统中一次对外部业务请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在减少单个服务复杂度、增加复用性的同时，也不可避免地增加了服务的数量，缩短了留给每个服务的响应时间。这要求每一个服务都必须在极短的时间内完成计算，这样组合多个服务的总耗时才不会太长；也要求每一个服务提供者都要能同时处理数量更庞大的请求，这样才不会出现请求由于某个服务被阻塞而出现等待。</p>
<p>Java目前的并发编程机制就与上述架构趋势产生了一些矛盾，1：1的内核线程模型是如今Java虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费。</p>
<p>传统的Java Web服务器的线程池的容量通常在几十个到两百之间，当程序员把数以百万计的请求往线程池里面灌时，系统即使能处理得过来，但其中的切换损耗也是相当可观的。现实的需求在迫使Java去研究新的解决方案，同大家又开始怀念以前绿色线程的种种好处</p>
<h3 id="协程的复苏"><a href="#协程的复苏" class="headerlink" title="协程的复苏"></a>协程的复苏</h3><p>Q&amp;A : 为什么内核线程调度切换起来成本就要更高？</p>
<p>内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本。</p>
<p>假设发生了这样一次线程切换：<strong>线程A -&gt; 系统中断 -&gt; 线程B</strong></p>
<p>处理器要去执行线程A的程序代码时，并不是仅有代码程序就能跑得起来，程序是数据与代码的组合体，代码执行时还必须要有上下文数据的支撑。而这里说的“上下文”，</p>
<ul>
<li>以程序员的角度来看，是方法调用过程中的各种局部的变量与资源；</li>
<li>以线程的角度来看，是方法的调用栈中存储的各类信息；</li>
<li>而以操作系统和硬件的角度来看，则是存储在内存、缓存和寄存器中的一个个具体数值。</li>
<li>物理硬件的各种存储设备和寄存器是被操作系统内所有线程共享的资源，当中断发生，从线程A切换到线程B去执行之前，操作系统首先要把线程A的上下文数据妥善保管好，然后把寄存器、内存分页等恢复到线程B挂起时候的状态，这样线程B被重新激活后才能仿佛从来没有被挂起过。这种保护和恢复现场的工作，免不了涉及一系列数据在各种寄存器、缓存中的来回拷贝，当然不可能是一种轻量级的操作。</li>
</ul>
<p>由于最初多数的用户线程是被设计成协同式调度（Cooperative Scheduling）的，所以它有了一个别名——“协程”（Coroutine）。又由于这时候的协程会<br>完整地做调用栈的保护、恢复工作，所以今天也被称为“有栈协程”（Stackfull Coroutine），起这样的名字是为了便于跟后来的“无栈协程”（Stackless Coroutine）区分开。无栈协程不是本节的主角，不过还是可以简单提一下它的典型应用，即各种语言中的await、async、yield这类关键字。无栈协程本质上<br>是一种有限状态机，状态保存在闭包里，自然比有栈协程恢复调用栈要轻量得多，但功能也相对更有限。</p>
<ul>
<li><p>协程的主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多</p>
</li>
<li><p>协程当然也有它的局限，需要在应用层面实现的内容（调用栈、调度器这些）特别多，这个缺点就不赘述了。除此之外，协程在最初，甚至在今天很多语言和框架中会被设计成协同式调度，这样在语言运行平台或者框架上的调度器就可以做得非常简单</p>
</li>
<li><p>具体到Java语言，还会有一些别的限制，譬如HotSpot这样的虚拟机，Java调用栈跟本地调用栈是做在一起的。如果在协程中调用了本地方法，还能否正常切换协程而不影响整个线程？另外，如果协程中遇传统的线程同步措施会怎样？譬如Kotlin提供的协程实现，一旦遭遇synchronize关键字，那挂起来的仍将是整个线程。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-15-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-15-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">深入理解jvm-15-后端编译与优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-28 20:29:17" itemprop="dateCreated datePublished" datetime="2021-01-28T20:29:17+08:00">2021-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-15-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-15-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h1><p>后端编译器<strong>编译性能的好坏</strong>、<strong>代码优化质量的高低</strong>确实衡量一款商用虚拟机优秀与否的关键指标之一，他们也是商业java虚拟机中的核心，是最能体现技术水平的价值的功能。</p>
<h2 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2><p>目前主流的两款商用Java虚拟机（HotSpot、OpenJ9）里，Java程序最初都是通过<strong>解释器（Interpreter）</strong>进行解释执行的，当虚拟机发现<strong>某个方法或代码块</strong>的<strong>运行特别频繁</strong>，就会把这些代码认定为<strong>“热点代码”（Hot Spot Code）</strong>，为了提高热点代码的执行效率，在运行时，<strong>虚拟机将会把这些代码编译成本地机器码</strong>，并以各种手段尽可能地进行代码优化，运行时完成这个任务的<strong>后端编译器被称为即时编译器</strong>。本节我们将会了解HotSpot虚拟机内的即时编译器的运作过程，此外，我们还将解决以下几个问题：</p>
<ul>
<li>为何HotSpot虚拟机要使用解释器与即时编译器并存的架构？</li>
<li>为何HotSpot虚拟机要实现两个（或三个）不同的即时编译器？</li>
<li>程序何时使用解释器执行？何时使用编译器执行？</li>
<li>哪些程序代码会被编译为本地代码？如何编译本地代码？</li>
<li>如何从外部观察到即时编译器的编译过程和编译结果？</li>
</ul>
<h3 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h3><p>解释器与编译器两者各有优势：</p>
<ul>
<li>当程序需要<strong>迅速启动和执行</strong>的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。</li>
<li>当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。</li>
<li>当程序运行环境中内存资源限制较大，可以使用解释执行节约内存（如部分嵌入式系统中和大部分的JavaCard应用中就只有解释器的存在），反之可以使用编<br>译执行来提升效率。</li>
<li>同时，解释器还可以作为编译器激进优化时后备的“逃生门”（如果情况允许，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当“逃生门”的角色），让编译器根据概率选择一些不能保证所有情况都正确，但大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类以后，类型继承结构出现变化、出现“罕见陷阱”（Uncommon Trap）时可以通过逆优化（Deoptimization）退回到解释状态继续执行，</li>
<li>因此在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作，其交互关系如图11-1所示。</li>
</ul>
<p><img src="/uploads/jvm/13Compile/Interpreter01.png"></p>
<p>HotSpot虚拟机中内置了两个（或三个）即时编译器，其中有两个编译器存在已久，分别被称为“客户端编译器”（Client Compiler）和“服务端编译器”（Server Compiler），或者简称为C1编译器和C2编译器（部分资料和JDK源码中C2也叫Opto编译器），第三个是在JDK 10时才出现的、长期目标是代替C2的Graal编译器。Graal编译器目前还处于实验状态</p>
<p>无论采用的编译器是客户端编译器还是服务端编译器，解释器与编译器搭配使用的方式在虚拟机中被称为<strong>“混合模式”（Mixed Mode）</strong>，</p>
<p>用户也可以使用参数<strong>“-Xint”</strong>强制虚拟机运行于<strong>“解释模式”（Interpreted Mode</strong>），这时候编译器完全不介入工作，全部代码都使用解释方式执行。</p>
<p>另外，也可以使用参数<strong>“-Xcomp”</strong>强制虚拟机运行于<strong>“编译模式”（Compiled Mode）</strong>，这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。可以通过虚拟机的“-version”命令的输出结果显示出这三种模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$java</span> -version</span><br><span class="line">java version <span class="string">&quot;11.0.3&quot;</span> 2019-04-16 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, mixed mode)</span><br><span class="line"></span><br><span class="line"><span class="variable">$java</span> -Xint -version</span><br><span class="line">java version <span class="string">&quot;11.0.3&quot;</span> 2019-04-16 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, interpreted mode)</span><br><span class="line"></span><br><span class="line"><span class="variable">$java</span> -Xcomp -version</span><br><span class="line">java version <span class="string">&quot;11.0.3&quot;</span> 2019-04-16 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, compiled mode)</span><br></pre></td></tr></table></figure>

<h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>由于即时编译器编译本地代码需要占用程序运行时间，通常要<strong>编译出优化程度越高的代码，所花费的时间便会越长</strong>；而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。</p>
<p>为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机在编译子系统中加入了分层编译的功能。</p>
<p>分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p>
<ul>
<li>第0层。程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li>
<li>第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启性能监控功能。</li>
<li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li>
<li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li>
<li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。<br>以上层次并不是固定不变的，根据不同的运行参数和版本，虚拟机可以调整分层的数量。各层次编译之间的交互、转换关系如图11-2所示。</li>
</ul>
<p>实施分层编译后，解释器、客户端编译器和服务端编译器就会同时工作，热点代码都可能会被多次编译，</p>
<p>用客户端编译器获取更高的编译速度，</p>
<p>用服务端编译器来获取更好的编译质量，</p>
<p>在解释执行的时候也无须额外承担收集性能监控信息的任务，而在服务端编译器采用高复杂度的优化算法时，客户端编译器可先采用简单优化来为它争取更多的编译时间。</p>
<p><img src="/uploads/jvm/13Compile/layerCompile.png"></p>
<h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><p>在运行过程中会被即时编译器编译的目标是“热点代码”，这里所指的热点代码主要有两类，包括：</p>
<ul>
<li><p><strong>被多次调用的方法。</strong>（一个方法被调用得多了，方法体内代码执行的次数自然就多，它成为“热点代码”是理所当然的）</p>
</li>
<li><p><strong>被多次执行的循环体</strong> （为了解决当一个方法只被调用过一次或少量的几次，但是方法体内部存在循环次数较多的循环体，这样循环体的代码也被重复执行多次，因此这些代码也应该认为是“热点代码”）</p>
<p>对于这两种情况，<strong>编译的目标对象都是整个方法体</strong>，而不会是单独的循环体</p>
<ul>
<li>第一种情况，由于是依靠方法调用触发的编译，那编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的即时编译方式。</li>
<li>对于后一种情况，尽管编译动作是由循环体所触发的，热点只是方法的一部分，但编译器依然必须以整个方法作为编译对象，只是执行入口（从方法第几条字节码指令开始执行）会稍有不同，编译时会传入执行入口点字节码序号（Byte Code Index，BCI）。这种编译方式因为编译发生在方法执行的过程中，因此被很形象地称为<strong>“栈上替换”（On Stack Replacement，OSR）</strong>，即方法的栈帧还在栈上，方法就被替换了。</li>
</ul>
</li>
</ul>
<p><strong>即时编译被触发的条件</strong> 要知道方法执行多少次才算多次，代码块执行多少次 才算多次，要有一个定量。</p>
<h4 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h4><p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“<strong>热点探测”（HotSpot Code Detection）</strong>，其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主流的热点探测判定方式有两种[2]，分别是：</p>
<ul>
<li><strong>基于采样的热点探测（Sample Based Hot Spot Code Detection</strong>）。采用这种方法的虚拟机会<strong>周期性地检查各个线程的调用栈顶</strong>，如果发现某个（或某些）方法<strong>经常出现在栈顶，那这个方法就是“热点方法”</strong>。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，<strong>容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测</strong>。</li>
<li><strong>基于计数器的热点探测（Counter Based Hot Spot Code Detection</strong>）。采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li>
</ul>
<p>在HotSpot虚拟机中使用的是第二种基于计数器的热点探测方法，为了实现热点计数，HotSpot为每个方法准备了两类计数器：<strong>方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter，“回边”的意思就是指在循环边界往回跳转）</strong>。当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈<br>值，计数器阈值一旦溢出，就会触发即时编译。</p>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>顾名思义，这个计数器就是用于统计方法被调用的次数，它的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数-XX：CompileThreshold来人为设定。</p>
<p>当一个方法被调用时，虚拟机会先检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将该方法的调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。一旦已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。</p>
<p>如果没有做过任何设置，<strong>执行引擎默认不会同步等待编译请求完成</strong>，而是<strong>继续进入解释器按照解释方式执行字节码，直到提交的请求被即时编译器编译完成</strong>。当编译工作完成后，这个方法的<strong>调用入口地址就会被系统自动改写成新值</strong>，下一次调用该方法时就会使用已编译的版本了，整个即时编译的交互过程如图11-3所示。</p>
<p>在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为<strong>方法调用计数器热度的衰减（Counter Decay），</strong></p>
<p>而这段时间就称为此<strong>方法统计的半衰周期（Counter Half Life Time</strong>），进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX：-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。</p>
<p>另外还可以使用-XX：CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
<p><img src="/uploads/jvm/13Compile/methodIvokeCounter.png"></p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>回边计数器，它的作用是<strong>统计一个方法中循环体代码执行的次数</strong>，在字节码中遇到<strong>控制流向后跳转的指令就称为“回边（Back Edge</strong>）”，很显然建立回边计数<br>器统计的目的是为了<strong>触发栈上的替换编译</strong></p>
<ul>
<li>虚拟机运行在客户端模式下，回边计数器阈值计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以OSR比率（-XX：OnStackReplacePercentage）除以100。其中-XX：OnStackReplacePercentage默认值为933，如果都取默认值，那客户端模式虚拟机的回边计数器的阈值为13995。</li>
<li>虚拟机运行在服务端模式下，回边计数器阈值的计算公式为：方法调用计数器阈值（-XX：CompileThreshold）乘以（OSR比率（-XX：OnStackReplacePercentage）减去解释器监控比率（-XX：InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，-XX：InterpreterProfilePercentage默认值为33，如果都取默认值，那服务端模式虚拟机回边计数器的阈值为10700。</li>
</ul>
<p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个栈上替换编译请求，并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果，整个执行过程如图11-4所示。</p>
<p><img src="/uploads/jvm/13Compile/BackEdgeCounter.png"></p>
<p>与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p>在默认条件下，无论是方法调用产生的标准编译请求，还是栈上替换编译请求，虚拟机在编译器还未完成编译之前，都仍然将按照解释方式继续执行代码，而编译动作则在后台的编译线程中进行。用户可以通过参数-XX：-BackgroundCompilation来禁止后台编译，后台编译被禁止后，当达到触发即时编译的条件时，执行线程向虚拟机提交编译请求以后将会一直阻塞等待，直到编译过程完成再开始执行编译器输出的本地代码。</p>
<h4 id="客户端编译器"><a href="#客户端编译器" class="headerlink" title="客户端编译器"></a>客户端编译器</h4><p>服务端编译器和客户端编译器的编译过程是有所差别的。对于客户端编译器来说，它是一个相对简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。</p>
<ul>
<li>在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-LevelIntermediate Representation，HIR，即与目标机器指令集无关的中间表示）。HIR使用静态单分配（Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化，如方法内联、常量传播等优化将会在字节码被构造成HIR之前完成。</li>
<li>在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</li>
<li>最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。客户端编译器大致的执行过程如图11-5所示。</li>
</ul>
<p><img src="/uploads/jvm/13Compile/ClientCompile.png"></p>
<h2 id="提前编译器（TODO）"><a href="#提前编译器（TODO）" class="headerlink" title="提前编译器（TODO）"></a>提前编译器（TODO）</h2><h2 id="编译器优化技术"><a href="#编译器优化技术" class="headerlink" title="编译器优化技术"></a>编译器优化技术</h2><p>编译器的目标虽然是做由程序代码翻译为本地机器码的工作，但其实难点并不在于能不能成功翻译出机器码，输出代码优化质量的高低才是决定编译器优秀与否的关键。</p>
<h4 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a>优化技术概览</h4><p><img src="/uploads/jvm/13Compile/OptimizeTech.png"></p>
<p><img src="/uploads/jvm/13Compile/OptimizeTech02.png"></p>
<p>简单挑选几个代表性的优化技术：</p>
<ul>
<li>最重要的优化技术之一：方法内联。</li>
<li>最前沿的优化技术之一：逃逸分析。</li>
<li>语言无关的经典优化技术之一：公共子表达式消除。</li>
<li>语言相关的经典优化技术之一：数组边界检查消除。</li>
</ul>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>方法内联，说它是编译器最重要的优化手段，甚至都可以不加上“之一”。内联被业内戏称为优化之母，因为除了消除方法调用的成本之外，它更重要的意义<strong>是为其</strong><br><strong>他优化手段建立良好的基础</strong>，代码清单11-11所示的简单例子就揭示了内联对其他优化手段的巨大价值：没有内联，多数其他优化都无法有效进行。</p>
<p>例子里testInline()方法的内部全部是无用的代码，但如果不做内联，后续即使进行了无用代码消除的优化，也无法发现任何“Dead Code”的存在。如果分开来看，foo()和testInline()两个方法里面的操作都有可能是有意义的。</p>
<p>代码清单11-11　未作任何优化的字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInline</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    foo(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法内联的优化行为理解起来是没有任何困难的，不过就是<strong>把目标方法的代码原封不动地“复制”到发起调用的方法之中</strong>，避免发生真实的方法调用而已。</p>
<p>但实际上Java虚拟机中的内联过程却远没有想象中容易，甚至如果不是即时编译器做了一些特殊的努力，按照经典编译原理的优化理论，大多数的Java方法都无法进行内联。</p>
<p><strong>无法内联的原因</strong>其实在第8章中讲解Java<strong>方法解析和分派调用</strong>的时候就已经解释过：只有使用<strong>invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析</strong>。除了上述四种方法之外（<strong>最多再除去被final修饰的方法这种特殊情况，尽管它使用invokevirtual指令调用，但也是非虚方法</strong>，《Java语言规范》中明确说明了这点），<strong>其他的Java方法调用都必须在运行时进行方法接收者的多态选择</strong>，<strong>它们都有可能存在多于一个版本的方法接收者，简而言之，Java语言中默认的实例方法是虚方法</strong>。</p>
<p>ps:  因为Java默认是虚方法，一个方法就可能被重写（动态分派），方法可能存在多个版本，复制方法内容就 不确定复制哪个版本的了。</p>
<p>对于一个虚方法，<strong>编译器静态地去做内联的时候很难确定应该使用哪个方法版本</strong>，以将代码清单11-7中所示b.get()直接内联为b.value为例，如果不依赖上下文，是无法确定b的实际类型是什么的。假如有ParentB和SubB是两个具有继承关系的父子类型，并且子类重写了父类的get()方法，那么b.get()是执行父类的get()方法还是子类的get()方法，这应该是根据实际类型动态分派的，而<strong>实际类型必须在实际运行到这一行代码时才能确定，编译器很难在编译时得出绝对准确的结论</strong>。</p>
<p>更糟糕的情况是，由于Java提倡使用面向对象的方式进行编程，而Java对象的方法默认就是虚方法，可以说Java间接鼓励了程序员使用大量的虚方法来实现程序逻辑。根据上面的分析可知，<strong>内联与虚方法之间会产生“矛盾”</strong>，那是不是为了提高执行性能，就应该默认给每个方法都使用final关键字去修饰呢？C和C++语言的确是这样做的，默认的方法是非虚方法，如果需要用到多态，就用virtual关键字来修饰，但<strong>Java选择了在虚拟机中解决这个问题</strong>。</p>
<h4 id="类型继承关系分析（激进优化）"><a href="#类型继承关系分析（激进优化）" class="headerlink" title="类型继承关系分析（激进优化）"></a>类型继承关系分析（激进优化）</h4><p>为了解决虚方法的内联问题，Java虚拟机首先引入了一种名为<strong>类型继承关系分析（Class HierarchyAnalysis，CHA）</strong>的技术，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。这样，编译器在进行内联时就会分不同情况采取不同的处理：</p>
<ul>
<li>如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的；</li>
<li>如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为<strong>守护内联（Guarded Inlining</strong>）。</li>
<li>不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。</li>
<li>假如在程序的后续执行过程中，虚拟机一直没有加载到会令这个方法的接收者的继承关系发生变化的类，那这个内联优化的代码就可以一直使用下去。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。</li>
</ul>
<p>假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用<strong>内联缓存（Inline Cache）</strong>的方式来缩减方法调用的开销。这种状态下方法调用是真正发生了的，但是比起直接查虚方法表还是要快一些。内联缓存是一个建立在目标方法正常入口之前的缓存，它的工作原理大致为：</p>
<ul>
<li>在未发生方法调用之前，内联缓存状态为空，</li>
<li>当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。</li>
<li>如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种<strong>单态内联缓存（Monomorphic InlineCache</strong>）。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。</li>
<li>但如果真的出现方法接收者不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成<strong>超多态内联缓存（Megamorphic Inline Cache）</strong>，其开销相当于真正查找虚方法表来进行方法分派。</li>
</ul>
<p>所以说，在多数情况下Java虚拟机进行的方法内联都是一种<strong>激进优化</strong>。事实上，激进优化的应用在高性能的Java虚拟机中比比皆是，极为常见。除了方法内联之外，对于出现概率很小（通过经验数据或解释器收集到的性能监控信息确定概率大小）的隐式异常、使用概率很小的分支等都可以被激进优化“移除”，如果真的出现了小概率事件，这时才会从“逃生门”回到解释状态重新执行。</p>
<h3 id="逃逸分析（前沿技术）"><a href="#逃逸分析（前沿技术）" class="headerlink" title="逃逸分析（前沿技术）"></a>逃逸分析（前沿技术）</h3><p>逃逸分析（Escape Analysis）是目前Java虚拟机中比较前沿的优化技术，它<strong>与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术</strong></p>
<p>逃逸分析的基本原理是：<strong>分析对象动态作用域</strong>，当一个对象在方法里面被定义后，它可能被外部方法所引用，</p>
<ul>
<li>例如<strong>作为调用参数传递到其他方法中，这种称为方法逃逸</strong>；</li>
<li>甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为<strong>线程逃逸；</strong></li>
<li>从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</li>
</ul>
<p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，如：</p>
<h4 id="栈上分配（Stack-Allocations）"><a href="#栈上分配（Stack-Allocations）" class="headerlink" title="栈上分配（Stack Allocations）"></a>栈上分配（Stack Allocations）</h4><p>在Java虚拟机中，Java堆上分配创建对象的内存空间几乎是Java程序员都知道的常识，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引<br>用，就可以访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。</p>
<p>如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，<strong>对象所占用的内存空间就可以随栈帧出栈而销毁</strong>。在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多</p>
<p><strong>栈上分配可以支持方法逃逸，但不能支持线程逃逸</strong>。</p>
<h4 id="标量替换（Scalar-Replacement）"><a href="#标量替换（Scalar-Replacement）" class="headerlink" title="标量替换（Scalar Replacement）"></a>标量替换（Scalar Replacement）</h4><p>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为<strong>标量</strong>。</p>
<p>相对的，如果一个数据可以继续分解，那它就被称为<strong>聚合量（Aggregate）</strong>，Java中的对象就是典型的聚合量。</p>
<p>如果把一个Java对象拆散，根据程序访问的情况，<strong>将其用到的成员变量恢复为原始类型来访问</strong>，这个过程就称为标量替换。</p>
<p>假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。</p>
<p>标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，<strong>它不允许对象逃逸出方法范围内</strong></p>
<h4 id="同步消除（Synchronization-Elimination）"><a href="#同步消除（Synchronization-Elimination）" class="headerlink" title="同步消除（Synchronization Elimination）"></a>同步消除（Synchronization Elimination）</h4><p>线程同步本身是一个相对耗时的过程，如果逃逸分析能够<strong>确定一个变量不会逃逸出线程，无法被其他线程访问</strong>，那么这个变量的读写肯定就不会有竞争，<br>对这个变量实施的同步措施也就可以安全地消除掉。</p>
<h3 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h3><p>公共子表达式消除是一项非常经典的、普遍应用于各种编译器的优化技术，它的含义是：</p>
<ul>
<li><p>如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为<strong>公共子表达式</strong>。</p>
</li>
<li><p>对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。</p>
</li>
<li><p>如果这种优化仅限于程序基本块内，便可称为<strong>局部公共子表达式消除（Local Common Subexpression Elimination）</strong>，</p>
</li>
<li><p>如果这种优化的范围涵盖了多个基本块，那就称为<strong>全局公共子表达式消除（Global Common Subexpression Elimination）</strong>。</p>
<p>下面举个简单的例子来说明它的优化过程，假设存在如下代码：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int d = (c * b) * 12 + a + (a + b * c);</span><br></pre></td></tr></table></figure>

<p>当这段代码进入虚拟机即时编译器后，它将进行如下优化：编译器检测到c<em>b与b</em>c是一样的表达式，而且在计算期间b与c的值是不变的。</p>
<p>因此这条表达式就可能被视为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">12</span> + a + (a + E);</span><br></pre></td></tr></table></figure>

<p>这时候，编译器还可能（取决于哪种虚拟机的编译器以及具体的上下文而定）进行另外一种优化——<strong>代数化简（Algebraic Simplification）</strong>，在E本来就有乘法运算的前提下，把表达式变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d = E * <span class="number">13</span> + a + a;</span><br></pre></td></tr></table></figure>

<p>表达式进行变换之后，再计算起来就可以节省一些时间了</p>
<h3 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h3><p>数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术</p>
<p>我们知道Java语言是一门<strong>动态安全的语言</strong>，对数组的读写访问也不像C、C++那样实质上就是裸指针操作。</p>
<ul>
<li>如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界的范围检查，即i必须满足“i&gt;=0&amp;&amp;i&lt;foo.length”的访问条件，否则将抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException。</li>
<li>这对软件开发者来说是一件很友好的事情，即使程序员没有专门编写防御代码，也能够避免大多数的溢出攻击。</li>
<li>但是对于虚拟机的执行子系统来说，<strong>每次数组元素的读写都带有一次隐含的条件判定操作</strong>，对于拥有大量数组访问的程序代码，这必定是一种<strong>性能负担</strong>。</li>
</ul>
<p>为了安全，<strong>数组边界检查肯定是要做的</strong>，但数组边界检查<strong>是不是必须在运行期间一次不漏地进行</strong>则是可以“商量”的事情。</p>
<p>例如下面这个简单的情况：数组下标是一个常量，如foo[3]，只要<strong>在编译期根据数据流分析来确定foo.length的值</strong>，并判断下标“3”没有越界，执行的时候就无须判断了。</p>
<p>更加常见的情况是，数组访问发生在循环之中，并且使用循环变量来进行数组的访问。如果编译器只要通过数据流分析就可以判定循环变量的取值范围永远在区间[0，foo.length)之内，那么在循环中就可以把整个数组的上下界检查消除掉，这可以节省很多次的条件判断操作。</p>
<p>把这个数组边界检查的例子放在更高的视角来看，<strong>大量的安全检查使编写Java程序比编写C和C++程序容易了很多</strong>，比如：数组越界会得到ArrayIndexOutOfBoundsException异常；空指针访问会得到NullPointException异常；除数为零会得到ArithmeticException异常……在C和C++程序中出现类似的问题，一个不小心就会出现Segment Fault信号或者Windows编程中常见的“XXX内存不能为Read/Write”之类的提示，处理不好程序就直接崩溃退出了。但这些安全检查也导致出现相同的程序，从而使Java比C和C++要做更多的事情（各种检查判断），这些事情就会导致一些隐式开销，如果不处理好它们，就很可能成为一项“Java语言天生就比较慢”的原罪。</p>
<ul>
<li><p>为了消除这些隐式开销，除了如<strong>数组边界检查优化这种尽可能把运行期检查提前到编译期完成的思路之外</strong>，</p>
</li>
<li><p>还有一种避开的处理思路——隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这种方案。举个例子，程序中访问一个对象（假设对象叫foo）的某个属性（假设属性叫value），那以Java伪代码来表示虚拟机访问foo.value的过程为：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> foo.value;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> NullPointException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用隐式异常优化之后，虚拟机会把上面的伪代码所表示的访问过程变为如下伪代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除了 一次判断foo是否为空的操作</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> foo.value;</span><br><span class="line">&#125; <span class="keyword">catch</span> (segment_fault) &#123;</span><br><span class="line">	uncommon_trap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机会注册一个Segment Fault信号的异常处理器（伪代码中的uncommon_trap()，务必注意这里是指进程层面的异常处理器，并非真的Java的try-catch语句的异常处理器），</p>
<ul>
<li>这样当foo不为空的时候，对value的访问是不会有任何额外对foo判空的开销的，</li>
<li>而代价就是当foo真的为空时，必须转到异常处理器中恢复中断并抛出NullPointException异常。进入异常处理器的过程涉及进程从用户态转到内核态中处理的过程，结束后会再回到用户态，速度远比一次判空检查要慢得多。</li>
<li>当foo极少为空的时候，隐式异常优化是值得的，但假如foo经常为空，这样的优化反而会让程序更慢。</li>
<li>幸好HotSpot虚拟机足够聪明，它会根据运行期收集到的性能监控信息自动选择最合适的方案</li>
</ul>
<p>与语言相关的其他消除操作还有不少，如<strong>自动装箱消除（Autobox Elimination）、安全点消除（Safepoint Elimination）、消除反射（Dereflection）</strong>等，这里就不再一一介绍了。</p>
<h2 id="深入理解Graal编译器（TODO）"><a href="#深入理解Graal编译器（TODO）" class="headerlink" title="深入理解Graal编译器（TODO）"></a>深入理解Graal编译器（TODO）</h2><h3 id="代码中间表示"><a href="#代码中间表示" class="headerlink" title="代码中间表示"></a>代码中间表示</h3><p>Graal编译器在设计之初就刻意采用了与HotSpot服务端编译器一致（略有差异但已经非常接近）的中间表示形式，也即是被称为<strong>Sea-of-Nodes的中间表示</strong>，或者与其等价的被称为<strong>理想图（IdealGraph，在代码中称为Structured Graph）的程序依赖图（Program Dependence Graph，PDG）形式</strong>。</p>
<p>在11.2节即时编译器的实战中，我们已经通过可视化工具Ideal Graph Visualizer看到过在理想图上翻译和优化输入代码的整体过程，</p>
<p>从编译器内部来看即：<strong>字节码→理想图→优化→机器码（以Mach NodeGraph表示）的转变过程</strong>。在本节里面，我们以例子和对照Graal源码的形式，详细讲解输入代码与理想图的转化对应关系，以便读者理解Graal是如何基于理想图去优化代码的。</p>
<h4 id="理想图"><a href="#理想图" class="headerlink" title="理想图"></a>理想图</h4><p>理想图是一种有向图，<strong>用节点来表示程序中的元素，譬如变量、操作符、方法、字段等</strong>，而<strong>用边来表示数据或者控制流</strong>。我们先从最简单的例子出发。譬如有一个表达式：x+y，在理想图中可以表示为x、y两个节点的数据流流入加法操作符，表示相加操作读取了x、y的值，流出的便则表示数据流的流向，即相加的结果会在哪里被使用，如图11-13所示。</p>
<p><img src="/uploads/jvm/13Compile/IdealGraph01.png"></p>
<p>我们把例子稍微复杂化一些，把表达式x+y变为getX()+getY()，仍是用理想图表达其计算过程，这时候除了数据流向之外，还必须要考虑方法调用的顺序。在理想图中用另外一条边来表示方法的调用（为了便于区分，数据流笔者使用蓝色线（以虚线表示），控制流使用红色线（以实线表示）），说明代码的执行顺序是先调用getX()方法，再调用getY()方法，如图11-14所示。</p>
<p><img src="/uploads/jvm/13Compile/IdealGraph02.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">深入理解jvm-14-前端编译与优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-27 20:12:07" itemprop="dateCreated datePublished" datetime="2021-01-27T20:12:07+08:00">2021-01-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-14-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h1><p>在Java技术下谈“编译期”而没有具体上下文语境的话，其实是一句很含糊的表述，</p>
<ul>
<li><p>因为它可能是指一个前端编译器（叫“编译器的前端”更准确一些）把*.java文件转变成*.class文件的过程；</p>
</li>
<li><p>也可能是指Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程；</p>
</li>
<li><p>还可能是指使用静态的提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接把程序编译成与目标机器指令集相关的二进制代码的过程</p>
</li>
</ul>
<p>列举了这3类编译过程里一些比较有代表性的编译器产品：</p>
<ul>
<li>前端编译器：JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li>
<li>即时编译器：HotSpot虚拟机的C1、C2编译器，Graal编译器。</li>
<li>提前编译器：JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET</li>
</ul>
<p>因为Java虚拟机设计团队选择把<strong>对性能的优化全部集中到运行期的即时编译器中</strong>，这样可以让那些不是由Javac产生的Class文件（如JRuby、Groovy等语言的Class<br>文件）也同样能享受到编译器优化措施所带来的性能红利。</p>
<ul>
<li>前端编译器，开发优化程序员的编码过程，降低了编码复杂度，提高了编码效率，提高了程序员的幸福感，很多”<strong>语法糖</strong>（枚举、泛型、装箱拆箱）“就是依赖前端编译期实现的。</li>
<li>即时编译器 在运行期的优化过程，支撑了程序的执行效率不断的提升，</li>
</ul>
<h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><p>分析源码是了解一项技术的实现内幕最彻底的手段，Javac编译器不像HotSpot虚拟机那样使用C++语言（包含少量C语言）实现，它本身就是一个由Java语言编写的程序，这为纯Java的程序员了解它的编译过程带来了很大的便利。</p>
<h4 id="Javac编译过程"><a href="#Javac编译过程" class="headerlink" title="Javac编译过程"></a>Javac编译过程</h4><ol>
<li>准备过程： 初始化插入式注解处理器</li>
<li>解析与填充符号表过程，包括：<ul>
<li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树</li>
<li>填充符号表。产生符号地址和符号信息</li>
</ul>
</li>
<li>插入式注解处理器的注解处理过程：  插入式注解处理器的执行阶段</li>
<li>分析与字节码生成过程，包括：<ul>
<li>标注检查。对语法的静态信息进行检查。</li>
<li>数据流及控制流分析。对程序动态运行过程进行检查</li>
<li>解语法糖。将简化代码编写的语法糖还原为原有的形式</li>
<li>字节码生成。将前面各个步骤所生成的信息转换为字节码</li>
</ul>
</li>
</ol>
<p>上述3个处理过程，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中 重新处理这些新符号。从总体上来看，三者之间的关系与交互顺序如下图所示</p>
<p><img src="/uploads/jvm/13Compile/javac-compile.png"></p>
<ul>
<li>Javac编译动作的入口是com.sun.tools.javac.main.JavaCompiler类，上述3个过程的代码逻辑集中在这个类的compile()和compile2()方法里</li>
</ul>
<p><img src="/uploads/jvm/13Compile/javac-compile2.png"></p>
<h4 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h4><p>解析过程由图10-5中的parseFiles()方法（图10-5中的过程1.1）来完成，解析过程包括了经典程序编译原理中的词法分析和语法分析两个步骤。</p>
<h5 id="词法、语法分析"><a href="#词法、语法分析" class="headerlink" title="词法、语法分析"></a>词法、语法分析</h5><p><strong>词法分析</strong>是将源代码的字符流转变为标记（Token）集合的过程，单个字符是程序编写时的最小元素，但标记才是编译时的最小元素。关键字、变量名、字面量、运算符都可以作为标记，如“int a=b+2”这句代码中就包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由3个字符构成，但是它只是一个独立的标记，不可以再拆分。在Javac的源码中，词法分析过程由com.sun.tools.javac.parser.Scanner类来实现。</p>
<p><strong>语法分析</strong>是根据标记序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，抽象语法树的每一个节点都代表着程序代码中的一个语法结构（Syntax Construct），例如包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</p>
<p>在Javac的源码中，<strong>语法分析过程由com.sun.tools.javac.parser.Parser</strong>类实现，这个阶段产出的<strong>抽象语法树是以com.sun.tools.javac.tree.JCTree类表示</strong>的。</p>
<h5 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h5><p>完成了语法分析和词法分析之后，下一个阶段是对符号表进行填充的过程，也就是图10-5中 enterTrees()方法（图10-5中注释的过程1.2）要做的事情</p>
<p>符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构，读者可以把它类比想象成哈希表中键值对的存储形式（实际上符号表不一定是哈希表实现，可以是有序符号表、树状符号表、栈结构符号表等各种形式）。符号表中所登记的信息在编译的不同阶段都要被用到。譬如在语义分析的过程中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的声明是否一致）和产生中间代码，在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</p>
<p>在Javac源代码中，<strong>填充符号表</strong>的过程由<strong>com.sun.tools.javac.comp.Enter类实现</strong>，该过程的产出物是一个待处理列表，其中包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java（如果存在的话）的顶级节点。</p>
<h5 id="注解处理器（Lombok的实现原理）"><a href="#注解处理器（Lombok的实现原理）" class="headerlink" title="注解处理器（Lombok的实现原理）"></a>注解处理器（Lombok的实现原理）</h5><p>在JDK 6中又提出并通过了JSR-269提案[1]，该提案设计了一组被称为“<strong>插入式注解处理器</strong>”的标准API，可以提前至编译期对代码中的特定注解进行处理，从而影响到前端编译器的工作过程。我们可以把插入式注解处理器看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行过修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环过程称为一个轮次（Round），这也就对应着图10-4的那个回环过程。</p>
<p>有了编译器注解处理的标准API后，<strong>程序员的代码才有可能干涉编译器的行为</strong>，<strong>由于语法树中的任意元素，甚至包括代码注释都可以在插件中被访问到</strong>，所以<strong>通过插入式注解处理器实现的插件在功能上有很大的发挥空间</strong>。只要有足够的创意，程序员能使用插入式注解处理器来实现许多原本只能在编码中由人工完成的事情。譬如Java著名的编码效率工具<strong>Lombok</strong>[2]，它可以通过注解来实现自动产生getter/setter方法、进行空置检查、生成受查异常表、产生equals()和hashCode()方法，等等，帮助开发人员消除Java的冗长代码，<strong>这些都是依赖插入式注解处理器</strong>来实现的，</p>
<p>在Javac源码中，插入式注解处理器的初始化过程是在<strong>initPorcessAnnotations</strong>()方法中完成的，而它的执行过程则是在<strong>processAnnotations</strong>()方法中完成。这个方法会判断是否还有新的注解处理器需要执行，如果有的话，通过com.sun.tools.javac.processing.JavacProcessing-Environment类的doProcessing()方法来生成一个新的JavaCompiler对象，对编译的后续步骤进行处理。</p>
<h5 id="语义分析与字节码生成（IDE工具提示报错原理）"><a href="#语义分析与字节码生成（IDE工具提示报错原理）" class="headerlink" title="语义分析与字节码生成（IDE工具提示报错原理）"></a>语义分析与字节码生成（IDE工具提示报错原理）</h5><p>经过语法分析之后，编译器获得了程序代码的抽象语法树表示，抽象语法树能够表示一个结构正确的源程序，但无法保证源程序的语义是符合逻辑的</p>
<p>而<strong>语义分析</strong>的主要任务则是对结构上正确的源程序<strong>进行上下文相关性质的检查</strong>，譬如进行<strong>类型检查、控制流检查、数据流检查</strong>。</p>
<p>我们编码时经常能在IDE中看到由红线标注的错误提示，其中绝大部分都是来源于语义分析阶段的检查结果。</p>
<h6 id="标注检查"><a href="#标注检查" class="headerlink" title="标注检查"></a>标注检查</h6><p>Javac在编译过程中，语义分析过程可分为标注检查和数据及控制流分析两个步骤，分别由图10-5的attribute()和flow()方法（分别对应图10-5中的过程3.1和过程3.2）完成。</p>
<p>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等</p>
<p>在标注检查中，还会顺便进行一个称为常量折叠（Constant Folding）的代码优化，这是Javac编译器会对源代码做的极少量优化措施之一（代码优化几乎都在即时编译器中进行）</p>
<p>标注检查步骤在Javac源码中的实现类是com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类。</p>
<h6 id="数据及控制流分析"><a href="#数据及控制流分析" class="headerlink" title="数据及控制流分析"></a>数据及控制流分析</h6><p>数据流分析和控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上可以看作是一致的，但校验范围会有所区别，有一些校验项只有在编译期或运行期才能进行。</p>
<p>下面举一个关于final修饰符的数据及控制流分析的例子，见代码清单10-1所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一带有final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二没有final修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这两个foo()方法中，一个方法的参数和局部变量定义使用了final修饰符，另外一个则没有，<strong>在代码编写时程序肯定会受到final修饰符的影响</strong>，<strong>不能再改变arg和var变量的值</strong>，</p>
<p>但是如果观察这<strong>两段代码编译出来的字节码</strong>，会发现<strong>它们是没有任何一点区别的</strong>，每条指令，甚至每个字节都一模一样。</p>
<p>通过第6章对Class文件结构的讲解我们已经知道，局部变量与类的字段（实例变量、类变量）的存储是有显著差别的，<strong>局部变量在常量池中并没有CONSTANT_Fieldref_info的符号引用</strong>，<strong>自然就不可能存储有访问标志（access_flags）的信息</strong>，甚至可能连变量名称都不一定会被保留下来（这取决于编译时的<br>编译器的参数选项），自然<strong>在Class文件中就不可能知道一个局部变量是不是被声明为final了</strong>。</p>
<p>因此，可以肯定地推断出把局部变量声明为final，对运行期是完全没有影响的，<strong>变量的不变性仅仅由Javac编译器在编译期间来保障</strong>，这就是一个只能在编译期而不能在运行期中检查的例子。</p>
<p>在Javac的源码中，数据及控制流分析的入口是图10-5中的flow()方法（图10-5中的过程3.2），具体操作由com.sun.tools.javac.comp.Flow类来完成。</p>
<h6 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h6><p>语法糖（Syntactic Sugar），也称糖衣语法，，是由英国计算机科学家Peter J.Landin发明的一种编程术语，指的是在计算机语言中添加的某种语法，这种语法对语言的编译结果和功能并没有实际影响，但是却能更方便程序员使用该语言。通常来说使用语法糖能够减少代码量、增加程序的可读性，从而减少程序代码出错的机会。</p>
<p>Java中最常见的语法糖包括了前面提到过的泛型（其他语言中泛型并不一定都是语法糖实现，如C#的泛型就是直接由CLR支持的）、变长参数、自动装箱拆箱，等等，Java虚拟机运行时并不直接支持这些语法，它们在编译阶段被还原回原始的基础语法结构，这个过程就称为解语法糖.</p>
<p>在Javac的源码中，解语法糖的过程由desugar()方法触发，在com.sun.tools.javac.comp.TransTypes类<br>和com.sun.tools.javac.comp.Lower类中完成。</p>
<h6 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h6><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作.</p>
<ul>
<li>前文多次登场的实例构造器<init>()方法和类构造器<clinit>()方法就是在这个阶段被添加到语法树之中的</li>
<li>请注意<strong>这里的实例构造器并不等同于默认构造函数</strong>，如果用户代码中没有提供任何构造函数，那编译器将会添加一个没有参数的、可访问性（public、protected、private或<package>）与当前类型一致的默认构造函数，<strong>这个工作在填充符号表阶段中就已经完成</strong></li>
<li><init>()和<clinit>()这两个构造器的产生实际上是一种代码收敛的过程，编译器会把语句块（对于实例构造器而言是“{}”块，对于类构造器而言是“static{}”块）、变量初始化（实例变量和类变量）、调用父类的实例构造器（仅仅是实例构造器，<clinit>()方法中无须调用父类的<clinit>()方法，Java虚拟机会自动保证父类构造器的正确执行，但在<clinit>()方法中经常会生成调用java.lang.Object的<init>()方法的代码）等操作收敛到<init>()和<br><clinit>()方法之中，并且<strong>保证无论源码中出现的顺序如何，都一定是按先执行父类的实例构造器，然后初始化变量，最后执行语句块的顺序进行</strong>，上面所述的动作由**Gen::normalizeDefs()**方法来实现</li>
<li>还有其他的一些代码替换工作用于优化程序某些逻辑的实现方式，如把字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK 5）的append()操作，等等。</li>
</ul>
<p>完成了对语法树的遍历和调整之后，就会把填充了所有所需信息的符号表交到<strong>com.sun.tools.javac.jvm.ClassWriter</strong>类手上，由这个类的writeClass()方法输出字节码，<strong>生成最终的Class文件</strong>，到此，整个编译过程宣告结束。</p>
<h3 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h3><p>语法糖可以看作是前端编译器实现的一些“小把戏”，这些“小把戏”可能会使效率得到“大提升”，但我们也应该去了解这些“小把戏”背后的真实面貌，那样才能利用好它们，而不是被它们所迷惑。</p>
<p><strong>ps:  其实只需要在 反编译class文件后，就可以知道 使用了语法糖的java文件最后去语法糖后，变成了什么样子</strong></p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型的本质是 参数化类型（Parameterized Type）或者参数化多态（Parameteric Polymorphism）的应用， 即可以<strong>将操作的数据类型指定为方法签名中的一种参数</strong>，这种参数类型能够用在 类、接口和方法的创建中，分别构成 泛型类、泛型接口和泛型方法。 泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大的增强了编程语言的类型系统以及抽象能力。</p>
<p>Java的泛型直到今天依然作为Java语言不如C#语言好用的“铁证”被众人嘲讽</p>
<h5 id="Java与C-的泛型"><a href="#Java与C-的泛型" class="headerlink" title="Java与C#的泛型"></a>Java与C#的泛型</h5><ul>
<li><p>Java选择的泛型实现方式叫作“类型擦除式泛型”（Type Erasure Generics），</p>
</li>
<li><p>而C#选择的泛型实现方式是“具现化式泛型”（Reified Generics）。具现化和特化、偏特化这些名词最初都是源于C++模版语法中的概念</p>
</li>
<li><p>C#里面泛型无论在程序源码里面、编译后的中间语言表示（Intermediate Language，这时候泛型是一个占位符）里面，抑或是运行期的CLR里面都是切实存在的，List<int>与 List<string>就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。</p>
</li>
<li><p>而Java语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的裸类型（Raw Type),并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>其实是同一个类型，由此读者可以想象“类型擦除”这个名字的含义和来源</p>
</li>
</ul>
<p>代码清单10-2　Java中不支持的泛型用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeErasureGenerics</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> E) &#123; <span class="comment">// 不合法，无法对泛型进行实例判断</span></span><br><span class="line">        	...</span><br><span class="line">        &#125;</span><br><span class="line">        E newItem = <span class="keyword">new</span> E(); <span class="comment">// 不合法，无法使用泛型创建对象</span></span><br><span class="line">        E[] itemArray = <span class="keyword">new</span> E[<span class="number">10</span>]; <span class="comment">// 不合法，无法使用泛型创建数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>C#2.0引入了泛型之后，带来的显著优势之一便是对比起Java在执行性能上的提高，因为在<strong>使用平台提供的容器类型</strong>（如List<T>，Dictionary&lt;TKey，TValue&gt;）时，<strong>无须像Java里那样不厌其烦地拆箱和装箱</strong>[1]，如果在Java中要避免这种损失，就必须构造一个与数据类型相关的容器类（譬如IntFloatHashMap这样的容器）。显然，这除了引入更多代码造成复杂度提高、复用性降低之外，更是丧失了泛型本身的存在价值。</p>
</li>
<li><p>Java的类型擦除式泛型无论在使用效果上还是运行效率上，几乎是全面落后于C#的具现化式泛型，而它的<strong>唯一优势是在于实现这种泛型的影响范围上</strong>：擦除式泛型的<strong>实现几乎只需要在Javac编译器上做出改进即可，不需要改动字节码、不需要改动Java虚拟机</strong>，也<strong>保证了以前没有使用泛型的库可以直接运行在Java 5.0之上</strong>。但这种听起来节省工作量甚至可以说是有偷工减料嫌疑的优势就显得非常短视</p>
</li>
</ul>
<p>在没有泛型的时代，由于Java中的数组是支持协变（Covariant）的[6]，对应的集合类也可以存入不同类型的元素，类似于代码清单10-3这样的代码尽管不提倡，但是完全可以正常编译成Class文件。</p>
<p>代码清单10-3　以下代码可正常编译为Class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 编译期不会有问题，运行时会报错</span></span><br><span class="line">ArrayList things = <span class="keyword">new</span> ArrayList();</span><br><span class="line">things.add(Integer.valueOf(<span class="number">10</span>)); <span class="comment">//编译、运行时都不会报错</span></span><br><span class="line">things.add(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>为了保证这些编译出来的Class文件可以在Java 5.0引入泛型之后继续运行，设计者面前大体上有两条路可以选择：<br>1）需要泛型化的类型（主要是容器类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型。<br>2）直接把已有的类型泛型化，即让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。</p>
<p>C# 选择了第一种方式，平行的加了一套泛型化版本的新类型 </p>
<p>Java选择了，第一要考虑到 保证“二进制向后兼容性”（Binary Backwards Compatibility）。二进制向后兼容性是明确写入《Java语言<br>规范》中的对Java使用者的严肃承诺，譬如一个在JDK 1.2中编译出来的Class文件，必须保证能够在JDK 12乃至以后的版本中也能够正常运行。</p>
<p>然后Java当时已经流行了10来年，存量老代码太多。</p>
<p>但<strong>第二条路也并不意味着一定只能使用类型擦除来实现</strong>，如果当时有足够的时间好好设计和实现，是完全有可能做出更好的泛型系统的，否则也不会有今天的<strong>Valhalla</strong>项目来<strong>还以前泛型偷懒留下的技术债</strong>了</p>
<h5 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h5><p>由于Java选择了第二条路，直接把已有的类型泛型化。要让所有需要泛型化的已有类型，譬如 ArrayList，原地泛型化后变成 ArrayList<T>,而且保证以前直接使用ArrayList的代码在泛型新版本里必须还能继续用这同一容器，这就必须让所有泛型化的实例，譬如 ArrayList<Integer>、ArrayList<String>这些全部自动成为<br>ArrayList的子类型才能可以，否则类型转换就是不安全的。由此 就引出了 <strong>“裸类型”（Raw Type）</strong>的概念，裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type），</p>
<p>代码清单10-4　裸类型赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; ilist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; slist = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList list; <span class="comment">// 裸类型</span></span><br><span class="line">list = ilist;</span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure>

<p>接下来的问题是该如何实现裸类型。这里又有了两种选择：</p>
<ul>
<li>一种是在运行期由Java虚拟机来自动地、真实地构造出ArrayList<Integer>这样的类型，并且自动实现从ArrayList<Integer>派生自ArrayList的继承关系来满足裸类型的定义；</li>
<li>（<strong>被选择</strong>）另外一种是<strong>索性简单粗暴地直接在编译时把ArrayList<Integer>还原回ArrayList</strong>，只在<strong>元素访问、修改时自动插入一些强制类型转换和检查指令</strong>，这样看起来也是能满足需要，这两个选择的最终结果大家已经都知道了。</li>
</ul>
<p>代码清单10-5是一段简单的Java泛型例子，我们可以看一下它编译后的实际样子是怎样的。</p>
<p>代码清单10-5　泛型擦除前的例子</p>
<p>代码清单10-5　泛型擦除前的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;how are you?&quot;</span>, <span class="string">&quot;吃了没？&quot;</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;how are you?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，<strong>泛型类型都变回了裸类型</strong>，只在<strong>元素访问时插入了从Object到String的强制转型代码</strong>，如代码清单10-6所示。</p>
<p>代码清单10-6　泛型擦除后的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;how are you?&quot;</span>, <span class="string">&quot;吃了没？&quot;</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    System.out.println((String) map.get(<span class="string">&quot;how are you?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，使用擦除法实现泛型直接导致了对原始类型（Primitive Types）数据的支持又成了新的麻烦，譬如将代码清单10-2稍微修改一下，变成代码清单10-7这个样子</li>
</ul>
<p>代码清单10-7　原始类型的泛型（目前的Java不支持）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; ilist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">ArrayList&lt;<span class="keyword">long</span>&gt; llist = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">long</span>&gt;();</span><br><span class="line">ArrayList list;</span><br><span class="line">list = ilist;</span><br><span class="line">list = llist;</span><br></pre></td></tr></table></figure>

<p>这种情况下，一旦把泛型信息擦除后，到要插入强制转型的地方就没办法往下做了，因为 不支持 int、long 与 Object之间的强制类型转换。 当时Java给出的解决方案一如既往的简单粗暴：  既然没法转换，<strong>索性就不支持原生类型的泛型</strong>。都用ArrayList<Integer>、ArrayList<Long>，反正都做了<strong>自动的强制类型转换</strong>，遇到<strong>原生类型时把装箱、拆箱也自动做了</strong>.。这个决定也导致了无数构造包装类的装箱、拆箱的开销， 称为Java泛型慢的重要原因。</p>
<ul>
<li>第二，运行期无法取到泛型类型信息，会让一些代码变得相当啰嗦，譬如代码清单10-2中罗列的几种Java不支持的泛型用法，都是由于运行期Java虚拟机无法取得泛型类型而导致的。像代码清单10-8这样，我们去写一个泛型版本的从List到数组的转换方法，由于不能从List中取得参数化类型T，所以不得不从一个额外参数中再传入一个数组的组件类型进去，实属无奈。</li>
</ul>
<p>代码清单10-8　不得不加入的类型参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123;</span><br><span class="line">    T[] array = (T[])Array.newInstance(componentType, list.size());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后，通过擦除法来实现泛型，还丧失了一些面向对象思想应有的优雅，带来了一些模棱两可的模糊状况，例如代码清单10-9的例子</li>
</ul>
<p>代码清单10-9　当泛型遇见重载1 (<strong>这段代码无法编译通过</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypes</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">   	 	System.out.println(<span class="string">&quot;invoke method(List&lt;String&gt; list)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是不能被编译的，因为参数List<Integer>和List<String>编译之后都被擦除了，变成了同一种的裸类型List，<br>类型擦除导致这两个方法的特征签名变得一模一样。（<strong>特征签名最重要的任务就是作为方法独一无二不可重复的ID，在Java代码中的方法特征签名只包括了方法名称、参数顺序及参数类型，而在字节码中的特征签名还包括方法返回值及受查异常表</strong>）</p>
<ul>
<li>由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响并带来新的需求，如在泛型类中如何获取传入的参数化类型等。</li>
<li>所以JCP组织对《Java虚拟机规范》做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，</li>
<li>Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[8]，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范[9]要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。</li>
<li>另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们在编码时能通过反射手段取得参数化类型的根本依据。</li>
</ul>
<h5 id="值类型与未来的泛型"><a href="#值类型与未来的泛型" class="headerlink" title="值类型与未来的泛型"></a>值类型与未来的泛型</h5><p>值类型，这点也是C#用户攻讦Java语言的常用武器之一，C#并没有Java意义上的原生数据类型，在C#中使用的int、bool、double关键字其实是对应了一系列在.NET框架中预定义好的结构体（Struct），如Int32、Boolean、Double等。在C#中开发人员也可以定义自己值类型，只要继承于ValueType类型即可，而ValueType也是统一基类Object的子类，所以并不会遇到Java那样int不自动装箱就无法转型为Object的尴尬。</p>
<p>值类型可以与引用类型一样，具有构造函数、方法或是属性字段，等等，而它与引用类型的区别在于它在赋值的时候通常是整体复制，而不是像引用类型那样传递引用的。更为关键的是，值类型的实例很容易实现分配在方法的调用栈上的，这意味着值类型会随着当前方法的退出而自动释放，不会给垃圾收集子系统带来任何压力。</p>
<h5 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h5><p>代码清单10-11　自动装箱、拆箱与遍历循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">    	sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单10-12　自动装箱、拆箱与遍历循环编译之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = Arrays.asList( <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">    Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">    Integer.valueOf(<span class="number">4</span>) &#125;);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码清单10-11中一共包含了泛型、自动装箱、自动拆箱、遍历循环与变长参数5种语法糖，代码<br>清单10-12则展示了它们在编译前后发生的变化。泛型就不必说了，</p>
<ul>
<li>自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法，如本例中的Integer.valueOf()与Integer.intValue()方法，</li>
<li>而遍历循环则是把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因。</li>
<li>最后再看看变长参数，它在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员的确也就是使用数组来完成类似功能的。</li>
</ul>
<p>这些语法糖虽然看起来很简单，但也不见得就没有任何值得我们特别关注的地方，代码清单10-13演示了自动装箱的一些错误用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoBoxing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">        System.out.println(c+<span class="string">&quot; &quot;</span>+d+<span class="string">&quot; &quot;</span>+System.identityHashCode(c)+<span class="string">&quot; &quot;</span>+System.identityHashCode(d));</span><br><span class="line">        System.out.println(e == f);</span><br><span class="line">        System.out.println(e+<span class="string">&quot; &quot;</span>+f+<span class="string">&quot; &quot;</span>+System.identityHashCode(e)+<span class="string">&quot; &quot;</span>+System.identityHashCode(f));</span><br><span class="line">        System.out.println(c == (a + b));</span><br><span class="line">        System.out.println(c.equals(a + b));</span><br><span class="line">        System.out.println(g == (a + b));</span><br><span class="line">        System.out.println(g.equals(a + b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Integer 源码（解释为什么  System.out.println(e == f);  //返回false）</span></span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">    <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>鉴于<strong>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</strong>，以及<strong>它们equals()方法不处理数据转型的关系</strong>，</p>
<p>Integer::valueOf(int i),  当i的值 处于[-128,127]时，从缓存Cache中取， 否则 new Integer(i)，包装类==比较hash地址，所以  返回false</p>
<h5 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h5><p>在Java语言之中并没有使用预处理器，因为Java语言天然的编译方式（编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此各个文件之间能够互相提供符号信息）就无须使用到预处理器。</p>
<p>Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。如代码清单10-14所示，该代码中的if语句不同于其他Java代码，它在编译阶段就会被“运行”，生成的字节码之中只包括“System.out.println(“block 1”)；”一条语句，并不会包含if语句及另外一个分子中的“System.out.println(“block 2”)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;block 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后的反编译结果：</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;block 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>只能使用条件为常量的if语句才能达到上述效果，如果使用常量与其他带有条件判断能力的语句搭配，则可能在控制流分析中提示错误，被拒绝编译，如代码清单10-15所示的代码就会被编译器拒绝编译。</p>
<p>代码清单10-15　不能使用其他条件语句来完成条件编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器将会提示“Unreachable code”</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">   	 System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了本节中介绍的泛型、自动装箱、自动拆箱、遍历循环、变长参数和条件编译之外，Java语言还有不少其他的语法糖，如<strong>内部类、枚举类、断言语句、数值字面量、对枚举和字符串的switch支持、try语句中定义和关闭资源（这3个从JDK 7开始支持）、Lambda表达式（</strong>从JDK 8开始支持，Lambda不能算是单纯的语法糖，但在前端编译器中做了大量的转换工作），等等，读者<strong>可以通过跟踪Javac源码、反编译Class文件等方式了解它们的本质实现</strong></p>
<h3 id="实战：插入式注解处理器-TODO"><a href="#实战：插入式注解处理器-TODO" class="headerlink" title="实战：插入式注解处理器(TODO)"></a>实战：插入式注解处理器(TODO)</h3><p>NameCheckProcessor的实战例子只演示了JSR-269嵌入式注解处理API其中的一部分功能，基于这组API支持的比较有名的项目还有用于校验Hibernate标签使用正确性的Hibernate Validator AnnotationProcessor[1]（本质上与NameCheckProcessor所做的事情差不多）、自动为字段生成getter和setter方法等辅助内容的Lombok[2]（根据已有元素生成新的语法树元素）等，读者有兴趣的话可以参考它们官方站点的相关内容</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在本章中，我们从Javac编译器源码实现的层次上学习了Java源代码编译为字节码的过程，分析了Java语言中泛型、主动装箱拆箱、条件编译等多种语法糖的前因后果，并实战练习了如何使用插入式注解处理器来完成一个检查程序命名规范的编译器插件。</p>
<p>如本章概述中所说的，在<strong>前端编译器中，“优化”手段主要用于提升程序的编码效率</strong>，之所以把Javac这类将Java代码转变为字节码的编译器称作“前端编译器”，是因为<strong>它只完成了从程序到抽象语法树或中间字节码的生成</strong>，而在此之后，还有一组<strong>内置于Java虚拟机内部的“后端编译器”来完成代码优化以及从字节码生成本地机器码的过程</strong>，即前面多次提到的即时编译器或提前编译器，这个<strong>后端编译器的编译速度及编译结果质量高低，是衡量Java虚拟机性能最重要的一个指标</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">深入理解jvm-13-类加载及执行子系统的案例与实战</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-25 22:22:30" itemprop="dateCreated datePublished" datetime="2021-01-25T22:22:30+08:00">2021-01-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-13-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>20k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类加载及执行子系统的案例与实战"><a href="#类加载及执行子系统的案例与实战" class="headerlink" title="类加载及执行子系统的案例与实战"></a>类加载及执行子系统的案例与实战</h1><p>在Class文件格式与执行引擎这部分里，用户的程序能直接参与的内容并不太多，Class文件以何种格式存储，类型何时加载、如何连接，以及虚拟机如何执行字节码指令等都是由虚拟机直接控制的行为，用户程序无法对其进行改变.</p>
<p>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路，这些思路后来成为许多常用功能和程序实现的基础。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="Tomcat：正统的类加载器架构"><a href="#Tomcat：正统的类加载器架构" class="headerlink" title="Tomcat：正统的类加载器架构"></a>Tomcat：正统的类加载器架构</h3><p>主流的Java Web服务器，如Tomcat、Jetty、WebLogic、WebSphere或其他笔者没有列举的服务器，都实现了自己定义的类加载器，而且一般还都不止一个。因为一个功能健全的Web服务器，都要解决如下的这些问题：</p>
<ol>
<li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现<strong>相互隔离</strong>。这是最基本的需求，两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求每个类库在一个服务器中只能有一份，服务器应当能够<strong>保证两个独立应用程序的类库可以互相独立使用。</strong></li>
<li>部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。这个需求与前面一点正好相反，但是也很常见，例如用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费——这主要倒不是浪费磁盘空间的问题，而是指类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方 法区就会很容易出现过度膨胀的风险。</li>
<li>服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。目前，有许多主流的JavaWeb服务器自身也是使用Java语言来实现的。因此服务器本身也有类库依赖的问题，一般来说，基于安全考虑，服务器所使用的类库应该与应用程序的类库互相独立。</li>
<li>支持JSP应用的Web服务器，十有八九都需要支持HotSwap功能。我们知道JSP文件最终要被编译成Java的Class文件才能被虚拟机执行，但JSP文件由于其纯文本存储的特性，被运行时修改的概率远大于第三方类库或程序自己的Class文件。而且ASP、PHP和JSP这些网页应用也把修改后无须重启作为一个很大的“优势”来看待，因此“主流”的Web服务器都会支持JSP生成类的热替换，当然也有“非主流”的，如运行在生产模式（Production Mode）下的WebLogic服务器默认就不会处理JSP文件的变化。</li>
</ol>
<p>由于存在上述问题，在部署Web应用时，单独的一个ClassPath就不能满足需求了，所以各种Web服务器都不约而同地<strong>提供了好几个有着不同含义的ClassPath路径</strong>供用户存放第三方类库，这些路径一般会以“lib”或“classes”命名。被放置到不同路径中的类库，具备不同的访问范围和服务对象，通常每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。现在就以Tomcat服务器[1]为例，与读者一同分析Tomcat具体是如何规划用户类库结构和类加载器的。</p>
<p>在Tomcat目录结构中，可以设置3组目录（/<strong>common</strong>/<em>、/<strong>server</strong>/<em>和/</em></em>shared**/<em>，但默认不一定是开放的，可能只有/lib/<em>目录存在）用于存放Java类库，另外还应该加上Web应用程序自身的“/</em></em>WEBINF**/*”目录，一共4组。把Java类库放置在这4组目录中，每一组都有独立的含义，分别是：</p>
<ul>
<li>放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</li>
<li>放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</li>
<li>放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</li>
<li>放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用程序都不可见。</li>
</ul>
<p>为了支持这套目录结构，并对目录里面的类库进行加载和隔离，<strong>Tomcat自定义了多个类加载器</strong>，这些类加载器按照经典的双亲委派模型来实现，其关系如图9-1所示。</p>
<p><img src="/uploads/jvm/23-tomcatClassLoader.png"></p>
<ul>
<li>灰色背景的3个类加载器是JDK（以JDK 9之前经典的三层类加载器为例）默认提供的类加载器，这3个加载器的作用在第7章中已经介绍过了。</li>
<li>而Common类加载器、Catalina类加载器（也称为Server类加载器）、Shared类加载器和Webapp类加载器则是Tomcat自己定义的类加载器，它们分别加<br>载/common/*、/server/*、/shared/*和/WebApp/WEB-INF/*中的Java类库。</li>
<li>其中WebApp类加载器和JSP类加载器通常还会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个JasperLoader类加载器。</li>
</ul>
<p>从图9-1的委派关系中可以看出，</p>
<ul>
<li>Common类加载器能加载的类都可以被Catalina类加载器和Shared类加载器使用，</li>
<li>而Catalina类加载器和Shared类加载器自己能加载的类则与对方相互隔离。</li>
<li>WebApp类加载器可以使用Shared类加载器加载到的类，但各个WebApp类加载器实例之间相互隔离。</li>
<li>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class文件，它存在的目的就是为了被丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的JSP类加载器来实现JSP文件的HotSwap功能。</li>
</ul>
<p>本例中的类加载结构在<strong>Tomcat 6以前</strong>是它默认的类加载器结构，在Tomcat 6及之后的版本简化了默认的目录结构，只有指定了<strong>tomcat/conf/catalina.properties</strong>配置文件的<strong>server.loader和share.loader</strong>项后才会真正建立Catalina类加载器和Shared类加载器的实例，否则会用到这两个类加载器的地方都会用Common类加载器的实例代替，</p>
<p>而默认的配置文件中并没有设置这两个loader项，所以Tomcat 6之后也顺理成章地把/common、/server和/shared这3个目录默认合并到一起变成1个/lib目录，这个目录里的类库相当于以前/common目录中类库的作用，是Tomcat的开发团队为了简化大多数的部署场景所做的一项易用性改进。</p>
<p>如果默认设置不能满足需要，用户可以通过修改配置文件指定server.loader和share.loader的方式重新启用原来完整的加载器架构。</p>
<h4 id="Tomcat类加载过程"><a href="#Tomcat类加载过程" class="headerlink" title="Tomcat类加载过程"></a>Tomcat类加载过程</h4><p>（1）在Tomcat启动时，会创建一系列的类加载器，在其主类Bootstrap的初始化过程中，会先初始化classloader，然后将其绑定到Thread中。 </p>
<p>（2）其中initClassLoaders方法，会根据catalina.properties的配置，创建相应的classloader。由于默认只配置了common.loader属性，所以其中只会创建一个出来</p>
<p>（3）然后，当一个应用启动的时候，会为其创建对应的WebappClassLoader。此时会将commonClassLoader设置为其parent</p>
<p>（4）在加载时，与java双亲委托机制不同，默认是子优先，也就是先用子加载器加载但是保证Java的基础类不允许其重新加载，以及servlet-api也不允许重新加载。</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>那么笔者不妨再提一个问题让各位读者思考一下：前面曾经提到过一个场景，如果有10个Web应用程序都是用Spring来进行组织和管理的话，可以把Spring<br>放到Common或Shared目录下让这些程序共享。Spring要对用户程序的类进行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中的。那么被Common类加载器或Shared类加载器加载的Spring如何访问并不在其加载范围内的用户程序呢？</p>
<h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><p><strong>当然就是前片所说的使用线程上下文类加载器，当我们在spring的配置文件中通过类来创建对象，spring都是使用线程上下文类加载器来加载了，默认设置为WebAppClassLoader，所以当在web应用程序内，spring通过线程上下文类加载器使用WebAppClassLoader来加载bean</strong></p>
<p>答案明显是使用线程上下文类加载器来实现的啊！仔细看源码你会发现，spring加载类所用的classloader都是通过Thread.currentThread().getContextClassLoader()来获取的，而当线程创建时会默认 setContextClassLoader(AppClassLoader)，即spring中始终可以获取到这个AppClassLoader(在tomcat里就是WebAppClassLoader)子类加载器来加载bean，以后任何一个线程都可以通过getContextClassLoader()获取到WebAppClassLoader来getbean了</p>
<h3 id="OSGi：灵活的类加载器架构"><a href="#OSGi：灵活的类加载器架构" class="headerlink" title="　OSGi：灵活的类加载器架构"></a>　OSGi：灵活的类加载器架构</h3><p>曾经在Java程序社区中流传着这么一个观点：“学习Java EE规范，推荐去看JBoss源码；学习类加载器的知识，就推荐去看OSGi源码。</p>
<ul>
<li><p>OSGi的Bundle类加载器之间只有规则，没有固定的委派关系。例如，某个Bundle声明了一个它依赖的Package，如果有其他Bundle声明了发布这个Package后，那么所有对这个Package的类加载动作都会委派给发布它的Bundle类加载器去完成。不涉及某个具体的Package时，各个Bundle加载器都是平级的关系，只有具体使用到某个Package和Class的时候，才会根据Package导入导出定义来构造Bundle间的委派和依赖。</p>
</li>
<li><p>另外，一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控制访问范围。如果一个类存在于Bundle的类库中但是没有被Export，那么这个Bundle的类加载器能找到这个类，但不会提供给其他Bundle使用，而且OSGi框架也不会把其他Bundle的类加载请求分配给这个Bundle来<br>处理。</p>
</li>
</ul>
<p>我们可以举一个更具体些的简单例子来解释上面的规则：</p>
<p>假设存在Bundle A、Bundle B、BundleC3个模块，并且这3个Bundle定义的依赖关系如下所示。</p>
<ul>
<li><p>Bundle A：声明发布了packageA，依赖了java.<em>的包；</em></p>
</li>
<li><p>*Bundle B：声明依赖了packageA和packageC，同时也依赖了java.*的包；</p>
</li>
<li><p>Bundle C：声明发布了packageC，依赖了packageA。</p>
</li>
</ul>
<p>那么，这3个Bundle之间的类加载器及父类加载器之间的关系如图9-2所示。</p>
<p><img src="/uploads/jvm/24-OSGiClassLoader.png"></p>
<p>由于没有涉及具体的OSGi实现，图9-2中的类加载器都没有指明具体的加载器实现，它只是一个<br>体现了加载器之间关系的概念模型，并且只是体现了OSGi中最简单的加载器委派关系。一般来说，在<br>OSGi里，加载一个类可能发生的查找行为和委派关系会远远比图9-2中显示的复杂，类加载时可能进<br>行的查找规则如下：</p>
<ul>
<li>以java.*开头的类，委派给父类加载器加载。</li>
<li>否则，委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的Classpath，使用自己的类加载器加载。</li>
<li>否则，查找是否在自己的Fragment Bundle中，如果是则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
<p>从图9-2中还可以看出，在OSGi中，加载器之间的关系不再是双亲委派模型的树形结构，而是已经进一步发展成一种更为复杂的、运行时才能确定的网状结构。这种网状的类加载器架构在带来更优秀的灵活性的同时，也可能会产生许多新的隐患</p>
<p>代码模块之间的依赖关系错综复杂，勉强分离出各个模块的Bundle后，发现在高并发环境下经常出现死锁。我们很容易就找到了死锁的原因：如果出现了Bundle A依赖Bundle B的Package B，而Bundle B又依赖了Bundle A的Package A，这两个Bundle进行类加载时就有很高的概率发生死锁。具体情况是当Bundle A加载Package B的类时，首先需要锁定当前类加载器的实例对象（java.lang.ClassLoader.loadClass()是一个同步方法），然后把请求委派给Bundle B的加载器处理，但如果这时Bundle B也正好想加载Package A的类，它会先锁定自己的加载器再去请求Bundle A的加载器处理，这样两个加载器都在等待对方处理自己的请求，而对方处理完之前自己又一直处于同步锁定的状态，因此它们就互相死锁，永远无法完成加载请求了。</p>
<p>在JDK 7时才终于出现了JDK层面的解决方案，类加载器架构进行了一次专门的升级，在ClassLoader中增加了registerAsParallelCapable方法对可并行的类加载进行注册声明，把锁的级别从ClassLoader对象本身，降低为要加载的类名这个级别，目的是从底层避免以上这类死锁出现的可能。</p>
<p>总体来说，OSGi描绘了一个很美好的模块化开发的目标，而且定义了实现这个目标所需的各种服务，同时也有成熟框架对其提供实现支持。对于单个虚拟机下的应用，从开发初期就建立在OSGi上是一个很不错的选择，这样便于约束依赖。但并非所有的应用都适合采用OSGi作为基础架构，OSGi在提供强大功能的同时，也引入了额外而且非常高的复杂度，带来了额外的风险。</p>
<h3 id="字节码生成技术与动态代理的实现"><a href="#字节码生成技术与动态代理的实现" class="headerlink" title="字节码生成技术与动态代理的实现"></a>字节码生成技术与动态代理的实现</h3><p>在Java世界里面除了Javac和字节码类库外，使用到字节码生成的例子比比皆是，如Web服务器中的JSP编译器，编译时织入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机都有可能会在运行时生成字节码来提高执行速度。我们选择其中相对简单的动态代理技术来讲解字节码生成技术是如何影响程序运作的。</p>
<p>相信许多Java开发人员都使用过动态代理，即使没有直接使用过java.lang.reflect.Proxy或实现过java.lang.reflect.InvocationHandler接口，应该也用过Spring来做过Bean的组织管理。如果使用过Spring，那大多数情况应该已经不知不觉地用到动态代理了，因为如果Bean是面向接口编程，那么在Spring内部都是通过动态代理的方式来对Bean进行增强的。动态代理中所说的“动态”，是针对使用Java代码实际编写了代理类的“静态”代理而言的，它的优势不在于省去了编写代理类那一点编码工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。</p>
<p>代码清单9-1演示了一个最简单的动态代理的用法，原始的代码逻辑是打印一句“hello world”，代理类的逻辑是在原始类方法执行前打印一句“welcome”。我们先看一下代码，然后再分析JDK是如何做到的。</p>
<p>代码清单9-1　动态代理的简单示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.originalObj = originalObj;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IHello hello = (IHello) <span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">        System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">welcome</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>



<p>在上述代码里，唯一的“黑匣子”就是Proxy::newProxyInstance()方法，除此之外再没有任何特殊之处。这个方法返回一个实现了IHello的接口，并且代理了new Hello()实例行为的对象。跟踪这个方法的源码，可以看到程序进行过验证、优化、缓存、同步、生成字节码、显式类加载等操作，前面的步骤并不是我们关注的重点，这里只分析它最后调用sun.misc.ProxyGenerator::generateProxyClass()方法来完成生成字节码的动作，这个方法会在运行时产生一个描述代理类的字节码byte[]数组.磁盘中将会产生一个名为“$Proxy0.class”的代理类Class文件，反编译后可以发现</p>
<p>这个代理类的实现代码也很简单，它为传入接口中的每一个方法，以及从java.lang.Object中继承来的equals()、hashCode()、toString()方法都生成了对应的实现，并且统一调用了InvocationHandler对象的invoke()方法（代码中的“this.h”就是父类Proxy中保存的InvocationHandler实例变量）来实现这些方法的内容，各个方法的区别不过是传入的参数和Method对象有所不同而已，所以无论调用动态代理的哪一个方法，实际上都是在执行InvocationHandler::invoke()中的代理逻辑。</p>
<h3 id="Backport工具：Java的时光机器"><a href="#Backport工具：Java的时光机器" class="headerlink" title="Backport工具：Java的时光机器"></a>Backport工具：Java的时光机器</h3><p>在Java世界里，每一次JDK大版本的发布，都会伴随着规模不等或大或小的技术革新，而对Java程序编写习惯改变最大的，肯定是那些对Java语法做出重大改变的版本，譬如JDK 5时加入的自动装箱、泛型、动态注解、枚举、变长参数、遍历循环（foreach循环）；譬如JDK 8时加入的Lambda表达式、Stream API、接口默认方法等。事实上在没有这些语法特性的年代，Java程序也照样能写，但是现在回头看来，上述每一种语法的改进几乎都是“必不可少”的，如同用惯了32寸液晶、4K分辨率显示器的程序员，就很难再在19寸显示器、1080P分辨率的显示器上编写代码了。</p>
<p>但假如公司“不幸”因为要保护现有投资、维持程序结构稳定等，必须使用JDK 5或者JDK 8以前的版本呢？幸好，我们没有办法把19寸显示器变成32寸的，但却可以跨越JDK版本之间的沟壑，把高版本JDK中编写的代码放到低版本JDK环境中去部署使用。为了解决这个问题，一种名为“Java逆向移植”的工具（Java Backporting Tools）应运而生，Retrotranslator[1]和Retrolambda是这类工具中的杰出代表。</p>
<p><strong>Retrotranslator</strong>的作用是将JDK 5编译出来的Class文件转变为可以在JDK 1.4或1.3上部署的版本，它能很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK 5中新增的集合改进、并发包及对泛型、注解等的反射操作。</p>
<p><strong>Retrolambda</strong>的作用与Retrotranslator是类似的，目标是将JDK 8的Lambda表达式和try-resources语法转变为可以在JDK5、JDK 6、JDK 7中使用的形式，同时也对接口默认方法提供了有限度的支持。</p>
<p>要想知道Backporting工具如何在旧版本JDK中模拟新版本JDK的功能，首先要搞清楚JDK升级中会提供哪些新的功能。JDK的每次升级新增的功能大致可以分为以下五类：</p>
<ol>
<li><p>对Java类库API的代码增强。譬如JDK 1.2时代引入的java.util.Collections等一系列集合类，在JDK 5时代引入的java.util.concurrent并发包、在JDK 7时引入的java.lang.invoke包，等等。</p>
</li>
<li><p>在前端编译器层面做的改进。这种改进被称作语法糖，如自动装箱拆箱，实际上就是Javac编译器在程序中使用到包装对象的地方自动插入了很Integer.valueOf()、Float.valueOf()之类的代码；变长参数在编译之后就被自动转化成了一个数组来完成参数传递；泛型的信息则在编译阶段就已经被擦<br>除掉了（但是在元数据中还保留着），相应的地方被编译器自动插入了类型转换代码。</p>
</li>
<li><p>需要在字节码中进行支持的改动。如JDK 7里面新加入的语法特性——动态语言支持，就需要在虚拟机中新增一条invokedynamic字节码指令来实现相关的调用功能。不过字节码指令集一直处于相对稳定的状态，这种要在字节码层面直接进行的改动是比较少见的。</p>
</li>
<li><p>需要在JDK整体结构层面进行支持的改进，典型的如JDK 9时引入的Java模块化系统，它就涉及了JDK结构、Java语法、类加载和连接过程、Java虚拟机等多个层面。</p>
</li>
<li><p>集中在虚拟机内部的改进。如JDK 5中实现的JSR-133[4]规范重新定义的Java内存模型（JavaMemory Model，JMM），以及在JDK 7、JDK 11、JDK 12中新增的G1、ZGC和Shenandoah收集器之类的改动，这种改动对于程序员编写代码基本是透明的，只会在程序运行时产生影响。</p>
</li>
</ol>
<p>上述的5类新功能中，逆向移植工具能比较完美地模拟了前两类，从第3类开始就逐步深入地涉及了直接在虚拟机内部实现的改进了，这些功能一般要么是逆向移植工具完全无能为力，要么是不能完整地或者在比较良好的运行效率上完成全部模拟。想想这也挺合理的，如果在语法糖和类库层面可以完美解决的问题，Java虚拟机设计团队也没有必要舍近求远地改动处于JDK底层的虚拟机嘛。</p>
<ul>
<li>在能够较好模拟的前两类功能中，第一类模拟相对更容易实现一些，如JDK 5引入的java.util.concurrent包，实际是由多线程编程的大师Doug Lea开发的一套并发包，在JDK 5出现之前就已经存在（那时候名字叫作dl.util.concurrent，引入JDK时由作者和JDK开发团队共同进行了一些改进），所以要在旧的JDK中支持这部分功能，以独立类库的方式便可实现。Retrotranslator中就附带了一个名叫“backport-util-concurrent.jar”的类库（由另一个名为“Backport to JSR166”的项目所提供）来代替JDK 5的并发包。</li>
<li>至于第二类JDK在编译阶段进行处理的那些改进，Retrotranslator则是使用ASM框架直接对字节码进行处理。由于组成Class文件的字节码指令数量并没有改变，所以无论是JDK 1.3、JDK 1.4还是JDK5，能用字节码表达的语义范围应该是一致的。当然，肯定不会是简单地把Class的文件版本号从49.0改回48.0就能解决问题了，虽然字节码指令的数量没有变化，但是元数据信息和一些语法支持的内容还是要做相应的修改。</li>
</ul>
<p>以枚举为例，尽管在JDK 5中增加了enum关键字，但是Class文件常量池的CONSTANT_Class_info类型常量并没有发生任何语义变化，仍然是代表一个类或接口的符号引用，没有加入枚举，也没有增加过“CONSTANT_Enum_info”之类的“枚举符号引用”常量。所以使用enum关键字定义常量，尽管从Java语法上看起来与使用class关键字定义类、使用interface关键字定义接口是同一层次的，但实际上这是由Javac编译器做出来的假象，从字节码的角度来看，枚举仅仅是一个继承于java.lang.Enum、自动生成了values()和valueOf()方法的普通Java类而已。</p>
<p>Retrotranslator对枚举所做的主要处理就是把枚举类的父类从“java.lang.Enum”替换为它运行时类库中包含的“net.sf.retrotranslator.runtime.java.lang.Enum_”，然后再在类和字段的访问标志中抹去ACC_ENUM标志位。当然，这只是处理的总体思路，具体的实现要比上面说的复杂得多。可以想象既然两个父类实现都不一样，values()和valueOf()的方法自然需要重写，常量池需要引入大量新的来自父类的符号引用，这些都是实现细节。</p>
<p>用Retrolambda模拟JDK 8的Lambda表达式属于涉及字节码改动的第三类情况，Java为支持Lambda会用到新的invokedynamic字节码指令，但幸好这并不是必须的，只是基于效率的考量。在JDK 8之前，Lambda表达式就已经被其他运行在Java虚拟机的编程语言（如Scala）广泛使用了，那时候是怎么生成字节码的现在照着做就是，不使用invokedynamic，除了牺牲一点效率外，可行性方面并没有太大的障碍。</p>
<p>Retrolambda的Backport过程实质上就是生成一组匿名内部类来代替Lambda，里面会做一些优化措施，譬如采用单例来保证无状态的Lambda表达式不会重复创建匿名类的对象。有一些Java IDE工具，如IntelliJ IDEA和Eclipse里会包含将此过程反过来使用的功能特性，在低版本Java里<strong>把匿名内部类显示成Lambda语法</strong>的样子，<strong>实际存在磁盘上的源码还是匿名内部类形式的</strong>，只是在IDE里可以把它显示为Lambda表达式的语法，让人阅读起来比较简洁而已。</p>
<h2 id="实战自己动手实现远程执行功能"><a href="#实战自己动手实现远程执行功能" class="headerlink" title="实战自己动手实现远程执行功能"></a>实战自己动手实现远程执行功能</h2><h3 id="痛点："><a href="#痛点：" class="headerlink" title="痛点："></a>痛点：</h3><p>在做程序维护的时候是否遇到过这类情形：排查问题的过程中，想查看内存中的一些参数值，却苦于没有方法把这些值输出到界面或日志中。又或者定位到某个缓存数据有问题，由于缺少缓存的统一管理界面，不得不重启服务才能清理掉这个缓存。类似的需求有一个共同的特点，那就是只要在服务中执行一小段程序代码，就可以定位或排除问题，但就是偏偏找不到可以让服务器执行临时代码的途径，让人恨不得在服务器上装个后门。这是项目运维中的常见问题，通常解决类问题有<br>以下几种途径：</p>
<h3 id="现存方案："><a href="#现存方案：" class="headerlink" title="现存方案："></a>现存方案：</h3><ol>
<li>可以使用BTrace[1]这类JVMTI工具去动态修改程序中某一部分的运行代码，这部分在第4章有简要的介绍，类似的JVMTI工具还有阿里巴巴的Arthas[2]等。</li>
<li>使用JDK 6之后提供了Compiler API，可以动态地编译Java程序，这样虽然达不到动态语言的灵活度，但让服务器执行临时代码的需求是可以得到解决的。</li>
<li>也可以通过“曲线救国”的方式来做到，譬如写一个JSP文件上传到服务器，然后在浏览器中运行它，或者在服务端程序中加入一个BeanShell Script、JavaScript等的执行引擎（如Mozilla Rhino[3]）去执行动态脚本。</li>
<li>在应用程序中内置动态执行的功能。</li>
</ol>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>首先，在实现“在服务端执行临时代码”这个需求之前，先来明确一下本次实战的具体目标，我们希望最终的产品是这样的：</p>
<ul>
<li>不依赖某个JDK版本才加入的特性（包括JVMTI），能在目前还被普遍使用的JDK中部署，只要是使用JDK 1.4以上的JDK都可以运行。</li>
<li>不改变原有服务端程序的部署，不依赖任何第三方类库。</li>
<li>不侵入原有程序，即无须改动原程序的任何代码。也不会对原有程序的运行带来任何影响。</li>
<li>考虑到BeanShell Script或JavaScript等脚本与Java对象交互起来不太方便，“临时代码”应该直接支<br>持Java语言。</li>
<li>“临时代码”应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。这里写的是“不需要”而不是“不可以”，当“临时代码”需要引用其他类库时也没有限制，只要服务端程序能使用的类型和接口，临时代码都应当能直接引用。</li>
<li>“临时代码”的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的异常等。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在程序实现的过程中，我们需要解决以下3个问题：</p>
<ul>
<li>如何编译提交到服务器的Java代码？</li>
<li>如何执行编译之后的Java代码？</li>
<li>如何收集Java代码的执行结果？</li>
</ul>
<p>对于第一个问题，我们有两种方案可以选择。</p>
<ol>
<li><p>一种在服务器上编译，在JDK 6以后可以使用Compiler API，在JDK 6以前可以使用tools.jar包（在JAVA_HOME/lib目录下）中的com.sun.tools.Javac.Main类来编译Java文件，它们其实和直接使用Javac命令来编译是一样的。这种思路的缺点是引入了额外的依赖，而且把程序绑死在特定的JDK上了，要部署到其他公司的JDK中还得把tools.jar带上（虽然JRockit和J9虚拟机也有这个JAR包，但它总不是标准所规定必须存在的）。</p>
</li>
<li><p>另外一种思路是直接在客户端编译好，把字节码而不是Java代码传到服务端，这听起来好像有点投机取巧，一般来说确实不应该假定客户端一定具有编译代码的能力，也不能假定客户端就有编译出产品所需的依赖项。但是既然程序员会写Java代码去给服务端排查问题，那么很难想象他的机器上会连编译Java程序的环境都没有。</p>
</li>
</ol>
<p>对于第二个问题：</p>
<p>要执行编译后的Java代码，让类加载器加载这个类生成一个Class对象，然后反射调用一下某个方法就可以了（因为不实现任何接口，我们可以借用一下Java中约定俗成的“main()”方法）。但我们还应该考虑得更周全些：一段程序往往不是编写、运行一次就能达到效果，同一个类可能要被反复地修改、提交、执行。另外，提交上去的类要能访问到服务端的其他类库才行。还有就是既然提交的是临时代码，那提交的Java类在执行完后就应当能被卸载和回收掉。</p>
<p>最后一个问题，</p>
<p>我们想把程序往标准输出（System.out）和标准错误输出（System.err）中打印的信息收集起来。但标准输出设备是整个虚拟机进程全局共享的资源，如果使用<br>System.setOut()/System.setErr()方法把输出流重定向到自己定义的PrintStream对象上固然可以收集到输出信息，但也会对原有程序产生影响：会把其他线程向标准输出中打印的信息也收集了。虽然这些并不是不能解决的问题，不过为了达到完全不影响原程序的目的，我们可以采用另外一种办法：直接在执行的类中把对System.out的符号引用替换为我们准备的PrintStream的符号引用，依赖前面学习到的知识，做到这一点并不困难。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="HotSwapClassLoader"><a href="#HotSwapClassLoader" class="headerlink" title="HotSwapClassLoader"></a>HotSwapClassLoader</h4><p>第一个类用于实现“同一个类的代码可以被多次加载”这个需求，即用于解决9.2节列举的第二个问题的HotSwapClassLoader，具体程序如代码清单9-3所示。</p>
<p>HotSwapClassLoader所做的事情仅仅是公开父类（即java.lang.ClassLoader）中的protected方法defineClass()，我们将会使用这个方法把提交执行的Java类的byte[]数组转变为Class对象。HotSwapClassLoader中并没有重写loadClass()或findClass()方法，因此如果不算外部手工调用loadByte()方法的话，这个类加载器的类查找范围与它的父类加载器是完全一致的，在被虚拟机调用时，它会按照双亲委派模型交给父类加载。构造函数中指定为加载HotSwapClassLoader类的类加载器作为父类加载器，<strong>这一步是实现提交的执行代码可以访问服务端引用类库的关键</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 为了多次载入执行类而加入的加载器</span><br><span class="line"> * 把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法</span><br><span class="line"> * 由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载</span><br><span class="line"> *</span><br><span class="line"> * @author zzm</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HotSwapClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    public HotSwapClassLoader() &#123;</span><br><span class="line">        super(HotSwapClassLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class loadByte(byte[] classByte) &#123;</span><br><span class="line">        return defineClass(null, classByte, 0, classByte.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClassModifier-、ByteUtils"><a href="#ClassModifier-、ByteUtils" class="headerlink" title="ClassModifier 、ByteUtils"></a>ClassModifier 、ByteUtils</h4><p>第二个类是实现将java.lang.System替换为我们自己定义的HackSystem类的过程，它直接修改符合Class文件格式的byte[]数组中的常量池部分，将常量池中指定内容的CONSTANT_Utf8_info常量替换为新的字符串，具体代码如下面的代码清单9-4所示。ClassModifier中涉及对byte[]数组操作的部分，主要是将byte[]与int和String互相转换，以及把对byte[]数据的替换操作封装在代码清单9-5所示的ByteUtils中。</p>
<p>经过ClassModifier处理后的byte[]数组才会传给HotSwapClassLoader.loadByte()方法进行类加载，byte[]数组在这里替换符号引用之后，与客户端直接在Java代码中引用HackSystem类再编译生成的Class是完全一样的。这样的实现既避免了客户端编写临时执行代码时要依赖特定的类（不然无法引入HackSystem），又避免了服务端修改标准输出后影响到其他程序的输出。下面我们来看看代码清单9-4和代码清单9-5。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改Class文件，暂时只提供修改常量池常量的功能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassModifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class文件中常量池的起始偏移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_POOL_COUNT_INDEX = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CONSTANT_Utf8_info常量的tag标志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_Utf8_info = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] CONSTANT_ITEM_LENGTH = &#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> u2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] classByte;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassModifier</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classByte = classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改常量池中CONSTANT_Utf8_info常量的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldStr 修改前的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newStr 修改后的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 修改结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] modifyUTF8Constant(String oldStr, String newStr) &#123;</span><br><span class="line">        <span class="keyword">int</span> cpc = getConstantPoolCount();</span><br><span class="line">        <span class="keyword">int</span> offset = CONSTANT_POOL_COUNT_INDEX + u2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cpc; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tag = ByteUtils.bytes2Int(classByte, offset, u1);</span><br><span class="line">            <span class="keyword">if</span> (tag == CONSTANT_Utf8_info) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = ByteUtils.bytes2Int(classByte, offset + u1, u2);</span><br><span class="line">                offset += (u1 + u2);</span><br><span class="line">                String str = ByteUtils.bytes2String(classByte, offset, len);</span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(oldStr)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] strBytes = ByteUtils.string2Bytes(newStr);</span><br><span class="line">                    <span class="keyword">byte</span>[] strLen = ByteUtils.int2Bytes(newStr.length(), u2);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset - u2, u2, strLen);</span><br><span class="line">                    classByte = ByteUtils.bytesReplace(classByte, offset, len, strBytes);</span><br><span class="line">                    <span class="keyword">return</span> classByte;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    offset += len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                offset += CONSTANT_ITEM_LENGTH[tag];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classByte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取常量池中常量的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 常量池数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getConstantPoolCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ByteUtils.bytes2Int(classByte, CONSTANT_POOL_COUNT_INDEX, u2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bytes数组处理工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2Int</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = start + len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = ((<span class="keyword">int</span>) b[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">            n &lt;&lt;= (--len) * <span class="number">8</span>;</span><br><span class="line">            sum = n + sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] int2Bytes(<span class="keyword">int</span> value, <span class="keyword">int</span> len) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            b[len - i - <span class="number">1</span>] = (<span class="keyword">byte</span>) ((value &gt;&gt; <span class="number">8</span> * i) &amp; <span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">bytes2String</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> start, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(b, start, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] string2Bytes(String str) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bytesReplace(<span class="keyword">byte</span>[] originalBytes, <span class="keyword">int</span> offset, <span class="keyword">int</span> len, <span class="keyword">byte</span>[] replaceBytes) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] newBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[originalBytes.length + (replaceBytes.length - len)];</span><br><span class="line">        System.arraycopy(originalBytes, <span class="number">0</span>, newBytes, <span class="number">0</span>, offset);</span><br><span class="line">        System.arraycopy(replaceBytes, <span class="number">0</span>, newBytes, offset, replaceBytes.length);</span><br><span class="line">        System.arraycopy(originalBytes, offset + len, newBytes, offset + replaceBytes.length, originalBytes.length - offset - len);</span><br><span class="line">        <span class="keyword">return</span> newBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="HackSystem"><a href="#HackSystem" class="headerlink" title="HackSystem"></a>HackSystem</h4><p>最后一个类就是前面提到过的用来代替java.lang.System的HackSystem，这个类中的方法看起来不少，但其实除了把out和err两个静态变量改成使用ByteArrayOutputStream作为打印目标的同一个PrintStream对象，以及增加了读取、清理ByteArrayOutputStream中内容的getBufferString()和clearBuffer()方法外，就再没有其他新鲜的内容了。其余的方法全部都来自于System类的public方法，方法名字、参数、返回值都完全一样，并且实现也是直接转调了System类的对应方法而已。保留这些方法的目的，是为了在Sytem被替换成HackSystem之后，保证执行代码中调用的System的其余方法仍然可以继续使用，HackSystem的实现如代码清单9-6所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 为Javaclass劫持java.lang.System提供支持</span><br><span class="line"> * 除了out和err外，其余的都直接转发给System处理</span><br><span class="line"> *</span><br><span class="line"> * @author zzm</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HackSystem &#123;</span><br><span class="line"></span><br><span class="line">    public final static InputStream in &#x3D; System.in;</span><br><span class="line"></span><br><span class="line">    private static ByteArrayOutputStream buffer &#x3D; new ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    public final static PrintStream out &#x3D; new PrintStream(buffer);</span><br><span class="line"></span><br><span class="line">    public final static PrintStream err &#x3D; out;</span><br><span class="line"></span><br><span class="line">    public static String getBufferString() &#123;</span><br><span class="line">        return buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void clearBuffer() &#123;</span><br><span class="line">        buffer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setSecurityManager(final SecurityManager s) &#123;</span><br><span class="line">        System.setSecurityManager(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SecurityManager getSecurityManager() &#123;</span><br><span class="line">        return System.getSecurityManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static long currentTimeMillis() &#123;</span><br><span class="line">        return System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) &#123;</span><br><span class="line">        System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int identityHashCode(Object x) &#123;</span><br><span class="line">        return System.identityHashCode(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面所有的方法都与java.lang.System的名称一样</span><br><span class="line">    &#x2F;&#x2F; 实现都是字节转调System的对应方法</span><br><span class="line">    &#x2F;&#x2F; 因版面原因，省略了其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JavaclassExecuter"><a href="#JavaclassExecuter" class="headerlink" title="JavaclassExecuter"></a>JavaclassExecuter</h4><p>我们来看看最后一个类JavaclassExecuter，它是提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。JavaclassExecuter只有一个execute()方法，用输入的符合Class文件格式的byte[]数组替换掉java.lang.System的符号引用后，使用HotSwapClassLoader加载生成一个Class对象，由于每次执行execute()方法都会生成一个新的类加载器实例，因此同一个类可以实现重复加载。然后反射调用这个Class对象的main()方法，如果期间出现任何异常，将异常信息打印到HackSystem.out中，最后把缓冲区中的信息作为方法的结果来返回。JavaclassExecuter的实现代码<br>如代码清单9-7所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Javaclass执行工具</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaclassExecuter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行外部传过来的代表一个Java类的Byte数组&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类</span></span><br><span class="line"><span class="comment">     * 执行方法为该类的static main(String[] args)方法，输出结果为该类向System.out/err输出的信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classByte 代表一个Java类的Byte数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">execute</span><span class="params">(<span class="keyword">byte</span>[] classByte)</span> </span>&#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = <span class="keyword">new</span> ClassModifier(classByte);</span><br><span class="line">        <span class="keyword">byte</span>[] modiBytes = cm.modifyUTF8Constant(<span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;org/fenixsoft/classloading/execute/HackSystem&quot;</span>);</span><br><span class="line">        HotSwapClassLoader loader = <span class="keyword">new</span> HotSwapClassLoader();</span><br><span class="line">        Class clazz = loader.loadByte(modiBytes);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = clazz.getMethod(<span class="string">&quot;main&quot;</span>, <span class="keyword">new</span> Class[]&#123;String[].class&#125;);</span><br><span class="line">            method.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> String[]&#123;<span class="keyword">null</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="验证（TODO）"><a href="#验证（TODO）" class="headerlink" title="验证（TODO）"></a>验证（TODO）</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/" class="post-title-link" itemprop="url">深入理解jvm-12-动态类型语言支持</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-24 16:00:57" itemprop="dateCreated datePublished" datetime="2021-01-24T16:00:57+08:00">2021-01-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-12-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h1><p>在介绍Java虚拟机的动态类型语言支持之前，</p>
<ul>
<li>我们要先弄明白动态类型语言是什么？</li>
<li>它与Java语言、Java虚拟机有什么关系？</li>
</ul>
<p>了解Java虚拟机提供动态类型语言支持的技术背景，对理解这个语言特性是非常有必要的。</p>
<h2 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h2><ul>
<li><p>定义： 动态类型语言的关键特征是 它的<strong>类型检查的主体是在运行期而不是 编译期进行的</strong>，</p>
</li>
<li><p>满足这个特征的语言有很多，常用的包括： APL、Clojure、Erlang、Groovy、JavaScript、Lisp、Lua、PHP、Prolog、Python、Ruby、Smalltalk、Tcl，等等</p>
</li>
<li><p>那相对地，<strong>在编译期就进行类型检查过程的语言</strong>，譬如 C++ 和Java等就是最常用的<strong>静态类型语言</strong> </p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	int[][][] array = new int[1][0][-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这段Java代码能够正常编译，但运行的时候会出现NegativeArraySizeException异常。在《Java虚拟机规范》中明确规定了NegativeArraySizeException是一个运行时异常（Runtime Exception），通俗一点说，<strong>运行时异常就是指只要代码不执行到这一行就不会出现问题</strong>。</li>
<li>与运行时异常相对应的概念是<strong>连接时</strong>（<strong>类加载阶段的验证、准备和解析 称为连接阶</strong>段）<strong>异常</strong>，例如很常见的NoClassDefFoundError便属于连接时异常，即使导致连接时异常的代码放在一条根本无法被执行到的路径分支上，类加载时（第7章解释过Java的连接过程不在编译阶段，而在类加载阶段）也照样会抛出异常。</li>
</ul>
<p>不过在C语言中，语义相同的代码就会在编译期就直接出错，而不是等到运行时才出现异常：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main(void) &#123;</span><br><span class="line">	int i[1][0][-1]; // GCC拒绝编译，报“size of array is negative”</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此看来，一门语言的哪一种检查行为 要在运行期进行，哪一种检查要在编译期进行并没有什么必然的因果逻辑关系，关键在于语言规范中人为设立的约定。</p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>虽然正在阅读本书的每一位读者都能看懂这行代码要做什么，但对于计算机来讲，这一行“没头没尾”的代码是无法执行的，它需要一个具体的上下文中（譬如程序语言是什么、obj是什么类型）才有讨论的意义。</p>
<ul>
<li>现在先假设这行代码是在<strong>Java语言中</strong>，并且变量obj的静态类型为java.io.PrintStream，那变量obj的实际类型就必须是PrintStream的子类（实现了PrintStream接口的类）才是合法的。否则，哪怕obj属于一个确实包含有println(String)方法相同签名方法的类型，但只要它与PrintStream接口没有继承关系，代码依然不可能运行——因为**<em>类型检查不合法**</em></li>
<li>但是相同的代码在<strong>ECMAScript（JavaScript</strong>）中情况则不一样，无论obj具体是何种类型，无论其继承关系如何，只要这种类型的方法定义中确实包含有println(String)方法，能够找到相同签名的方法，调用便可成功。</li>
<li>产生这种差别产生的根本原因是Java语言在编译期间却已将println(String)方法完整的符号引用（本例中为一项CONSTANT_InterfaceMethodref_info常量）生成出来，并作为方法调用指令的参数存储到Class文件中，</li>
<li>例如下面这个样子：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual <span class="comment">#4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br></pre></td></tr></table></figure>

<ol>
<li>这个符号引用包含了该方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息，通过这个符号引用，Java虚拟机就可以翻译出该方法的直接引用。</li>
<li>而ECMAScript等动态类型语言与Java有一个核心的差异就是变量obj本身并没有类型，<strong>变量obj的值才具有类型</strong>，</li>
<li>所以编译器在编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型（即<strong>方法接收者不固定</strong>）。</li>
<li><strong><em>“变量无类型而变量值才有类型”这个特点也是动态类型语言的一个核心特征。</em></strong></li>
</ol>
<h3 id="动态类型对比静态类型语言的优缺点："><a href="#动态类型对比静态类型语言的优缺点：" class="headerlink" title="动态类型对比静态类型语言的优缺点："></a>动态类型对比静态类型语言的优缺点：</h3><p>了解了动态类型和静态类型语言的区别后，也许读者的下一个问题就是动态、静态类型语言两者谁更好，或者谁更加先进呢？这种比较不会有确切答案，它们都有自己的优点，选择哪种语言是需要权衡的事情。</p>
<ul>
<li><p>静态类型语言能够<strong>在编译期确定变量类型</strong>，最显著的好处是<strong>编译器可以提供全面严谨的类型检查</strong>，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于<strong>稳定性</strong>及让项目容易达到更大的规模。</p>
</li>
<li><p>而动态类型语言在运行期才确定类型，这可以为开发人员提供极大的<strong>灵活性</strong>，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很<strong>清晰简洁</strong>，清晰简洁通常也就意味着<strong>开发效率的提升</strong>。</p>
</li>
<li><p>ps： <strong>动态类型语言与动态语言、弱类型语言并不是一个概念，需要区别对待。</strong></p>
</li>
</ul>
<h2 id="Java与动态类型"><a href="#Java与动态类型" class="headerlink" title="Java与动态类型"></a>Java与动态类型</h2><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ol>
<li>Java语言、Java虚拟机与 动态类型语言之间有什么关系。</li>
</ol>
<ul>
<li><p>Java虚拟机毫无疑问是Java语言的运行平台，但它的使命并不限于此。</p>
</li>
<li><p>目前确实已经有许多动态类型语言运行于Java虚拟机之上了，如Clojure、Groovy、Jython和JRuby等，能够在同一个虚拟机之上可以实现静态类型语言的严谨与动态类型语言的灵活，这的确是一件很美妙的事情。</p>
</li>
<li><p>但遗憾的是Java虚拟机层面对动态类型语言的支持一直都还有所欠缺，主要表现在方法调用方面：</p>
<ul>
<li>JDK 7以前的字节码指令集中，4条方法调用指令（invokevirtual、invokespecial、invokestatic、invokeinterface）的第一个参数都是<strong>被调用的方法的符号引用</strong>（CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量）</li>
<li>前面已经提到过，方法的符号引用在编译时产生，而<strong>动态类型语言只有在运行期才能确定方法的接收者</strong>。这样，在Java虚拟机上实现的动态类型语言就不得不使用“曲线救国”的方式（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现</li>
<li>但这样势必会<strong>让动态类型语言实现的复杂度增加</strong>，也会带来额外的性能和内存开销。</li>
<li>内存开销是很显而易见的，方法调用产生的那一大堆的动态类就摆在那里。</li>
<li>而其中最严重的性能瓶颈是在于动态类型方法调用时，由于<strong>无法确定调用对象的静态类型</strong>，而导致的<strong>方法内联无法有效进行</strong>。</li>
<li>尽管也可以想一些办法（譬如调用点缓存）尽量缓解支持动态语言而导致的性能下降，但这种改善毕竟不是本质的</li>
</ul>
</li>
</ul>
<p>譬如有类似一下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arrays = &#123;<span class="string">&quot;abc&quot;</span>, new ObjectX(), 123, Dog, Cat, Car..&#125;</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> arrays)&#123;</span><br><span class="line">	item.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JVM动态字节码指令背景"><a href="#JVM动态字节码指令背景" class="headerlink" title="JVM动态字节码指令背景"></a>JVM动态字节码指令背景</h3><ul>
<li>在动态类型语言下这样的代码是没有问题，但由于在运行时arrays中的元素可以是任意类型，即使它们的类型中都有sayHello()方法，也肯定无法在编译优化的时候就确定具体sayHello()的代码在哪里，编译器只能不停编译它所遇见的每一个sayHello()方法，并缓存起来供执行时选择、调用和<strong>内联，</strong></li>
<li>如果arrays数组中不同类型的对象很多，就势必会对内联缓存产生很大的压力，缓存的大小总是有限的，类型信息的不确定性导致了缓存内容不断被失效和更新，先前优化过的方法也可能被不断替换而无法重复使用。</li>
<li>所以这种<strong>动态类型方法调用的底层问题</strong>终归是<strong>应当在Java虚拟机层次上去解决才最合适</strong>。</li>
<li>因此，在Java虚拟机层面上提供动态类型的直接支持就成为Java平台发展必须解决的问题，</li>
<li>这便是JDK 7时JSR-292提案中<strong>invokedynamic指令</strong>以及 <strong>java.lang.invoke</strong> 包出现的技术背景。</li>
</ul>
<h2 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a>java.lang.invoke包</h2><h3 id="方法句柄："><a href="#方法句柄：" class="headerlink" title="方法句柄："></a>方法句柄：</h3><p>JDK 7时新加入的java.lang.invoke包[1]是JSR 292的一个重要组成部分，这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，提供一种新的动态确定目标方法的机制，称为“方法句柄”（Method Handle）。</p>
<p>不妨把方法句柄与C/C++ 中的函数指针（Function Pointer），或者C# 里面的委派（Delegate）互相类比一下来理解。举个例子，，如果我们实现一个带谓词（谓词就是外部传入的排序时比较大小的动作）的排序函数，在C/C++ 中的常用做法时把谓词定义为函数，用函数指针来把谓词传递到排序方法，像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void sort(int list[], const int size, int (*compare)(int, int))</span><br></pre></td></tr></table></figure>

<p>但在Java语言中做不到这一点，没有办法单独把一个函数作为参数进行传递，普遍的做法是  涉及一个带有compare（）方法的Comparetor 接口，以实现这个接口的对象作为参数，例如 Java类库中的Collections：： sort 方法就是这样定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list,Comparator c)</span></span></span><br></pre></td></tr></table></figure>

<p>不过，在拥有方法句柄之后，Java 语言也可以拥有类似于 函数指针或者委托的方法别名这样的工具了，</p>
<p>以下代码演示了方法句柄的基本用法，无论obj 是何种类型（临时定义的ClassA 或者是实现PrintStream接口的实现类 System.out），都可以正确的调用到println（）方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JSR 292 MethodHandle基础用法演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">// 无论obj最终是哪个实现类，下面这句都能正确调用到println方法。</span></span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">&quot;icyfenix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object reveiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// MethodType：代表“方法类型”，包含了方法的返回值（methodType()的第一个参数）和具体参数（methodType()第二个及以后的参数）。</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</span><br><span class="line">        <span class="comment">// lookup()方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄。</span></span><br><span class="line">        <span class="comment">// 因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即是this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情。</span></span><br><span class="line">        <span class="keyword">return</span> lookup().findVirtual(reveiver.getClass(), <span class="string">&quot;println&quot;</span>, mt).bindTo(reveiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法getPrintlnMH()中实际上是模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个由用户设计的Java方法来实现。</p>
<p>而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。以此为基础，有了MethodHandle就可以写出类似于C/C++那样的函数声明了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, MethodHandle compare)</span></span></span><br></pre></td></tr></table></figure>

<p>从上面的例子看来，使用MethodHandle并没有多少困难，不过看完它的用法之后，读者大概就会产生疑问，相同的事情，用反射不是早就可以实现了吗？</p>
<p>确实，仅站在Java语言的角度看，MethodHandle在使用方法和效果上与Reflection有众多相似之处。不过，它们也有以下这些区别：</p>
<ol>
<li>Reflection和MethodHandle机制本质上都是在模拟方法调用，但是<strong>Reflection是在模拟Java代码层次的方法调用</strong>，而<strong>MethodHandle是在模拟字节码层次的方法调用</strong>。在MethodHandles.Lookup上的3个方法findStatic()、findVirtual()、findSpecial()正是为了对应于invokestatic、invokevirtual（以及<br>invokeinterface）和invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。</li>
<li>Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的java.lang.invoke.MethodHandle对象所包含的信息来得多。前者是<strong>方法在Java端的全面映像，包含了方法的签名、描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等的运行期信息</strong>。而后者仅包含<strong>执行该方法的相关信息</strong>。用开发人员通俗的话来讲，<strong>Reflection是重量级，而MethodHandle是轻量级。</strong></li>
<li>由于MethodHandle是对字节码的方法指令调用的模拟，那理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现还在继续完善中），而通过<strong>反射去调用方法则几乎不可能直接去实施各类调用点优化措施</strong>。</li>
<li>MethodHandle与Reflection除了上面列举的区别外，最关键的一点还在于去掉前面讨论施加的前提“仅站在Java语言的角度看”之后：<strong>Reflection API的设计目标是只为Java语言服务的</strong>，而<strong>MethodHandle则设计为可服务于所有Java虚拟机之上的语言，其中也包括了Java语言而已</strong>，而且Java在这里并不是主角。</li>
</ol>
<h2 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h2><p>了JDK 7为了更好地支持动态类型语言，引入了第五条方法调用的字节码指令invokedynamic，</p>
<ul>
<li>某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke<em>”指令方法（**</em>invokevirtual<strong>、</strong>invokespecial<strong>、**<em>invokestatic</em></strong>、**<em>invokeinterface**</em>））分派规则完全固化在虚拟机之中的问题，把<strong>如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中</strong>，让用户（广义的用户，包含其他程序语言的设计者）有更高的自由度。</li>
<li>而且，它们两者的思路也是可类比的，都是为了达成同一个目的，只是一个用上层代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。因此，如果前面MethodHandle的例子看懂了，相信理解invokedynamic指令并不困难。</li>
</ul>
<ul>
<li>每一处含有invokedynamic指令的位置都被称作“<strong>动态调用点（Dynamically-Computed Call Site）</strong>”，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是<strong>变为JDK 7时新加入的CONSTANT_InvokeDynamic_info常量</strong>，从这个新常量中可以得到3项信息：<strong>引导方法</strong><br><strong>（Bootstrap Method，该方法存放在新增的BootstrapMethods属性中）、方法类型（MethodType）和名称。</strong></li>
<li>引导方法是有固定的参数，并且返回值规定是java.lang.invoke.CallSite对象，这个对象代表了真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用到要执行的目标方法上</li>
</ul>
<p>代码清单8-13所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeDynamicTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        INDY_BootstrapMethod().invokeExact(<span class="string">&quot;icyfenix&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello String:&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">BootstrapMethod</span><span class="params">(MethodHandles.Lookup lookup, String name, MethodType mt)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(lookup.findStatic(InvokeDynamicTest.class, name, mt));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodType <span class="title">MT_BootstrapMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MethodType</span><br><span class="line">                .fromMethodDescriptorString(</span><br><span class="line">                        <span class="string">&quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;&quot;</span>,</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">MH_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookup().findStatic(InvokeDynamicTest.class, <span class="string">&quot;BootstrapMethod&quot;</span>, MT_BootstrapMethod());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">INDY_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        CallSite cs = (CallSite) MH_BootstrapMethod().invokeWithArguments(lookup(), <span class="string">&quot;testMethod&quot;</span>,</span><br><span class="line">                MethodType.fromMethodDescriptorString(<span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> cs.dynamicInvoker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>前文提到过，由于**<em>invokedynamic**</em>指令面向的主要服务对象并非Java语言，而是<strong>其他Java虚拟机之上的其他动态类型语言</strong>，因此，光靠Java语言的<br>编译器Javac的话，在JDK 7时甚至还完全没有办法生成带有invokedynamic指令的字节码（曾经有一个java.dyn.InvokeDynamic的语法糖可以实现，但后来被取消了），</p>
</li>
<li><p>而到JDK 8引入了Lambda表达式和接口默认方法后，Java语言才算享受到了一点invokedynamic指令的好处，但用Lambda来解释invokedynamic指令运作就比较别扭，也无法与前面MethodHandle的例子对应类比，</p>
</li>
<li><p>所以笔者采用一些变通的办法：John Rose（JSR 292的负责人，以前Da Vinci Machine Project的Leader）编写过一个把程序的字节码转换为使用invokedynamic的简单工具<strong>INDY</strong>[1]来完成这件事，我们要使用这个工具来产生最终需要的字节码，</p>
</li>
<li><p>因此代码清单8-13中的方法名称不能随意改动，更不能把几个方法合并到一起写，因为它们是要被INDY工具读取的</p>
</li>
<li><p>把上面的代码编译，再使用INDY转换后重新生成的字节码如代码清单8-14所示,使用javap输出</p>
</li>
</ul>
<p>代码清单8-14　InvokeDynamic指令演示（2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    #121 = NameAndType #33:#30 // testMethod:(Ljava/lang/String;)V</span><br><span class="line">    #123 = InvokeDynamic #0:#121 // #0:testMethod:(Ljava/lang/String;)V</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span> <span class="keyword">throws</span> java.lang.Throwable</span>;</span><br><span class="line">	Code:</span><br><span class="line">		stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">            0: ldc #23 // String abc</span><br><span class="line">            2: invokedynamic #123, 0 // InvokeDynamic #0:testMethod: (Ljava/lang/String;)V   </span><br><span class="line">            <span class="number">7</span>: nop</span><br><span class="line">            <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.invoke.<span class="function">CallSite <span class="title">BootstrapMethod</span><span class="params">(java.lang.invoke.Method Handles$Lookup, java.lang.String, </span></span></span><br><span class="line"><span class="function"><span class="params">	Code:</span></span></span><br><span class="line"><span class="function"><span class="params">		stack=<span class="number">6</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">0</span>: new #<span class="number">63</span> // class java/lang/invoke/ConstantCallSite</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">3</span>: dup</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">4</span>: aload_0</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">5</span>: ldc #<span class="number">1</span> // class org/fenixsoft/InvokeDynamicTest</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">7</span>: aload_1</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">8</span>: aload_2</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">9</span>: invokevirtual #<span class="number">65</span> // Method java/lang/invoke/MethodHandles$ Lookup.findStatic:(Ljava/lang/Class;</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="number">12</span>: invokespecial #<span class="number">71</span> // Method java/lang/invoke/ConstantCallSite. <span class="string">&quot;&lt;init&gt;&quot;</span>:(Ljava/lang/invoke/MethodHandle;)</span></span></span><br><span class="line"><span class="function">            15: areturn</span></span><br></pre></td></tr></table></figure>

<p>从main()方法的字节码中可见，原本的方法调用指令已经被替换为invokedynamic了，它的参数为第123项常量（第二个值为0的参数在虚拟机中不会直接用到，这与invokeinterface指令那个的值为0的参数一样是占位用的，目的都是为了给常量池缓存留出足够的空间）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2: invokedynamic #123, 0 // InvokeDynamic #0:testMethod:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>

<p>从常量池中可见，第123项常量显示“#123=InvokeDynamic#0：</p>
<ul>
<li>#121”说明它是一项CONSTANT_InvokeDynamic_info类型常量，常量值中前面“#0”代表引导方法取Bootstrap Methods属性表的第0项（javap没有列出属性表的具体内容，不过示例中仅有一个引导方法，即BootstrapMethod()），</li>
<li>而后面的“#121”代表引用第121项类型为CONSTANT_NameAndType_info的常量，从这个常量中可以获取到方法名称和描述符，即后面输出的“testMethod：<br>(Ljava/lang/String；)V”。</li>
</ul>
<p>再看BootstrapMethod()，这个方法在Java源码中并不存在，是由INDY产生的，但是它的字节码很容易读懂，</p>
<ul>
<li>所有逻辑都是调用MethodHandles$Lookup的findStatic()方法，产生testMethod()方法的MethodHandle，</li>
<li>然后用它创建一个ConstantCallSite对象。</li>
<li>最后，这个对象返回给invokedynamic指令实现对testMethod()方法的调用，invokedynamic指令的调用过程到此就宣告完成了。</li>
</ul>
<h2 id="实战：掌控方法分派规则"><a href="#实战：掌控方法分派规则" class="headerlink" title="实战：掌控方法分派规则"></a>实战：掌控方法分派规则</h2><p><strong>invokedynamic</strong>指令与此前4条传统的“invoke*”指令的最大区别就是它的<strong>分派逻辑不是由虚拟机决定的</strong>，而是<strong>由程序员决定</strong>。</p>
<p>在介绍Java虚拟机动态语言支持的最后一节中，笔者希望通过一个简单例子（如代码清单8-15所示），帮助读者理解程序员可以掌控方法分派规则之后，我们能做什么以前无法做到的事情。</p>
<p>代码清单8-15　方法调用问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 请读者在这里填入适当的代码（不能修改其他地方的代码）</span></span><br><span class="line">			<span class="comment">// 实现调用祖父类的thinking()方法，打印&quot;i am grandfather&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_1().<span class="function">new <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java程序中，可以通过“super”关键字很方便地调用到父类中的方法，但如果要访问祖类的方法呢？不妨自己思考一下，在JDK 7之前有没有办法解决这<br>个问题。</p>
<p>在拥有invokedynamic和java.lang.invoke包之前，使用纯粹的Java语言很难处理这个问题（使用ASM等字节码工具直接生成字节码当然还是可以处理的，但这已经是在字节码而不是Java语言层面来解决问题了），原因是在Son类的thinking()方法中根本无法获取到一个实际类型是GrandFather的对象引用，而invokevirtual指令的分派逻辑是固定的，只能按照方法接收者的实际类型进行分派，这个逻辑完全固化在虚拟机中，程序员无法改变。</p>
<p>如果是JDK 7 Update 9之前，使用代码清单8-16中的程序就可以直接解决该问题。</p>
<p>代码清单8-16　使用MethodHandle来解决问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">                MethodHandle mh = lookup().findSpecial(GrandFather.class,<span class="string">&quot;thinking&quot;</span>, mt, getClass());</span><br><span class="line">                mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_1().n<span class="function">ew <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用<strong>JDK 7 Update 9之前</strong>的HotSpot虚拟机运行，会得到如下运行结果： i am grandfather</p>
<p>ps:  <strong>我试了一下用jdk 9</strong>，运行结果是： i am father，因为: </p>
<ul>
<li>这个逻辑在JDK 7 Update 9之后被视作一个潜在的安全性缺陷修正了，</li>
<li>原因是<strong>必须保证findSpecial()查找方法版本时受到的访问约束</strong>（譬如对访问控制的限制、对参数类型的限制）<strong>应与使用invokespecial指令一样</strong>，两者必须保持精确对等，包括在上面的场景中它只能访问到其直接父类中的方法版本。</li>
<li>所以在JDK 7 Update 10修正之后，运行以上代码只能得到如下结果 : i am father</li>
</ul>
<p>那在新版本的JDK中，上面的问题是否能够得到解决呢？</p>
<ul>
<li>答案是可以的，如果读者去查看MethodHandles.Lookup类的代码，将会发现需要进行哪些访问保护，在该API实现时是预留了后门的。</li>
<li>访问保护是通过一个<strong>allowedModes</strong>的参数来控制，而且这个参数可以被设置成“TRUSTED”来绕开所有的保护措施。尽管这个参数只是在Java类库本身使用，没有开放给外部设置，但我们<strong>通过反射可以轻易打破这种限制</strong>。</li>
<li>由此，我们可以把代码清单8-16中子类的thinking()方法修改为如下所示的代码来解决问题：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandles;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandFatherTestCase_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am grandfather&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFatherTestCase_2</span>.<span class="title">GrandFather</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i am father&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">GrandFatherTestCase_2</span>.<span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class);</span><br><span class="line">                Field lookupImpl = MethodHandles.Lookup.class.getDeclaredField(<span class="string">&quot;IMPL_LOOKUP&quot;</span>);</span><br><span class="line">                lookupImpl.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                MethodHandle mh = ((MethodHandles.Lookup) lookupImpl.get(<span class="keyword">null</span>)).findSpecial(GrandFather.class,<span class="string">&quot;thinking&quot;</span>, mt, GrandFather.class);</span><br><span class="line">                mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> GrandFatherTestCase_2().<span class="function">new <span class="title">Son</span><span class="params">()</span>).<span class="title">thinking</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行以上代码，在目前所有JDK版本中均可获得如下结果:   i am grandfather</p>
<h1 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h1><p>我们来探讨虚拟机是如何执行方法里面的字节码指令的。许多Java虚拟机的执行引擎在执行Java代码的时候都有<strong>解释执行（通过解释器执行）</strong>和 <strong>编译执行（通过即时编译器产生本地代码执行）</strong>两种选择，在本节中，我们将会分析在概念模型下的Java虚拟机解释执行字节码时，其执行引擎是如何工作的。</p>
<p>笔者在本章多次强调了“概念模型”，是因为实际的虚拟机实现，譬如HotSpot的模板解释器工作的时候，并不是按照下文中的动作一板一眼地进行机械式计算，而是动态产生每条字节码对应的汇编代码来运行，这与概念模型中执行过程的差异很大，但是结果却能保证是一致的。</p>
<h2 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h2><ul>
<li>Java语言经常被人们定位为“解释执行”的语言，在Java初生的JDK 1.0时代，这种定义还算是比较准确的，</li>
<li>但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事。</li>
<li>再后来，Java也发展出可以直接生成本地代码的编译器（如Jaotc、GCJ[1]，Excelsior JET），而C/C++语言也出现了通过解释器执行的版本（如<br>CINT[2]），</li>
<li>这时候再笼统地说“解释执行”，对于整个Java语言来说就成了几乎是没有意义的概念，</li>
<li>只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较合理确切。</li>
</ul>
<ul>
<li>无论是解释还是编译，也无论是物理机还是虚拟机，对于应用程序，机器都不可能如人那样阅读、理解，然后获得执行能力。</li>
<li>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过图8-4中的各个步骤。</li>
<li>如果读者对大学编译原理的相关课程还有印象的话，很容易就会发现图8-4中下面的那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程；而中间的那条分支，自然就是解释执行的过程。</li>
</ul>
<p><img src="/uploads/jvm/11diapatch/compile.png"></p>
<p>如今，基于物理机、Java虚拟机，或者是非Java的其他高级语言虚拟机（HLLVM）的代码执行过程，大体上都会遵循这种符合现代经典编译原理的思路，在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树（Abstract Syntax Tree，AST）。</p>
<ul>
<li>对于一门具体语言的实现来说，词法、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。</li>
<li>也可以选择把其中一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java语言。又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的JavaScript执行引擎。</li>
</ul>
<p>在Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p>
<h2 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h2><ul>
<li><p>Javac编译器输出的字节码指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作</p>
</li>
<li><p>与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，如果说得更通俗一些就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作</p>
</li>
</ul>
<h3 id="基于栈的指令集与基于寄存器的指令集区别："><a href="#基于栈的指令集与基于寄存器的指令集区别：" class="headerlink" title="基于栈的指令集与基于寄存器的指令集区别："></a>基于栈的指令集与基于寄存器的指令集区别：</h3><p>举个最简单的例子，分别使用这两种指令集去计算“1+1”的结果</p>
<h4 id="基于栈的指令集："><a href="#基于栈的指令集：" class="headerlink" title="基于栈的指令集："></a>基于栈的指令集：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>

<p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个变量槽中。这种指令流中的指令通常都是不带参数的，使用操作数栈中的数据作为指令的运算输入，指令的运算结果也存储在操作数栈之中。</p>
<h4 id="基于寄存器的指令集"><a href="#基于寄存器的指令集" class="headerlink" title="基于寄存器的指令集:"></a>基于寄存器的指令集:</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">add eax, 1</span><br></pre></td></tr></table></figure>

<p>mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。这种二地址指令是x86指令集中的主流，每个指令都包含两个单独的输入参数，依赖于寄存器来访问和存储数据。</p>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul>
<li><p>基于栈的指令集主要优点是可移植，</p>
</li>
<li><p>因为寄存器由硬件直接提供[2]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束，</p>
</li>
<li><p>栈架构的指令集还有一些其他的优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编<br>译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）等。</p>
</li>
<li><p>栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些，所有主流物理机的指令集都是寄存器架构[3]也从侧面印证了这点</p>
</li>
<li><p>在解释执行时，栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。更重要的是栈实现在内存中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。因此由于指令数量和内存访问的原因，导致了栈架构指令集的执行速度会相对慢上一点。</p>
</li>
</ul>
<h2 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="　基于栈的解释器执行过程"></a>　基于栈的解释器执行过程</h2><p>代码清单8-17　一段简单的算术代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>;</span><br><span class="line">	Code:</span><br><span class="line">        Stack=<span class="number">2</span>, Locals=<span class="number">4</span>, Args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: bipush <span class="number">100</span></span><br><span class="line">        <span class="number">2</span>: istore_1</span><br><span class="line">        <span class="number">3</span>: sipush <span class="number">200</span></span><br><span class="line">        <span class="number">6</span>: istore_2</span><br><span class="line">        <span class="number">7</span>: sipush <span class="number">300</span></span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: iload_1</span><br><span class="line">        <span class="number">12</span>: iload_2</span><br><span class="line">        <span class="number">13</span>: iadd</span><br><span class="line">        <span class="number">14</span>: iload_3</span><br><span class="line">        <span class="number">15</span>: imul</span><br><span class="line">        <span class="number">16</span>: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javap提示这段代码需要<strong>深度为2的操作数栈</strong>和<strong>4个变量槽</strong>的局部变量空间，笔者就根据这些信息画了图8-5至图8-11共7张图片，来描述代码清单8-13执行过程中的代码、操作数栈和局部变量表的变化情况。</p>
<p><img src="/uploads/jvm/12bytecodeEngineer/01bipush.png"></p>
<ol>
<li>首先，执行偏移地址为0的指令，Bipush指令的作用是将单字节的整型常量值（-128～127）推入操作数栈顶，跟随有一个参数，指明推送的常量值，这里是100。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/02istore.png"></p>
<ol start="2">
<li>执行偏移地址为2的指令，<strong>istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量槽中</strong>。后续4条指令（直到偏移为11的指令为止）都是做一样的事情，也就是在对应代码中把变量a、b、c赋值为100、200、300。这4条指令的图示略过。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/03iload.png"></p>
<ol start="3">
<li>执行偏移地址为11的指令，<strong>iload_1指令的作用是将局部变量表第1个变量槽中的整型值复制到操作数栈顶</strong>。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/04iload2.png"></p>
<ol start="4">
<li>执行偏移地址为12的指令，iload_2指令的执行过程与iload_1类似，<strong>把第2个变量槽的整型值入栈</strong>。<br>画出这个指令的图示主要是为了显示下一条iadd指令执行前的堆栈状况。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/05iadd.png"></p>
<ol start="5">
<li>执行偏移地址为13的指令，<strong>iadd指令的作用是将操作数栈中头两个栈顶元素出栈，做整型加法，</strong><br><strong>然后把结果重新入栈。</strong>在iadd指令执行完毕后，栈中原有的100和200被出栈，<strong>它们的和300被重新入栈</strong>。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/06iload3.png"></p>
<ol start="6">
<li>执行偏移地址为14的指令，iload_3指令<strong>把存放在第3个局部变量槽中的300入栈到操作数栈中</strong>。这时操作数栈为两个整数300。下一条指令imul是将操作数栈中头两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，与iadd完全类似，所以笔者省略图示。</li>
</ol>
<p><img src="/uploads/jvm/12bytecodeEngineer/07ireturn.png"></p>
<ol start="7">
<li>执行偏移地址为16的指令，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶<br>的整型值返回给该方法的调用者。到此为止，这段方法执行结束。</li>
</ol>
<p>再次强调上面的执行过程仅仅是一种<strong>概念模型</strong>，虚拟机最终会对执行过程做出<strong>一系列优化</strong>来提高性能，实际的运作过程并不会完全符合概念模型的描述。</p>
<p>更确切地说，实际情况会和上面描述的概念模型差距非常大，差距产生的根本原因是<strong>虚拟机中解析器和即时编译器都会对输入的字节码进行优化</strong>，即使解释器中也不是按照字节码指令去逐条执行的。例如在HotSpot虚拟机中，就有很多以“fast_”开头的非标准字节码指令用于合并、替换输入的字节码以提升解释执行性能，即时编译器的优化手段则更是花样繁多</p>
<p>我们从这段程序的执行中也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径，符合我们在前面分析的特点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" class="post-title-link" itemprop="url">深入理解jvm-11-虚拟机字节码执行引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-19 23:42:20" itemprop="dateCreated datePublished" datetime="2021-01-19T23:42:20+08:00">2021-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-11-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>31k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>28 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>执行引擎是Java虚拟机核心的组成部分之一。</p>
</li>
<li><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，</p>
</li>
<li><p>其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，</p>
</li>
<li><p>而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</p>
</li>
</ul>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><h3 id="栈帧（Stack-Frame）"><a href="#栈帧（Stack-Frame）" class="headerlink" title="栈帧（Stack Frame）"></a>栈帧（Stack Frame）</h3><ul>
<li><p>Java虚拟机以方法作为最基本的执行单元，而 <strong>栈帧</strong> （Stack Frame）则是用于java虚拟机进行方法调用和方法执行背后的数据结构， 它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p>
</li>
<li><p>栈帧存储了方法的<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>和<strong>方法返回地址</strong> 等信息，</p>
</li>
<li><p>每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从<strong>入栈到出栈</strong>的过程</p>
</li>
<li><p>在编译Java程序源码的时候，栈帧需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。</p>
</li>
<li><p>一个栈帧需要分配多少内存，并不会收到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式</p>
</li>
</ul>
<ul>
<li>一个线程中的方法调用链 可能会很长，以java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。</li>
<li>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame）,与这个栈帧关联的方法 被称为 “当前方法”（Current Method）。</li>
<li>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，</li>
</ul>
<h3 id="栈帧的概念结构"><a href="#栈帧的概念结构" class="headerlink" title="栈帧的概念结构"></a>栈帧的概念结构</h3><p><img src="/uploads/jvm/10StackFrame/01-StackFrameConstruct.png"></p>
<h4 id="局部变量表（Local-Variables-Table）"><a href="#局部变量表（Local-Variables-Table）" class="headerlink" title="局部变量表（Local Variables Table）"></a>局部变量表（Local Variables Table）</h4><ul>
<li><p>局部变量表 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量表。 </p>
</li>
<li><p>在Java程序被编译成Class文件时，就在方法的Code属性中的<strong>max_locals</strong> 数据项中确定了该方法所需分配的局部变量表的最大容量</p>
</li>
<li><p>局部变量表的容量以 变量槽（Variable slot）为最小单位，</p>
</li>
<li><p>《Java虚拟机规范》被没有明确指出一个变量槽应占用的 内存空间大小，只有向导性的说每个变量槽 Variable Slot 都应该能存放一个  boolean 、 byte、 char、 short、 int、 float、 reference 或看return Address类型的数据</p>
</li>
</ul>
<h5 id="局部变量表中的数据类型"><a href="#局部变量表中的数据类型" class="headerlink" title="局部变量表中的数据类型"></a>局部变量表中的数据类型</h5><ul>
<li>一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference[1]和returnAddress这8种类型。</li>
<li>而第7种reference类型表示对一个对象实例的引用，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则将无法实现《Java语言规范》中定义的语法约定</li>
<li>第8种returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转，但现在也已经全部改为采用异常表来代替了</li>
<li>对于64位的数据类型，Java虚拟机会以 <strong>高位对齐</strong> 的方式为其分配 <strong>两个连续的变量槽空间</strong> 。Java语言中明确的64位的数据类型只有 long 和 double 两种。</li>
<li>这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中允许把一次long和double数据类型读写分割为两次32位读写的做法有些类<br>似。</li>
<li>由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。</li>
</ul>
<ul>
<li><p>Java虚拟机通过<strong>索引定位</strong>的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位数据类型的变量，则说明会<strong>同时使用第N和N+1两个变量槽</strong>.</p>
</li>
<li><p>对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机<strong>不允许采用任何方式单独访问其中的某一个</strong>，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。</p>
</li>
<li><p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成<strong>参数值到参数列表</strong>的传递过程，即 <strong>实参到形参</strong>的传递。如果执行的时实例方法（没有被 static 修饰的方法），那局部变量表中的<strong>第0 位索引</strong>的变量槽 默认是 用于传递<strong>方法实例的引用</strong>，在方法中可以通过 关键字“this” 来访问到这个隐含的参数。 其余的参数 则是按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，在根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
</li>
</ul>
<h5 id="局部变量表的重用"><a href="#局部变量表的重用" class="headerlink" title="局部变量表的重用"></a>局部变量表的重用</h5><ul>
<li>为了尽可能的节省栈帧耗用的内存空间，<strong>局部变量表中的变量槽是可以重用</strong>的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体（就是一个方法体中的局部变量可能用到一半就不使用了，比如方法体有10行，而局部变量只在其中的3-4行被使用，那这个局部变量就没有覆盖整个方法体），如果当前字节码PC计数器的值 已经超过了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。</li>
<li>不过这样的设计除了节省栈帧空间外，还会伴随少量的<strong>副作用</strong></li>
<li>例如 在某些情况下变量槽的复用会直接影响到系统的GC 行为，如下如代码所示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M </span></span><br><span class="line"><span class="comment"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseVariableSlot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result: (我这里使用的JDK <span class="number">9</span>)</span><br><span class="line">[<span class="number">0.028</span>s][info][gc] Using G1</span><br><span class="line">[<span class="number">0.142</span>s][info][gc] GC(<span class="number">0</span>) <span class="function">Pause Initial <span class="title">Mark</span> <span class="params">(G1 Humongous Allocation)</span> 2M-&gt;1<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 1.368ms</span></span><br><span class="line"><span class="function">[0.142s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle</span></span><br><span class="line"><span class="function">[0.171s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Remark 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.724ms</span></span><br><span class="line"><span class="function">[0.171s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Cleanup 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.174ms</span></span><br><span class="line"><span class="function">[0.175s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">2</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 3.810ms</span></span><br><span class="line"><span class="function">[0.175s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle 33.128ms</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  </span></span><br></pre></td></tr></table></figure>

<p>代码中可以看到：</p>
<p>向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上“-verbose：gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收掉这64MB的内存。</p>
<p>代码没有回收掉 placeHolder所占的内存说的过去，因为执行system.gc()时，变量 placeholder 还处于作用域之内，虚拟机自然不敢回收掉placeholder 的内存。</p>
<p>我们修改一下代码，改成这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M</span></span><br><span class="line"><span class="comment"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReuseVariableSlot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result： 同上</span><br><span class="line">    [<span class="number">0.026</span>s][info][gc] Using G1</span><br><span class="line">[<span class="number">0.137</span>s][info][gc] GC(<span class="number">0</span>) <span class="function">Pause Initial <span class="title">Mark</span> <span class="params">(G1 Humongous Allocation)</span> 2M-&gt;1<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 1.593ms</span></span><br><span class="line"><span class="function">[0.137s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle</span></span><br><span class="line"><span class="function">[0.162s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Remark 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.727ms</span></span><br><span class="line"><span class="function">[0.165s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">2</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 3.594ms</span></span><br><span class="line"><span class="function">[0.166s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Pause Cleanup 66M-&gt;66<span class="title">M</span><span class="params">(<span class="number">80</span>M)</span> 0.001ms</span></span><br><span class="line"><span class="function">[0.166s][info][gc] <span class="title">GC</span><span class="params">(<span class="number">1</span>)</span> Concurrent Cycle 28.351ms</span></span><br></pre></td></tr></table></figure>

<p>加入了花括号之后，placeholder的作用域被限制在了 花括号之内，从代码逻辑上讲，在执行 system.gc()的时候，placeholder 已经不可能再被访问了，但执行这段程序的时候，发现 64M的内存 还是没有被回收掉，</p>
<p>为什么呢，解释之前我们再修改一下代码,先对这段代码进行第二次修改，在调用System.gc()之前加入一行“int  a=0；”，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM参数：-verbose:gc -Xms80M -Xmx80M -Xmn10M</span><br><span class="line"> * // -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> */</span><br><span class="line">public class ReuseVariableSlot &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            byte[] placeholder = new byte[64 * 1024 * 1024];</span><br><span class="line">        &#125;</span><br><span class="line">         int a = 0;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> result: </span><br><span class="line"> [0.026s][info][gc] Using G1</span><br><span class="line">[0.145s][info][gc] GC(0) Pause Initial Mark (G1 Humongous Allocation) 2M-&gt;1M(80M) 1.527ms</span><br><span class="line">[0.145s][info][gc] GC(1) Concurrent Cycle</span><br><span class="line">[0.170s][info][gc] GC(1) Pause Remark 66M-&gt;66M(80M) 0.789ms</span><br><span class="line">[0.170s][info][gc] GC(1) Pause Cleanup 66M-&gt;66M(80M) 0.351ms</span><br><span class="line">[0.170s][info][gc] GC(1) Concurrent Cycle 25.457ms</span><br><span class="line">[0.174s][info][gc] GC(2) Pause Full (System.gc()) 66M-&gt;1M(80M) 3.362ms </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们发现加上 int a = 0; 之后，发现内存被回收了 （[info][gc] GC(2) Pause Full (System.gc()) 66M-&gt;1M(80M) 3.362ms ）</p>
<h5 id="代码总结："><a href="#代码总结：" class="headerlink" title="代码总结："></a>代码总结：</h5><p>上面的代码 ，<strong>placeholder 能否被回收</strong> 的根本原因是：  </p>
<ul>
<li>局部变量表的变量槽 是否还存有 关于placeholder数组对象的 <strong>引用</strong></li>
<li>第一次修改中（加花括号），代码虽然 已经离开了placeholder的作用域，但在之后，在没有发生过任何对局部变量表的读写 操作，placeholder 原本所占用的变量槽  还没有被其他变量所复用，所以作为 GC ROOTs 一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断。再绝大部分情况下影响很轻微。 但如果遇到 一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用大部分内存但实际已经不会再使用的变量， 手动 将其设置为 null值 （用来代替 int a=0，把变量对应的局部变量槽清空）便不见得是一个绝对无意义的操作 。这是<strong>奇技淫巧</strong> ，并不是很认同。</li>
<li>这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到即时编译器的编译条件）下的“奇技”来使用。Java语言的一本非常著名的书籍《Practical Java》中将把“不使用的对象应手动赋值为null”作为一条推荐的编码规则（笔者并不认同这条规则），但是并没有解释具体原因</li>
<li>这是<strong>奇技淫巧</strong> ，并不是很认同。因为：<ul>
<li>从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法</li>
<li>更关键的是，从执行角度来讲，使用赋null操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的，概念模型与实际执行过程是外部看起来等效，内部看上去则可以完全不同。当虚拟机使用解释器执行时，通常与概念模型还会比较接近，但经过即时编译器施加了各种编译优化措施以后，两者的差异就会非常大，只保证程序执行的结果与概念一致。在实际情况中，即时编译才是虚拟机执行代码的主要方式，赋null值的操作在经过即时编译优化后几乎是一定会被当作无效操作消除掉的，这时候将变量设置为null就是毫无意义的行为。字节码被即时编译为本地代码后，对GC Roots的枚举也与解释执行时期有显著差别，以前面的例子来看，经过第一次修改的代码（第二个方法）在经过即时编译后，System.gc()执行时就可以正确地回收内存，根本无须写成代码（第三个方法）的样子。</li>
</ul>
</li>
</ul>
<h5 id="局部变量表不存在准备阶段"><a href="#局部变量表不存在准备阶段" class="headerlink" title="局部变量表不存在准备阶段"></a>局部变量表不存在准备阶段</h5><ul>
<li><p>局部变量表不像类变量那样存在“准备阶段”，</p>
</li>
<li><p>之前我们在《虚拟机的类加载过程》学过，类的字段变量 有2次赋初始值的过程，  一次是在 准备阶段，赋予系统初始值；另外一次是在 初始化阶段，赋予程序员在代码中定义的初始值。 因此 即使在初始化阶段 程序员没有为类变量赋值也没有关系，类变量仍然具有一个决定的初始值（零值，默认值），不会产生歧义。</p>
</li>
<li><p>但是 局部变量就不一样 了，如果一个局部变量定义了，但没有赋初始值，那它是完全不能使用的。</p>
</li>
<li><p>所以不要认为 Java中任何情况都存在 诸如 整型变量默认为0、布尔型变量默认为 false 等这样的默认值规则。</p>
</li>
<li><p>如果局部变量不赋初始值，编译期在编译期间能检查到并提示出来，ide工具是会报错的。</p>
</li>
<li><p>即使编译能通过或者 通过手动的方式生成字节码，在《虚拟机的类加载过程》的字节码验证阶段，也会被虚拟机发现，从而导致 类加载失败。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a; <span class="comment">//</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result:  编译期报错：  可能尚未初始化变量a</span><br></pre></td></tr></table></figure>



<h3 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h3><ul>
<li><p>操作数栈 （Operand Stack）也常被称为操作栈，它是一个<strong>先入后出</strong> (Last In First Out,LIFO） 栈。 </p>
</li>
<li><p>同局部变量表一样， 操作数栈的最大深度也在编译的时候被写入到 Code 属性的 <strong>max_stacks</strong> 数据项之中。</p>
</li>
<li><p>操作数栈的每一个元素 都可以是包括long 和 double 在内的<strong>任意java数据类型</strong> 。32位 数据类型 所占的栈容量为 1，64 位数据类型所占的栈容量为  2。</p>
</li>
<li><p>javac 编译器的数据流分析工作保证了 在方法执行的任何时候，操作数栈的深度 都不会超过 在 max_stacks 数据项设定的最大值。</p>
</li>
</ul>
<h5 id="方法执行时的操作栈动作"><a href="#方法执行时的操作栈动作" class="headerlink" title="方法执行时的操作栈动作"></a>方法执行时的操作栈动作</h5><ul>
<li><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的。  在方法的执行过程中，会有各种<strong>字节码指令</strong> 往  <strong>操作数栈</strong> 中写入和提取 内容， 也就是出栈和入栈操作。</p>
<p>譬如 在做算术运算的时候 ，通过将运算涉及的操作数栈 压入栈顶后 ，然后 调用运算指令来执行。</p>
</li>
</ul>
<p>又譬如 在调用其他方法的时候 ，通过操作数栈 来进行方法参数的传递。</p>
<p>举个例子， 例如整数加法 的字节码 iadd, 这条指令在运行的时候 ，要求操作数栈中最接近 栈顶的2个元素 已经存入了2个int 型的数值，当执行 iadd这个指令时候，会把这2 个int 值出栈 并相加，然后将 相加的结果重新入栈 。</p>
<h5 id="字节码指令严格匹配操作栈元素数据类型"><a href="#字节码指令严格匹配操作栈元素数据类型" class="headerlink" title="字节码指令严格匹配操作栈元素数据类型"></a>字节码指令严格匹配操作栈元素数据类型</h5><p>操作数栈中元素的数据类型必须 与字节码指令的序列严格匹配，在编译程序代码的时候，编译期必须严格保证这一点，在类校验阶段的数据流分析中还要 再次验证这一点。</p>
<p>例如： iadd指令只能 用于整型数据的加法，该指令在执行时，最接近栈顶的2个元素的数据类型 必须为int 型，不能出现一个long 和一个float 使用iadd指令相加的 情况。</p>
<h5 id="栈帧的优化"><a href="#栈帧的优化" class="headerlink" title="栈帧的优化"></a>栈帧的优化</h5><ul>
<li><p>Java虚拟机的<strong>解释执行引擎</strong> 被称为“<strong>基于栈的执行引擎</strong>”, 里面的栈 就是操作数栈。后续还会对基于栈的代码执行过程进行更详细的讲解。介绍它与更常见的<strong>基于寄存器的执行引擎</strong>有那些差别</p>
</li>
<li><p>在概念 模型中，两个不同栈帧（Stack Frame）作为不同方法的虚拟机栈 元素，是<strong>完全互相独立</strong>的。  但是在大多数虚拟机的实现中，会对这块进行一些<strong>优化处理</strong> ，令2个 不同方法的栈帧出现一部分 <strong>重叠</strong>。让下面的栈帧的部分操作数栈 与 上面栈帧的部分局部变量表 重叠在一起，这样做不仅节约了 一些空间，更重要的是 在进行方法调用的时候 就可以直接共用 一部分数据，无需进行<strong>额外的 参数 复制传递</strong>了 。重叠的过程如下图所示： </p>
</li>
</ul>
<p><img src="/uploads/jvm/10StackFrame/02-StackFrameOverlap.png"></p>
<h3 id="动态连接（Dynamic-Linking）"><a href="#动态连接（Dynamic-Linking）" class="headerlink" title="动态连接（Dynamic Linking）"></a>动态连接（Dynamic Linking）</h3><p>每个栈帧 都包含一个指向<strong>运行时常量池</strong> 中<strong>该栈帧所属方法的引用</strong>，持有这个引用 是为了支持方法调用过程中的<strong>动态连接</strong>。</p>
<p>通过之前文章，我们知道 Class文件 的常量池中存有 大量的符号引用，字节码中的<strong>方法调用指令</strong> 就以 常量池里<strong>指向方法的符号连接</strong> 作为参数。</p>
<ul>
<li>这些符号引用一部分将在 <strong>类加载阶段</strong>或者<strong>第一次使用的时候</strong>就被转化为<strong>直接引用</strong>，这种转化称为  <strong>静态解析</strong></li>
<li>另外一部分将在<strong>每一次运行期间</strong>都<strong>转化 为直接引用</strong>，这部分就称为 <strong>动态连接</strong>。后续后详细讲解</li>
</ul>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有 2种 方式退出这个方法。</p>
<ul>
<li>第一种退出方式是执行引擎遇到任意一个方法<strong>返回的字节码指令</strong>，这时候 可能会有返回值 传递给上层方法调用者 （调用当前方法的方法称为 <strong>主调方法</strong> 或者 “<strong>调用者</strong>”）， 方法是否有返回值 以及返回值的类型 将根据 何种方法返回指令来决定，这种退出方式 称为 “<strong>正常调用完成（Normal Method Invocation Completion）</strong>”</li>
<li>另外一种退出方式 就是方法执行过程中 遇到了异常，并且这个异常没有在方法体内得到妥善处理。  无论是Java虚拟机内部的异常，还是代码中<strong>athrow字指令</strong> 产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式 称为 “**异常调用完成(Abrupt Method Invocation Completion)**”  。一个方法使用异常完成出口的方式退出，是不会给他的上层调用者 提供任何返回值的。</li>
</ul>
<p>无论采用何种退出方式，在方法退出之后，都必须<strong>返回最初方法被调用的位置</strong>，程序才能继续执行。</p>
<p>方法返回时 可能需要在栈帧中 保存一些信息，用来帮助<strong>恢复它的上层主调方法的执行状态</strong> 。 </p>
<p>一般来说，方法正常退出时，<strong>主调方法的PC计数器的值 就可以作为返回地址</strong>，栈帧中很可能 会保存这个计数器值。</p>
<p>而异常退出的时候，返回地址就是 通过异常处理器 来确定的，栈帧中 一般不会保存这部分信息 （主调方法的PC计数器值）</p>
<h5 id="方法退出的过程"><a href="#方法退出的过程" class="headerlink" title="方法退出的过程"></a>方法退出的过程</h5><p>方法退出的过程实际上等同于<strong>把 当前栈帧出栈</strong>，因此退出时可能执行的操作有：</p>
<ul>
<li>恢复上层主调方法的局部变量表和操作数栈，</li>
<li>把返回值（如果有的话） 压入 调用者（主调方法对应的）栈帧的操作数栈中，</li>
<li>调整PC计数器值 以指向方法调用指令后面的 的一条指令等。</li>
</ul>
<p>这些都是 基于概念模型的讨论，只有具体到某一款 java虚拟机实现，会执行哪些操作才能确定下来</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>
<p>在讨论概念时候，一般会把 <strong>动态连接，方法返回地址 与 其他附加信息</strong>全部归为一类，称为<strong>栈帧信息</strong> 。</p>
<h2 id="方法调用详解（TODO）"><a href="#方法调用详解（TODO）" class="headerlink" title="方法调用详解（TODO）"></a>方法调用详解（TODO）</h2><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体执行过程。</p>
<p>在程序执行时，进行方法调用是最普遍最频繁的操作之一，Class文件的编译过程中 不包含传统程序语言编译的连接步骤，一切方法调用在Class文件 里面存储的都是 符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。 这个特性给了Java带来了更强大的动态扩展能力，也使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用的目标方法在Class 文件里面都是一个 常量池的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是:  方法在程序真正执行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。 换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为<strong>解析</strong>（<strong>Resolution</strong>）</p>
<h4 id="编译期可知，运行期不可变"><a href="#编译期可知，运行期不可变" class="headerlink" title="编译期可知，运行期不可变"></a>编译期可知，运行期不可变</h4><p>在Java语言中，符合“编译期可知，运行期不可变”这个要求的方法，主要有 <strong>静态方法</strong> 和<strong>私有方法</strong>两大类，前者与类型直接关联，后者在外部不可访问，这两种方法各自的特点决定了他们都不可能通过继承或 别的方式重写出其他版本，因为它们都适合在类解析阶段进行解析。</p>
<h4 id="方法调用字节码指令"><a href="#方法调用字节码指令" class="headerlink" title="方法调用字节码指令"></a>方法调用字节码指令</h4><p>调用不同类型的方法，字节码指令集里面设计了不同的指令。在Java虚拟机支持 以下5条方法调用字节码指令，分别是：</p>
<ol>
<li>invokestatic ： 用于调用静态方法</li>
<li>invokespecial：  用于调用实例构造器<init>()方法、私有方法和父类中的方法</li>
<li>invokevirtual :  用于调用所有的虚方法</li>
<li>invokeinterface: 用于调用接口方法，会在运行时在确定一个实现该接口的对象</li>
<li>invokedynamic：  现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ol>
<h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><ul>
<li>前面的1-4条调用指令，分配逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</li>
<li>只要能被invokespecial 和 invokestatic指令调用的方法，都可以在解析阶段中确定唯一的调用版本 ，Java语言里符合这个条件的方法 有： </li>
</ul>
<p><strong>静态方法、私有方法、实例构造器、父类方法</strong>4种，再加上被 final修饰的方法（尽管它用invokevirtual）指令调用，这5种方法调用会再类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“<strong>非虚方法</strong>”（<strong>Non-Virtual Method</strong>），与之相反的，其他方法就被称为 <strong>虚方法（Virtual Method）</strong></p>
<p>方法静态解析演示：</p>
<p>演示了一种常见的解析调用的例子，该样例中，<strong>静态方法sayHello 只可能属于类型 StaticResolution ，没有任何途径可以覆盖或隐藏这个方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态解析演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticResolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticResolution.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 javap -verbose StaticResolution.class   得到下面结果：</p>
<p>使用javap命令查看这段程序对应的字节码，会发现的确是通过<strong>invokestatic</strong>命令来调用sayHello()方法，而且其调用的方法版本已经在编译时就明确以<strong>常量池项的形式</strong>固化在字节码指令的参数之中（ #5 = Methodref ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"> Last modified <span class="number">2021</span>-<span class="number">1</span>-<span class="number">18</span>; size <span class="number">672</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">4041d</span>61106416a1bb60c338694bf8d00</span><br><span class="line">  Compiled from <span class="string">&quot;StaticResolution.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter8</span>.<span class="title">StaticResolution</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">53</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#22         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #25            // hello world</span><br><span class="line">   #4 = Methodref          #26.#27        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Methodref          #6.#28         // org/fenixsoft/jvm/chapter8/StaticResolution.sayHello:()V</span><br><span class="line">   #6 = Class              #29            // org/fenixsoft/jvm/chapter8/StaticResolution</span><br><span class="line">   #7 = Class              #30            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticResolution;</span><br><span class="line">  #15 = Utf8               sayHello</span><br><span class="line">  #16 = Utf8               main</span><br><span class="line">  #17 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               args</span><br><span class="line">  #19 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               StaticResolution.java</span><br><span class="line">  #22 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #23 = Class              #31            // java/lang/System</span><br><span class="line">  #24 = NameAndType        #32:#33        // out:Ljava/io/PrintStream;</span><br><span class="line">  #25 = Utf8               hello world</span><br><span class="line">  #26 = Class              #34            // java/io/PrintStream</span><br><span class="line">  #27 = NameAndType        #35:#36        // println:(Ljava/lang/String;)V</span><br><span class="line">  #28 = NameAndType        #15:#9         // sayHello:()V</span><br><span class="line">  #29 = Utf8               org/fenixsoft/jvm/chapter8/StaticResolution</span><br><span class="line">  #30 = Utf8               java/lang/Object</span><br><span class="line">  #31 = Utf8               java/lang/System</span><br><span class="line">  #32 = Utf8               out</span><br><span class="line">  #33 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #34 = Utf8               java/io/PrintStream</span><br><span class="line">  #35 = Utf8               println</span><br><span class="line">  #36 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.jvm.chapter8.StaticResolution();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticResolution;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">8</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: invokestatic  #5                  // Method sayHello:()V</span><br><span class="line">         <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">15</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">3</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">4</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticResolution.java&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java中的非虚方法除了使用  <strong>invokespecial、invokestatic</strong> 调用的方法之外，还有一种就是 <strong>被final 修饰的实例方法</strong>。历史设计的原因，final 方法使用的是 <strong>invokevirtual</strong> 指令调用的，但是因为它无法被覆盖，没有其他版本的可能，所以也无须 对方法接收者 进行多态选择，又或者说 多态选择的结果肯定是唯一的。</p>
<p>再《Java语言规范》中明确定义了被 final修饰的方法是一种<strong>非虚方法</strong>.</p>
<h4 id="解析调用："><a href="#解析调用：" class="headerlink" title="解析调用："></a>解析调用：</h4><p>解析调用一定是一个静态过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部 转变为 明确的直接引用，不必延迟到运行期再去完成。</p>
<h4 id="分派调用："><a href="#分派调用：" class="headerlink" title="分派调用："></a>分派调用：</h4><p>另一种主要的方法调用形式：  <strong>分派（Dispatch）</strong>调用则复杂许多，它可能是静态的也可能是动态的，按照分派依据 的宗量数可分为 <strong>单分派</strong> 和 <strong>多分派</strong>。 这两类分派两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派 4种分派组合情况 </p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>As we all know, Java 是一门面向对象的程序语言，因为java具备面向对象的 3个基本特征：  <strong>继承、封装 和多态。</strong></p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p> <strong>“分派”（Dispatch）</strong> 这个词本身就具有动态性，一般不应用在静态语境中。这部分原本在 英文原版的《Java虚拟机规范》和 《Java语言规范》里的说法都是:  </p>
<p>“Method Overload Resolution 方法重载解析” ,但部分外文资料和国内翻译的许多中文资料都将这种行为 称为 “静态分派”。</p>
<p>为了解释静态分派和重载（Overload），笔者准备了一段经常出现在面试题中的程序代码，读者不妨先看一遍，想一下程序的输出结果是什么。后面的话题将围绕这个类的方法来编写重载代码，以分析虚拟机和编译器确定方法版本的过程。程序如代码清单8-6所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法静态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    hello,guy!</span><br><span class="line">hello,guy!</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>为什么虚拟机会选择执行参数类型为Human的重载版本呢？在解决这个问题之前，我们先通过如下代码来定义两个关键概念：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br></pre></td></tr></table></figure>

<ul>
<li>我们把上面代码中的 “Human” 称为 变量的 <strong>“静态类型”（static Type）</strong>，或者叫 <strong>“外观类型”（Apparent Type）</strong>,</li>
<li>“Man” 则被称为变量的 <strong>“实际类型”（Actual Type）</strong>或者叫做 <strong>“运行时类型”（Runtime Type）</strong>.</li>
<li>静态类型和实际类型在程序中都可能会发生变化，区别是 静态类型的变化仅仅在使用时发生， 变量本身的静态类型不会被改变，并且最终的静态类型在编译期可知的；而 实际类型变化的结果在运行期才可确定，编译期在编译程序的时候并不知道一个对象的实际类型时什么</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象human 的实际类型是可变的，编译期间 它完全是个 “薛定谔的人”，到底是 Man 还是woman，必须等到程序运行到这行的时候才能确定。</p>
</li>
<li><p>而human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()<br>方法的调用，在编译期完全可以明确转型的是Man还是Woman。</p>
</li>
</ul>
<p>main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全<strong>取决于传入参数的数量和数据类型</strong>。</p>
<p>代码中故意<strong>定义了两个静态类型相同</strong>，而<strong>实际类型不同的变量</strong>，但虚拟机（或者准确地说是编译器）<strong>在重载时是通过参数的静态类型</strong>而<strong>不是实际类型</strong>作为判定依据的。由于<strong>静态类型在编译期可知</strong>，所以<strong>在编译阶段</strong>，Javac编译器就<strong>根据参数的静态类型决定了会使用哪个重载版本</strong>，因此选择了<strong>sayHello(Human)作为调用目标</strong>，并把<strong>这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter8</span>.<span class="title">StaticDispatch</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">53</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #14.#44        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #45.#46        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #47            // hello,guy!</span><br><span class="line">   #4 = Methodref          #48.#49        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = String             #50            // hello,gentleman!</span><br><span class="line">   #6 = String             #51            // hello,lady!</span><br><span class="line">   #7 = Class              #52            // org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">   #8 = Methodref          #7.#44         // org/fenixsoft/jvm/chapter8/StaticDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 = Class              #53            // org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">  #10 = Methodref          #9.#44         // org/fenixsoft/jvm/chapter8/StaticDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #11 = Class              #54            // org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">  #12 = Methodref          #11.#44        // org/fenixsoft/jvm/chapter8/StaticDispatch.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #13 = Methodref          #11.#55        // org/fenixsoft/jvm/chapter8/StaticDispatch.sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #14 = Class              #56            // java/lang/Object</span><br><span class="line">  #15 = Utf8               Woman</span><br><span class="line">  #16 = Utf8               InnerClasses</span><br><span class="line">  #17 = Utf8               Man</span><br><span class="line">  #18 = Class              #57            // org/fenixsoft/jvm/chapter8/StaticDispatch$Human</span><br><span class="line">  #19 = Utf8               Human</span><br><span class="line">  #20 = Utf8               &lt;init&gt;</span><br><span class="line">  #21 = Utf8               ()V</span><br><span class="line">  #22 = Utf8               Code</span><br><span class="line">  #23 = Utf8               LineNumberTable</span><br><span class="line">  #24 = Utf8               LocalVariableTable</span><br><span class="line">  #25 = Utf8               this</span><br><span class="line">  #26 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">  #27 = Utf8               sayHello</span><br><span class="line">  #28 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #29 = Utf8               guy</span><br><span class="line">  #30 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">  #31 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;)V</span><br><span class="line">  #32 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;</span><br><span class="line">  #33 = Utf8               (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;)V</span><br><span class="line">  #34 = Utf8               Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;</span><br><span class="line">  #35 = Utf8               main</span><br><span class="line">  #36 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #37 = Utf8               args</span><br><span class="line">  #38 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #39 = Utf8               man</span><br><span class="line">  #40 = Utf8               woman</span><br><span class="line">  #41 = Utf8               sr</span><br><span class="line">  #42 = Utf8               SourceFile</span><br><span class="line">  #43 = Utf8               StaticDispatch.java</span><br><span class="line">  #44 = NameAndType        #20:#21        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #45 = Class              #58            // java/lang/System</span><br><span class="line">  #46 = NameAndType        #59:#60        // out:Ljava/io/PrintStream;</span><br><span class="line">  #47 = Utf8               hello,guy!</span><br><span class="line">  #48 = Class              #61            // java/io/PrintStream</span><br><span class="line">  #49 = NameAndType        #62:#63        // println:(Ljava/lang/String;)V</span><br><span class="line">  #50 = Utf8               hello,gentleman!</span><br><span class="line">  #51 = Utf8               hello,lady!</span><br><span class="line">  #52 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">  #53 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">  #54 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">  #55 = NameAndType        #27:#28        // sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">  #56 = Utf8               java/lang/Object</span><br><span class="line">  #57 = Utf8               org/fenixsoft/jvm/chapter8/StaticDispatch$Human</span><br><span class="line">  #58 = Utf8               java/lang/System</span><br><span class="line">  #59 = Utf8               out</span><br><span class="line">  #60 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #61 = Utf8               java/io/PrintStream</span><br><span class="line">  #62 = Utf8               println</span><br><span class="line">  #63 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> org.fenixsoft.jvm.chapter8.StaticDispatch();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Human)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello,guy!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">19</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Man)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #5                  // String hello,gentleman!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">23</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Man;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.fenixsoft.jvm.chapter8.StaticDispatch$Woman)</span></span>;</span><br><span class="line">    descriptor: (Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #6                  // String hello,lady!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">27</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">28</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">1</span>   guy   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Woman;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #7                  // class org/fenixsoft/jvm/chapter8/StaticDispatch$Man</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #8                  // Method org/fenixsoft/jvm/chapter8/StaticDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: new           #9                  // class org/fenixsoft/jvm/chapter8/StaticDispatch$Woman</span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        12: invokespecial #10                 // Method org/fenixsoft/jvm/chapter8/StaticDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        16: new           #11                 // class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">        <span class="number">19</span>: dup</span><br><span class="line">        20: invokespecial #12                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">23</span>: astore_3</span><br><span class="line">        <span class="number">24</span>: aload_3</span><br><span class="line">        <span class="number">25</span>: aload_1</span><br><span class="line">        26: invokevirtual #13                 //这里： Method sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">        <span class="number">29</span>: aload_3</span><br><span class="line">        <span class="number">30</span>: aload_2</span><br><span class="line">        31: invokevirtual #13                 //这里： Method sayHello:(Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;)V</span><br><span class="line">        <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">31</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">32</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">33</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">34</span>: <span class="number">24</span></span><br><span class="line">        line <span class="number">35</span>: <span class="number">29</span></span><br><span class="line">        line <span class="number">36</span>: <span class="number">34</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">35</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">27</span>     <span class="number">1</span>   man   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">           <span class="number">16</span>      <span class="number">19</span>     <span class="number">2</span> woman   Lorg/fenixsoft/jvm/chapter8/StaticDispatch$Human;</span><br><span class="line">           <span class="number">24</span>      <span class="number">11</span>     <span class="number">3</span>    sr   Lorg/fenixsoft/jvm/chapter8/StaticDispatch;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;StaticDispatch.java&quot;</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     static #15= #9 of #11; //Woman=class org/fenixsoft/jvm/chapter8/StaticDispatch$Woman of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">     static #17= #7 of #11; //Man=class org/fenixsoft/jvm/chapter8/StaticDispatch$Man of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br><span class="line">     static abstract #19= #18 of #11; //Human=class org/fenixsoft/jvm/chapter8/StaticDispatch$Human of class org/fenixsoft/jvm/chapter8/StaticDispatch</span><br></pre></td></tr></table></figure>



<p>所有依赖静态类型来决定执行版本的分派动作，都被称为 <strong>静态分派</strong>。 静态分配的最典型应用表现就是 <strong>方法重载</strong>。 静态分派 发生在编译阶段，因此确定静态分派的动作实际上并不是由虚拟机来执行的 ，这点也是为什么一些资料选择把它归入 为 “解析”而不是 “分派”的原因。</p>
<h5 id="重载方法匹配优先级"><a href="#重载方法匹配优先级" class="headerlink" title="重载方法匹配优先级"></a>重载方法匹配优先级</h5><p>需要注意Javac编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一”的，往往只能确定一个“相对更合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是个比较稀罕的事件，产生这种模糊结论的主要原因是字面量天生的模糊性，它不需要定义，所以字面量就没有显式的静态类型，它的静态类型只能通过语言、语法的规则去理解和推断。代码清单8-7演示了何谓“更加合适的”版本。</p>
<p>代码清单8-7　重载方法匹配优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello int&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello long&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Character&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello char ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello Serializable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayHello(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一次运行结果： <strong>hello char</strong>，这很好理解，’a’是一个char类型的数据，自然会寻找参数类型为char的重载方法，</p>
</li>
<li><p>如果注释掉 sayHello(char arg)方法，那输出会变为：<strong>hello int</strong> ，这时发生了一次自动类型转换，’a’除了可以代表一个字符串，还可以代表数字97（字符’a’的<br>Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的</p>
</li>
<li><p>我们继续注释掉sayHello(int arg)方法，那输出会变为： <strong>hello long</strong> .这时发生了两次自动类型转换，’a’转型为整数97之后，进一步转型为长整数97L，匹配了参数类型为long的重载。笔者在代码中没有写其他的类型如float、double等的重载，不过实际上自动转型还能继续发生多次，按照<strong>char&gt;int&gt;long&gt;float&gt;double的顺序转型进行匹配</strong>，但<strong>不会匹配到byte和short类型的重载</strong>，因为<strong>char到byte或short的转型是不安全的</strong>。</p>
</li>
<li><p>继续注释掉sayHello(long arg)方法，那输出会变为 : <strong>hello Character</strong>  ，这时发生了一次自动装箱，’a’被包装为它的封装类型java.lang.Character，所以匹配到了参数类型为Character的重载</p>
</li>
<li><p>继续注释掉sayHello(Character arg)方法，那输出会变为： <strong>hello Serializable</strong>,  出现hello Serializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱之后发现还是找不到装箱类，但是找到了装箱类所实现的接口类型，所以紧接着又发生一次自动转型。char可以转型成int，<br>但是Character是绝对不会转型为Integer的，它只能安全地转型为它实现的接口或父类。Character还实现了另外一个接口java.lang.Comparable<Character>，如果同时出现两个参数分别为Serializable和Comparable<Character>的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示“类型模糊”（Type Ambiguous），并拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如：sayHello((Comparable<Character>)’a’)，才能编译通过</p>
</li>
<li><p>继续注释掉sayHello(Serializable arg)方法，输出会变为： <strong>hello Object</strong> ，这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接上层的优先级越低。即使方法调用传入的参数值为null时，这个规则仍然适用。</p>
</li>
<li><p>我们把sayHello(Objectarg)也注释掉，输出将会变为： <strong>hello char …</strong>,7个重载方法已经被注释得只剩1个了，可见变长参数的重载优先级是最低的，这时候字符’a’被当作了一个char[]数组的元素。笔者使用的是char类型的变长参数，读者在验证时还可以选择int类型、Character类型、Object类型等的变长参数重载来把上面的过程重新折腾一遍。但是要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不成立的[2]。</p>
</li>
</ul>
<p>另外还有一点读者可能比较容易混淆：笔者讲述的<strong>解析与分派这两者之间的关系并不是二选一的排他关系</strong>，它们是在<strong>不同层次上去筛选、确定目标方法</strong>的过程。例如前面说过静态方法会在编译期确定、在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，<strong>选择重载版本的过程也是通过静态分派</strong>完成的</p>
<ul>
<li>可以这么理解吗： <strong>overload重载是gen据静态类型来决定的（静态分派），  override是根据 实际类型来决定的（动态分派）。</strong></li>
</ul>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>看一下Java语言里动态分派的实现过程，它与Java语言多态性的另外一个重要体现[3]——重写（Override）有着很密切的关联。我们还是用前面的Man和Woman一起 sayHello的例子来讲解动态分派，请看代码清单8-8中所示的代码。</p>
<p>代码清单8-8　方法动态分派演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法动态分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;woman say hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>

<h5 id="Java虚拟机是如何判断应该调用哪个方法"><a href="#Java虚拟机是如何判断应该调用哪个方法" class="headerlink" title="Java虚拟机是如何判断应该调用哪个方法"></a>Java虚拟机是如何判断应该调用哪个方法</h5><ul>
<li>可以这么理解吗： <strong>overload重载是gen据静态类型来决定的（静态分派），  override是根据 实际类型来决定的（动态分派）。</strong></li>
</ul>
<p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为<strong>静态类型同样都是Human的两个变量</strong>man和woman在调用sayHello()方法时产生了不同的行为，甚至变量man在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是因为这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？我们使用javap命令输出这段代码的字节码，尝试从中寻找答案，输出结果如代码清单8-9所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">	Code:</span><br><span class="line">        Stack=2, Locals=3, Args_size=1</span><br><span class="line">        0: new <span class="comment">#16; //class org/fenixsoft/polymorphic/DynamicDispatch$Man</span></span><br><span class="line">        3: dup</span><br><span class="line">        4: invokespecial <span class="comment">#18; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        7: astore_1</span><br><span class="line">        8: new <span class="comment">#19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span></span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial <span class="comment">#21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        24: new <span class="comment">#19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman</span></span><br><span class="line">        27: dup</span><br><span class="line">        28: invokespecial <span class="comment">#21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        31: astore_1</span><br><span class="line">        32: aload_1</span><br><span class="line">        33: invokevirtual <span class="comment">#22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V</span></span><br><span class="line">        36: <span class="built_in">return</span></span><br></pre></td></tr></table></figure>

<p>0～15行的字节码是准备动作，作用是建立man和woman的内存空间、调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表的变量槽中，这些动作实际对应了Java源码中的这两行： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br></pre></td></tr></table></figure>

<p>接下来的16～21行是关键部分，16和20行的<strong>aload指令</strong>分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的sayHello()方法的所有者，称为接收者（Receiver）；</p>
<p>17和21行是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用）都完全一样，但是这两句指令最终执行的目标方法并不相同。那看来解决问题的关键还必须从invokevirtual指令本身入手，要弄清楚它是如何确定调用方法版本、如何实现多态查找来着手分析才行。根据《Java虚拟机规范》，invokevirtual指令的运行时解析过程[4]大致分为以下几步：</p>
<ol>
<li><strong>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</strong>。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，<strong>如果通过则返回这个方法的直接引用</strong>，查找过程结束；不通过则返回java.lang.<strong>IllegalAccessError</strong>异常。</li>
<li>否则，按照<strong>继承关系从下往上依次</strong>对C的各个父类进行第二步的<strong>搜索和验证</strong>过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.<strong>AbstractMethodError</strong>异常。</li>
</ol>
<p>正是因为invokevirtual指令执行的<strong>第一步就是在运行期确定接收者的实际类型</strong>，所以两次调用中的invokevirtual指令并<strong>不是把常量池中方法的符号引用解析到直接引用上</strong>就结束了，还会<strong>根据方法接收者的实际类型来选择方法版本</strong>，这个过程就是<strong>Java语言中方法重写的本质</strong>。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为<strong>动态分派。</strong></p>
<p>既然这种多态性的<strong>根源在于虚方法调用指令invokevirtual的执行逻辑</strong>，那自然我们得出的结论就<strong>只会对方法有效，对字段是无效的，因为字段不使用这条指令</strong>。事实上，在Java里面只有虚方法存在，字段永远不可能是虚的，</p>
<p>换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。<strong>当子类声明了与父类同名的字段时</strong>，虽然在子类的内存中两个字段都会存在，但是<strong>子类的字段会遮蔽父类的同名字段</strong>。</p>
<p>为了加深理解，又编撰了一份“劣质面试题式”的代码片段，请阅读代码清单8-10，思考运行后会输出什么结果。</p>
<p>代码清单8-10　字段没有多态性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段不参与多态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHasNoPolymorphic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            money = <span class="number">2</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Father, i have $&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            money = <span class="number">4</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am Son,  i have $&quot;</span> + money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father gay = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">&quot;This gay has $&quot;</span> + gay.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果为: </span><br><span class="line">I am Son,  i have $<span class="number">0</span></span><br><span class="line">I am Son,  i have $<span class="number">4</span></span><br><span class="line">This gay has $<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出两句都是“I am Son”，</p>
<ul>
<li>这是因为Son类在创建的时候，首先隐式调用了<strong>Father的构造函数</strong>，而Father构造函数中<strong>对showMeTheMoney()的调用是一次虚方法调用</strong>，实际执行的版本是Son::showMeTheMoney()方法，所以输出的是“I am Son”，这点经过前面的分析相信读者是没有疑问的了。</li>
<li>而这时候虽然父类的money字段已经被初始化成2了，但Son::showMeTheMoney()方法中访问的却是<strong>子类的money字段</strong>，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。</li>
<li>main()的最后一句<strong>通过静态类型访问到了父类中的money</strong>，输出了2。</li>
</ul>
<p><strong>todo  消化一下</strong></p>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><h5 id="宗量"><a href="#宗量" class="headerlink" title="宗量"></a>宗量</h5><p>方法的接收者与方法的参数统称为方法的<strong>宗量</strong></p>
<p>根据分派基于多少种宗量，可以将分派划分为<strong>单分派</strong>和<strong>多分派</strong>两种。</p>
<p>单分派 是根据<strong>一个宗量对目标进行选择</strong>，</p>
<p>多分派则是根据<strong>多于一个宗量对目标方法进行选择。</strong></p>
<p>代码清单：  单分派和多分派</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单分派、多分派演示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;father choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose qq&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;son choose 360&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Father son = <span class="keyword">new</span> Son();</span><br><span class="line">        father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果： </span><br><span class="line">    father choose <span class="number">360</span></span><br><span class="line">	son choose qq</span><br></pre></td></tr></table></figure>

<ul>
<li>main（）里调用了两次hardChoice 方法，这两次hardChoice 方法的选择结果在程序输出 中已经显示得很清楚了。 </li>
<li>我们关注得首先是 编译阶段中编译 器的选择过程，也就是静态分派的过程。</li>
<li>选择目标的依据有两点：<ul>
<li>一个是静态类型是 Father 还是SON</li>
<li>二是方法参数是QQ还是360</li>
</ul>
</li>
</ul>
<p>这次选择结果的最终产物是产生了2条invokevirtual 指令，两条指令的参数 分别是常量池中指向 Father:: hardChoice(360)  以及 Father:: hardChoice(QQ)方法的符号引用</p>
<ul>
<li>因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型</li>
</ul>
<h5 id="动态分派的过程"><a href="#动态分派的过程" class="headerlink" title="动态分派的过程"></a>动态分派的过程</h5><p>再看看运行阶段中虚拟机的选择，也就是<strong>动态分派</strong>的过程。</p>
<p>在执行 “son.hardChoice(new QQ()) ” 这行方法时，更准确的说，是在执行这行代码所对应的  Invokevirtual指令时，由于编译期已经决定目标方法的签名 必须为 hardChoice（QQ） ,虚拟机此时 不会关心传递过来的参数 “QQ”到底是 “腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型 都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有该方法的接收者的实际类型是 Father 还是 Son 。</p>
<p>因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型 。</p>
<p>根据上述论证的结果，我们可以总结一句： </p>
<p>如今的Java语言是一门静态多分派、动态单分派的语言。</p>
<p>强调”如今的Java语言”是因为这个结论未必会恒久不变。JDK10 时Java语法中新出现 var关键字，</p>
<p>var 是在编译时根据声明语句中赋值符右侧的表达式类型来静态地推断类型。这本质时一种语法糖：</p>
<h4 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h4><p>前面介绍的分派过程，作为对Java虚拟机概念模型的解释基本上已经足够了，它已经解决了虚拟机在分派中“<strong>会做什么</strong>”这问题，但是 问Java虚拟机 “<strong>具体如果做到</strong>” 的，答案则可能因为 各种虚拟机的实现不同会有些差别。</p>
<p>动态分派 是执行非常频繁的动作，而且动态分派的方法版本 选择过程 需要运行时在接收者类型的方法元数据中 选择合适的目标方法，因此Java虚拟机实现基于执行性能的考虑，真实运行时一般不会如此频繁的去反复搜索类型元数据。</p>
<p>面对这种情况，一种基础而且常见的优化手段 是为类型在方法中建一个虚方法表（Virtual Method Table，也称为 vtable），与此对应的，在invokeinterface 执行时也会用到 接口方法表-Interface Method Table，简称itable。 使用虚方法表 索引来代替元数据查找以提高性能。  我们来看看上面代码 所对应的虚方法表结构示例： 如下图所示</p>
<p><img src="/uploads/jvm/11diapatch/methodTable.png"></p>
<p>虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是 一致的，都指向父类的实现入口。</p>
<p>如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为 指向子类实现版本的入口地址。</p>
<p>在上图中，son重写了来自 Father的全部方法，因此son的方法表 没有指向Father类型数据的箭头。</p>
<p>但是son 和 Father都没有重写来自Object的方法，所以他们的方法表中所有从Object 继承来的方法都指向了Object的类型数据。</p>
<p>为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中 都应当具有一样的索引序号，这样当类型变换时，仅仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。 <strong>虚方法表一般在类加载的连接阶段进行初始化</strong>，准备了类的变量初始值后，虚拟机 会把 该<strong>类的虚方法表也一同初始化完毕。</strong></p>
<p>上面说的<strong>查虚方法表</strong> 是 <strong>分派调用</strong>的一种<strong>优化手段</strong>，<strong>由于Java对象里面的方法 默认（即不使用final 修饰）就是虚方法</strong>，虚拟机除了使用虚方法表外，为了进一步提高性能，还会使用<strong>类型继承分析（Class Hierarchy Analysis，CHA）</strong> ，<strong>守护内联（Guarded Inlining）</strong>，<strong>内联缓存（Inline Cache）</strong> 等多种非稳定的激进优化来争取更大的性能空间，</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">深入理解jvm-10-Java模块化系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-18 23:00:29" itemprop="dateCreated datePublished" datetime="2021-01-18T23:00:29+08:00">2021-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-10-Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java模块化系统-TODO-DODO"><a href="#Java模块化系统-TODO-DODO" class="headerlink" title="Java模块化系统(TODO DODO)"></a>Java模块化系统(TODO DODO)</h1><p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p>
<ul>
<li>依赖其他模块的列表。</li>
<li>导出的包列表，即其他模块可以使用的列表。</li>
<li>开放的包列表，即其他模块可反射访问模块的列表。</li>
<li>使用的服务列表。</li>
<li>提供服务的实现列表</li>
</ul>
<h2 id="可配置的封装隔离机制"><a href="#可配置的封装隔离机制" class="headerlink" title="可配置的封装隔离机制"></a>可配置的封装隔离机制</h2><ul>
<li>可配置的封装隔离机制首先要解决JDK 9之前基于<strong>类路径（ClassPath）来查找依赖</strong>的可靠性问题。此前，如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接时才会报出运行的异常</li>
<li>而在JDK 9以后，如果启用了<strong>模块化进行封装</strong>，模块就可以声明对其他模块的<strong>显式依赖</strong>，这样Java虚拟机就能够在<strong>启动时验证</strong>应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分[1]由于类型依赖而引发的运行时异常</li>
<li>可配置的封装隔离机制还<strong>解决了原来类路径上跨JAR文件的public类型的可访问性问题</strong>。JDK 9中的public类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更<strong>精细的可访问性控制</strong>，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种<strong>访问控制也主要是在类加载过程中</strong>完成的</li>
</ul>
<h2 id="模块的兼容性"><a href="#模块的兼容性" class="headerlink" title="模块的兼容性"></a>模块的兼容性</h2><ul>
<li>为了使可配置的封装隔离机制能够兼容传统的类路径查找机制，JDK 9提出了与“<strong>类路径</strong>”（ClassPath）相对应的“<strong>模块路径</strong>”（ModulePath）的概念</li>
<li>就是某个类库到底是模块还是传统的JAR包，只取决于<strong>它存放在哪种路径上</strong>。</li>
<li>只要是放在<strong>类路径上的JAR文件</strong>，无论其中是否包含模块化信息（是否包含了module-info.class文件），它都会被当作<strong>传统的JAR包</strong>来对待；</li>
<li>相应地，只要放在<strong>模块路径上的JAR文件</strong>，即使没有使用JMOD后缀，甚至说其中并不包含module-info.class文件，它也仍然会被当作一个<strong>模块</strong>来对待。</li>
</ul>
<h3 id="保障规则："><a href="#保障规则：" class="headerlink" title="保障规则："></a>保障规则：</h3><p>模块化系统将按照以下规则来保证使用传统类路径依赖的Java程序可以不经修改地直接运行在JDK 9及以后的Java版本上，即使这些版本的JDK已经使用模块来封装了Java SE的标准类库，模块化系统的这套规则也仍然保证了传统程序可以访问到所有标准类库模块中导出的包</p>
<h4 id="JAR文件在类路径的访问规则"><a href="#JAR文件在类路径的访问规则" class="headerlink" title="JAR文件在类路径的访问规则"></a>JAR文件在类路径的访问规则</h4><ul>
<li>JAR文件在类路径的访问规则：所有类路径下的JAR文件及其他资源文件，都被视为自动打包在一个匿名模块（Unnamed Module）里，这个匿名模块几乎是没有任何隔离的，它可以看到和使用类路径上所有的包、JDK系统模块中所有的导出包，以及模块路径上所有模块中导出的包。</li>
</ul>
<h4 id="模块在模块路径的访问规则"><a href="#模块在模块路径的访问规则" class="headerlink" title="模块在模块路径的访问规则"></a>模块在模块路径的访问规则</h4><ul>
<li>模块在模块路径的访问规则：模块路径下的具名模块（Named Module）只能访问到它依赖定义中列明依赖的模块和包，匿名模块里所有的内容对具名模块来说都是不可见的，即具名模块看不见传统JAR包的内容。</li>
</ul>
<h4 id="JAR文件在模块路径的访问规则"><a href="#JAR文件在模块路径的访问规则" class="headerlink" title="JAR文件在模块路径的访问规则"></a>JAR文件在模块路径的访问规则</h4><ul>
<li>JAR文件在模块路径的访问规则：如果把一个传统的、不包含模块定义的JAR文件放置到模块路径中，它就会变成一个自动模块（Automatic Module）。尽管不包含module-info.class，但自动模块将默认依赖于整个模块路径中的所有模块，因此可以访问到所有模块导出的包，自动模块也默认导出自己所有的包。</li>
</ul>
<p>以上3条规则保证了即使Java应用依然使用传统的类路径，升级到JDK 9对应用来说几乎（类加载器上的变动还是可能会导致少许可见的影响，将在下节介绍）不会有任何感觉，项目也不需要专门为了升级JDK版本而去把传统JAR包升级成模块。</p>
<p>除了向后兼容性外，随着JDK 9模块化系统的引入，更值得关注的是它本身面临的模块间的管理和兼容性问题：如果同一个模块发行了多个不同的版本，那只能由开发者在编译打包时人工选择好正确版本的模块来保证依赖的正确性。Java模块化系统目前不支持在模块定义中加入版本号来管理和约束依赖，本身也不支持多版本号的概念和版本选择功能。</p>
<p>我们不论是在Java命令、Java类库的API抑或是《Java虚拟机规范》定义的Class文件格式里都能轻易地找到证据，表明模块版本应是编译、加载、运行期间<br>都可以使用的。譬如输入“java–list-modules”，会得到明确带着版本号的模块列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.base@12.0.1</span><br><span class="line">java.compiler@12.0.1</span><br><span class="line">java.datatransfer@12.0.1</span><br><span class="line">java.desktop@12.0.1</span><br><span class="line">java.instrument@12.0.1</span><br><span class="line">java.logging@12.0.1</span><br><span class="line">java.management@12.0.1</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>在JDK 9时加入Class文件格式的<strong>Module属性</strong>，里面有<strong>module_version_index</strong>这样的字段，用户可以在编译时使用“<strong>javac–module-version</strong>”来指定模块版本，在Java类库API中也存在java.lang.module.ModuleDescriptor.Version这样的接口可以在运行时获取到模块的版本号。这一切迹象都证明了<strong>Java模块化系统对版本号的支持本可以不局限在编译期</strong>。</p>
<h2 id="模块化下的类加载器"><a href="#模块化下的类加载器" class="headerlink" title="模块化下的类加载器"></a>模块化下的类加载器</h2><p>为了保证兼容性，JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架构以及双亲委派模型。但是为了模块化系统的顺利施行，模块化下的类加载器仍然发生了一些应该被注意到变动，主要包括以下几个方面。</p>
<h3 id="扩展类加载器被取代"><a href="#扩展类加载器被取代" class="headerlink" title="扩展类加载器被取代"></a>扩展类加载器被取代</h3><ul>
<li>首先，是扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。</li>
<li>这其实是一个很顺理成章的变动，既然整个JDK都基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留**<JAVA_HOME>\lib\ext**目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了，用来加载这部分类库的扩展类加载器也完成了它的历史使命。</li>
<li>类似地，在新版的JDK中也<strong>取消了<JAVA_HOME>\jre</strong>目录，因为随时可以组合构建出程序运行所需的JRE来，譬如假设我们只使用java.base模块中的类型，那么随时可以通过以下命令打包出一个“JRE”：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jlink -p <span class="variable">$JAVA_HOME</span>/jmods --add-modules java.base --output jre</span><br></pre></td></tr></table></figure>

<h3 id="BuiltinClassLoade"><a href="#BuiltinClassLoade" class="headerlink" title="BuiltinClassLoade"></a>BuiltinClassLoade</h3><ul>
<li>其次，平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader，如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK 9及更高版本的JDK中崩溃。</li>
<li>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</li>
</ul>
<p><img src="/uploads/jvm/09ClassLoader/01-ClassLoader_before.png"></p>
<p><img src="/uploads/jvm/09ClassLoader/02-ClassLoader_after.png"></p>
<p>图7-6中有“BootClassLoader”存在，启动类加载器现在是在Java虚拟机内部和Java类库共同协作实现的类加载器，尽管有了BootClassLoader这样的Java类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景（譬如Object.class.getClassLoader()）中仍然会返回null来代替，而不会得到BootClassLoader的实例。</p>
<h3 id="类加载的委派关系发生了变动"><a href="#类加载的委派关系发生了变动" class="headerlink" title="类加载的委派关系发生了变动"></a>类加载的委派关系发生了变动</h3><p><img src="source/uploads/jvm/09ClassLoader/03-ClassLoader_Parentnew.png"></p>
<p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。</p>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载，也许这可以算是对双亲委派的第四次破坏。</p>
<h4 id="类加载器负责加载的模块"><a href="#类加载器负责加载的模块" class="headerlink" title="类加载器负责加载的模块"></a>类加载器负责加载的模块</h4><h5 id="启动类加载器负责加载的模块"><a href="#启动类加载器负责加载的模块" class="headerlink" title="启动类加载器负责加载的模块"></a>启动类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.base java.security.sasl</span><br><span class="line">java.datatransfer java.xml</span><br><span class="line">java.desktop jdk.httpserver</span><br><span class="line">java.instrument jdk.internal.vm.ci</span><br><span class="line">java.logging jdk.management</span><br><span class="line">java.management jdk.management.agent</span><br><span class="line">java.management.rmi jdk.naming.rmi</span><br><span class="line">java.naming jdk.net</span><br><span class="line">java.prefs jdk.sctp</span><br><span class="line">java.rmi jdk.unsupported</span><br></pre></td></tr></table></figure>



<h5 id="平台类加载器负责加载的模块"><a href="#平台类加载器负责加载的模块" class="headerlink" title="平台类加载器负责加载的模块"></a>平台类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.activation* 					jdk.accessibility</span><br><span class="line">java.compiler* 						jdk.charsets</span><br><span class="line">java.corba* 						jdk.crypto.cryptoki</span><br><span class="line">java.scripting 						jdk.crypto.ec</span><br><span class="line">java.se 							jdk.dynalink</span><br><span class="line">java.se.ee 							jdk.incubator.httpclient</span><br><span class="line">java.security.jgss					jdk.internal.vm.compiler*</span><br><span class="line">java.smartcardio 					jdk.jsobject</span><br><span class="line">java.sql 							jdk.localedata</span><br><span class="line">java.sql.rowset						jdk.naming.dns</span><br><span class="line">java.transaction* 					jdk.scripting.nashorn</span><br><span class="line">java.xml.bind* 						jdk.security.auth</span><br><span class="line">java.xml.crypto 					jdk.security.jgss</span><br><span class="line">java.xml.ws* 						jdk.xml.dom</span><br><span class="line">java.xml.ws.annotation* 			jdk.zipfs</span><br></pre></td></tr></table></figure>

<h5 id="应用程序类加载器负责加载的模块"><a href="#应用程序类加载器负责加载的模块" class="headerlink" title="应用程序类加载器负责加载的模块"></a>应用程序类加载器负责加载的模块</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jdk.aot 						jdk.jdeps</span><br><span class="line">jdk.attach 						jdk.jdi</span><br><span class="line">jdk.compiler 					jdk.jdwp.agent</span><br><span class="line">jdk.editpad 					jdk.jlink</span><br><span class="line">jdk.hotspot.agent 				jdk.jshell</span><br><span class="line">jdk.internal.ed					jdk.jstatd</span><br><span class="line">jdk.internal.jvmstat 			jdk.pack</span><br><span class="line">jdk.internal.le 				jdk.policytool</span><br><span class="line">jdk.internal.opt 				jdk.rmic</span><br><span class="line">jdk.jartool 					jdk.scripting.nashorn.shell</span><br><span class="line">jdk.javadoc 					jdk.xml.bind*</span><br><span class="line">jdk.jcmd 						jdk.xml.ws*</span><br><span class="line">jdk.jconsole</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="post-title-link" itemprop="url">深入理解jvm-09-类加载器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-18 20:53:23" itemprop="dateCreated datePublished" datetime="2021-01-18T20:53:23+08:00">2021-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-09-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>Java虚拟机设计团队 有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流” 这个动作放到java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 “<strong>类加载器</strong>”（Class Loader）。</p>
<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><ul>
<li>类加载器虽然只用于实现类的加载，但它在Java程序中起到的作用却<strong>远超类加载阶段</strong>。</li>
<li>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的<strong>唯一性</strong>，<strong>每一个类加载器都拥有一个独立的类名称空间</strong>。</li>
<li>比较2个类是否“<strong>相等</strong>”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这2个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这2个类就必定不相等。</li>
<li>这里所说的“相等”，包括了类的Class对象的 equals() 、isAssignableFrom()、 isInstance()方法的返回结果，也包括了使用instanceof 关键字做对象所属关系判断等 各种情况。</li>
<li>下面代码演示了不同的类加载器对instanceof关键字运算的结果的影响</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;org.fenixsoft.jvm.chapter7.ClassLoaderTest&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.jvm.chapter7.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">fenixsoft</span>.<span class="title">jvm</span>.<span class="title">chapter7</span>.<span class="title">ClassLoaderTest</span></span></span><br><span class="line"><span class="class">	<span class="title">false</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码构造了一个简单的类加载器，它可以加载与自己在同意路径下的Class 文件，我们使用这个类加载器去加载了一个名为 “ class org.fenixsoft.jvm.chapter7.ClassLoaderTest” 的类，并实例化了这个类的对象。</li>
<li>todo： 看一下类加载器的源码，如：loadClass（）、defineClass（）等</li>
<li>两行输出结果中，从第一行可以看到这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化出来的，但在第二行的输出中却发现这个对象与类org.fenixsoft.classloading.ClassLoaderTest做所属类型检查的时候返回了false。 </li>
<li> 因为Java虚拟机中同时存在两个 ClassLoaderTest 类，一个是由虚拟机的应用程序类加载器所加载的， 另一个是我们自定义的类加载器加载的，虽然他们都来自于同一个Class文件，但在JVM中仍然是两个互相独立的类，做对象所属类型检查时的结果自然为false。</li>
</ul>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>站在Java 虚拟机的角度来看，只存在2种不同的类加载器：</p>
<ul>
<li> 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器由C++ 语言实现，是虚拟机自身的一部分</li>
<li>另一种就是其他所有的类加载器，这些类加载器都有Java语言实现，独立存在虚拟机外部，全部继承自抽象类 java.lang.ClassLoader</li>
</ul>
<p>站在Java开发人员的角度来看，类加载器应当划分的更细致一些，从JDK1.2以来，Java一直保持 3层类加载器、双亲委派的 类加载架构。</p>
<p>3层类加载器：</p>
<h3 id="启动类加载器（Bootstrap-ClassLoader）："><a href="#启动类加载器（Bootstrap-ClassLoader）：" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）："></a>启动类加载器（Bootstrap ClassLoader）：</h3><ul>
<li>负责加载存放在%JAVA_HOME%\lib 目录，或者被 -Xbootclasspath 参数所指定的路径存放的，而且是Java虚拟机能够识别的（PS：java虚拟机识别是按照文件名识别的，如rt.jar,  tool.jar ，名字不符合类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li>
<li>启动类加载器无法被java程序直接引用，用户在编写自定义的ClassLoader 时，如果需要把加载请求委派给  启动类加载器 去处理，直接使用<strong>null</strong> 代替即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the class loader for the class.  Some implementations may use </span></span><br><span class="line"><span class="comment">    * null to represent the bootstrap class loader. This method will return</span></span><br><span class="line"><span class="comment">    * null in such implementations if this class was loaded by the bootstrap</span></span><br><span class="line"><span class="comment">    * class loader.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt; If a security manager is present, and the caller&#x27;s class loader is</span></span><br><span class="line"><span class="comment">    * not null and the caller&#x27;s class loader is not the same as or an ancestor of</span></span><br><span class="line"><span class="comment">    * the class loader for the class whose class loader is requested, then</span></span><br><span class="line"><span class="comment">    * this method calls the security manager&#x27;s &#123;<span class="doctag">@code</span> checkPermission&#125;</span></span><br><span class="line"><span class="comment">    * method with a &#123;<span class="doctag">@code</span> RuntimePermission(&quot;getClassLoader&quot;)&#125;</span></span><br><span class="line"><span class="comment">    * permission to ensure it&#x27;s ok to access the class loader for the class.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;If this object</span></span><br><span class="line"><span class="comment">    * represents a primitive type or void, null is returned.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  the class loader that loaded the class or interface</span></span><br><span class="line"><span class="comment">    *          represented by this object.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">    *    if a security manager exists and its</span></span><br><span class="line"><span class="comment">    *    &#123;<span class="doctag">@code</span> checkPermission&#125; method denies</span></span><br><span class="line"><span class="comment">    *    access to the class loader for the class.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.ClassLoader</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> SecurityManager#checkPermission</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.lang.RuntimePermission</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ClassLoader cl = getClassLoader0();</span><br><span class="line">       <span class="keyword">if</span> (cl == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> cl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Returns the class loader for the class.  Some implementations may use     <strong>null to represent the bootstrap class loader.</strong> </p>
<p>This method will <strong>return  null in</strong> such implementations if this class was <strong>loaded by the bootstrap  class loader</strong>.</p>
<h3 id="扩展类加载器（Extension-Class-Loader）"><a href="#扩展类加载器（Extension-Class-Loader）" class="headerlink" title="扩展类加载器（Extension Class Loader）"></a>扩展类加载器（Extension Class Loader）</h3><ul>
<li><p>这个类加载器时在类 sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。</p>
</li>
<li><p>它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
</li>
<li><p>根据“扩展类加载器”这个名称，就可以推断出这是一种Java系统类库的扩展机制，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代</p>
</li>
<li><p>由于扩展类加载器是由 Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载 Class文件</p>
</li>
</ul>
<h3 id="应用程序类加载器（Application-Class-Loader）"><a href="#应用程序类加载器（Application-Class-Loader）" class="headerlink" title="应用程序类加载器（Application Class Loader）"></a>应用程序类加载器（Application Class Loader）</h3><ul>
<li>这个类加载器由sun.misc.Launcher$AppClassLoader来实现</li>
<li>由于应用程序类加载器是ClassLoader类中的getSystem- ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。</li>
<li>它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器</li>
<li>如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<h3 id="类加载器双亲委派模型"><a href="#类加载器双亲委派模型" class="headerlink" title="类加载器双亲委派模型"></a>类加载器双亲委派模型</h3><p><strong>图7-2　类加载器双亲委派模型</strong></p>
<pre class="mermaid">classDiagram
BootstrapClassLoader <-- ExtensionClassLoader : 父亲
ExtensionClassLoader <-- ApplicationClassLoader : 父亲
ApplicationClassLoader <-- Custom_ClassLoader1 : 父亲
ApplicationClassLoader <-- Custom_ClassLoader2 : 父亲</pre>

<ul>
<li><p>图7-2中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型（Parents DelegationModel）”。</p>
</li>
<li><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>
</li>
<li><p>不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
</li>
<li><p>类加载器的双亲委派模型在JDK 1.2时期被引入，并被广泛应用于此后几乎所有的Java程序中，但它并不是一个具有强制性约束力的模型，而是Java设计者们推荐给开发者的一种类加载器实现的最佳实践。</p>
</li>
</ul>
<h4 id="双亲委派工作过程"><a href="#双亲委派工作过程" class="headerlink" title="双亲委派工作过程"></a>双亲委派工作过程</h4><ul>
<li>如果一个ClassLoader 收到了 类加载的请求，</li>
<li>它首先不会自己去尝试加载这个类，而是把这个请求委派给 <strong>父类加载器</strong> 去完成，每一个层次的类加载器都是如此，</li>
<li>因此所有的加载请求最终都应该送到最顶层的启动类加载器中，</li>
<li>只有当 父类加载器 反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去完成加载。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul>
<li>Java中类随着它的类加载器一起具有了一种带有优先级的层次关系。</li>
<li>例如：类java.lang.Object ，它存放在rt.jar 中，无论哪一个类加载要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器 环境中都能保证时同一个类。</li>
<li>反之 如果没有使用双亲委派模型，都有各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object的类，并放在程序的ClassPath中，那系统中就会出现 多个不同的Object类，Java类型体系中最基础的行为也就无从保证。</li>
</ul>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">	<span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="comment">// 在父类加载器无法加载时</span></span><br><span class="line">	<span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑清晰易懂：</p>
<ul>
<li><p>先检查请求加载的类型是否已经被加载过，</p>
<ul>
<li><p>若没有则调用父加载器的loadClass()方法，</p>
</li>
<li><p>若父加载器为空则默认使用启动类加载器作为父加载器。</p>
</li>
</ul>
</li>
<li><p>假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
</li>
</ul>
<h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<h3 id="第一次破坏双亲委派"><a href="#第一次破坏双亲委派" class="headerlink" title="第一次破坏双亲委派"></a>第一次破坏双亲委派</h3><ul>
<li>第一次 “被破坏”其实发生在<strong>双亲委派模型出现之前</strong>——即JDK 1.2面世以前的“远古”时代。</li>
<li>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了<strong>兼容这些已有代码</strong>，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个<strong>新的protected方法findClass()**，并</strong>引导用户编写的类加载逻辑时尽可能去重写这个方法**，而不是在loadClass()中编写代码。</li>
<li>我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</li>
</ul>
<h3 id="第二次破坏双亲委派"><a href="#第二次破坏双亲委派" class="headerlink" title="第二次破坏双亲委派"></a>第二次破坏双亲委派</h3><ul>
<li>第二次“被破坏”是由这个模型自身的缺陷导致的，</li>
<li>双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，</li>
<li>但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？</li>
<li>一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</li>
<li>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内<br>都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>
<li>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种<strong>父类加载器去请求子类加载器完成类加载</strong>的行为，这种行为实际上是打通了双亲委派模型的层次结构来<strong>逆向使用类加载器</strong>，已经<strong>违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了<strong>java.util.ServiceLoader类</strong>，以<strong>META-INF/services</strong>中的配置信息，<strong>辅以责任链模式</strong>，这才算是给SPI的加载提供了一种相对合理的解决方案。</li>
</ul>
<h3 id="第三次破坏双亲委派"><a href="#第三次破坏双亲委派" class="headerlink" title="第三次破坏双亲委派"></a>第三次破坏双亲委派</h3><ul>
<li>第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：<strong>代码热替换</strong>（<strong>Hot Swap</strong>）、<strong>模块热部署</strong>（<strong>Hot Deployment</strong>）等。</li>
<li>说白了就是希望Java应用程序能像我们的电脑外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用关机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是大型系统或企业级软件开发者具有很大的吸引力。</li>
</ul>
<h3 id="OSGi实现热部署原理"><a href="#OSGi实现热部署原理" class="headerlink" title="OSGi实现热部署原理"></a>OSGi实现热部署原理</h3><p>OSGi实现模块化热部署的关键是它<strong>自定义的类加载器机制</strong>的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把<strong>Bundle连同类加载器一起换掉</strong>以实现代码的热替换。</p>
<p>在OSGi环境下，类加载器不再是双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以java.*开头的类，委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。</li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>上面的查找顺序中只有<strong>开头两点仍然符合双亲委派模型</strong>的原则，其余的类查找都是在<strong>平级的类加载器</strong>中进行的。</p>
<p>虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。</p>
<p><strong>只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新</strong>。</p>
<p>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">深入理解jvm-08-虚拟机类加载机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-14 20:34:10" itemprop="dateCreated datePublished" datetime="2021-01-14T20:34:10+08:00">2021-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm-08-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虚拟机的类加载机制：</p>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<p>在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载稍微增加一些性能开销，</p>
<p>但是却为了Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接的特点实现的。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期都将会经历 加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。 这7个阶段的发生顺序为:</p>
<p><img src="/uploads/jvm/08ClassLoading/01ClassLoadingLifecircle.png"></p>
<ul>
<li>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，</li>
<li>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</li>
<li>请注意，是按部就班地<strong>“开始”</strong>，而不是按部就班地“进行”或按部就班地<strong>“完成”</strong>，强调这点是因为这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</li>
</ul>
<h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，</p>
<p>这六种场景中的行为称为对一个类型进行主动引用。</p>
<p>除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p>
<p>下面举三个例子来说明何为被动引用，分别见代码清单7-1、代码清单7-2和代码清单7-3。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><h4 id="通过子类引用父类的静态字段，不会导致子类初始化"><a href="#通过子类引用父类的静态字段，不会导致子类初始化" class="headerlink" title="通过子类引用父类的静态字段，不会导致子类初始化"></a>通过子类引用父类的静态字段，不会导致子类初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.classloading;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示一：</span></span><br><span class="line"><span class="comment">* 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line">SuperClass init!</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。</p>
</li>
<li><p>对于静态字段，只有<strong>直接定义这个字段的类</strong>才会被初始化，因此<strong>通过其子类来引用父类中定义的静态字段</strong>，只会<strong>触发</strong><br><strong>父类的初始化</strong>而不会触发子类的初始化。</p>
</li>
<li><p>至于是否要触发子类的加载和验证阶段，在《Java虚拟机规范》中并未明确规定，所以这点取决于虚拟机的具体实现。对于HotSpot虚拟机来说，可通过-XX：+TraceClassLoading参数观察到此操作是会导致子类加载的。</p>
</li>
</ul>
<h4 id="通过数组定义来引用类，不会触发此类的初始化"><a href="#通过数组定义来引用类，不会触发此类的初始化" class="headerlink" title="通过数组定义来引用类，不会触发此类的初始化"></a>通过数组定义来引用类，不会触发此类的初始化</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 被动使用类字段演示二：</span><br><span class="line"> * 通过数组定义来引用类，不会触发此类的初始化</span><br><span class="line"> **/</span><br><span class="line">public class NotInitialization_2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SuperClass[] sca = new SuperClass[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 javap -verbose NotInitialization_2.class</span><br><span class="line">&#123;</span><br><span class="line">  public org.fenixsoft.jvm.chapter7.NotInitialization_2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lorg/fenixsoft/jvm/chapter7/NotInitialization_2;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: anewarray     <span class="comment">#2                  // class org/fenixsoft/jvm/chapter7/SuperClass</span></span><br><span class="line">         5: astore_1</span><br><span class="line">         6: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 6</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       7     0  args   [Ljava/lang/String;</span><br><span class="line">            6       1     1   sca   [Lorg/fenixsoft/jvm/chapter7/SuperClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>运行之后发现没有输出“SuperClassinit！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。</p>
</li>
<li><p>但是这段代码里面触发了另一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是<br>一个合法的类型名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。</p>
</li>
<li><p>这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里</p>
</li>
</ul>
<h4 id="常量在编译阶段会存入调用类的常量池中"><a href="#常量在编译阶段会存入调用类的常量池中" class="headerlink" title="常量在编译阶段会存入调用类的常量池中"></a>常量在编译阶段会存入调用类的常量池中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被动使用类字段演示三：</span></span><br><span class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码运行之后，也没有输出“ConstClass init！”，、</p>
</li>
<li><p>这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在编译阶段通过*<strong>常量传播优化**<em>，已经将此常量的值“helloworld”直接存储在NotInitialization类的</em></strong>常量池*<strong>中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用，实际都被转化为NotInitialization类</strong>对自身常量池的引用**了</p>
</li>
<li><p>也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class文件后就已不存在任何联系了。</p>
</li>
</ul>
<h2 id="接口的加载过程"><a href="#接口的加载过程" class="headerlink" title="接口的加载过程"></a>接口的加载过程</h2><ul>
<li>接口的加载过程与类加载过程稍有不同，</li>
<li>针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，</li>
<li>而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[2]，用于初始化接口中所定义的成员变量。</li>
<li>接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：<br>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><ul>
<li><p>“<strong>加载</strong>”（Loading）阶段是整个“<strong>类加载</strong>”（Class Loading）过程中的一个阶段，</p>
</li>
<li><p>希望没有混淆这两个看起来很相似的名词。在加载阶段，Java虚拟机需要完成以下三件事情：</p>
</li>
</ul>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<ul>
<li><p>《Java虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与Java应用的灵活度都是相当大的。</p>
</li>
<li><p>例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。仅仅这一点空隙，Java虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台。例如：</p>
<ol>
<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是Web Applet。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</li>
<li>从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li>
<li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li>
</ol>
</li>
<li><p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p>
</li>
<li><p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的</p>
</li>
<li><p>但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ElementType，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p>
<ol>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>
</ol>
</li>
</ul>
<ul>
<li><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在**<em>方法区**</em>之中了（<strong>平安面试遇到过，编译后的数据放在哪个内存区域</strong>（<strong>方法区</strong>））</p>
</li>
<li><p>类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
</li>
<li><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
</li>
</ul>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><ul>
<li><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
</li>
<li><p>因为使用纯粹的java语言是可以拦截一些异常的，使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果尝试这样去做了，编译器会毫不留情地抛出异常、拒绝编译。</p>
</li>
<li><p>但是 Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。上述Java代码无法做到的事情在字节码层面上都是可以实现的，至少语义上是可以表达出来的</p>
</li>
<li><p>所以 Java虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有错误或有恶意企图的字节码流而导致整个系统受攻击甚至崩溃，所以验证字节码是Java虚拟机保护自身的一项必要措施。</p>
</li>
<li><p>验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重</p>
</li>
</ul>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
<li>and so on …</li>
</ul>
<p>验证阶段的主要目的是保证输入的<strong>字节流</strong>能<strong>正确地解析并存储于方法区</strong>之内，格式上符合描述一个Java类型信息的要求。</p>
<p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，</p>
<p>所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方<br>法重载，例如方法参数都一致，但返回值类型却不同等）</li>
<li>and so on … </li>
</ul>
<p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息。</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，</p>
<p>主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p>在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的</li>
<li> and so on …</li>
</ul>
<p>如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再严密的检查，也依然不能保证这一点。</p>
<p>这里涉及了离散数学中一个很著名的问题——“停机问题”（Halting Problem）[2]，即不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p>
<p>在我们讨论字节码校验的上下文语境里，通俗一点的解释是通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在Bug。</p>
<h5 id="Ps"><a href="#Ps" class="headerlink" title="Ps:"></a>Ps:</h5><ul>
<li>由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行</li>
<li>具体做法是给方法体Code属性的属性表中新增加了一项名为“<strong>StackMapTable</strong>”的新属性，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，</li>
<li>在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。这样就将字节码验证的<strong>类型推导</strong>转变为<strong>类型检查</strong>，从而节省了大量校验时间</li>
</ul>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，</p>
<p>这个转化动作将在连接的第三阶段——解析阶段中发生。</p>
<p>符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，</p>
<p>通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<p>本阶段通常需要校验下列内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当前类访问。</li>
<li>and so on …</li>
</ul>
<p>符号引用验证的主要目的是确保解析行为能正常执行，</p>
<p>如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：<br>java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p>
<h5 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h5><p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><ul>
<li><p>准备阶段是正式为类中定义的变量（即<strong>静态变量</strong>，被static修饰的变量）<strong>分配内存并设置类变量初始值</strong>的阶段，</p>
</li>
<li><p>从概念上讲，这些变量所使用的内存都应当在<strong>方法区</strong>中进行分配，但必须注意到方法区本身是一个逻辑上的区域，</p>
</li>
<li><p>在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；</p>
</li>
<li><p>而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了，</p>
</li>
</ul>
<p>关于准备阶段，还有两个容易产生混淆的概念需要着重强调，</p>
<ul>
<li><p>首先是这时候进行内存分配的仅包括<strong>类变量</strong>，而不包括实例变量，</p>
</li>
<li><p>实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
<li><p>其次是这里所说的<strong>初始值</strong>“<strong>通常情况</strong>”下是<strong>数据类型的零值</strong>，</p>
</li>
<li><p>假设一个类变量的定义为：public static int value = 123;</p>
</li>
<li><p>那变量value在准备阶段过后的<strong>初始值为0</strong>而不是123，因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于<strong>类构造器</strong><clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</p>
</li>
</ul>
<p><strong>基本数据类型的零值</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>零值</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0d</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“<strong>特殊情况</strong>”：如果类字段的字段属性表中存在<strong>ConstantValue</strong>属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，假设上面类变量value的定义修改为：</p>
<p>public static final int value = 123;</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据Con-stantValue的设置<br>将value赋值为123。</p>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p>在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所说的直接引用与符号引用又有什么关联呢？</p>
<h4 id="符号引用-Symbolic-References"><a href="#符号引用-Symbolic-References" class="headerlink" title="符号引用(Symbolic References):"></a>符号引用(Symbolic References):</h4><ul>
<li><p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
</li>
<li><p>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，</p>
</li>
<li><p>但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</p>
</li>
</ul>
<h4 id="直接引用（Direct-References）："><a href="#直接引用（Direct-References）：" class="headerlink" title="直接引用（Direct References）："></a>直接引用（Direct References）：</h4><ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</li>
<li>直接引用是和虚拟机实现的内存布局直接相关的，</li>
<li>同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li>
<li>如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</li>
</ul>
<p>《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行ane-warray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invoke-special、invokestatic、invokevirtual、ldc、ldc_w、ldc2_w、multianewarray、new、putfield和putstatic这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p>
<p>所以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引<br>用将要被使用前才去解析它。</p>
<p>解析动作主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>这7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CON-STANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、<br>CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info 8种常量类型</p>
<p>后4种(CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info和CONSTANT_InvokeDynamic_info)，它们都和动态语言支持密切相关</p>
<h4 id="4-1-类或接口的解析"><a href="#4-1-类或接口的解析" class="headerlink" title="4.1 类或接口的解析"></a>4.1 类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个<strong>从未解析过的符号引用N</strong>解析为一个<strong>类或接口C的直接引用</strong>，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<ol>
<li><p>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</p>
</li>
<li><p>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</p>
</li>
<li><p>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，<br>但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p>
</li>
</ol>
<p>针对上面第3点访问权限验证，在JDK 9引入了模块化以后，一个public类型也不再意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。</p>
<p>如果我们说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：</p>
<ul>
<li>被访问类C是public的，并且与访问类D处于同一个模块。</li>
<li>被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块允许被访问类D的模块进行访问</li>
<li>被访问类C不是public的，但是它与访问类D处于同一个包中</li>
</ul>
<h4 id="4-2-字段解析"><a href="#4-2-字段解析" class="headerlink" title="4.2 字段解析"></a>4.2 字段解析</h4><p>要解析一个未被解析过的字段符号引用，</p>
<ul>
<li><p>首先将会对字段表内class_index[3]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。</p>
<ul>
<li><p>如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。</p>
</li>
<li><p>如果解析成功完成，那把这个字段所属的类或接口用C表示，</p>
</li>
</ul>
</li>
</ul>
<p>《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：</p>
<ol>
<li><p>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
</li>
<li><p>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</p>
</li>
</ol>
<p> 如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<p>如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac编译器就可能直接拒绝其编译为Class文件。</p>
<p>在代码清单7-4中演示了这种情况，如果注释了Sub类中的“public static int A=4；”，接口与父类同时存在字段A，那Oracle公司实现的Javac编译器将提示“<strong>The field Sub.A is ambiguous</strong>”，并且会拒绝编译这段代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class FieldResolution &#123;</span><br><span class="line"></span><br><span class="line">    interface Interface0 &#123;</span><br><span class="line">        int A = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Interface1 extends Interface0 &#123;</span><br><span class="line">        int A = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Interface2 &#123;</span><br><span class="line">        int A = 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Parent implements Interface1 &#123;</span><br><span class="line">        public static int A = 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Sub extends Parent implements Interface2 &#123;</span><br><span class="line">        public static int A = 4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/uploads/jvm/08ClassLoading/02-analysisError.png"></p>
<h4 id="4-3-方法解析"><a href="#4-3-方法解析" class="headerlink" title="4.3 方法解析"></a>4.3 方法解析</h4><p>方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的class_index[4]项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，</p>
<p>接下来虚拟机将会按照如下步骤进行后续的方法搜索：(TODO 不是很理解，回头看 <strong>字节码结构</strong>)</p>
<p>ps :简单名称则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</p>
<ol>
<li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang.IncompatibleClassChangeError异常。</li>
<li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</li>
</ol>
<p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此<br>方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p>
<h4 id="4-4-接口方法解析"><a href="#4-4-接口方法解析" class="headerlink" title="4.4 接口方法解析"></a>4.4 接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，</p>
<p>如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<ol>
<li>与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法,但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li>
<li>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ol>
<p>在JDK 9之前，Java接口中的所有方法都默认是public的，也没有模块化的访问约束，所以不存在访问权限的问题，接口方法的符号解析就不可能抛出java.lang.IllegalAccessError异常。</p>
<p>但在JDK 9中增加了接口的静态私有方法，也有了模块化的访问约束，所以从JDK 9起，接口方法的访问也完全有可能因访问权限控制而出现java.lang.IllegalAccessError异常。</p>
<p>[1] invokedynamic指令是在JDK 7时加入到字节码中的，当时确实只为了做动态语言（如JRuby、<br>Scala）支持，Java语言本身并不会用到它。而到了JDK 8时代，Java有了Lambda表达式和接口的默认方<br>法，它们在底层调用时就会用到invokedynamic指令，这时再提动态语言支持其实已不完全切合，我们<br>就只把它当个代称吧。笔者将会在第8章中介绍这部分内容。<br>[2] 严格来说，CONSTANT_String_info这种类型的常量也有解析过程，但是很简单而且直观，不再做<br>独立介绍。<br>[3] 参见第6章中关于CONSTANT_Fieldref_info常量的相关内容。<br>[4] 参见第6章关于CONSTANT_Methodref_info常量的相关内容。<br>[5] 参见第6章中关于CONSTANT_InterfaceMethodref_info常量的相关内容。</p>
<h3 id="5-初始化-应用程序发挥作用-clinit"><a href="#5-初始化-应用程序发挥作用-clinit" class="headerlink" title="5.初始化(应用程序发挥作用 clinit)"></a>5.初始化(应用程序发挥作用 clinit)</h3><p>类的初始化阶段是类加载过程的最后一个步骤，</p>
<p>之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全<strong>由Java虚拟机来主导控制</strong>。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将<strong>主导权移交给应用程序</strong>。</p>
<p>进行<strong>准备阶段</strong>时，变量已经赋过一次系统要求的<strong>初始零值</strong>，而在<strong>初始化阶段</strong>，则会根据程序员通过<strong>程序编码</strong>制定的主观计划去初始化类变量和其他资源。</p>
<p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及<clinit>()方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作[1]。</p>
<p><clinit>()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块</strong>（static{}块）中的语句合并产生的，</p>
<p><strong>编译器收集的顺序</strong>是由语句在源文件中<strong>出现的顺序</strong>决定的，静态语句块中只能访问到<strong>定义在静态语句块之前</strong>的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如代码清单7-5所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过</span></span><br><span class="line">        System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值<br>操作，如代码清单7-6中，字段B的值将会是2而不是1。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test01 &#123;</span><br><span class="line">    static class Parent &#123;</span><br><span class="line">        public static int A = 1;  //step1</span><br><span class="line">        static &#123;</span><br><span class="line">            A = 2; //step2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Sub extends Parent &#123;</span><br><span class="line">        public static int B = A; //step3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Sub.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果： 2</span><br></pre></td></tr></table></figure>

<ul>
<li><p><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</p>
</li>
<li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</p>
</li>
<li><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，</p>
<ul>
<li>如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等<br>待，直到活动线程执行完毕<clinit>()方法。</li>
</ul>
</li>
<li><p>如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞[2]，在实际应用中这种阻塞往往是很隐蔽的。</p>
<p>  代码清单7-7演示了这种场景。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLoopClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不加上这个if语句，编译器将提示“Initializer does not complete normally”并拒绝编译</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;init DeadLoopClass&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable script = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">                DeadLoopClass dlc = <span class="keyword">new</span> DeadLoopClass();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot; run over&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(script);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果如下，一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待：</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">0</span>,<span class="number">5</span>,main]start</span><br><span class="line">Thread[Thread-<span class="number">1</span>,<span class="number">5</span>,main]init DeadLoopClass</span><br></pre></td></tr></table></figure>

<p>[2] 需要注意，其他线程虽然会被阻塞，但如果执行＜clinit＞()方法的那条线程退出＜clinit＞()方法后，其他线程唤醒后则不会再次进入＜clinit＞()方法。同一个类加载器下，一个类型只会被初始化一次。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinshi</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"4oBiQGiWDHdACABLWjT7ouaV-gzGzoHsz","appKey":"fr4vMSPUjcHLtIrF2hmRF6UE","serverURLs":"https://4obiqgiw.lc-cn-n1-shared.com","placeholder":"国王不动，手下怎么跟随? --反叛的鲁鲁修","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"cdh":"https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"}, {
      el: '#valine-comments',
      path: "/page/3/",
      serverURLs: "https://4obiqgiw.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>


</body>
</html>
