<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="HCj467TtuvFkAzzdCvYvbniAeNiUy7TUwp2hG1qGWQE">
  <meta name="baidu-site-verification" content="LppFIbSdZO">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"limingzhang666.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":false,"sidebar":{"position":"left","width":320,"display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="拨开云雾见青天">
<meta property="og:type" content="website">
<meta property="og:title" content="Yinshi&#39;s Blog">
<meta property="og:url" content="https://limingzhang666.github.io/page/3/index.html">
<meta property="og:site_name" content="Yinshi&#39;s Blog">
<meta property="og:description" content="拨开云雾见青天">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yinshi">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://limingzhang666.github.io/page/3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yinshi's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Yinshi's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook" rel="section"><i class="fa fa-book fa-fw"></i>留言</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yinshi"
      src="/images/yinshi01_avatar.jpg">
  <p class="site-author-name" itemprop="name">Yinshi</p>
  <div class="site-description" itemprop="description">拨开云雾见青天</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">74</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/limingzhang666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;limingzhang666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:laimingcham@163.com" title="E-Mail → mailto:laimingcham@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/limingzhang666" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">java高并发详解-08-线程池原理以及自定义线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-24 20:33:31" itemprop="dateCreated datePublished" datetime="2021-02-24T20:33:31+08:00">2021-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/24/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-08-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>线程池主要是为了重复利用线程，提高效率</li>
<li>因为线程是一个重量级的资源，创建、启动以及销毁都是比较耗费资源的，因此对线程重复利用是一种好的程序设计习惯</li>
<li>系统中可创建的线程数量是有限的，线程数量和系统性能是一种抛物线的关系</li>
<li>本章主要从原理入手，设计一个线程池，理解一个线程池应该具有哪些功能，需要注意哪些细节</li>
</ul>
<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p>一个完整的线程池应该具备如下要素</p>
<ul>
<li><p>任务队列： 用户缓存提交的任务</p>
</li>
<li><p>线程数量管理功能： 一个线程池必须能够很好的管理 和控制线程的数量，可以通过3个参数来实现：</p>
<ul>
<li>创建线程池时 初始的线程数量init</li>
<li>线程池自动扩充的最大线程数量max</li>
<li>在线程池空闲的时候需要释放线程，但是也要维护一定数量的活跃数量或者核心数量 core</li>
</ul>
<p>有了这3个参数，就能够很好的控制线程池中的线程数量，将其维护在一个合理的范围之内，三者关系是  init&lt;=core&lt;=max</p>
</li>
<li><p>任务拒绝策略： 如果线程数量已达到上限且任务队列已满，则需要有相应的拒绝策略来通知任务提交者。</p>
</li>
<li><p>线程工厂： 用于个性化定制线程，比如将线程设置为守护线程以及设置线程名称等</p>
</li>
<li><p>QueueSize： 任务队列主要存放 提交的Runnable，但是为了防止内存溢出，需要有limit 数量对其进行控制</p>
</li>
<li><p>KeepedAlive时间： 该时间主要决定线程各个重要参数自动维护的时间间隔</p>
</li>
</ul>
<p><img src="/uploads/java-concurrency-master/ThreadPoolPrinciple.png"></p>
<h1 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h1><p><img src="/uploads/java-concurrency-master/ThreadPoolImpl.png"></p>
<h2 id="线程池接口定义"><a href="#线程池接口定义" class="headerlink" title="线程池接口定义"></a>线程池接口定义</h2><ol>
<li><p>ThreadPool</p>
<p>ThreadPool主要顶一个了一个线程池应该具备的基本操作和方法，</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务到线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池大小,返回初始线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getInitSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池最大线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池的核心线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCoreSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中用户缓存任务队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中活跃线程的数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//查看线程池是否已经被shutdown</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>RunnableQueue</p>
<p>RunnableQueue 用于存放提交的Runnable，该Runnable是一个BlockedQueue，并且有limit的限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务队列，用户缓存提交到线程池中的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当有新任务进来时候，首先会offer 到队列中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作线程通过take方法 获取Runnable</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Runnable <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务队列中任务的数量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>ThreadFactory</p>
<p>THreadFactory 提供创建线程的接口，以便于个性化的定制 Thread，比如应该被加入到哪个 group中，优先级，线程名字以及是否为守护线程等</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">createThread</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>DenyPolicy</p>
<p>DenyPolicy主要用于 当Queue中的runnable 达到了limit上限的时候， 决定采用何种策略通知提交者。该接口中默认定义了3中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现1： 直接将任务丢弃</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DiscardDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现2： 像任务提交者抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AbortDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RunnableDenyException(<span class="string">&quot;The runnable &quot;</span> + runnable + <span class="string">&quot; will be abort.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认实现3： 在提交者所在的线程中执行任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RunnerDenyPolicy</span> <span class="keyword">implements</span> <span class="title">DenyPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable runnable, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!threadPool.isShutdown()) &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>RunnableDenyException</p>
<p>RunnableDenyException 是RuntimeException的子类，主要用于通知 任务提交者，任务队列已无法再接受新的任务</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDenyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableDenyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>InternalTask</p>
<p>InternalTask 是 Runnable的一个实现，主要用于线程池内部，该类会使用到 RunnableQueue，然后不断地从queue中取出某个runnable ，并且运行runnable的 run方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RunnableQueue runnableQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalTask</span><span class="params">(RunnableQueue runnableQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runnableQueue = runnableQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前任务为 running ，并且没有被中断，</span></span><br><span class="line">        <span class="keyword">while</span> (running &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 则其将不断地 从queue中获取 runnable，然后执行run方法</span></span><br><span class="line">                Runnable task = runnableQueue.take();</span><br><span class="line">                task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                running = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止当前任务，主要会在 线程池的shutdown 方法中使用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程池的详细实现"><a href="#线程池的详细实现" class="headerlink" title="线程池的详细实现"></a>线程池的详细实现</h2><ol>
<li><p>LinkedRunnableQueue (将runnableList 作为同步锁 对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedRunnableQueue</span> <span class="keyword">implements</span> <span class="title">RunnableQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务队列的最大容量，在构造时候传入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="comment">// 假如任务队列中的任务满了，则需要执行拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DenyPolicy denyPolicy;</span><br><span class="line">    <span class="comment">// 用于存放任务的队列（双向循环列表）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Runnable&gt; runnableList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPool threadPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedRunnableQueue</span><span class="params">(<span class="keyword">int</span> limit, DenyPolicy denyPolicy, ThreadPool threadPool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        <span class="keyword">this</span>.denyPolicy = denyPolicy;</span><br><span class="line">        <span class="keyword">this</span>.threadPool = threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runnableList.size() &gt;= limit) &#123;</span><br><span class="line">                <span class="comment">// 无法容纳新的任务时，执行拒绝策略</span></span><br><span class="line">                denyPolicy.reject(runnable, threadPool);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将任务假如到队尾，并且唤醒阻塞中的线程</span></span><br><span class="line">                runnableList.addLast(runnable);</span><br><span class="line">                runnableList.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Runnable <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="comment">// 如果任务队列中没有可执行的任务，则将当前线程挂起，进入 runnablelist 关联的wait set中等待唤醒</span></span><br><span class="line">            <span class="comment">// （有新任务假如时，会被唤醒）</span></span><br><span class="line">            <span class="keyword">while</span> (runnableList.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runnableList.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 被中断时，需要将该异常抛出，通知上游 InternalTask</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从任务队列头部移除一个任务</span></span><br><span class="line">            <span class="keyword">return</span> runnableList.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回当前任务队列中的任务数量</span></span><br><span class="line">        <span class="keyword">synchronized</span> (runnableList) &#123;</span><br><span class="line">            <span class="keyword">return</span> runnableList.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>2.初始化线程池 (线程池本身也是一个线程)</p>
<p>线程池需要有数量控制属性（）、创建线程工厂（ThreadFactory）、任务队列策略（DenyPolicy） 等功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池本身自己也是一个线程，需要keepAlive，更新容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThreadPool</span> <span class="keyword">extends</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> initSize;</span><br><span class="line">    <span class="comment">//线程池最大线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//线程池核心线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 当前活跃的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> activeCount;</span><br><span class="line">    <span class="comment">// 创建线程工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RunnableQueue runnableQueue;</span><br><span class="line">    <span class="comment">// 线程池是否已经被shutdown</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isShutdown = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 工作线程队列（存放活跃线程）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;ThreadTask&gt; threadQueue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DenyPolicy DEFAULT_DENY_POLICY = <span class="keyword">new</span> DenyPolicy.DiscardDenyPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadFactory DEFAULT_THREAD_FACTORY = <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeUnit timeUnit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initSize  初始的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize   最大的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize  核心线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueSize 任务队列的最大数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicThreadPool</span><span class="params">(<span class="keyword">int</span> initSize, <span class="keyword">int</span> maxSize, <span class="keyword">int</span> coreSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> queueSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initSize, maxSize, coreSize, DEFAULT_THREAD_FACTORY,</span><br><span class="line">                queueSize, DEFAULT_DENY_POLICY, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造线程池需要传入的参数，更多</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initSize      初始的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxSize       最大的线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coreSize      核心线程数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory 创建线程工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueSize     任务队列的最大数量（最大任务数）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> denyPolicy    任务队列满后的拒绝策略</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicThreadPool</span><span class="params">(<span class="keyword">int</span> initSize, <span class="keyword">int</span> maxSize, <span class="keyword">int</span> coreSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory, <span class="keyword">int</span> queueSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           DenyPolicy denyPolicy, <span class="keyword">long</span> keepAliveTime, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initSize = initSize;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.runnableQueue = <span class="keyword">new</span> LinkedRunnableQueue(queueSize, denyPolicy, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="keyword">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时，先创建initSize 个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initSize; i++) &#123;</span><br><span class="line">            newThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务，只需要将 runnable插入任务队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">this</span>.runnableQueue.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池的自动维护，具体逻辑看 InternalTask的run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InternalTask internalTask = <span class="keyword">new</span> InternalTask(runnableQueue);</span><br><span class="line">        Thread thread = <span class="keyword">this</span>.threadFactory.createThread(internalTask);</span><br><span class="line">        ThreadTask threadTask = <span class="keyword">new</span> ThreadTask(thread, internalTask);</span><br><span class="line">        threadQueue.offer(threadTask);</span><br><span class="line">        <span class="keyword">this</span>.activeCount++;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从线程池中 remove 某个线程</span></span><br><span class="line">        ThreadTask threadTask = threadQueue.remove();</span><br><span class="line">        threadTask.internalTask.stop();</span><br><span class="line">        <span class="keyword">this</span>.activeCount--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 主要用于维护线程数量，比如 扩容、回收等工作</span></span><br><span class="line">        <span class="keyword">while</span> (!isShutdown &amp;&amp; !isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                timeUnit.sleep(keepAliveTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                isShutdown = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShutdown)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(runnableQueue.size() + <span class="string">&quot;==&quot;</span> + activeCount);</span><br><span class="line">                <span class="comment">// 当前队列中 有任务尚未处理，并且 activeCount&lt; coreSize 则继续扩容</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() &gt; <span class="number">0</span> &amp;&amp; activeCount &lt; coreSize) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = initSize; i &lt; coreSize; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;--create&quot;</span>);</span><br><span class="line">                        newThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前队列中 有任务尚未处理，并且 activeCount&lt; maxSize 则继续扩容</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() &gt; <span class="number">0</span> &amp;&amp; activeCount &lt; maxSize) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = coreSize; i &lt; maxSize; i++) &#123;</span><br><span class="line">                        newThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果任务队列中 没有任务，则需要回收，回收至 coreSize 即可</span></span><br><span class="line">                <span class="keyword">if</span> (runnableQueue.size() == <span class="number">0</span> &amp;&amp; activeCount &gt; maxSize) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;remove...&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = coreSize; i &lt; maxSize; i++) &#123;</span><br><span class="line">                        removeThread();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShutdown) <span class="keyword">return</span>;</span><br><span class="line">            isShutdown = <span class="keyword">true</span>;</span><br><span class="line">            threadQueue.forEach(threadTask -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                threadTask.internalTask.stop();</span><br><span class="line">                threadTask.thread.interrupt();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">this</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInitSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.initSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCoreSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.coreSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The thread pool is destroy&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> runnableQueue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.activeCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isShutdown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger GROUP_COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadGroup group = <span class="keyword">new</span> ThreadGroup(<span class="string">&quot;MyThreadPool-&quot;</span> + GROUP_COUNTER.getAndDecrement());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">createThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(group, runnable, <span class="string">&quot;thread-pool-&quot;</span> + COUNTER.getAndDecrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadTask 只是 InternalTask和Thread的一个组合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadTask</span><span class="params">(Thread thread, InternalTask internalTask)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">            <span class="keyword">this</span>.internalTask = internalTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread thread;</span><br><span class="line"></span><br><span class="line">        InternalTask internalTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BasicThreadPool 同时也是Thread的子类，它在初始化的时候启动，在keepalive时间到了之后，再自动维护活动线程数量</li>
<li>TODO： BasicThreadPool 采用继承Thread的方式，不好的方式，会暴露Thread的方法，建议 改为组合关系，TODO 后面我这边会自行修改 </li>
</ul>
<h3 id="线程自动维护"><a href="#线程自动维护" class="headerlink" title="线程自动维护"></a>线程自动维护</h3><ul>
<li>自动维护线程的代码块（run方法） 是同步代码块，主要是为了阻止在线程维护过程中 线程池销毁引起的数据不一致的问题</li>
<li>任务队列中若存在积压任务，并且当前活动线程少于核心线程数，则新建 （CoreSize-initSize）数量的线程，并且将其假如到活动线程队列中，为了防止马上进行 （maxSize-coreSize）数量的扩充，建议使用 continue 终止本次循环</li>
<li>任务队列中有 积压任务，并且当前活动线程少于 最大线程数，则新建（maxSIze-coreSIze）数量的扩充，建议使用 continue 终止本次循环</li>
<li>当线程池不够繁忙时，则需要回收部分线程，回收到coreSize 数量即可，回收时调用removeThread（）方法，在该方法中需要考虑的一点是，如果被回收的线程恰巧从Runnable任务取出了某个任务，则会继续保持该线程的运行，知道完成了任务的运行为止 。详情见 InterTask 的run方法</li>
</ul>
<h3 id="线程池销毁shutdown"><a href="#线程池销毁shutdown" class="headerlink" title="线程池销毁shutdown"></a>线程池销毁shutdown</h3><ul>
<li>线程池的销毁同样需要同步机制的保护，主要是 为了防止与线程池本身的维护线程引起数据冲突</li>
</ul>
<h1 id="线程池的应用"><a href="#线程池的应用" class="headerlink" title="线程池的应用"></a>线程池的应用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ThreadPool threadPool = <span class="keyword">new</span> BasicThreadPool(<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">            threadPool.execute(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is running and done.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (; ; )</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getActiveCount:&quot; + threadPool.getActiveCount());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getQueueSize:&quot; + threadPool.getQueueSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getCoreSize:&quot; + threadPool.getCoreSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;getMaxSize:&quot; + threadPool.getMaxSize());</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;======================================&quot;);</span></span><br><span class="line"><span class="comment">//            TimeUnit.SECONDS.sleep(5);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">12</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>TODO： 看看 JDK 的 ExecutorService的原理和源码，据说是类似的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">java高并发详解-07-Hook线程以及捕获线程执行异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-23 21:30:24" itemprop="dateCreated datePublished" datetime="2021-02-23T21:30:24+08:00">2021-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-07-Hook%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8D%95%E8%8E%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%BC%82%E5%B8%B8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>学习如何获取线程在运行时期的异常信息</li>
<li>学习如何向Java程序注入 Hook线程</li>
</ul>
<h1 id="获取线程运行时异常"><a href="#获取线程运行时异常" class="headerlink" title="获取线程运行时异常"></a>获取线程运行时异常</h1><p>在Thread类中，关于处理运行时异常的API总共有4个，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.  为某个特定线程 指定 UncaughtExceptionHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(</span><br><span class="line">                <span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setDefaultUncaughtExceptionHandler&quot;</span>)</span><br><span class="line">                    );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         defaultUncaughtExceptionHandler = eh;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//2. 设置全局的 UncaughtExceptionHandler</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UncaughtExceptionHandler <span class="title">getDefaultUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defaultUncaughtExceptionHandler;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//3.  获取特定线程的 UncaughtExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">            uncaughtExceptionHandler : group;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4.  获取全局的 UncaughtExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler eh)</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        uncaughtExceptionHandler = eh;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="UncaughtExceptionHandler的介绍"><a href="#UncaughtExceptionHandler的介绍" class="headerlink" title="UncaughtExceptionHandler的介绍"></a>UncaughtExceptionHandler的介绍</h2><ul>
<li>线程在执行单元中时不允许抛出checked异常的</li>
<li>线程运行在自己的上下文中，派生它的线程将无法直接获得它运行中出现的异常信息</li>
</ul>
<p>所以Java为我们提供了一个 UncaughtExceptionHandler 接口，</p>
<ul>
<li>当线程在运行过程中出现了异常时，会回调UncaughtExceptionHandler 接口，从而我们得知 哪个线程在运行时出错，以及错误类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Interface for handlers invoked when a &lt;tt&gt;Thread&lt;/tt&gt; abruptly</span></span><br><span class="line"><span class="comment">     * terminates due to an uncaught exception.</span></span><br><span class="line"><span class="comment">     （当一个线程突然的终结了由于一个未被捕获的异常，这个时候这个handler会被调用 ）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;When a thread is about to terminate due to an uncaught exception</span></span><br><span class="line"><span class="comment">     * the Java Virtual Machine will query the thread for its</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt; using</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #getUncaughtExceptionHandler&#125; and will invoke the handler&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;uncaughtException&lt;/tt&gt; method, passing the thread and the</span></span><br><span class="line"><span class="comment">     * exception as arguments.</span></span><br><span class="line"><span class="comment">     （当线程由于未捕获的异常即将终止时，Java虚拟机将查询它的线程 为了给 UncaughtExceptionHandler做参数，JVM 传递线程和</span></span><br><span class="line"><span class="comment">*异常作为参数给 uncaughtException方法）</span></span><br><span class="line"><span class="comment">     * If a thread has not had its &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * explicitly set, then its &lt;tt&gt;ThreadGroup&lt;/tt&gt; object acts as its</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;UncaughtExceptionHandler&lt;/tt&gt;. If the &lt;tt&gt;ThreadGroup&lt;/tt&gt; object</span></span><br><span class="line"><span class="comment">     * has no</span></span><br><span class="line"><span class="comment">     * special requirements for dealing with the exception, it can forward</span></span><br><span class="line"><span class="comment">     * the invocation to the &#123;<span class="doctag">@linkplain</span> #getDefaultUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * default uncaught exception handler&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setDefaultUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setUncaughtExceptionHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ThreadGroup#uncaughtException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Method invoked when the given thread terminates due to the</span></span><br><span class="line"><span class="comment">         * given uncaught exception.</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Any exception thrown by this method will be ignored by the</span></span><br><span class="line"><span class="comment">         * Java Virtual Machine.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> t the thread</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e the exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该回调接口会被Thread 中的dispatchUncaughtException方法调用，如下所示：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch an uncaught exception to the handler. This method is</span></span><br><span class="line"><span class="comment"> * intended to be called only by the JVM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchUncaughtException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    getUncaughtExceptionHandler().uncaughtException(<span class="keyword">this</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 当线程在运行过程中出现异常时，JVM会调用dispatchUncaughtException方法，该方法会将对应的线程实例以及异常信息传递给回调接口</li>
</ul>
<h2 id="UncaughtExceptionHandler-实例"><a href="#UncaughtExceptionHandler-实例" class="headerlink" title="UncaughtExceptionHandler 实例"></a>UncaughtExceptionHandler 实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureThreadException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler((t, e) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot; occur exception&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//here will throw unchecked exception.</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Test-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    Test-Thread occur exception</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.CaptureThreadException.lambda$main$<span class="number">1</span>(CaptureThreadException.java:<span class="number">22</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.CaptureThreadException$$Lambda$<span class="number">2</span>/<span class="number">1078694789.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这种设计方式是比较常见的，（在后面的设计模式也会讲到），尤其是那种异步执行方法，</li>
<li>比如Google 的guava toolkit就提供了 EventBus ，在EventBus 中事件源和实践的subscriber两者 借助EventBus 实现了完全的解耦合，但是在subscriber执行任务时有可能会出现异常i情况，EventBus也是借助于一个ExceptionHandler进行回调处理的 </li>
</ul>
<h2 id="UncaughtExceptionHandler-源码分析"><a href="#UncaughtExceptionHandler-源码分析" class="headerlink" title="UncaughtExceptionHandler 源码分析"></a>UncaughtExceptionHandler 源码分析</h2><p>当 没有主动的 向线程 注入UncaughtExceptionHandler 回调接口的情况下，线程加入出现了异常 又将如何处理呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns the handler invoked when this thread abruptly terminates</span></span><br><span class="line"><span class="comment">  * due to an uncaught exception. If this thread has not had an</span></span><br><span class="line"><span class="comment">  * uncaught exception handler explicitly set then this thread&#x27;s</span></span><br><span class="line"><span class="comment">  * &lt;tt&gt;ThreadGroup&lt;/tt&gt; object is returned, unless this thread</span></span><br><span class="line"><span class="comment">  * has terminated, in which case &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the uncaught exception handler for this thread</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">         uncaughtExceptionHandler : group;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getUncaughtExceptionHandler 方法首先会判断当前线程是否设置了handler，</p>
<ul>
<li>如果有则执行线程自己的uncaughtException方法 ，</li>
<li>否则就到所在的ThreadGroup中获取</li>
</ul>
</li>
<li><p>ThreadGroup同样也实现了UncaughtExceptionHandler接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">            <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ueh.uncaughtException(t, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">                System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span></span><br><span class="line">                                 + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先 ThreadGroup实现了  Thread.UncaughtExceptionHandler  接口</p>
<ol>
<li>该 ThreadGroup如果有父 ThreadGroup，则直接调用 父group的 uncaughtException方法</li>
<li>如果 设置了全局默认的 UncaughtExceptionHandler  ，则调用全局的 uncaughtException方法</li>
<li>如果既没有父 ThreadGroup，也没有全局默认的 UncaughtExceptionHandler  ， 则直接 将异常的堆栈信息定向到 System.err中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// get current thread&#x27;s thread group</span></span><br><span class="line">        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();</span><br><span class="line">        System.out.println(mainGroup.getName());</span><br><span class="line">        System.out.println(mainGroup.getParent());</span><br><span class="line">        System.out.println(mainGroup.getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//here will throw unchecked exception.</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;Test-Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果： </span><br><span class="line">    main</span><br><span class="line">java.lang.ThreadGroup[name=system,maxpri=<span class="number">10</span>]</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">Exception in thread <span class="string">&quot;Test-Thread&quot;</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.EmptyExceptionHandler.lambda$main$<span class="number">0</span>(EmptyExceptionHandler.java:<span class="number">21</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter07.EmptyExceptionHandler$$Lambda$<span class="number">1</span>/<span class="number">295530567.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码 既没有设置默认的Handler ,也没有对thread指定Handler，因此当thread出现异常时，会向上寻找 Group的 uncaughtException方法</li>
</ul>
<pre class="mermaid">graph LR
线程出现异常 -->MainGroup -->SystemGroup -->System.err</pre>

<pre class="mermaid">graph TD
线程出现异常 -->getUncaughtExceptionHandler{当前线程是否设置了异常处理器}
getUncaughtExceptionHandler -->|uncaughtExceptionHandler不为空| CurrThread[当前线程异常处理器处理]
getUncaughtExceptionHandler -->|uncaughtExceptionHandler为空| group[找所在 group]

group --> 父group{是否存在父group}
父group -->|父group存在| parent.uncaughtException[父group去处理]
父group -->|父group不存在| getDefaultUncaughtExceptionHandler[找全局默认的UncaughtExceptionHandler]

getDefaultUncaughtExceptionHandler -->DefaultUncaughtExceptionHandler{是否设置全局DefaultUncaughtExceptionHandler}
DefaultUncaughtExceptionHandler -->|DefaultUncaughtExceptionHandler不为空|Defaultueh.uncaughtException[DefaultUncaughtExceptionHandler处理]
DefaultUncaughtExceptionHandler -->|DefaultUncaughtExceptionHandler为空|System.err.print[输出异常堆栈]</pre>

<h1 id="注入钩子函数"><a href="#注入钩子函数" class="headerlink" title="注入钩子函数"></a>注入钩子函数</h1><h2 id="Hook线程介绍"><a href="#Hook线程介绍" class="headerlink" title="Hook线程介绍"></a>Hook线程介绍</h2><p>JVM进程的退出是由于： <strong>JVM进程中没有活跃的非守护线程，或者收到了系统中断信号</strong>，向JVM程序注入一个 Hook线程，在JVM进程退出的时候，Hook 线程会启动执行，<strong>通过Runtime可以为JVM注入多个Hook线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadHook</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Hook线程1</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The hook thread 2 is running.&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;The program will exit.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// Hook线程2 </span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;The hook thread 2 is running.&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;The hook thread 2 will exit.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// JVM 退出信号</span></span><br><span class="line">        System.out.println(<span class="string">&quot;The program will is stopping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">    The program will is stopping.</span><br><span class="line">The hook thread <span class="number">2</span> is running.</span><br><span class="line">The hook thread <span class="number">2</span> is running.</span><br><span class="line">The program will exit.</span><br><span class="line">The hook thread <span class="number">2</span> will exit.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>给Java程序注入了两个Hook线程，在main线程中结束，也就是JVM中没有了活动的非守护线程</li>
<li>jvm进程即将退出时，两个Hook线程会被启动并且运行 </li>
</ul>
<h2 id="Hook线程实战"><a href="#Hook线程实战" class="headerlink" title="Hook线程实战"></a>Hook线程实战</h2><p>我们在开发中经常会遇到Hook线程，比如：</p>
<ul>
<li>为了防止某个程序被重复启动，在启动时会创建一个lock文件，进程收到中断信号时候会删除lock文件，我们在mysql 服务器、zookeeper、kafka等系统都能看到lock文件的存在</li>
</ul>
<p>本代码利用hook线程的特点，模拟一个防止重复启动的程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreventDuplicated</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_PATH = <span class="string">&quot;/home/yinshi/locks/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LOCK_FILE = <span class="string">&quot;.lock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String PERMISSIONS = <span class="string">&quot;rw-------&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.注入hook线程，在程序退出时删除lock文件</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The program received kill SIGNAL.&quot;</span>);</span><br><span class="line">            getLockFile().toFile().delete();</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">// 2.检查是否存在 .lock文件</span></span><br><span class="line">        checkRunning();</span><br><span class="line">		<span class="comment">//3.简单模拟程序running</span></span><br><span class="line">        <span class="comment">//simulate the program is running.</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;program is running.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkRunning</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = getLockFile();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.toFile().exists())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;The program already running.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString(PERMISSIONS);</span><br><span class="line">        Files.createFile(path, PosixFilePermissions.asFileAttribute(perms));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Path <span class="title">getLockFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Paths.get(LOCK_PATH, LOCK_FILE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行kill pid 或者 kill -1 pid 命令后，JVM进程会收到中断信号，并且启动hook线程 删除.lock文件</li>
</ul>
<h2 id="Hook线程应用场景以及注意事项"><a href="#Hook线程应用场景以及注意事项" class="headerlink" title="Hook线程应用场景以及注意事项"></a>Hook线程应用场景以及注意事项</h2><ul>
<li>hook线程只有在收到退出信号的时候会被执行，如果 是 kill -9 ，那么Hook线程不会得到执行，进程将会退出，因此 .lock文件将得不到清理</li>
<li>hook线程中也可以执行 一些资源释放的工作，比如 关闭文件句柄、socket链接、数据库connection等</li>
<li>尽量不要在 Hook线程中执行一些耗时非常长的操作，因为其会导致程序迟迟不能退出</li>
</ul>
<h1 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h1><ul>
<li>知道了如何通过Handler回调的方式获取线程运行期间的异常信息， </li>
<li>分析了Thread的源码 和 ThreadGroup的源码，追踪uncaughtException的执行顺序</li>
<li>了解了Hook的执行时机，帮助程序获得进程中断的信号，有机会在进程退出之前做一些资源释放或者告警通知</li>
<li>如果强制杀死进程，（比如kill -9） 那么进程将不会收到任何中断信号</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java高并发详解-06-ThreadGroup详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-23 00:08:17" itemprop="dateCreated datePublished" datetime="2021-02-23T00:08:17+08:00">2021-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-06-ThreadGroup%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>创建线程的时候如果没有显示得指定ThreadGroup，那么新的线程会被加入到父线程相同的ThreadGroup中</li>
<li>其实这里主要就是看ThreadGroup的源码，以及Thread的源码，就可以知道关于Thread的一些规则，比如 Thread的优先级 的范围，以及不能超过ThreadGroup的MAX</li>
</ul>
<h1 id="ThreadGroup-与Thread"><a href="#ThreadGroup-与Thread" class="headerlink" title="ThreadGroup 与Thread"></a>ThreadGroup 与Thread</h1><h2 id="创建ThreadGroup"><a href="#创建ThreadGroup" class="headerlink" title="创建ThreadGroup"></a>创建ThreadGroup</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是private ，不对外暴露</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadGroup</span><span class="params">(Void unused, ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.maxPriority = parent.maxPriority;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.daemon;</span><br><span class="line">        <span class="keyword">this</span>.vmAllowSuspension = parent.vmAllowSuspension;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        parent.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个构造函数为 ThreadGroup赋予了名字，它的默认父 ThreadGroup是创建它的线程所在的ThreadGroup</li>
<li>第二构造函数赋予group名字的同时，显示指定了父ThreadGroup</li>
</ul>
<h2 id="复制Thread数组和ThreadGroup数组"><a href="#复制Thread数组和ThreadGroup数组" class="headerlink" title="复制Thread数组和ThreadGroup数组"></a>复制Thread数组和ThreadGroup数组</h2><h3 id="复制Thread数组"><a href="#复制Thread数组" class="headerlink" title="复制Thread数组"></a>复制Thread数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies into the specified array every active thread in this</span></span><br><span class="line"><span class="comment">     * thread group and its subgroups.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment">     * way as the invocation</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> #enumerate(Thread[], boolean) enumerate&#125;&#123;<span class="doctag">@code</span> (list, true)&#125;</span></span><br><span class="line"><span class="comment">     * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  list</span></span><br><span class="line"><span class="comment">     *         an array into which to put the list of threads</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the number of threads put into the array</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">     *          if &#123;<span class="doctag">@linkplain</span> #checkAccess checkAccess&#125; determines that</span></span><br><span class="line"><span class="comment">     *          the current thread cannot access this thread group</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[])</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copies into the specified array every active thread in this</span></span><br><span class="line"><span class="comment">     * thread group. If &#123;<span class="doctag">@code</span> recurse&#125; is &#123;<span class="doctag">@code</span> true&#125;,</span></span><br><span class="line"><span class="comment">     * this method recursively enumerates all subgroups of this</span></span><br><span class="line"><span class="comment">     * thread group and references to every active thread in these</span></span><br><span class="line"><span class="comment">     * subgroups are also included. If the array is too short to</span></span><br><span class="line"><span class="comment">     * hold all the threads, the extra threads are silently ignored.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; An application might use the &#123;<span class="doctag">@linkplain</span> #activeCount activeCount&#125;</span></span><br><span class="line"><span class="comment">     * method to get an estimate of how big the array should be, however</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;if the array is too short to hold all the threads, the extra threads</span></span><br><span class="line"><span class="comment">     * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active</span></span><br><span class="line"><span class="comment">     * thread in this thread group, the caller should verify that the returned</span></span><br><span class="line"><span class="comment">     * int value is strictly less than the length of &#123;<span class="doctag">@code</span> list&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Due to the inherent race condition in this method, it is recommended</span></span><br><span class="line"><span class="comment">     * that the method only be used for debugging and monitoring purposes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层私有逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(Thread list[], <span class="keyword">int</span> n, <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ngroupsSnapshot = <span class="number">0</span>;</span><br><span class="line">        ThreadGroup[] groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nt = nthreads;</span><br><span class="line">            <span class="keyword">if</span> (nt &gt; list.length - n) &#123;</span><br><span class="line">                nt = list.length - n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nt; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (threads[i].isAlive()) &#123;</span><br><span class="line">                    list[n++] = threads[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">                ngroupsSnapshot = ngroups;</span><br><span class="line">                <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (recurse) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">                n = groupsSnapshot[i].enumerate(list, n, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的public 的2个方法，会将ThreadGroup 中active线程全部复制到Thread数组中，</li>
<li>其中recurse参数如果为True，则方法会将所有子 group的active线程全部递归到Thread数组中，</li>
<li>enumerate（list ）实际上等价于 enumerate（list，true）</li>
</ul>
<h3 id="复制ThreadGroup数组"><a href="#复制ThreadGroup数组" class="headerlink" title="复制ThreadGroup数组"></a>复制ThreadGroup数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[])</span> </span>&#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">enumerate</span><span class="params">(ThreadGroup list[], <span class="keyword">boolean</span> recurse)</span> </span>&#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       <span class="keyword">return</span> enumerate(list, <span class="number">0</span>, recurse);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和复制Thread数组类似，上面方法用于复制当前ThreadGroup的子 Group，同样recurse会决定是否以递归的方式复制</li>
</ul>
<h2 id="ThreadGroup操作"><a href="#ThreadGroup操作" class="headerlink" title="ThreadGroup操作"></a>ThreadGroup操作</h2><p>Threadgroup 并不能提供对线程的管理，主要功能是对线程提供组织</p>
<h3 id="ThreadGroup基本操作"><a href="#ThreadGroup基本操作" class="headerlink" title="ThreadGroup基本操作"></a>ThreadGroup基本操作</h3><ul>
<li>activeCount（）： 用于获取group中活跃的线程，只是一个估计值，该方法会递归获取其他子group中的活跃线程</li>
<li>activeGroupCount（）： 用于获取group中活跃的子group，只是一个估计值，该方法也会递归获取所有的子 group</li>
<li>getMaxPriority() 用于获取group的优先级，默认情况下，Group的优先级为10，在该group中，所有线程的优先级不能大于group的优先级</li>
<li>getName() 用于获取group的名字</li>
<li>getParent（）用于获取group的父 group，如果父group不存在，则会返回null ，比如system group的父group就是 null</li>
<li>list（）该方法没有返回值，执行该方法会将group中所有的活跃线程信息全部输出到控制台，也就是 System.out</li>
<li>parentOf（ThreadGroup g）会判断当前group是不是给定的group的父group ，另外如果给定的group就是本身，那么也返回true</li>
<li>setMaxPriority(int pri)会指定group的最大优先级 ，最大优先级不能超过父 group的最大优先级。执行该方法不仅仅会改变当前group的最大优先级，还会改变所有子goup的最大优先级</li>
</ul>
<p>ThreadGroup的interrupt</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Interrupts all threads in this thread group.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is</span></span><br><span class="line"><span class="comment">   * called with no arguments; this may result in a security exception.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * This method then calls the &lt;code&gt;interrupt&lt;/code&gt; method on all the</span></span><br><span class="line"><span class="comment">   * threads in this thread group and in all of its subgroups.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span>  SecurityException  if the current thread is not allowed</span></span><br><span class="line"><span class="comment">   *               to access this thread group or any of the threads in</span></span><br><span class="line"><span class="comment">   *               the thread group.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.Thread#interrupt()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.SecurityException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>        java.lang.ThreadGroup#checkAccess()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span>      1.2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">      ThreadGroup[] groupsSnapshot;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          checkAccess();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nthreads ; i++) &#123;</span><br><span class="line">              threads[i].interrupt();</span><br><span class="line">          &#125;</span><br><span class="line">          ngroupsSnapshot = ngroups;</span><br><span class="line">          <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">              groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i++) &#123;</span><br><span class="line">          groupsSnapshot[i].interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>interrupt一个thread group会导致 该group中所有的active 线程都被interrupt ，</li>
<li>也就说该 group中的每一个interrupt 标识都被设置了 </li>
<li>通过源码分析，可以看出interrupt内部会执行所有thread 的interrupt方法，并且会递归获取子 group，然后执行他们各自的interrupt方法</li>
</ul>
<h3 id="ThreadGroup的destory"><a href="#ThreadGroup的destory" class="headerlink" title="ThreadGroup的destory"></a>ThreadGroup的destory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroys this thread group and all of its subgroups. This thread</span></span><br><span class="line"><span class="comment"> * group must be empty, indicating that all threads that had been in</span></span><br><span class="line"><span class="comment"> * this thread group have since stopped.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is</span></span><br><span class="line"><span class="comment"> * called with no arguments; this may result in a security exception.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread group is not</span></span><br><span class="line"><span class="comment"> *               empty or if the thread group has already been destroyed.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  SecurityException  if the current thread cannot modify this</span></span><br><span class="line"><span class="comment"> *               thread group.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.ThreadGroup#checkAccess()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>      JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ngroupsSnapshot;</span><br><span class="line">    ThreadGroup[] groupsSnapshot;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (destroyed || (nthreads &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        ngroupsSnapshot = ngroups;</span><br><span class="line">        <span class="keyword">if</span> (groups != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            groupsSnapshot = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            destroyed = <span class="keyword">true</span>;</span><br><span class="line">            ngroups = <span class="number">0</span>;</span><br><span class="line">            groups = <span class="keyword">null</span>;</span><br><span class="line">            nthreads = <span class="number">0</span>;</span><br><span class="line">            threads = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ngroupsSnapshot ; i += <span class="number">1</span>) &#123;</span><br><span class="line">        groupsSnapshot[i].destroy();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>destory 用于销毁 ThreadGroup ，该方法只是针对一个没有任何active线程的group 进行一个 destory标记，调用该方法的结果是在父 group中将自己移除</li>
</ul>
<h3 id="守护ThreadGroup"><a href="#守护ThreadGroup" class="headerlink" title="守护ThreadGroup"></a>守护ThreadGroup</h3><ul>
<li>线程可以设置为守护线程，ThreadGroup也可以设置为 守护ThreadGroup，</li>
<li>但是将一个THreadGroup 设置为 daemon ，也并不会影响线程的daemon属性</li>
<li>如果一个 ThreadGroup 的daemon被设置为  true，那么在group中没有任何active线程的时候，该group将自动destory </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">java高并发详解-05-线程间通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-21 14:50:38" itemprop="dateCreated datePublished" datetime="2021-02-21T14:50:38+08:00">2021-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/21/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-05-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><p>线程间通信又称为 进程内通信，多个线程实现互斥访问共享资源时 会互相发送信号或等待信号</p>
</li>
<li><p>主要是 线程之间 wait，notify，notifyAll ，以及背后的原理内幕</p>
</li>
<li><p>wait 和 notify 方法必须拥有该对象的monitor ，也就是wait方法必须在同步方法中使用**</p>
</li>
</ul>
<h1 id="同步阻塞与异步非阻塞"><a href="#同步阻塞与异步非阻塞" class="headerlink" title="同步阻塞与异步非阻塞"></a>同步阻塞与异步非阻塞</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Event&gt; eventQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_EVENT = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_MAX_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventQueue.size() &gt;= max) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is full.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            console(<span class="string">&quot; the new event is submitted&quot;</span>);</span><br><span class="line">            eventQueue.addLast(event);</span><br><span class="line">            <span class="comment">// 只能唤醒一个 线程</span></span><br><span class="line">            eventQueue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is empty.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Event event = eventQueue.removeFirst();</span><br><span class="line">            <span class="keyword">this</span>.eventQueue.notify();</span><br><span class="line">            console(<span class="string">&quot; the event &quot;</span> + event + <span class="string">&quot; is handled.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">console</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s:%s\n&quot;</span>, currentThread().getName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="同步阻塞消息处理"><a href="#同步阻塞消息处理" class="headerlink" title="同步阻塞消息处理"></a>同步阻塞消息处理</h2><ul>
<li>同步Event 提交，客户端等待时间过长 会陷入阻塞，导致二次提交 Event耗时过长</li>
<li>由于客户端提交的Event数量不多，导致系统同时受理业务数量有限，也就是系统的整理的吞吐量不高</li>
<li>这种一个线程处理一个Event的方式，会导致出现频繁的创建开启和销毁，从而增加系统额外开销</li>
<li>在业务达到峰值的时候，大量的业务处理线程阻塞会导致频繁的CPU切换上下文，从而降低系统性能</li>
</ul>
<h2 id="异步非阻塞消息处理"><a href="#异步非阻塞消息处理" class="headerlink" title="异步非阻塞消息处理"></a>异步非阻塞消息处理</h2><ul>
<li>客户端不用等到结果处理结束之后才能返回，从而提高了系统的吞吐量和并发量</li>
<li>服务端的线程数量在一个可控的范围之内是不会导致太多的CPU上下文切换，从而带来额外的开销</li>
<li>服务端线程可以重复利用，这样可以减少不断创建线程带来的资源浪费</li>
</ul>
<h1 id="单线程间通信"><a href="#单线程间通信" class="headerlink" title="单线程间通信"></a>单线程间通信</h1><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><ul>
<li><p>wait 和 notify是 Object中的方法，也就是说 JDK中的每一个类都拥有这2个方法</p>
</li>
<li><p>下面是 wait的 3个重载方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 2. </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>wait 方法的3个重载方法都将调用wait（long timeout）这个方法，</li>
<li>wait（）等价于 wait（0），其中0代表永不超时 </li>
<li>Object的wait（long timeout）方法会导致当前线程进入阻塞，直到 有其他线程调用了 Object的notify 或者 notifyAll方法才能将其唤醒，或者 阻塞时间到达了 timeout时间而自动唤醒</li>
<li><strong>wait方法必须拥有该对象的monitor ，也就是wait方法必须在同步方法中使用</strong></li>
<li><strong>当前线程执行了该对象的wait方法之后，将会放弃对该 monitor的所有权并且进入与该对象关联的waitset中，也就说一旦线程执行了某个object 的wait方法之后，他就会释放对该对象 monitor的所有权，</strong>其他线程也会有机会继续争抢该 monitor的所有权 </li>
<li>（这个就是 Thread:: join的背后的逻辑，thread.join就是调用了wait 方法，所以父线程会 等到子线程执行完毕，才继续执行）</li>
</ul>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Wakes up a single thread that is waiting on this object&#x27;s</span></span><br><span class="line"><span class="comment">    * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment">    * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment">    * the discretion of the implementation. A thread waits on an object&#x27;s</span></span><br><span class="line"><span class="comment">    * monitor by calling one of the &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The awakened thread will not be able to proceed until the current</span></span><br><span class="line"><span class="comment">    * thread relinquishes the lock on this object. The awakened thread will</span></span><br><span class="line"><span class="comment">    * compete in the usual manner with any other threads that might be</span></span><br><span class="line"><span class="comment">    * actively competing to synchronize on this object; for example, the</span></span><br><span class="line"><span class="comment">    * awakened thread enjoys no reliable privilege or disadvantage in being</span></span><br><span class="line"><span class="comment">    * the next thread to lock this object.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment">    * of this object&#x27;s monitor. A thread becomes the owner of the</span></span><br><span class="line"><span class="comment">    * object&#x27;s monitor in one of three ways:</span></span><br><span class="line"><span class="comment">    * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;By executing a synchronized instance method of that object.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;By executing the body of a &#123;<span class="doctag">@code</span> synchronized&#125; statement</span></span><br><span class="line"><span class="comment">    *     that synchronizes on the object.</span></span><br><span class="line"><span class="comment">    * &lt;li&gt;For objects of type &#123;<span class="doctag">@code</span> Class,&#125; by executing a</span></span><br><span class="line"><span class="comment">    *     synchronized static method of that class.</span></span><br><span class="line"><span class="comment">    * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Only one thread at a time can own an object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment">    *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        java.lang.Object#notifyAll()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        java.lang.Object#wait()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>看一下方法说明注释-</p>
<ul>
<li><p>唤醒<strong>单个</strong>正在等待执行该对象wait 方法的线程</p>
</li>
<li><p>如果有很多线程都在等待，其中之一会被选中唤醒， 选择是任意的</p>
</li>
<li><p>被唤醒的线程需要重新获取对该对象所关联 monitor的lock 才能继续执行</p>
</li>
<li><p>被唤醒的线程将不能继续，直到当前线程放弃对该对象的锁。被唤醒的线程将以通常的方式与任何其他可能正在主动竞争同步这个对象的线程竞争;例如，被唤醒的线程在成为下一个锁定该对象的线程时没有任何可靠的特权或劣势</p>
</li>
</ul>
<h3 id="关于wait-和notify的注意事项"><a href="#关于wait-和notify的注意事项" class="headerlink" title="关于wait 和notify的注意事项"></a>关于wait 和notify的注意事项</h3><ul>
<li><p><strong>wait 是可中断方法</strong>，所以： 当前线程一旦调用了wait方法 进入阻塞状态，其他线程是可以使用 interrupt 方法将其打断的； 可中断方法被打断后，会收到 中断异常 InterruptedException ，同时 interrupt flag 也会被擦除 </p>
</li>
<li><p>线程执行了某个对象的wait 方法之后，会加入与之 对应的wait set中，<strong>每一个对象的 monitor 都有一个与之关联的 wait set</strong></p>
</li>
<li><p><strong>当线程进入wait set之后，notify 方法可以将其唤醒</strong>，也就是 从 wait set中弹出，<strong>同时中断 wait 中的线程也会将其唤醒</strong></p>
</li>
<li><p><strong>必须在同步方法中 使用 wait 和 notify 方法，</strong> 因为执行wait 和 notify 的前提条件是  必须持有同步方法的monitor 的所有权， 运行下面任何一个方法 都会抛出 非法的 monitor 状态异常  InllegalMonitorStateException: </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，因为 **必须在同步方法中 使用 wait 和 notify 方法，**</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testwait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.wait();  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错，**必须在同步方法中 使用 wait 和 notify 方法，**</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testwait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步代码的monitor 必须与执行  wait  notify方法的对象一致，简单来说就是 <strong>用哪个对象的 monitor 进行同步，就只能用哪个对象 进行wait 和 notify操作。</strong></li>
</ul>
<p>运行下面代码的任何一个方法会报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object MUTEX = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错，如果非要用 MUTEx ，可以使用同步代码块的形式 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            MUTEX.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 报错，报错，如果非要用 MUTEx ，可以使用同步代码块的形式 </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testNotify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MUTEX.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WaitNotify waitNotify = <span class="keyword">new</span> WaitNotify();</span><br><span class="line">        waitNotify.testNotify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br><span class="line">	at java.lang.Object.notifyAll(Native Method)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.WaitNotify.testNotify(WaitNotify.java:<span class="number">21</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.WaitNotify.main(WaitNotify.java:<span class="number">27</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面同步方法中 monitor 引用的是 this，而wait notify 使用的确实  MUTEX，<strong>虽然是在 同步方法中执行 wait  notify方法，但是 wait 和 notify方法的执行并未 获取 MUTEX 的monitor 为前提</strong></p>
<h2 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait 和sleep"></a>wait 和sleep</h2><ul>
<li>都可以使线程进入 阻塞状态</li>
<li>都是可中断方法，被中断后会收到中断异常</li>
<li>wait 时 Object方法， sleep 是 THread  方法</li>
<li>wait 执行需要在 synchronized 方法中进行，而sleep 不需要</li>
<li><strong>线程在同步方法中执行sleep 方法时，不会释放 monitor锁 ， 而 wait 方法则会释放monitor 锁</strong></li>
<li>sleep 方法短暂休眠后会主动退出阻塞 ，而 wait方法（没有指定时间） 则需要被其他线程中断才能退出阻塞 </li>
</ul>
<h1 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h1><ul>
<li>前面之所以 把 notify划到  单线程通信，我觉得是 因为 notify 只能唤醒一个线程，所以叫单线程通信</li>
<li>而 notifyAll 可以唤醒所以 waitset中的线程，所以称为 多线程通信</li>
</ul>
<h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><h3 id="1-notifyAll-方法"><a href="#1-notifyAll-方法" class="headerlink" title="1.notifyAll 方法"></a>1.notifyAll 方法</h3><ul>
<li>多线程之间通信需要用到Object 的notifyAll 方法，该方法与notify类似，都可以唤醒 由于调用wait方法而阻塞的线程，</li>
<li>但是 notify方法只能唤醒其中的一个线程，而notifyALL方法则可以同时唤醒全部的阻塞线程，同样被唤醒的线程仍需要继续争抢monitor的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up all threads that are waiting on this object&#x27;s monitor. A</span></span><br><span class="line"><span class="comment"> * thread waits on an object&#x27;s monitor by calling one of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> wait&#125; methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The awakened threads will not be able to proceed until the current</span></span><br><span class="line"><span class="comment"> * thread relinquishes the lock on this object. The awakened threads</span></span><br><span class="line"><span class="comment"> * will compete in the usual manner with any other threads that might</span></span><br><span class="line"><span class="comment"> * be actively competing to synchronize on this object; for example,</span></span><br><span class="line"><span class="comment"> * the awakened threads enjoy no reliable privilege or disadvantage in</span></span><br><span class="line"><span class="comment"> * being the next thread to lock this object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method should only be called by a thread that is the owner</span></span><br><span class="line"><span class="comment"> * of this object&#x27;s monitor. See the &#123;<span class="doctag">@code</span> notify&#125; method for a</span></span><br><span class="line"><span class="comment"> * description of the ways in which a thread can become the owner of</span></span><br><span class="line"><span class="comment"> * a monitor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalMonitorStateException  if the current thread is not</span></span><br><span class="line"><span class="comment"> *               the owner of this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#notify()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>        java.lang.Object#wait()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-生产者消费者"><a href="#2-生产者消费者" class="headerlink" title="2.生产者消费者"></a>2.生产者消费者</h3><p>前面的EventQueue 队列在多个线程同时并发的情况下会出现数据不一致的情况。当线程的数量增加的时候，会出现数据不一致的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EventQueue eventQueue = <span class="keyword">new</span> EventQueue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    eventQueue.offer(<span class="keyword">new</span> EventQueue.Event());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Producer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    eventQueue.take();</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;Consumer&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer: the queue is empty.</span><br><span class="line">Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> Exception in thread <span class="string">&quot;Consumer&quot;</span> java.util.NoSuchElementException</span><br><span class="line">	at java.util.LinkedList.removeFirst(LinkedList.java:<span class="number">270</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventQueue.take(EventQueue.java:<span class="number">48</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventClient.lambda$main$<span class="number">1</span>(EventClient.java:<span class="number">25</span>)</span><br><span class="line">	at com.wangwenjun.concurrent.chapter05.EventClient$$Lambda$<span class="number">2</span>/<span class="number">1324119927.</span>run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></figure>

<p>数据不一致的情况大致分为2类，</p>
<ul>
<li>其一是 LinLinkedList 中没有元素的时候，依旧调用了 removeFirst方法，</li>
<li>其二是 当LinkedList中的元素超过了10个的时候 仍旧执行了addLast方法</li>
</ul>
<p>分析现象：</p>
<h4 id="LinLinkedList-为空时，执行removeFirst方法"><a href="#LinLinkedList-为空时，执行removeFirst方法" class="headerlink" title="LinLinkedList 为空时，执行removeFirst方法"></a>LinLinkedList 为空时，执行removeFirst方法</h4><p>假设EventQueue中元素为空，</p>
<ul>
<li>两个线程在执行take方法时分别调用wait 进入阻塞，另外一个offer线程执行addLast方法之后唤醒了其中一个阻塞的take线程，</li>
<li>该take线程顺利消费了一个元素之后，因为是 使用notify方法，只能唤醒一个线程，而此时恰巧再次唤醒了一个take线程，此时就会导致执行empty LinkedList的 removeFirst方法，过程如下：</li>
</ul>
<pre class="mermaid">sequenceDiagram
autonumber
note over take线程1,take线程2:queue size=0
take线程1 ->>take线程1: 执行wait,进入wait set中释放monitor lock
take线程2 ->>take线程2: 执行wait,进入wait set中释放monitor lock
offer线程1 ->>offer线程1: Offer线程addLast，queue size=1
offer线程1 ->>offer线程1: notify方法
offer线程1->>take线程2: 唤醒
take线程2 ->>take线程2: remove first,Queue size=0
take线程2 ->>take线程2: Notify
take线程2->>take线程1: 唤醒
take线程1 ->>take线程1: remove first,报错</pre>

<h4 id="LinLinkedList-元素为10时执行addLast方法"><a href="#LinLinkedList-元素为10时执行addLast方法" class="headerlink" title="LinLinkedList 元素为10时执行addLast方法"></a>LinLinkedList 元素为10时执行addLast方法</h4><pre class="mermaid">sequenceDiagram
autonumber
note over offer线程1,offer线程2:queue size=10
offer线程1 ->>offer线程1: 执行wait,进入wait set中释放monitor lock
offer线程2 ->>offer线程2: 执行wait,进入wait set中释放monitor lock
take线程1 ->>take线程1: Take线程removeFirst，queue size=9
take线程1 ->>take线程1: notify方法
take线程1->>offer线程2: 唤醒
offer线程2 ->>offer线程2: addLast,Queue size=10
offer线程2 ->>offer线程2: Notify
offer线程2->>offer线程1: 唤醒
offer线程1 ->>offer线程1: addLast,Queue size=10</pre>



<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p><strong>只需要将临界值的if判断更改为while ，将 notify更改为 notifyAll即可</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Event&gt; eventQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_MAX_EVENT = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_MAX_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventQueue</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (eventQueue.size() &gt;= max) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is full.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            console(<span class="string">&quot; the new event is submitted&quot;</span>);</span><br><span class="line">            eventQueue.addLast(event);</span><br><span class="line">            <span class="comment">// 唤醒所有线程，让他们再去争抢 monitor</span></span><br><span class="line">            eventQueue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Event <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (eventQueue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    console(<span class="string">&quot; the queue is empty.&quot;</span>);</span><br><span class="line">                    eventQueue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Event event = eventQueue.removeFirst();</span><br><span class="line">            <span class="comment">// 唤醒所有线程，让他们再去争抢 monitor</span></span><br><span class="line">            <span class="keyword">this</span>.eventQueue.notifyAll();</span><br><span class="line">            console(<span class="string">&quot; the event &quot;</span> + event + <span class="string">&quot; is handled.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">console</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s:%s\n&quot;</span>, currentThread().getName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程休息室wait-set"><a href="#线程休息室wait-set" class="headerlink" title="线程休息室wait set"></a>线程休息室wait set</h3><ul>
<li>在虚拟机规范中存在一个 wait set（线程休息室）的概念，至于 wait set时怎么样的数据结构，JDK官网并没有给出明确的定义，不同厂家的JDK有着不同的实现方式。</li>
<li>不管怎样，线程调用了某个对象的wait方法之后，都会加入与该对象monitor关联的wait set中，并且释放 monitor的所有权</li>
</ul>
<p>下图演示了 ： 若干个线程调用了 wait方法之后被加入与 monitor关联的wait set中，待 另外一个线程（当前monitor持有者）调用该monitor的 notify方法之后，其中一个线程会从 wait set中弹出 。至于时随机弹出 还是先进先出的方式弹出，虚拟机同样没有给出强制要求 </p>
<p><img src="/uploads/java-concurrency-master/notify-waitset.png"></p>
<p>而执行notifyAll 则不需要考虑哪个线程会被弹出，因为wait set中的所有wait线程都会被弹出，如下图5-6 所示</p>
<p><img src="/uploads/java-concurrency-master/notifyAll-waitset.png"></p>
<h2 id="自定义显示锁BooleanLock"><a href="#自定义显示锁BooleanLock" class="headerlink" title="自定义显示锁BooleanLock"></a>自定义显示锁BooleanLock</h2><h3 id="synchronized关键字的缺陷"><a href="#synchronized关键字的缺陷" class="headerlink" title="synchronized关键字的缺陷"></a>synchronized关键字的缺陷</h3><p>synchronized关键字 提供了一种排他式的数据同步机制，某个线程在获取 monitor lock的时候可能会被阻塞，而这种阻塞有2个很明显的缺陷：</p>
<ul>
<li>无法控制阻塞时长</li>
<li>阻塞不可被中断</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDefect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.HOURS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronizedDefect defect = <span class="keyword">new</span> SynchronizedDefect();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(defect::syncMethod, <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">        <span class="comment">//make sure the t1 started.</span></span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(defect::syncMethod, <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//make sure the t2 started.</span></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(t2.isInterrupted());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/T1_TIME_WAITTING.png"></p>
<p><img src="/uploads/java-concurrency-master/T2_BLOCKED.png"></p>
<ul>
<li>被 synchronized 同步的线程不可被中断</li>
</ul>
<h3 id="自定义显示锁BooleanLock-1"><a href="#自定义显示锁BooleanLock-1" class="headerlink" title="自定义显示锁BooleanLock"></a>自定义显示锁BooleanLock</h3><p>利用前面所学的知识，构造一个显示的BooleanLock，使其</p>
<ul>
<li>具备synchronized关键字所有功能的同时，</li>
<li>又具备<strong>可中断 和lock超时的功能</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 永远阻塞，除非获取到了锁，这一点与synchronized类似，</span></span><br><span class="line"><span class="comment">     * 但是该方法可以被中断，中断时会抛出 InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 除了被中断外，还增加了 对应的超时功能</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mills</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行锁的释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前有哪些线程被 阻塞，类是与 wait set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Thread&gt; <span class="title">getBlockedThreads</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true； 锁空闲</span></span><br><span class="line"><span class="comment">     * false：当前锁不可用，（锁被其他线程占领 &amp;&amp; 或者自己已经拥有锁（这次就不让锁重入了） ）</span></span><br><span class="line"><span class="comment">     * 该方式 只是去判断锁的状态，不会真正的去 lock 或者 unlock，也就是不会修改锁状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现BooleanLock"><a href="#实现BooleanLock" class="headerlink" title="实现BooleanLock"></a>实现BooleanLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前拥有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread currentThread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * false ：当前锁没有被任何线程 获得，或者已经释放</span></span><br><span class="line"><span class="comment">     * true： 该锁已经被某个线程获得，该线程就是 currThread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储因为获取锁 而阻塞的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Thread&gt; blockedList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (locked) &#123;</span><br><span class="line">                <span class="comment">//暂存当前线程</span></span><br><span class="line">                <span class="keyword">final</span> Thread tempThread = currentThread();</span><br><span class="line">                <span class="comment">// 装载 因获取锁而阻塞的 其他线程</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!blockedList.contains(currentThread()))</span><br><span class="line">                        blockedList.add(currentThread());</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前线程在wait时候被中断，则从blockedList中删除，避免内存泄漏</span></span><br><span class="line">                    blockedList.remove(tempThread);</span><br><span class="line">                    <span class="comment">//继续抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放自己</span></span><br><span class="line">            blockedList.remove(currentThread());</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            <span class="keyword">this</span>.locked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//更新当前拥有锁的对象</span></span><br><span class="line">            <span class="keyword">this</span>.currentThread = currentThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> mills)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//1. 如果 mills（超时时间）不合法，抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (mills &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidParameterException(<span class="string">&quot;非法的mills参数&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mills == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> remainingMills = mills;</span><br><span class="line">                <span class="keyword">long</span> endMills = currentTimeMillis() + remainingMills;</span><br><span class="line">                <span class="keyword">while</span> (locked) &#123;</span><br><span class="line">                    <span class="comment">//2. 如果剩余等待时间（remainingMills），小于等于0，意味着已经超时了，应该抛出 超时的异常</span></span><br><span class="line">                    <span class="keyword">if</span> (remainingMills &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">&quot;can not get the lock during &quot;</span> + mills + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!blockedList.contains(currentThread()))</span><br><span class="line">                        blockedList.add(currentThread());</span><br><span class="line">                    <span class="comment">// 3. 多次wait的过程中，剩余等待时间（remainingMills）也会不断地更新</span></span><br><span class="line">                    <span class="keyword">this</span>.wait(remainingMills);</span><br><span class="line">                    <span class="comment">// 4. 刷新 remainingMills</span></span><br><span class="line">                    remainingMills = endMills - currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5. 获得 monitor lock，从blockList中删除当前线程，修改locked 标识，且更新当前线程为 锁地拥有者</span></span><br><span class="line">                blockedList.remove(currentThread());</span><br><span class="line">                <span class="keyword">this</span>.locked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.currentThread = currentThread();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//1.只有锁地拥有者，才有资格释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (currentThread == currentThread()) &#123;</span><br><span class="line">                <span class="comment">// 2. 更新lock 标识为 未锁定</span></span><br><span class="line">                <span class="keyword">this</span>.locked = <span class="keyword">false</span>;</span><br><span class="line">                Optional.of(currentThread().getName() + <span class="string">&quot; release the lock monitor.&quot;</span>).ifPresent(System.out::println);</span><br><span class="line">                <span class="comment">//3. 清空wait set,通知wait set中所有线程，可以尝试抢锁了</span></span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Thread&gt; <span class="title">getBlockedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(blockedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="comment">//            // 如果当前 lock 标识为已锁定 并且 自己不是锁的拥有者</span></span><br><span class="line"><span class="comment">//            if (locked &amp;&amp; !this.currentThread.equals(currentThread())) &#123;</span></span><br><span class="line"><span class="comment">//                //直接返回，也不 加入blockList</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;tryLock fail，当前Lock拥有者是:&quot; + this.currentThread.getName());</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //说明当前锁 空闲或者自己已经是锁的拥有者，</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;说明当前锁 空闲或者自己已经是锁的拥有者&quot;);</span></span><br><span class="line"><span class="comment">//            return true;</span></span><br><span class="line">            <span class="comment">//如果当前锁空闲，则返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">                <span class="comment">//直接返回false，也不 加入blockList</span></span><br><span class="line">                System.out.println(<span class="string">&quot;tryLock succ,当前锁空闲&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;tryLock fail，当前Lock拥有者是:&quot;</span> + <span class="keyword">this</span>.currentThread.getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试类：-tryLock是自己加上的，也可以去除"><a href="#测试类：-tryLock是自己加上的，也可以去除" class="headerlink" title="测试类：(tryLock是自己加上的，也可以去除)"></a>测试类：(tryLock是自己加上的，也可以去除)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanLockTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> BooleanLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁失败，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(!lock.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程tryLock失败,退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(currentThread() + <span class="string">&quot; get the lock.&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> randomInt = current().nextInt(<span class="number">10</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(randomInt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethodTimeoutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁失败，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(!lock.tryLock())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程tryLock失败,退出&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.lock(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(currentThread() + <span class="string">&quot; get the lock.&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> randomInt = current().nextInt(<span class="number">10</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(randomInt);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BooleanLockTest blt = <span class="keyword">new</span> BooleanLockTest();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(blt::syncMethod, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(blt::syncMethodTimeoutable, <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*(BooleanLockTest blt = new BooleanLockTest();</span></span><br><span class="line"><span class="comment">        IntStream.range(0, 2)</span></span><br><span class="line"><span class="comment">                .mapToObj(i -&gt; new Thread(blt::syncMethod,&quot;Thread&quot;+i))</span></span><br><span class="line"><span class="comment">                .forEach(Thread::start);*/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li><p>介绍了wait 和notify方法的使用，以及注意事项，比如：</p>
<ul>
<li>wait 和notify方法必须在同步方法中使用，且当前线程必须拥有锁，才可以</li>
<li>同步代码的monitor 必须与执行  wait  notify方法的对象一致，简单来说就是 <strong>用哪个对象的 monitor 进行同步，就只能用哪个对象 进行wait 和 notify操作。</strong></li>
<li>不能使用空对象（null）作为 monitor</li>
</ul>
</li>
<li><p>生产者与消费者模型是多线程开发最常用的模型之一，也是多线程间 通信的最好范例</p>
</li>
<li><p>讲诉了wait set线程休息室的概念，以及调用notify 和 notifyAll 对wait set的影响</p>
</li>
<li><p>synchronized同步方法的缺点：</p>
<ul>
<li>不可以中断</li>
<li>无法超时</li>
</ul>
</li>
<li><p>通过synchronized的缺点，只定义开发了一个BooleanLock锁，其功能包括：</p>
<ul>
<li>synchronized关键字的互斥访问 共享资源</li>
<li>增加了可中断功能</li>
<li>增加了 可超时功能</li>
<li>增加了 tryLock功能</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">java高并发详解-04-线程安全与数据同步</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-18 23:56:02" itemprop="dateCreated datePublished" datetime="2021-02-18T23:56:02+08:00">2021-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-04-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>从字节码指令维度掌握 synchronized 关键字的原理,以及互斥同步的 流程</li>
<li>还有一点很重要的是,通过画时序图 分析数据不一致的场景 和原因</li>
</ul>
<h1 id="4-1数据同步-Todo"><a href="#4-1数据同步-Todo" class="headerlink" title="4.1数据同步(Todo)"></a>4.1数据同步(Todo)</h1><h3 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源:"></a>共享资源:</h3><p>多个线程同时对同一份资源进行访问(读写操作),被多个线程访问的资源,<strong>就称为共享资源</strong></p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>如何保证多个线程访问到的数据是一致的,则被称为<strong>数据同步或者资源同步</strong></p>
<h3 id="4-1-1-数据不一致问题的引入"><a href="#4-1-1-数据不一致问题的引入" class="headerlink" title="4.1.1 数据不一致问题的引入"></a>4.1.1 数据不一致问题的引入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindownRunnableError</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;的号码是：&quot;</span> + (index++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> TicketWindownRunnableError task = <span class="keyword">new</span> TicketWindownRunnableError();</span><br><span class="line">        Thread 一号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;一号窗口&quot;</span>);</span><br><span class="line">        Thread 二号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;二号窗口&quot;</span>);</span><br><span class="line">        Thread 三号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;三号窗口&quot;</span>);</span><br><span class="line">        Thread 四号窗口 = <span class="keyword">new</span> Thread(task, <span class="string">&quot;四号窗口&quot;</span>);</span><br><span class="line">        一号窗口.start();</span><br><span class="line">        二号窗口.start();</span><br><span class="line">        三号窗口.start();</span><br><span class="line">        四号窗口.start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h4><p>多次运行上面程序，会大致出现3类问题，具体如下：</p>
<ul>
<li>某个号码被略过，没有出现</li>
<li>某个号码被多次显示</li>
<li>号码超过了最大值500</li>
</ul>
<h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;的号码是：&quot;</span> + (index++));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-号码被掠过"><a href="#1-号码被掠过" class="headerlink" title="1. 号码被掠过"></a>1. 号码被掠过</h5><p>线程的执行是由CPU时间片轮询调度的，假设此时线程1.线程2 都执行到了index =65 的位置，其中线程2 将index 修改为66后未输出前，cpu调度将执行权力交给了线程1，线程1 将其累加到了 67， 那么66就被忽略了</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=65
Thread1 ->> Thread1 :thread 停顿
Thread2 ->> Thread2 : index+1 =65+1
Thread2 ->> Thread2 : index=66
Thread2 ->> Thread2 : thread停顿,问题点，此处忽略了print66，
Thread1 ->> Thread1 :index+1=66+1
Thread1 ->> Thread1 :index=67
Thread1 ->> Thread1 :print 67
Thread1 ->> Thread1 : index+1=67+1
Thread1 ->> Thread1 :index=68
Thread1 ->> Thread1 : print 68</pre>



<h5 id="2-号码重复出现"><a href="#2-号码重复出现" class="headerlink" title="2. 号码重复出现"></a>2. 号码重复出现</h5><p>线程1 执行index+1，然后cpu 执行权落入线程2手里，由于线程1 并没有给index 赋值301， 所以线程2 执行index+1的 结果也是 301，</p>
<p>所以出现了 重复号码的情况</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=300
Thread1 ->> Thread1 :index +1=300+1
Thread1 ->> Thread1 : 线程停顿
Thread2 ->> Thread2 : index+1 =300+1
Thread2 ->> Thread2 : index=301
Thread1 ->> Thread1 : index=301
Thread1 ->> Thread1 : print 301
Thread2 ->> Thread2 : 问题点-print 301</pre>

<h5 id="3-号码超过了最大值"><a href="#3-号码超过了最大值" class="headerlink" title="3. 号码超过了最大值"></a>3. 号码超过了最大值</h5><p>当 index=499 的时候，线程1 和线程2 都看到条件满足。线程2短暂停顿，线程1 将index增加到了500，线程2恢复运行后，又将 500+1 ，此时就出现了超过MAX 的情况。</p>
<pre class="mermaid">sequenceDiagram
autonumber
note over Thread1,Thread2: Index=499
Thread1 ->> Thread1 :进入while 循环条件满足
Thread2 ->> Thread2 :进入while 循环条件满足
Thread1 ->> Thread1 : index+1 =499+1
Thread2 ->> Thread2 : 线程停顿
Thread1 ->> Thread1 : index=500
Thread1 ->> Thread1 : print 500
Thread2 ->> Thread2 : index+1=500+1
Thread2 ->> Thread2 : index =501
Thread2 ->> Thread2 : 问题点-print 501</pre>

<h1 id="4-2-初始synchronized关键字"><a href="#4-2-初始synchronized关键字" class="headerlink" title="4.2 初始synchronized关键字"></a>4.2 初始synchronized关键字</h1><h2 id="4-2-1-什么是synchronized"><a href="#4-2-1-什么是synchronized" class="headerlink" title="4.2.1 什么是synchronized"></a>4.2.1 什么是synchronized</h2><p>JDK官网对synchronized关键字的权威解释：</p>
<p>Synchronized keyword enable a simple strategy for preventing thread interference and memory consistency errors:  if an object is visible to more than one thread,all reads or writes to that object’s  variables are done through synchronized methods.</p>
<p>Synchronized关键字启用了一种简单的策略来防止线程干扰和内存一致性错误:如果一个对象对多个线程可见，那么对该对象变量的所有读或写操作都通过Synchronized同步的方法完成。 </p>
<p>同步互斥： 互斥是方式，同步是结果</p>
<p>具体表现为：</p>
<ul>
<li>synchronized 关键字提供了一种锁机制，能够确保共享变量的互斥访问，从而防止数据不一致问题的出现</li>
<li>synchronized 关键字包括 monitor enter 和 monitor exit 两个JVM 指令，它能够保证在任何时候任何线程执行到 monitor enter成功之前都必须从主内存获取数据，而不是从缓存中， 在monitor exit运行成功之后，共享变量被更新后的值 必须刷入回之内存 （简单来说，就是 执行 monitor enter之前，从主内存中获取共享变量的值，在执行 monitor exit之后，将更新后的共享变量的值 同步回主内存，解决缓存一致性的问题）</li>
<li>synchronized 的指令严格遵守 java 的先行发生原则（happens-before），一个monitor exit 指令之前 一定由一个 monitor enter 指令，成对出现 。</li>
</ul>
<h2 id="4-2-2-synchronized-关键字的用法"><a href="#4-2-2-synchronized-关键字的用法" class="headerlink" title="4.2.2 synchronized 关键字的用法"></a>4.2.2 synchronized 关键字的用法</h2><p>synchronized 可以用于对 方法块 或者方法进行修饰， 不能够用于对class 或者变量进行修饰</p>
<h3 id="1-同步方法"><a href="#1-同步方法" class="headerlink" title="1. 同步方法"></a>1. 同步方法</h3><p>同步方法的语法  ： [default | public | private | protected] <strong>synchronized</strong> [static ] type methods().</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticSync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-同步代码块"><a href="#2-同步代码块" class="headerlink" title="2. 同步代码块"></a>2. 同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object MUTEX=<span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(MUTEX)&#123;</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-深入理解synchronized关键字"><a href="#4-3-深入理解synchronized关键字" class="headerlink" title="4.3 深入理解synchronized关键字"></a>4.3 深入理解synchronized关键字</h2><ul>
<li>synchronized 提供了一种互斥机制，在同一时刻，只能由一个线程访问同步资源</li>
<li>不应该将MUTEX称为锁，严谨的说法，应该是 某线程 获取到了 MUTEX关联的 monitor锁</li>
</ul>
<h3 id="Monitor-enter"><a href="#Monitor-enter" class="headerlink" title="Monitor enter"></a>Monitor enter</h3><p>每个对象都与一个monitor 相关联，一个monitor的lock的锁 只能被一个线程在同一时间获得，在一个线程尝试获得与 对象关联monitor的所有权时候回发生如下几件事情。</p>
<ul>
<li>如果monitor 的计数器为0，则意味着 该monitor的lock 还没有被获得，某个线程获得之后 将立即对该计数器加一 ，从此该线程就是这个monitor 的所有者了</li>
<li>如果一个已经拥有该monitor所有权的线程重入 ，则会导致 monitor计数器再次累加</li>
<li>如果monitor已经被其他线程 所拥有，则 其他线程尝试获取该monitor 的所有权时，会被陷入阻塞状态知道monitor计数器 变为0，才能再次尝试 获取对 monitor的所有权 。</li>
</ul>
<h3 id="Monitor-exit"><a href="#Monitor-exit" class="headerlink" title="Monitor exit"></a>Monitor exit</h3><ul>
<li>释放对 monitor的所有权，想要释放对 某个对象关联的 monitor的所有权的前提是 ，你曾经获得了所有权。</li>
<li>释放monitor锁的过程比较简单，就是将 monitor的计数器减一， </li>
<li>如果monitor的计数器 结果为0，那就意味着 该线程不再拥有对 该monitor的所有权，通俗的讲 就是解锁。</li>
<li>与此同时，被该 monitor block的线程将再次尝试 获得对该monitor的所有权</li>
</ul>
<h3 id="使用-synchronized需要注意的问题"><a href="#使用-synchronized需要注意的问题" class="headerlink" title="使用 synchronized需要注意的问题"></a>使用 synchronized需要注意的问题</h3><ul>
<li>与monitor关联的对象不能为空,  </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mutex=<span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">        、、、</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">每一个对象和一个 monitor 关联，对象都为<span class="keyword">null</span>了，monitor 肯定无从谈起</span><br></pre></td></tr></table></figure>

<ul>
<li>synchronized作用域太大，synchronized 应该尽可能地只作用于  <strong>共享资源地读写作用域</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">由于<span class="keyword">synchronized</span> 关键字存在排他性，也就是所有线程必须串行的经过<span class="keyword">synchronized</span>保护的共享区域，</span><br><span class="line">    如果<span class="keyword">synchronized</span> 作用域越大，则代表其效率越低，甚至丧失并发的优势</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不同的monitor 企图锁相同的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object mutex=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">         <span class="keyword">synchronized</span>(mutex)&#123;</span><br><span class="line">        、、、</span><br><span class="line">   	 &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(Task::<span class="keyword">new</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造了5个线程，同时也构造了5个 Runnable实例， Runnable作为逻辑单元传递给Thread，然后将发现：</span></span><br><span class="line"><span class="keyword">synchronized</span> 无法同步互斥， 因为 线程之间的monitor lock争抢只能发生在 monitor 关联的同一个引用上。</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>多个锁的交叉导致死锁</li>
</ul>
<h3 id="4-4-This-Monitor和Class-Monitor"><a href="#4-4-This-Monitor和Class-Monitor" class="headerlink" title="4.4 This Monitor和Class Monitor"></a>4.4 This Monitor和Class Monitor</h3><p>synchronized 的用法可以从两个维度上面分类：</p>
<h3 id="1-根据修饰对象分类"><a href="#1-根据修饰对象分类" class="headerlink" title="1.根据修饰对象分类"></a>1.根据修饰对象分类</h3><p>synchronized 可以修饰方法和代码块</p>
<ul>
<li>修饰代码块<ul>
<li>synchronized(this|object) {}</li>
<li>synchronized(类.class) {}</li>
</ul>
</li>
<li>修饰方法<ul>
<li>修饰非静态方法</li>
<li>修饰静态方法</li>
</ul>
</li>
</ul>
<h2 id="2-根据获取的锁分类"><a href="#2-根据获取的锁分类" class="headerlink" title="2. 根据获取的锁分类"></a>2. 根据获取的锁分类</h2><ul>
<li><p>获取对象锁</p>
<ul>
<li>synchronized(this|object) {}</li>
<li>修饰非静态方法</li>
</ul>
</li>
<li><p>获取类锁</p>
<ul>
<li>synchronized(类.class) {}</li>
<li>修饰静态方法，非静态方法</li>
</ul>
</li>
</ul>
<h4 id="This-Monitor（-对象锁）"><a href="#This-Monitor（-对象锁）" class="headerlink" title="This Monitor（ 对象锁）:"></a>This Monitor（ 对象锁）:</h4><ul>
<li>在 Java 中，每个对象都会有一个 monitor 对象，这个对象其实就是 Java 对象的锁，<strong>通常会被称为“内置锁”或“对象锁”</strong>。<strong>类的对象可以有多个，所以每个对象有其独立的对象锁，互不干扰。</strong></li>
</ul>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>synchronized 关键字修饰了同一个实例对象的两个不同方法，那么与之对应的monitor 是什么？ 两个 monitor是否一致呢。</p>
<p>实例锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisMonitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getName() + <span class="string">&quot; enter to method1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(currentThread().getName() + <span class="string">&quot; enter to method2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ThisMonitor thisMonitor = <span class="keyword">new</span> ThisMonitor();</span><br><span class="line">        <span class="keyword">new</span> Thread(thisMonitor::method1, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thisMonitor::method2, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/thread-thisMonitor.png"></p>
<p><img src="/uploads/java-concurrency-master/thread-thisMonitor2.png"></p>
<h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ul>
<li>由上图可以看出 T1获取了 monitor lock  并处于休眠状态，而 T2 线程企图获取 monitor 的lock时陷入了 BLOCKED 状态，可见 使用synchronized 关键字同步类的不同实例方法，争抢的时 同一个monitor的lock ，而 与之关联的引用则是 ThisMonitor 的实例引用</li>
<li>其中 method1 保持方法同步的方式，method2 则采用了同步代码块 的方式，并且使用的是 this的monitor</li>
</ul>
<p>when a thread invokes a synchronized method, it automatically acquires the intrinsic lock  for that method’s object and releases it when the method returns .  The lock release occurs even if the return was caused by an uncaught exception .</p>
<h4 id="Class-Monitor（类锁）"><a href="#Class-Monitor（类锁）" class="headerlink" title="Class Monitor（类锁）:"></a>Class Monitor（类锁）:</h4><ul>
<li>在 Java 中，针对每个类也有一个锁，可以称为“类锁”，类锁实际上是通过对象锁实现的，即类的 Class 对象锁。每个类只有一个 Class 对象，所以每个类只有一个类锁。</li>
</ul>
<p>对象锁，static修饰 ,有两个类方法（静态方法）分别使用 synchronized对其进行同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassMonitor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(currentThread().getName() + <span class="string">&quot; enter to method1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (ClassMonitor.class)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(currentThread().getName() + <span class="string">&quot; enter to method2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TimeUnit.MINUTES.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(ClassMonitor::method1, <span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ClassMonitor::method2, <span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/uploads/java-concurrency-master/thread-classMonitor.png"></p>
<p><img src="/uploads/java-concurrency-master/thread-classMonitor2.png"></p>
<ul>
<li> 从上图可以看出 用synchronized 同步某个类的不同静态方法争抢的也是 同一个 monitor的lock ，</li>
<li>与 This monitor 信息不一样的地方在于 （a java.lang.Class for ……..）</li>
<li>由此推断与 该 monitor关联的引用是 ClassMonitor.class  实例</li>
</ul>
<p>since  a static method is associated with a class, not an object  . In this case, the thread acquires the intrinstic lock for the Class  object associated with the class . Thus access to class’s static fields is controlled by a lock that’s distinct from the lock for any instance of the class .</p>
<h3 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h3><ul>
<li><strong>对于非静态方法，同一个实例的线程访问会被拦截，非同一实例可以同时访问。 即此时是默认对象锁（this）。</strong></li>
<li><strong>静态方法默认类锁。</strong></li>
<li><strong>对于静态方法，由于此时对象还未生成，所以只能采用类锁；</strong></li>
<li><strong>只要采用类锁，就会拦截所有线程，只能让一个线程访问。</strong></li>
<li><strong>对于对象锁（this），如果是同一个实例，就会按顺序访问，但是如果是不同实例，就可以同时访问。</strong></li>
<li><strong>如果对象锁跟访问的对象没有关系，那么就会都同时访问。</strong></li>
</ul>
<h3 id="4-5-程序死锁的原因以及如何诊断"><a href="#4-5-程序死锁的原因以及如何诊断" class="headerlink" title="4.5 程序死锁的原因以及如何诊断"></a>4.5 程序死锁的原因以及如何诊断</h3><ol>
<li><p>交叉锁可导致程序出现死锁</p>
<p>典型的哲学家吃面问题，</p>
</li>
<li><p>内存不足</p>
<p>当并发请求系统可用内存时，如果此时系统内存不足，则可能会出现死锁的情况，举个例子，两个线程 T1 和 T2，执行某个任务，其中T1 已经获取了10MB内存， T2 获取了20MB内存，如果每个线程都需要30MB的内存，但是剩余可用内存刚好为20MB，那么两个线程 有可能都在等待彼此能够释放内存资源。</p>
</li>
<li><p>一问一答式的数据交换</p>
</li>
<li><p>数据库锁</p>
<p>无论是数据库表级别的锁，还是行级别的锁， 比如 某个线程执行 for update语句退出了事务，其他线程访问该数据库时 都将陷入死锁。</p>
</li>
<li><p>文件锁</p>
<p>某线程获得了文件锁意外退出，其他读取该文件的线程也将会 进入死锁知道系统释放文件句柄资源</p>
</li>
<li><p>死循环引起的死锁</p>
</li>
</ol>
<h4 id="死锁诊断"><a href="#死锁诊断" class="headerlink" title="死锁诊断"></a>死锁诊断</h4><ol>
<li>交叉锁引起的死锁</li>
</ol>
<ul>
<li>打开jstack 工具或者 jconsole工具，一般交叉锁引起的死锁线程都会进入 BLOCKED状态，CPU资源占用不高，很容易借助工具来发现</li>
</ul>
<p><img src="/uploads/java-concurrency-master/deadLock_read.png"></p>
<p><img src="/uploads/java-concurrency-master/deadLock_write.png"></p>
<ol start="2">
<li>死循环引起的死锁（假死）</li>
</ol>
<ul>
<li>工作的线程并未BLOCKED ,而是始终处于 RUNNABLE状态，CPU使用率高居不下，</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li><p>synchronized 关键字在Java 中提供了同步语义，它可以保证在同一时间 只允许一个线程访问 共享数据资源。</p>
</li>
<li><p>本章介绍了synchronized的详细用法，修饰 方法，或者修饰代码块，</p>
<ul>
<li>如果修饰的是  static 方法或者static 方法快，那么 使用的就是 CLASS monitor，是 class 实例的monitor</li>
<li>如果修饰的不带static ，那就是 this monitor，使用的是某个对象的 monitor</li>
</ul>
</li>
<li><p>介绍死锁场景，以及定位死锁问题</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java高并发详解-03-ThreadAPI详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-18 13:25:17" itemprop="dateCreated datePublished" datetime="2021-02-18T13:25:17+08:00">2021-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/18/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-03-ThreadAPI%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程sleep"><a href="#线程sleep" class="headerlink" title="线程sleep"></a>线程sleep</h2><p>sleep是一个静态方法，其中有两个重载方法，其中一个需要传入毫秒数，另外一个既需要毫秒数也需要纳秒数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">     * execution) for the specified number of milliseconds, subject to</span></span><br><span class="line"><span class="comment">     * the precision and accuracy of system timers and schedulers. The thread</span></span><br><span class="line"><span class="comment">     * does not lose ownership of any monitors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes the currently executing thread to sleep (temporarily cease</span></span><br><span class="line"><span class="comment">     * execution) for the specified number of milliseconds plus the specified</span></span><br><span class="line"><span class="comment">     * number of nanoseconds, subject to the precision and accuracy of system</span></span><br><span class="line"><span class="comment">     * timers and schedulers. The thread does not lose ownership of any</span></span><br><span class="line"><span class="comment">     * monitors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the length of time to sleep in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  nanos</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> 0-999999&#125; additional nanoseconds to sleep</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative, or the value of</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@code</span> nanos&#125; is not in the range &#123;<span class="doctag">@code</span> 0-999999&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">            millis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(millis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>sleep方法会使得当前线程进入指定毫秒数的休眠，暂停执行，虽然给定一个休眠时间，但是最终要以系统的定时器和调度器的精度为准。</strong></p>
</li>
<li><p><strong>sleep 期间不会放弃 monitor 锁的所有权</strong> </p>
</li>
</ul>
<h3 id="使用TimeUnit-替代-Thread-sleep"><a href="#使用TimeUnit-替代-Thread-sleep" class="headerlink" title="使用TimeUnit 替代 Thread.sleep"></a>使用TimeUnit 替代 Thread.sleep</h3><ul>
<li>在JDK引入了一个枚举 TimeUnit，其对 sleep 方法提供了很好的封装。</li>
<li>强烈建议，使用TimeUnit代替 直接使用Thread.sleep()</li>
</ul>
<h2 id="线程yield"><a href="#线程yield" class="headerlink" title="线程yield"></a>线程yield</h2><ul>
<li>Thread.yeild 线程礼让，当前线程暂时不跑了，让其他线程先跑。类似于你去银行排队办事情，你跑到最后去重新拿个号重新排队。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A hint to the scheduler that the current thread is willing to yield</span></span><br><span class="line"><span class="comment">   * its current use of a processor. The scheduler is free to ignore this</span></span><br><span class="line"><span class="comment">   * hint.</span></span><br><span class="line"><span class="comment">   * // 意思是，给了调度器scheduler一个提示，我愿意让出当前的处理器processor给其他人，但是人家processor未必搭理你这个暗示。</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; Yield is a heuristic attempt to improve relative progression</span></span><br><span class="line"><span class="comment">   * between threads that would otherwise over-utilise a CPU. Its use</span></span><br><span class="line"><span class="comment">   * should be combined with detailed profiling and benchmarking to</span></span><br><span class="line"><span class="comment">   * ensure that it actually has the desired effect.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   这个例子就是通过yield方法来实现两个线程的交替执行。</span></span><br><span class="line"><span class="comment"> 		不过请注意：这种交替并不一定能得到保证，源码中也对这个问题进行说明：</span></span><br><span class="line"><span class="comment"> 		主要说明了三个问题：</span></span><br><span class="line"><span class="comment"> 　　调度器可能会忽略该方法。</span></span><br><span class="line"><span class="comment"> 　　使用的时候要仔细分析和测试，确保能达到预期的效果。</span></span><br><span class="line"><span class="comment"> 　　很少有场景要用到该方法，主要使用的地方是调试和测试。　　</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; It is rarely appropriate to use this method. It may be useful</span></span><br><span class="line"><span class="comment">   * for debugging or testing purposes, where it may help to reproduce</span></span><br><span class="line"><span class="comment">   * bugs due to race conditions. It may also be useful when designing</span></span><br><span class="line"><span class="comment">   * concurrency control constructs such as the ones in the</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> java.util.concurrent.locks&#125; package.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>yield方法属于一种<strong>启发式的方法</strong>，会提醒调度器 我愿意放弃当前CPU资源，如果CPU资源不紧张，则会忽略这种提醒</p>
</li>
<li><p>调用 yield 方法 会使当前线程从 ＲＵＮＮＩＮＧ　状态切换到　ＲＵＮＮＡＢＬＥ</p>
</li>
<li><p>yield 只是一个提示(hint),cpu 调度器并不会担保每次都能满足 yield提示.</p>
<h3 id="yield-和-sleep"><a href="#yield-和-sleep" class="headerlink" title="yield 和 sleep"></a>yield 和 sleep</h3><ul>
<li>sleep 会导致当前线程暂停指定的时间,没有CPU时间片的消耗</li>
<li>yield 只是对CPU调度器的一个提示,如果CPU调度器没有忽略这个提示, 他会导致线程上下文的切换.(因为当前线程愿意让出自己的资源)</li>
<li>sleep会使 线程短暂block ,会在给定的时间内释放 CPU资源 </li>
<li>yield 会使 RUNNING状态的Ｔｈｒｅａｄ　进入　ＲＵＮＮＡＢＬＥ状态(如果CPU调度器没有忽略这个提示的话)</li>
<li>sleep几乎百分百地完成了给定时间的休眠,而 yield 的提示并不能一定担保</li>
<li>一个线程sleep 另一个线程调用interrupt 会捕获到中断信号,而 yield 则不会</li>
<li><strong>yield 方法和同步没关系，也就是和ObjectMonitor没关系，你硬上锁就是在唱独角戏 ( _05_03_YieldTest）</strong></li>
</ul>
</li>
</ul>
<h2 id="设置线程的优先级"><a href="#设置线程的优先级" class="headerlink" title="设置线程的优先级"></a>设置线程的优先级</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Changes the priority of this thread.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called</span></span><br><span class="line"><span class="comment">  * with no arguments. This may result in throwing a</span></span><br><span class="line"><span class="comment">  * &lt;code&gt;SecurityException&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Otherwise, the priority of this thread is set to the smaller of</span></span><br><span class="line"><span class="comment">  * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted</span></span><br><span class="line"><span class="comment">  * priority of the thread&#x27;s thread group.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">     ThreadGroup g;</span><br><span class="line">     checkAccess();</span><br><span class="line">     <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">             newPriority = g.getMaxPriority();</span><br><span class="line">         &#125;</span><br><span class="line">         setPriority0(priority = newPriority);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns this thread&#x27;s priority.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  this thread&#x27;s priority.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #setPriority</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> priority;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>理论上优先级高的线程会优先获取到  被cpu调度的机会,但是<strong>这个优先级 和yield一样,同样只是一个  hint(提示)</strong></p>
</li>
<li><p>对于root用户,他会 hint  系统你想要设置的优先级别, 否则他会被忽略</p>
</li>
<li><p>如果CPU比较忙,设置优先级可能会获得更多的CPU时间片,但是 在闲时优先级的高低几乎不会有任何作用</p>
</li>
<li><p><strong>不要在程序设计当中企图使用线程优先级绑定某些特定的业务,或者让业务严重依赖线程优先级</strong></p>
</li>
<li><p>线程优先级 区间范围为 [1,10],如果不在该区间 则 抛出异常</p>
</li>
<li><p>如果set设置的优先级大于 ThreadGroup的优先级, 则以 ThreadGroup为准 .</p>
</li>
<li><p>线程默认的优先级与父类保持一致, 一般情况下是 5,因为main线程的优先级就是5,所以它派生出来的线程都是5.</p>
</li>
</ul>
<h2 id="获取线程唯一ID"><a href="#获取线程唯一ID" class="headerlink" title="获取线程唯一ID"></a>获取线程唯一ID</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns the identifier of this Thread.  The thread ID is a positive</span></span><br><span class="line"><span class="comment">   * &lt;tt&gt;long&lt;/tt&gt; number generated when this thread was created.</span></span><br><span class="line"><span class="comment">   * The thread ID is unique and remains unchanged during its lifetime.</span></span><br><span class="line"><span class="comment">   * When a thread is terminated, this thread ID may be reused.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> this thread&#x27;s ID.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> tid;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程的ID在整个JVM进程中都会是唯一的,并且是从 0开始逐次递增.</li>
<li>如果在main方法(main线程)中创建了一个唯一的线程,并且调用getid方法 后发现返回结果并不等于0 ,不必惊讶,因为一个JVM启动时候,实际上已经开辟了很多个线程.自增序列已经有所增加了,所以我们创建的并非是第0号线程</li>
</ul>
<h2 id="获取当前线程"><a href="#获取当前线程" class="headerlink" title="获取当前线程"></a>获取当前线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns a reference to the currently executing thread object.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>  the currently executing thread.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title">currentThread</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>currentThread() 用于返回当前执行线程的引用,这个方法虽然很简单,但是使用非常广泛,</li>
</ul>
<h2 id="设置线程上下文类加载器"><a href="#设置线程上下文类加载器" class="headerlink" title="设置线程上下文类加载器"></a>设置线程上下文类加载器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/* The context ClassLoader for this thread */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader contextClassLoader;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        contextClassLoader = cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (contextClassLoader == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                                   Reflection.getCallerClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contextClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>getContextClassLoader ()<ul>
<li>获取线程上下文的类加载器, 简单来说就是这个线程是由哪个类加载器加载的.</li>
<li>如果在没有修改线程上下文类加载器的情况下,则保持与父类同样的类加载器</li>
</ul>
</li>
<li>setContextClassLoader(ClassLoader cl) 设置该线程的类加载器,<ul>
<li>该方法可以打破java类加载的双亲加载(父委托机制),有时候也称为 <strong>Java类加载器的后门</strong></li>
<li>后续会有专门的讲解</li>
</ul>
</li>
</ul>
<h2 id="线程interrupt"><a href="#线程interrupt" class="headerlink" title="线程interrupt"></a>线程interrupt</h2><p><strong>中断线程阻塞</strong></p>
<p><strong>这是一个 非常重要的API</strong>,也是经常使用的方法,与线程中断的API有如下几个,我们通过源码详解解析</p>
<ul>
<li>public void interrupt() </li>
<li>public static boolean interrupted()</li>
<li>public boolean isInterrupted()</li>
</ul>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Interrupts this thread.(打断这个线程)   </span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Unless the current thread is interrupting itself, which is</span></span><br><span class="line"><span class="comment">     * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     * of this thread is invoked, which may cause a &#123;@link</span></span><br><span class="line"><span class="comment">     * SecurityException&#125; to be thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link</span></span><br><span class="line"><span class="comment">     * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link</span></span><br><span class="line"><span class="comment">     * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;</span></span><br><span class="line"><span class="comment">     * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link</span></span><br><span class="line"><span class="comment">     * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,</span></span><br><span class="line"><span class="comment">     * methods of this class, then its interrupt status will be cleared and it</span></span><br><span class="line"><span class="comment">     * will receive an &#123;@link InterruptedException&#125;.</span></span><br><span class="line"><span class="comment">     // 如果当前线程被阻塞了由于调用下面这些什么Object的wait或者Thread的 sleep .join方法,</span></span><br><span class="line"><span class="comment">     然后它的中断状态将被清除 会收到&#123;@link InterruptedException&#125;。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span></span><br><span class="line"><span class="comment">     * then the channel will be closed, the thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">     * status will be set, and the thread will receive a &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.ClosedByInterruptException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125;</span></span><br><span class="line"><span class="comment">     * then the thread&#x27;s interrupt status will be set and it will return</span></span><br><span class="line"><span class="comment">     * immediately from the selection operation, possibly with a non-zero</span></span><br><span class="line"><span class="comment">     * value, just as if the selector&#x27;s &#123;@link</span></span><br><span class="line"><span class="comment">     * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span></span><br><span class="line"><span class="comment">     * status will be set. &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果 当前线程正处于 阻塞状态,调用 interrupt方法,则可以 <strong>中断打断这个阻塞</strong></p>
</li>
<li><p>是线程进入阻塞的方法有:</p>
<ul>
<li><p>Object的 wait 方法 以及变形的 重载的方法:wait (long)    和wait (long,int)</p>
</li>
<li><p>Thread 的sleep(long)方法,以及 重载的方法</p>
</li>
<li><p>Thread的join方法 以及重载的方法</p>
</li>
<li><p>InterruptibleChannel 的io操作</p>
</li>
<li><p>Selector 的wakeup方法</p>
</li>
<li><p>其他方法</p>
<ul>
<li>以上的方法都会使得当前线程进入阻塞状态.如果另外一个线程调用被阻塞线程的 interrupt 方法,则会打破这种阻塞 .</li>
<li>打断一个线程并不等于该线程的生命周期结束,仅仅是 打断了当前线程的阻塞状态</li>
<li>一个线程在阻塞的情况下被打断,会抛出一个 InterruptedException 的异常,这个异常就像一个 signal 一样通知当前线程被打断了 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="interrupt源码解析"><a href="#interrupt源码解析" class="headerlink" title="interrupt源码解析"></a>interrupt源码解析</h3><ul>
<li>一个线程内存存在着名为 interrupt flag的标识,如果一个 线程被interrupt ,那么它的 flag 将被设置</li>
<li>通过源码可以看到Thread中存在一个私有方法: <strong>interrupt0();           // Just to set the interrupt flag</strong>“,该方法作用是  修改interrupt flag</li>
<li>如果一个线程已经是 死亡Terminated 状态,那么尝试对其的interrupt 会直接被忽略\</li>
</ul>
<h3 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted"></a>isInterrupted</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted</span></span><br><span class="line"><span class="comment">    * status&lt;/i&gt; of the thread is unaffected by this method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment">    * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment">    * returning false.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;</span></span><br><span class="line"><span class="comment">    *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #interrupted()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">    * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">    * passed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要判断当前线程是否被中断,该方法仅仅是对 interrupt flag 的一个判断,并不会影响改变 interrupt flag的值</li>
<li>可中断方法捕获到了中断信号(signal) 之后,也就是捕获了InterruptedException 异常之后,会擦除interrupt的标识.</li>
<li>可中断方法捕获到了中断信号后,为了不影响线程中的其他方法的执行,将线程的interrupt flag标识复位 ,很合理的 设计</li>
</ul>
<h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted"></a>interrupted</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests whether the current thread has been interrupted.  The</span></span><br><span class="line"><span class="comment">    * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In</span></span><br><span class="line"><span class="comment">    * other words, if this method were to be called twice in succession, the</span></span><br><span class="line"><span class="comment">    * second call would return false (unless the current thread were</span></span><br><span class="line"><span class="comment">    * interrupted again, after the first call had cleared its interrupted</span></span><br><span class="line"><span class="comment">    * status and before the second call had examined it).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    测试当前线程是否已被中断的 . 这个线程的 &lt;中断状态&gt;被这个方法清除。</span></span><br><span class="line"><span class="comment">*换句话说，如果这个方法被连续调用两次，则第二个调用将返回false(</span></span><br><span class="line"><span class="comment">   除非当前线程被再一次 interrupted,在第一次调用后 已经清除了它自身 的interrupted status后再次被中断状态和第二次调用之前检查它</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * &lt;p&gt;A thread interruption ignored because a thread was not alive</span></span><br><span class="line"><span class="comment">    * at the time of the interrupt will be reflected by this method</span></span><br><span class="line"><span class="comment">    * returning false.</span></span><br><span class="line"><span class="comment">    线程中断被忽略，因为线程不是活的中断的时间会被这个方法反映出来*返回false。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;</span></span><br><span class="line"><span class="comment">    *          &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #isInterrupted()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@revised</span> 6.0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tests if some Thread has been interrupted.  The interrupted state</span></span><br><span class="line"><span class="comment">    * is reset or not based on the value of ClearInterrupted that is</span></span><br><span class="line"><span class="comment">    * passed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用该方法会直接擦除掉线程的interrupt flag,</p>
</li>
<li><p>需要注意的是: 第一次调用interrupted方法会返回true ,并且立即擦除了interrupt flag;</p>
</li>
<li><p>第二次包括以后的调用永远都是返回false,除非在此期间又一次地被打断了 .</p>
</li>
</ul>
<h3 id="interrupted源码分析"><a href="#interrupted源码分析" class="headerlink" title="interrupted源码分析"></a>interrupted源码分析</h3><ul>
<li>isInterrupted() 方法和   interrupted()方法都调用了同一个 native方法 :isInterrupted(boolean ClearInterrupted);,                                                                 ClearInterrupted用来控制是否擦除线程的 interrupt flag</li>
<li>isInterrupted()的 参数为 false,表示 不想擦除</li>
<li>interrupt 静态方法中该参数为 true,表示想擦除 </li>
</ul>
<p>如果一个线程在没有执行可中断方法之前就被打断了,那么其接下来执行可中断方法,比如sleep 会发生什么情况呢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterrupt</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//  1.判断当前线程是否被中断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread is interrupted? &quot;</span> + Thread.interrupted());</span><br><span class="line">        <span class="comment">// 2.中断当前线程</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="comment">//  3.判断当前线程是否被中断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread is interrupted? &quot;</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//4. 当前线程执行可中断方法</span></span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 5.捕获中断信号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;I will be interrupted still.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果: </span><br><span class="line">Main thread is interrupted? <span class="keyword">false</span></span><br><span class="line">Main thread is interrupted? <span class="keyword">true</span></span><br><span class="line">I will be interrupted still.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明: 如果一个线程设置了 interrupt flag,那么接下来可中断方法 会立即中断,因此 注释5的信号捕获部分会被执行.</p>
<h2 id="线程Join"><a href="#线程Join" class="headerlink" title="线程Join"></a>线程Join</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits for this thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; An invocation of this method behaves in exactly the same</span></span><br><span class="line"><span class="comment"> * way as the invocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #join(long) join&#125;&#123;<span class="doctag">@code</span> (0)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment"> * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment"> * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment"> * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment"> *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment"> *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment"> *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment"> *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment"> *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>join某个线程A(),会使当前线程B进入等待,直到线程A结束生命周期,或者到达给定的时间,</p>
<p>那么在此期间B线程是处于BLOCKED的,而不是A线程,</p>
<ul>
<li>join方法会使得当前线程永远的等待下去,知道期间被另外的线程中断,或者join的线程执行结束.</li>
<li>join的另外2个重载方法,指定毫秒数,在指定的时间到达之后,当前线程也会退出阻塞.</li>
</ul>
<h4 id="问题-如果一个线程已经结束了生命周期-那么调用它的join方法的当前线程会被阻塞吗"><a href="#问题-如果一个线程已经结束了生命周期-那么调用它的join方法的当前线程会被阻塞吗" class="headerlink" title="问题: 如果一个线程已经结束了生命周期,那么调用它的join方法的当前线程会被阻塞吗?"></a>问题: 如果一个线程已经结束了生命周期,那么调用它的join方法的当前线程会被阻塞吗?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  Thread thread = <span class="keyword">new</span> Thread();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">不会被阻塞</span><br></pre></td></tr></table></figure>

<ul>
<li><p> join() 和 sleep() 一样，可以被中断（被中断时，会抛出 InterrupptedException 异常）；</p>
</li>
<li><p>不同的是，join() 内部调用了 wait()，会出让锁，</p>
</li>
<li><p>而 sleep() 会一直保持锁。</p>
</li>
</ul>
<h3 id="join-的示例和作用"><a href="#join-的示例和作用" class="headerlink" title="join() 的示例和作用"></a>join() 的示例和作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建child对象，此时child表示的线程处于NEW状态</span></span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        <span class="comment">// child表示的线程转换为RUNNABLE状态</span></span><br><span class="line">        child.start();</span><br><span class="line">        <span class="comment">// 等待child线程运行完再继续运行</span></span><br><span class="line">        child.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码展示了两个类：Parent（父线程类），Child（子线程类）。</p>
<p>Parent.main()方法是程序的入口，通过 Child child = new Child(); 新建child子线程（此时 child子线程处于NEW状态）；</p>
<p>然后调用child.start()（child子线程状态转换为RUNNABLE）；</p>
<p>再调用child.join()，此时，Parent父线程会等待child子线程运行完再继续运行。</p>
<p>下图是我总结的 Java 线程状态转换图：</p>
<p><img src="/uploads/java-concurrency-master/thread-join.png"></p>
<h3 id="join-的作用"><a href="#join-的作用" class="headerlink" title="join() 的作用"></a>join() 的作用</h3><p>让父线程等待子线程结束之后才能继续运行</p>
<p>Waiting for the finalization of a thread</p>
<p>In some situations, we will have to wait for the finalization of a thread. For example, we may have a program that will begin initializing the resources it needs before proceeding with the rest of the execution. We can run the initialization tasks as threads and wait for its finalization before continuing with the rest of the program. For this purpose, we can use the join() method of the Thread class.   <strong><em>When we call this method using a thread object, it suspends the execution of the calling thread until the object called finishes its execution.</em></strong></p>
<p> 当我们调用某个线程的这个方法时，这个方法会挂起调用线程，直到被调用线程结束执行，调用线程才会继续执行。</p>
<h3 id="join源码分析"><a href="#join源码分析" class="headerlink" title="join源码分析:"></a>join源码分析:</h3><p>join() 一共有三个重载版本，分别是无参、一个参数、两个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void join() throws InterruptedException;</span><br><span class="line">public final synchronized void join(long millis) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">public final synchronized void join(long millis, int nanos) throws InterruptedException;</span><br></pre></td></tr></table></figure>



<p>其中</p>
<p>(1) 三个方法都被final修饰，无法被子类重写。</p>
<p>(2) join(long), join(long, long) 是synchronized method，同步的对象是当前线程实例。</p>
<p>(2) 无参版本和两个参数版本最终都调用了一个参数的版本。</p>
<p>(3) join() 和 join(0) 是等价的，表示一直等下去；join(非0)表示等待一段时间。</p>
<p><strong>从源码可以看到 join(0) 调用了Object.wait(0)，其中Object.wait(0) 会一直等待，直到被notify/中断才返回。</strong></p>
<p><strong>while(isAlive())是为了防止子线程伪唤醒(spurious wakeup)，只要子线程没有TERMINATED的，父线程就需要继续等下去。</strong></p>
<p>(4) join() 和 sleep() 一样，可以被中断（被中断时，会抛出 InterrupptedException 异常）；不同的是，join() 内部调用了 wait()，会出让锁，而 sleep() 会一直保持锁。</p>
<p><strong>以本文开头的代码为例，我们分析一下代码逻辑：</strong></p>
<ul>
<li><p>调用链：Parent.main() -&gt; child.join() -&gt; child.join(0) -&gt; child.wait(0)（此时 Parent线程会获得 child 实例作为锁，其他线程可以进入 child.join() ，但不可以进入 child.join(0)， 因为child.join(0)是同步方法）。</p>
</li>
<li><p>如果 child 线程是 Active，则调用 child.wait(0)（为了防止子线程 spurious wakeup, 需要将 wait(0) 放入 while(isAlive()) 循环中。</p>
</li>
<li><p>一旦 child 线程不为 Active （状态为 TERMINATED）, child.notifyAll() 会被调用-&gt; child.wait(0)返回 -&gt; child.join(0)返回 -&gt; child.join()返回 -&gt; Parent.main()继续执行, 子线程会调用this.notify()，child.wait(0)会返回到child.join(0) ，child.join(0)会返回到 child.join(), child.join() 会返回到 Parent 父线程，Parent 父线程就可以继续运行下去了。</p>
</li>
</ul>
<ul>
<li>子线程结束后，子线程的this.notifyAll()会被调用，join()返回，父线程只要获取到锁和CPU，就可以继续运行下去了</li>
<li>在调用 join() 方法的程序中，原来的多个线程仍然多个线程，<strong>并没有发生“合并为一个单线程”</strong>。真正发生的是调用 join() 的线程进入 TIMED_WAITING 状态，等待 join() 所属线程运行结束后再继续运行。</li>
</ul>
<h2 id="如何关闭一个线程"><a href="#如何关闭一个线程" class="headerlink" title="如何关闭一个线程"></a>如何关闭一个线程</h2><h3 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h3><ol>
<li><p>线程结束生命周期,正常结束</p>
</li>
<li><p>捕获中断信号 关闭线程</p>
<ul>
<li><p>通过new Thread的方式创建线程,这种方式看似简单,但是其实 派生成本是比较高的,因此在一个线程中往往会循环地执行某个任务,比如心跳检查,不断接收网络消息报文,系统决定退出地时候,可以借助中断线程地方式使其退出,例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;I will start work&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (; ; )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//working.</span></span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;I will be exiting.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;System will be shutdown.&quot;</span>);</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">线程中执行某个可中断方法,可以通过捕获中断信号来决定是否退出</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用volatile开关控制</p>
<p>由于线程的interrupt 标识 很有可能被擦除,或者逻辑单元不会调用任何可中断方法,</p>
<p>所以使用volatile修饰的开关 flag关闭线程也是一种常见做法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlagThreadExit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I will start work&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!closed &amp;&amp; !isInterrupted())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//System.out.println(&quot;i am working.&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;I will be exiting.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.closed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyTask t = <span class="keyword">new</span> MyTask();</span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;System will be shutdown.&quot;</span>);</span><br><span class="line">        t.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
</li>
</ol>
<h3 id="异常退出"><a href="#异常退出" class="headerlink" title="异常退出"></a>异常退出</h3><p>在一个线程的执行单元中,是不允许抛出 checked异常的, 如果线程在运行过程中,需要捕获checked 异常并且判断是否继续运行,</p>
<p>那么此时可以将checked异常封装成unchecked异常(RuntimeException) 抛出,进而 结束线程的生命周期</p>
<h3 id="系统假死"><a href="#系统假死" class="headerlink" title="系统假死"></a>系统假死</h3><p>绝大部分原因是因为某个线程阻塞了,或者线程出现了死锁 .</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>学习了Thread 的大多数API,主要分为2类,</li>
<li>一类是 获取线程的信息,如 getID,getName,getPriority,currThread</li>
<li>一类是阻塞以及中断阻塞 方法, sleep,join,  interrupt </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/17/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-02-Thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/17/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-02-Thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">java高并发详解-02-Thread构造函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-17 23:04:23" itemprop="dateCreated datePublished" datetime="2021-02-17T23:04:23+08:00">2021-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/17/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-02-Thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/17/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-02-Thread%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Thread的构造函数详解"><a href="#Thread的构造函数详解" class="headerlink" title="Thread的构造函数详解"></a>Thread的构造函数详解</h1><p><img src="/uploads/java-concurrency-master/thread-construct.png"></p>
<h2 id="线程的命名"><a href="#线程的命名" class="headerlink" title="线程的命名"></a>线程的命名</h2><p>再构造线程的时候，推荐给线程起一个 有特殊意义的名字，这样有助于 排查问题和线程追踪。</p>
<ol>
<li><h3 id="线程的默认命名"><a href="#线程的默认命名" class="headerlink" title="线程的默认命名"></a>线程的默认命名</h3></li>
</ol>
<ul>
<li>Thread（）</li>
<li>Thread（Runnable target）</li>
<li>Thread ( ThreadGroup group , Runnable target )</li>
</ul>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new &#123;<span class="doctag">@code</span> Thread&#125; object. This constructor has the same</span></span><br><span class="line"><span class="comment"> * effect as &#123;<span class="doctag">@linkplain</span> #Thread(ThreadGroup,Runnable,String) Thread&#125;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> (null, target, gname)&#125;, where &#123;<span class="doctag">@code</span> gname&#125; is a newly generated</span></span><br><span class="line"><span class="comment"> * name. Automatically generated names are of the form</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> &quot;Thread-&quot;+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  target</span></span><br><span class="line"><span class="comment"> *         the object whose &#123;<span class="doctag">@code</span> run&#125; method is invoked when this thread</span></span><br><span class="line"><span class="comment"> *         is started. If &#123;<span class="doctag">@code</span> null&#125;, this classes &#123;<span class="doctag">@code</span> run&#125; method does</span></span><br><span class="line"><span class="comment"> *         nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For autonumbering anonymous threads. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有为线程显示的指定一个名字，那么线程将会<strong>以“Thread-” 作为前缀与 一个自增数字进行组合</strong>，这个自增数字（threadInitNumber）在整个JVM进程中将会不断自增。</p>
<ol start="2">
<li><h3 id="命名线程"><a href="#命名线程" class="headerlink" title="命名线程"></a>命名线程</h3></li>
</ol>
<ul>
<li>Thread(Runnable target,String name)</li>
<li>Thread(String name)</li>
<li>Thread(ThreadGroup group,Runnable target,String name)</li>
<li>Thread(ThreadGroup group,Runnable target,String name，long stackSize)</li>
<li>Thread(ThreadGroup group,String name)</li>
</ul>
<ol start="3">
<li><h3 id="修改线程的名字"><a href="#修改线程的名字" class="headerlink" title="修改线程的名字"></a>修改线程的名字</h3></li>
</ol>
<p>不论使用的是默认的函数命名规则，还是指定了一个特殊的名字，在线程启动之前还有一个记会可以对其进行修改，一旦线程启动，名字将不再被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Changes the name of this thread to be equal to the argument</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;name&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called</span></span><br><span class="line"><span class="comment">    * with no arguments. This may result in throwing a</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;SecurityException&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>      name   the new name for this thread.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span>  SecurityException  if the current thread cannot modify this</span></span><br><span class="line"><span class="comment">    *               thread.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #getName</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #checkAccess()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       checkAccess();</span><br><span class="line">       <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">       <span class="comment">//线程不是NEW 状态，对其的修改将不会生效 </span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123; </span><br><span class="line">           setNativeName(name);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程的父子关系"><a href="#线程的父子关系" class="headerlink" title="线程的父子关系"></a>线程的父子关系</h2><p>Thread的所有构造函数，最终都会去调用一个静态方法init （）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.name = name.toCharArray();</span><br><span class="line">	<span class="comment">///////////////////////////////// 获取当前线程作为父线程</span></span><br><span class="line">       Thread parent = currentThread();</span><br><span class="line">       SecurityManager security = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line">           <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">              what to do. */</span></span><br><span class="line">           <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">               g = security.getThreadGroup();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">              use the parent thread group. */</span></span><br><span class="line">           <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">               g = parent.getThreadGroup();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">          explicitly passed in. */</span></span><br><span class="line">       g.checkAccess();</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">               security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       g.addUnstarted();</span><br><span class="line">       <span class="keyword">this</span>.group = g;</span><br><span class="line">       <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">       <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">       <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">           <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">       <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">               acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">       setPriority(priority);</span><br><span class="line">       <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">               ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">       <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">       <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line">       <span class="comment">/* Set thread ID */</span></span><br><span class="line">       tid = nextThreadID();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Thread parent = currentThread(); 获取当前线程作为创建的父线程 。</p>
</li>
<li><p>线程的最初的状态是 NEW ，没有执行start方法之前，只能算一个Thread实例，并不意味着一个新的线程被创建，因此 parent 代表的将会是创建它的那个线程</p>
</li>
<li><p>一个线程的创建肯定是由另一个线程完成的</p>
</li>
<li><p>被创建线程的父线程 是创建它的线程。</p>
</li>
<li><p>main函数 所在的线程是由 JVM创建的，也就是main线程。</p>
</li>
</ul>
<h2 id="Thread-与-ThreadGroup"><a href="#Thread-与-ThreadGroup" class="headerlink" title="Thread 与 ThreadGroup"></a>Thread 与 ThreadGroup</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init 方法 片段</span></span><br><span class="line"><span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it&#x27;s an applet or not */</span></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* If the security doesn&#x27;t have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g.addUnstarted();</span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在构造Thread的时候没有显示指定一个ThreadGroup，那么子线程将会被加入到父线程所在的线程组。</li>
<li>main线程所在的 ThreadGroup 称为 main</li>
</ul>
<h2 id="Thread-与-Runnable"><a href="#Thread-与-Runnable" class="headerlink" title="Thread 与 Runnable"></a>Thread 与 Runnable</h2><p>Thread 负责线程本身相关的职责和控制，而 Runnable 则负责逻辑执行单元的部分</p>
<h2 id="Thread与JVM虚拟机栈"><a href="#Thread与JVM虚拟机栈" class="headerlink" title="Thread与JVM虚拟机栈"></a>Thread与JVM虚拟机栈</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * The requested stack size for this thread, or 0 if the creator did</span></span><br><span class="line"><span class="comment">   * not specify a stack size.  It is up to the VM to do whatever it</span></span><br><span class="line"><span class="comment">   * likes with this number; some VMs will ignore it.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> stackSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initializes a Thread.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> g the Thread group</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target the object whose run() method gets called</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name the name of the new Thread</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stackSize the desired stack size for the new thread, or</span></span><br><span class="line"><span class="comment">   *        zero to indicate that this parameter is to be ignored.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class="line"><span class="comment">   *            AccessController.getContext() if null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">         ...</span><br><span class="line">         		...</span><br><span class="line">      <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">      <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Set thread ID */</span></span><br><span class="line">      tid = nextThreadID();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>stackSize=0时，代表忽略该参数 </p>
</li>
<li><p>一般情况下，创建线程的时候不会手动指定栈内存的地址空间字节数组，同一通过xss 参数进行设置即可</p>
</li>
<li><p>stacksize越大，则代表着 正在线程内方法调用递归的深度越深</p>
</li>
<li><p>stacksize越小，代表者创建的线程数量越多。</p>
</li>
<li><p>栈内存划分的大小，将直接决定一个JVM进程中可以创建多少个线程（栈内存越大，可创建的线程数量越少，反比）</p>
</li>
<li><p>进程的内存大小为：  堆内存+ 线程数量*栈内存</p>
</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>问题： JVM程序在正常情况下什么时候退出</p>
<p>答案： The java virtual machine exits when the only threads running are all daemon threads</p>
<p>在正常情况下，若JVM中没有一个非守护线程，则JVM的进程会退出。  </p>
<p>异常情况就是使用System.exit()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Marks this thread as either a &#123;<span class="doctag">@linkplain</span> #isDaemon daemon&#125; thread</span></span><br><span class="line"><span class="comment">   * or a user thread. The Java Virtual Machine exits when the only</span></span><br><span class="line"><span class="comment">   * threads running are all daemon threads.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt; This method must be invoked before the thread is started.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  on</span></span><br><span class="line"><span class="comment">   *         if &#123;<span class="doctag">@code</span> true&#125;, marks this thread as a daemon thread</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  IllegalThreadStateException</span></span><br><span class="line"><span class="comment">   *          if this thread is &#123;<span class="doctag">@linkplain</span> #isAlive alive&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span>  SecurityException</span></span><br><span class="line"><span class="comment">   *          if &#123;<span class="doctag">@link</span> #checkAccess&#125; determines that the current</span></span><br><span class="line"><span class="comment">   *          thread cannot modify this thread</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;</span><br><span class="line">      checkAccess();</span><br><span class="line">      <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">      &#125;</span><br><span class="line">      daemon = on;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Whether or not the thread is a daemon thread. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span>     daemon = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>setDaemon 方法只在线程启动之前生效，</li>
<li>如果线程已经死亡，那么再设置setDaemon则会抛非法线程状态异常</li>
<li>守护线程经常用作与执行一些后台任务，因此也叫 后台线程 </li>
<li>当希望关闭某些线程的时候或者退出JVM进程的时候，一些线程能自动关闭， 可以使用守护线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// main 线程开始</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2_000L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread finished lifecycle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不设置 thread.setDaemon(true);，则 JVM 一直无法关闭</span></span><br></pre></td></tr></table></figure>



<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>详细了解Thread的构造函数，挖掘里面的各类细节，如 threadStatus =0代表 new状态，构造函数调用init函数，尤其是 stacksize  对Thread的影响</li>
<li>了解了线程的父子关系， 默认情况下子线程从父线程那里 继承了守护线程、优先级、ThreadGroup等特性</li>
<li>守护线程的特性以及使用场景</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/09/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/09/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-09 21:21:53" itemprop="dateCreated datePublished" datetime="2021-02-09T21:21:53+08:00">2021-02-09</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/09/hello-world/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/09/hello-world/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>411</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$  </span><br><span class="line"></span><br><span class="line"> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/02/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-01-%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/02/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-01-%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">java高并发详解-01-快速认识线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-02 23:52:08" itemprop="dateCreated datePublished" datetime="2021-02-02T23:52:08+08:00">2021-02-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">高并发详解</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/02/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-01-%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/02/java%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3-01-%E5%BF%AB%E9%80%9F%E8%AE%A4%E8%AF%86%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="快速认识线程"><a href="#快速认识线程" class="headerlink" title="快速认识线程"></a>快速认识线程</h1><p>其实蛮早时候就看过这本书，当时对其中的知识也是一知半解，当时的工作并发量也不是很大，对并发的问题也没有太多的考虑。后面慢慢的认识到了高并发的重要性，加上看完了jvm的原理，带着jvm的一些知识点，重读一遍这本书，相信会解开之前的一些疑问。总之，书读百遍，其意自现。每一遍都会得到不一样的收获。<br>在此记录一下</p>
<h2 id="1-1-线程的介绍"><a href="#1-1-线程的介绍" class="headerlink" title="1.1 线程的介绍"></a>1.1 线程的介绍</h2><p>线程是程序执行的一个路径，每一个线程都有自己的局部变量表、程序计数器以及各自的生命周期</p>
<h2 id="1-2-线程的生命周期"><a href="#1-2-线程的生命周期" class="headerlink" title="1.2 线程的生命周期"></a>1.2 线程的生命周期</h2><p><img src="/uploads/java-concurrency-master/thread-lifecycle.png"></p>
<p>线程可以大致分为5个阶段</p>
<ul>
<li>NEW</li>
<li>RUNNABLE</li>
<li>RUNNING</li>
<li>BLOCKED</li>
<li>TERMINATED</li>
</ul>
<h3 id="1-2-1-线程的new状态"><a href="#1-2-1-线程的new状态" class="headerlink" title="1.2.1 线程的new状态"></a>1.2.1 线程的new状态</h3><p>当我们用关键字new 创建一个Thread 对象时，此时它并不处于执行状态，因为没有调用start方法启动该线程，那么该线程的状态为new状态。</p>
<p>准确的来说，它只是Thread对象的状态，因为再没有start之前，该线程根本不存在。</p>
<p>new状态通过start方法进入Runnable状态</p>
<h3 id="1-2-2-线程的RUNNABLE-状态"><a href="#1-2-2-线程的RUNNABLE-状态" class="headerlink" title="1.2.2 线程的RUNNABLE 状态"></a>1.2.2 线程的RUNNABLE 状态</h3><ul>
<li>线程对象必须调用start方法 进入RUNNABLE状态，那么此时 才是真正的再JVM进程中创建了一个线程。</li>
<li>并不是线程一启动就直接得到执行的，线程的运行与否和进程一样都要听令于CPU的调用。我们把这个中间状态 称为 <strong>可执行状态（RUNNABLE）</strong></li>
<li>也就是说 它具备执行的资格，但是并没有真正的执行起来，而是在等待CPU的调度</li>
<li>由于存在Running状态，所以不会直接进入 BLOCKED 状态和 TERMINATED状态，<strong>即使是在线程的执行逻辑中调用wait、sleep或者其他block的 IO操作等，也必须要先获得 CPU的调度执行权才可以</strong>，严格来讲，RUNNABLE的线程只能意外终止或者进入RUNNING状态</li>
</ul>
<h3 id="1-2-3-线程的RUNNING状态"><a href="#1-2-3-线程的RUNNING状态" class="headerlink" title="1.2.3 线程的RUNNING状态"></a>1.2.3 线程的RUNNING状态</h3><p>cpu通过轮询或者其他方式从任务可执行队列中选中了线程，那么此时它才能真正地执行自己的逻辑代码，</p>
<p>running状态的线程，可以发生以下的状态转换：</p>
<ul>
<li>直接进入TERMINATED 状态，比如调用jdk已经不推荐使用的stop方法或者判断某个逻辑标识</li>
<li>进入BLOCKED状态，比如 调用了sleep 或者wait方法而加入了waitSet中</li>
<li>进行某个阻塞的IO操作，比如因网络数据的读写而进入了BLOCKED状态</li>
<li>获取某个锁资源，从而加入到该锁的阻塞队列中，从而进入了BOLCKED状态</li>
<li>由于CPU的调度器轮询使得该线程放弃执行，进入RUNNABLE状态</li>
<li>线程主动调用yield方法，放弃CPU执行权，进入RUNNABLE状态</li>
</ul>
<h3 id="1-2-4-线程的BLOCKED状态"><a href="#1-2-4-线程的BLOCKED状态" class="headerlink" title="1.2.4 线程的BLOCKED状态"></a>1.2.4 线程的BLOCKED状态</h3><p>线程在BLOCKED状态中可以切换至如下几个状态：</p>
<ul>
<li>直接进入TERMINATED状态，比如调用JDK已经不推荐使用的stop方法或者意外死亡（jvm  Crash）</li>
<li>线程阻塞的操作结束，比如读取了想要的数据字节进入到RUNNABLE状态</li>
<li>线程完成了指定时间的休眠，进入到了RUNNABLE状态</li>
<li>wait中的线程被其他线程 notify /notify all 唤醒，进入runnable状态 </li>
<li>线程获取到了某个锁资源，进入到 RUNNABLE 状态</li>
<li>线程在阻塞过程中被打断，比如其他线程调用了interrupt方法，进入RUNABLE 状态</li>
</ul>
<h3 id="1-2-5-线程的TERMINATED状态"><a href="#1-2-5-线程的TERMINATED状态" class="headerlink" title="1.2.5 线程的TERMINATED状态"></a>1.2.5 线程的TERMINATED状态</h3><p>TERMINATED 是一个线程的最终状态，在该状态中线程将不会切换到其他任何状态，线程进入 TERMINATED 状态，意味着该线程的整个生命周期都结束了，</p>
<p>下面这些情况将会使线程进入 TERMINATED状态。</p>
<ul>
<li>线程运行正常结束，结束生命周期</li>
<li>线程运行出错意外结束</li>
<li>JVM Crash，导致所有 的线程都结束</li>
</ul>
<h2 id="1-3-线程start方法剖析：模板设计模式在Thread中的应用"><a href="#1-3-线程start方法剖析：模板设计模式在Thread中的应用" class="headerlink" title="1.3 线程start方法剖析：模板设计模式在Thread中的应用"></a>1.3 线程start方法剖析：模板设计模式在Thread中的应用</h2><p>Thread start方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Causes this thread to begin execution; the Java Virtual Machine</span></span><br><span class="line"><span class="comment">    * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The result is that two threads are running concurrently: the</span></span><br><span class="line"><span class="comment">    * current thread (which returns from the call to the</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;run&lt;/code&gt; method).</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * It is never legal to start a thread more than once.</span></span><br><span class="line"><span class="comment">    * In particular, a thread may not be restarted once it has completed</span></span><br><span class="line"><span class="comment">    * execution.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class="line"><span class="comment">    *               started.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #run()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #stop()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">        * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>解释：  start方法的源码非常简单，其实最核心的部分是 start0这个本地方法，也就是JNI方法： </p>
<p> private native void start0(); </p>
<p>也就是说在start方法中 会调用本地方法 start0方法 </p>
<p>通过start方法的注释说明： Causes this thread to begin execution; the Java Virtual Machine   calls the <code>run</code> method of this thread.  </p>
<p><strong>在开始执行这个线程的时候，JVM将会调用调用该线程的run方法</strong>，换言之，**<em>run方法是被JNI方法start0（）调用的**</em>，。</p>
<p>总结如下几个知识要点：</p>
<ul>
<li>Thread被构造后的NEW状态，事实上threadStatus这个内部属性为0 </li>
<li>不能两次启动Thread，否则就会出现 IllegalThreadStatusException 异常</li>
<li>线程启动后将会被加入到一个ThreadGroup中，</li>
<li>一个线程生命周期结束，也就是到了TERMINATED状态，再次调用start方法是不允许的，也就是说 TERMINATED状态时没有办法回到 RUNNABLE/RUNNING 状态的。</li>
</ul>
<h3 id="1-3-2-模板设计模式在Thread中的应用"><a href="#1-3-2-模板设计模式在Thread中的应用" class="headerlink" title="1.3.2  模板设计模式在Thread中的应用"></a>1.3.2  模板设计模式在Thread中的应用</h3><p>通过上面分析我们知道，线程的真正执行逻辑时在 run方法中，通常 将run方法称为线程的执行单元，</p>
<p>Thread中run方法的代码如下：</p>
<p>（重写run方法，用start方法启动线程）</p>
<p>如果我们没有使用Runnable 接口对其改造，则可以认为Thread的run方法本身就是一个空的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">   * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">   * &lt;code&gt;Runnable&lt;/code&gt; object&#x27;s &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">   * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实 Thread的run 和 start 就是一个比较典型的模板设计模式，父类编写算法结构代码 ，子类实现逻辑细节  ，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;################&quot;</span>);</span><br><span class="line">        wrapPrint(message);</span><br><span class="line">        System.out.println(<span class="string">&quot;################&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TemplateMethod t1 = <span class="keyword">new</span> TemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;*&quot;</span>+message+<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.print(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TemplateMethod t2 = <span class="keyword">new</span> TemplateMethod()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wrapPrint</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;+&quot;</span>+message+<span class="string">&quot;+&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t2.print(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>print  方法类似于Thread 的start 方法，而 wrapPrint 则类似于 run方法，这样做的好处是： </p>
<ul>
<li>程序结构由父类控制，并且是final 修饰的，不允许被重写 </li>
<li>子类只需要实现想要的逻辑任务即可 </li>
</ul>
<h2 id="Runnable-接口的引入以及策略模式在Thread中的使用"><a href="#Runnable-接口的引入以及策略模式在Thread中的使用" class="headerlink" title="Runnable 接口的引入以及策略模式在Thread中的使用"></a>Runnable 接口的引入以及策略模式在Thread中的使用</h2><h3 id="1-5-1-Runnable的职责"><a href="#1-5-1-Runnable的职责" class="headerlink" title="1.5.1 Runnable的职责"></a>1.5.1 Runnable的职责</h3><p>Runnable 接口只定义了一个无参数无返回值的run方法 ，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在很多软文以及一些书籍中，经常会提到：创建线程有两种方式：</p>
<ul>
<li>第一种是构建一个Thread</li>
<li>第二种是实现Runnable接口，</li>
</ul>
<p>这种说法是错误的，最起码是不严谨的，在JDK 种代表线程的只有 Thread这个类。线程的执行单元是 run方法，</p>
<ul>
<li>我们可以通过继承Thread，然后重写run方法实现自己的业务逻辑</li>
<li>也可以实现 Runnable 接口实现自己的业务逻辑，代码如下： </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;Runnable&lt;/code&gt; object&#x27;s &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">    * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 如果构造 Thread时 传递了Runnable，则会执行 runnable的run方法</span></span><br><span class="line">       <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//否则 需要重写 Thread类的run方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>准确的讲， 创建线程只有一种方式，那就是构造Thread类 ，而实现线程的执行单元有2种方式 ： 一种是重写Thread的run方法，另一种 是实现Runnable接口的run方法，并且将Runnable 实例用作构造Thread的参数 。</p>
<h3 id="1-5-2-策略模式在Thread-中的应用"><a href="#1-5-2-策略模式在Thread-中的应用" class="headerlink" title="1.5.2 策略模式在Thread 中的应用"></a>1.5.2 策略模式在Thread 中的应用</h3><p>无论是 Runnable的run方法，还是Thread类本身的run方法（事实上Thread类也是实现了Runnable接口） 都是想将线程的控制本身 和业务逻辑的运行分离开来，达到职责分明、功能单一的原则，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RowHandler</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">handle</span><span class="params">(ResultSet rs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RowHandler 接口只负责对从数据中查询出来的结果集 进行操作，至于最终返回成什么样的数据结构，那就需要自己去实现，类似于Runable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordQuery</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecordQuery</span><span class="params">(Connection connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 只负责将数据查询 出来 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(RowHandler&lt;T&gt; handler, String sql, Object... params)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PreparedStatement stmt = connection.prepareStatement(sql))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (Object param : params)</span><br><span class="line">            &#123;</span><br><span class="line">                stmt.setObject(index++, param);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ResultSet resultSet = stmt.executeQuery();</span><br><span class="line">            <span class="comment">// 调用 RowHandler进行数据封装</span></span><br><span class="line">            <span class="keyword">return</span> handler.handle(resultSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的好处是，可以用query方法应对任何数据库的查询，返回结果的不同指挥因为 传入的RowHandler 的不同而不同，同样 RecordQuery只负责数据的获取，而 RowHander则负责数据的加工，职责分明，每个类均功能单一 </p>
<ul>
<li>重写Thread类的run方法和实现Runnable 接口的run方法还有一个很重要的不同 ，那就是 <strong>Thread类的run方法是不能共享的</strong>，</li>
<li>也就是说 A线程不能把 B线程的run方法当作自己的执行单元，而使用Runnable接口则 很容易实现这一点，使用同一个RUnnable的实例构造不同的Thread实例。</li>
</ul>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>线程的概念</li>
<li>如何创建一个线程，并且通过重写Thread的run方法和实现Runnable接口的run方法进而实现线程的执行单元</li>
<li>了解模板设计模式 以及 策略设计模式。</li>
<li>通过 Thread 以及 Runnable的结合，了解如何实现线程控制和业务执行解耦分离</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://limingzhang666.github.io/2021/02/01/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-00-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yinshi01_avatar.jpg">
      <meta itemprop="name" content="Yinshi">
      <meta itemprop="description" content="拨开云雾见青天">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yinshi's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/01/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-00-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">Spring源码解析-00-环境搭建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-01 23:51:27" itemprop="dateCreated datePublished" datetime="2021-02-01T23:51:27+08:00">2021-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Spring%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">Spring源码</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/02/01/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-00-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/02/01/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-00-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>41</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring源码解析环境搭建"><a href="#Spring源码解析环境搭建" class="headerlink" title="Spring源码解析环境搭建"></a>Spring源码解析环境搭建</h1><p>1.首先需要下载spring源码，github </p>
<p>todo</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yinshi</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>










<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"4oBiQGiWDHdACABLWjT7ouaV-gzGzoHsz","appKey":"fr4vMSPUjcHLtIrF2hmRF6UE","serverURLs":"https://4obiqgiw.lc-cn-n1-shared.com","placeholder":"国王不动，手下怎么跟随? --反叛的鲁鲁修","avatar":"","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"cdh":"https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"}, {
      el: '#valine-comments',
      path: "/page/3/",
      serverURLs: "https://4obiqgiw.lc-cn-n1-shared.com"
    }));
  }, window.Valine);
});
</script>


</body>
</html>
